cscope 15 $HOME/tizen-src/public/cert-svc               0001134283
	@include/cert-service-debug.h

23 #ide
CERT_SERVICE_DEBUG_H


24 
	#CERT_SERVICE_DEBUG_H


	)

26 #ifde
__lulus


33 #ifde
LOG_TAG


34 #unde
LOG_TAG


36 
	#LOG_TAG
 "CERT_SVC"

	)

38 
	~<dlog.h
>

40 #ifde
__lulus


	@include/cert-service-process.h

23 #ide
CERT_SERVICE_PROCESS_H


24 
	#CERT_SERVICE_PROCESS_H


	)

26 
	~<time.h
>

27 
	~<ݒs/x509v3.h
>

29 #ifde
__lulus


36 
_svc_ode_t
;

41 
r_me_d_da
(* 
r
, 
_svc_me_d_da
* 
d
);

42 
ch_da_fld
(
ch_fld
 
dName
, * 
dDa
, 
_svc__dest
* 
Desc
);

43 
g_fi_cur
(* 
dName
, 
_svc_fame_li
* 
feNames
,

44 
_svc_ode_t
 *
vised
);

46 
_vify_ifi_wh_ag
(
_svc_mem_buff
* 
Buf
, 
_svc_lked_li
** 
Li
, 
checkCaFg
, 
_svc_fame_li
* 
feNames
, * 
vidy
);

47 
_vify_sigtu
(
_svc_mem_buff
* 
Buf
, * 
mesge
, 
msgL
, * 
sigtu
, * 
go
, * 
vidy
);

48 
_exa_ifi_da
(
_svc_mem_buff
* 

, 
_svc__dest
* 
Desc
);

49 
_ch_ifi
(
_svc_fame_li
** 
feNames
, 
ch_fld
 
dName
, * 
dDa
);

50 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


51 
_check_oc_us
(
_svc_mem_buff
* 

, 
_svc_lked_li
** 
Li
, cڡ * 
uri
);

54 
a_ifi_buf
(
_svc_mem_buff
* 
Buf
);

55 
a_ifi_da
(
_svc__dest
* 
Desc
);

56 
a__li
(
_svc_lked_li
* 
Li
);

57 
a_fame_li
(
_svc_fame_li
* 
feNames
);

59 
g_visiby
(
CERT_CONTEXT
* 
cڋxt
, * 
visiby
);

60 
g_ifi_ty
(
CERT_CONTEXT
* 
cڋxt
, * 
_ty
);

62 #ifde
__lulus


	@include/cert-service-store.h

23 #ide
CERT_SERVICE_STORE_H


24 
	#CERT_SERVICE_STORE_H


	)

26 #ifde
__lulus


30 
g_fe_fu_th
(* 
igName
, cڡ * 
loti
, * 
outBuf
);

31 
_add_ifi_to_e
(cڡ * 
fePh
, cڡ * 
loti
);

32 
_de_ifi_om_e
(cڡ * 
fePh
, cڡ * 
loti
);

34 #ifde
__lulus


	@include/cert-service-util.h

23 #ide
CERT_SERVICE_UTIL_H


24 
	#CERT_SERVICE_UTIL_H


	)

26 
	~<ݒs/x509v3.h
>

28 #ifde
__lulus


38 
g_cڋ_to_buf_PEM
(* 
cڋ
, 
_svc_mem_buff
* 

);

39 
g_cڋ_to_buf_DER
(* 
cڋ
, 
_svc_mem_buff
* 

);

41 
_svc_ut_g_fe_size
(cڡ * 
fh
, * 
ngth
);

42 
_svc_ut_ld_fe_to_bufr
(cڡ * 
fePh
, 
_svc_mem_buff
* 
Buf
);

43 
_svc_ut_ld_PFX_fe_to_bufr
(cڡ * 
fePh
, 
_svc_mem_buff
* 
Buf
, 
_svc_lked_li
** 
Lk
, ** 
iveKey
, * 
iKeyL
, * 
ssPh
);

44 
_svc_ut_g__th
(cڡ * 
feName
, cڡ * 
loti
, * 
tBuf
);

45 
_svc_ut_ba64_code
(cڡ * 

, 
L
, * 
out
, * 
outL
);

46 
_svc_ut_ba64_decode
(cڡ * 

, 
L
, * 
out
, * 
outL
);

47 
_svc_ut_g_exnsi
(cڡ * 
fePh
, 
_svc_mem_buff
* 
Buf
);

48 
push__to_lked_li
(
_svc_lked_li
** 
Lk
, 
X509
* 
pedCt
);

49 
g_visiby_by_fgt
(cڡ * 
fgt
, * 
visiby
);

50 
g_visiby_by_ifi
(cڡ * 
_da
, 
da_n
, * 
visiby
);

51 
g_ty_by_fgt
(cڡ * 
fgt
, * 
_ty
);

52 
g_ifi_fgt
(cڡ *

, 
_size
, ** 
fgt
);

54 #ifde
__lulus


	@include/cert-service.h

23 #ide
CERT_SERVICE_H


24 
	#CERT_SERVICE_H


	)

26 #ifde
__lulus


34 
	#CERT_SVC_MAX_CERT_TYPE_SIZE
 50

	)

35 
	#CERT_SVC_MAX_FILE_NAME_SIZE
 256

	)

36 
	#CERT_SVC_MAX_BUFFER_SIZE
 (4 * 1024)

	)

38 
	#CERT_SVC_ERR_NO_ERROR
 0

	)

39 
	#CERT_SVC_ERR_UNKNOWN_ERROR
 -1

	)

40 
	#CERT_SVC_ERR_BROKEN_CHAIN
 -2

	)

41 
	#CERT_SVC_ERR_NO_ROOT_CERT
 -3

	)

42 
	#CERT_SVC_ERR_INVALID_SIGNATURE
 -4

	)

43 
	#CERT_SVC_ERR_INVALID_CERTIFICATE
 -5

	)

44 
	#CERT_SVC_ERR_FILE_IO
 -6

	)

45 
	#CERT_SVC_ERR_UNSUPPORTED_HASH_TYPE
 -7

	)

46 
	#CERT_SVC_ERR_UNSUPPORTED_KEY_TYPE
 -8

	)

47 
	#CERT_SVC_ERR_INVALID_OPERATION
 -9

	)

48 
	#CERT_SVC_ERR_BUFFER_TOO_SMALL
 -10

	)

49 
	#CERT_SVC_ERR_NO_MORE_CERTIFICATE
 -11

	)

50 
	#CERT_SVC_ERR_DUPLICATED_CERTIFICATE
 -12

	)

51 
	#CERT_SVC_ERR_SYSTEM_CALL
 -13

	)

52 
	#CERT_SVC_ERR_MEMORY_ALLOCATION
 -14

	)

53 
	#CERT_SVC_ERR_INVALID_PARAMETER
 -15

	)

54 
	#CERT_SVC_ERR_PERMISSION_DENIED
 -16

	)

55 
	#CERT_SVC_ERR_IS_EXPIRED
 -17

	)

56 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


57 
	#CERT_SVC_ERR_OCSP_REVOKED
 -18

	)

58 
	#CERT_SVC_ERR_OCSP_UNKNOWN
 -19

	)

59 
	#CERT_SVC_ERR_OCSP_VERIFICATION_ERROR
 -20

	)

60 
	#CERT_SVC_ERR_OCSP_NO_SUPPORT
 -21

	)

61 
	#CERT_SVC_ERR_OCSP_NETWORK_FAILED
 -22

	)

62 
	#CERT_SVC_ERR_OCSP_INTERNAL
 -23

	)

63 
	#CERT_SVC_ERR_OCSP_REMOTE
 -24

	)

66 
	#CERT_SVC_ERR_INVALID_NO_DEVICE_PROFILE
 -25

	)

67 
	#CERT_SVC_ERR_INVALID_DEVICE_UNIQUE_ID
 -26

	)

68 
	#CERT_SVC_ERR_INVALID_SDK_DEFAULT_AUTHOR_CERT
 -27

	)

69 
	#CERT_SVC_ERR_IN_DISTRIBUTOR_CASE_AUTHOR_CERT
 -28

	)

70 
	#CERT_SVC_ERR_IN_AUTHOR_CASE_DISTRIBUTOR_CERT
 -29

	)

73 
	#CERT_SVC_STORE_PATH
 "/u/she/-svc/s/"

	)

74 
	#CERT_SVC_STORE_PATH_DEFAULT
 "/u/she/-svc/s/s/"

	)

80 
SEARCH_FIELD_START
 = 0,

81 
ISSUER_COUNTRY
 = 0,

82 
ISSUER_STATEORPROVINCE
,

83 
ISSUER_LOCALITY
,

84 
ISSUER_ORGANIZATION
,

85 
ISSUER_ORGANIZATIONUNIT
,

86 
ISSUER_COMMONNAME
,

87 
ISSUER_EMAILADDRESS
,

88 
ISSUER_STR
,

89 
SUBJECT_COUNTRY
,

90 
SUBJECT_STATEORPROVINCE
,

91 
SUBJECT_LOCALITY
,

92 
SUBJECT_ORGANIZATION
,

93 
SUBJECT_ORGANIZATIONUNIT
,

94 
SUBJECT_COMMONNAME
,

95 
SUBJECT_EMAILADDRESS
,

96 
SUBJECT_STR
,

97 
SEARCH_FIELD_END
 = 16,

98 } 
	tch_fld
;

100 
	e_svc_visiby_t
 {

101 
CERT_SVC_VISIBILITY_DEVELOPER
 = 1,

102 
CERT_SVC_VISIBILITY_PUBLIC
 = 1 << 6,

103 
CERT_SVC_VISIBILITY_PARTNER
 = 1 << 7,

104 
CERT_SVC_VISIBILITY_PARTNER_OPERATOR
 = 1 << 8,

105 
CERT_SVC_VISIBILITY_PARTNER_MANUFACTURER
 = 1 << 9,

106 
CERT_SVC_VISIBILITY_PLATFORM
 = 1 << 10

107 } 
	t_svc_visiby
;

109 
	e_svc_ty_t
 {

110 
CERT_SVC_TYPE_NO_TYPE
 = 0,

111 
CERT_SVC_TYPE_TEST
 = 1 << 1,

112 
CERT_SVC_TYPE_VERIFY
 = 1 << 2,

113 
CERT_SVC_TYPE_STORE
 = 1 << 3

114 } 
	t_svc_ty
;

117 
fSecd
;

118 
fMu
;

119 
fHour
;

120 
fDay
;

121 
fMth
;

122 
fYr
;

123 
cdSecd
;

124 
cdMu
;

125 
cdHour
;

126 
cdDay
;

127 
cdMth
;

128 
cdYr
;

129 } 
	t_svc_vidy_d_da
;

132 * 
couryName
;

133 * 
eOrProvName
;

134 * 
lolyName
;

135 * 
giziName
;

136 * 
giziUnName
;

137 * 
commName
;

138 * 
emaAddss
;

139 } 
	t_svc_me_d_da
;

142 * 
me
;

143 * 
da
;

144 
dasize
;

145 } 
	t_svc__d_desc
;

148 
vsi
;

149 
rlNumb
;

150 * 
sigAlgo
;

151 * 
issuS
;

152 
_svc_me_d_da
 
issu
;

153 
_svc_vidy_d_da
 
vidPiod
;

154 * 
subjeS
;

155 
_svc_me_d_da
 
subje
;

156 * 
pubKeyAlgo
;

157 
pubKeyL
;

158 * 
pubKey
;

159 * 
issuUID
;

160 * 
subjeUID
;

161 } 
	t_svc_fmi_flds
;

164 
numOfFlds
;

165 
_svc__d_desc
* 
flds
;

166 } 
	t_svc_exnsi_flds
;

169 
ty
[4];

170 
_svc_fmi_flds
 
fo
;

171 
_svc_exnsi_flds
 
ext
;

172 * 
sigtuAlgo
;

173 * 
sigtuDa
;

174 
sigtuL
;

175 } 
	t_svc__dest
;

178 * 
da
;

179 
ty
[4];

180 
size
;

181 } 
	t_svc_mem_buff
;

183 
	s__svc_lked_li
 {

184 
_svc_mem_buff
* 
ifi
;

185 
__svc_lked_li
* 
xt
;

186 } 
	t_svc_lked_li
;

188 
	s__fame_li
 {

189 * 
fame
;

190 
__fame_li
* 
xt
;

191 } 
	t_svc_fame_li
;

194 
_svc_mem_buff
* 
Buf
;

195 
_svc__dest
* 
Desc
;

196 
_svc_lked_li
* 
Lk
;

197 
_svc_fame_li
* 
feNames
;

198 } 
	tCERT_CONTEXT
;

203 
CERT_CONTEXT
* 
_svc__cڋxt_
();

204 
_svc__cڋxt_f
(
CERT_CONTEXT
* 
x
);

206 
_svc_ld_buf_to_cڋxt
(
CERT_CONTEXT
* 
x
, * 
buf
);

207 
_svc_ld_fe_to_cڋxt
(
CERT_CONTEXT
* 
x
, cڡ * 
fePh
);

208 
_svc_ld_PFX_fe_to_cڋxt
(
CERT_CONTEXT
* 
x
, ** 
iveKey
, * 
iKeyL
, cڡ * 
fePh
, * 
ssPh
);

209 
_svc_push_buf_to_cڋxt
(
CERT_CONTEXT
* 
x
, * 
buf
);

210 
_svc_push_fe_to_cڋxt
(
CERT_CONTEXT
* 
x
, cڡ * 
fePh
);

212 
_svc_add_ifi_to_e
(cڡ * 
fePh
, cڡ * 
loti
);

213 
_svc_de_ifi_om_e
(cڡ * 
feName
, cڡ * 
loti
);

214 
_svc_vify_ifi
(
CERT_CONTEXT
* 
x
, * 
vidy
);

215 
_svc_vify_ckage_ifi
(
CERT_CONTEXT
* 
x
, * 
vidy
, cڡ * 
sigtuFe
);

216 
_svc_vify_ifi_wh_ag
(
CERT_CONTEXT
* 
x
, * 
vidy
);

217 
_svc_vify_sigtu
(
CERT_CONTEXT
* 
x
, * 
mesge
, 
msgL
, * 
sigtu
, * 
go
, * 
vidy
);

218 
_svc_exa_ifi_da
(
CERT_CONTEXT
* 
x
);

219 
_svc_ch_ifi
(
CERT_CONTEXT
* 
x
, 
ch_fld
 
dName
, * 
dDa
);

220 
_svc_g_visiby
(
CERT_CONTEXT
* 
x
, * 
visiby
);

221 
_svc_g_visiby_by_ro_ifi
(cڡ * 
_da
, 
da_n
, * 
visiby
);

224 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


225 
_svc_check_oc_us
(
CERT_CONTEXT
* 
x
, cڡ * 
uri
);

227 * 
_svc_g_ifi_t_fe_th
();

229 
_svc_ut_r_me_d_da
(* 
r
, 
_svc_me_d_da
* 
d
);

231 #ifde
__lulus


	@srcs/cert-service-process.c

22 
	~<rg.h
>

23 
	~<dlib.h
>

24 
	~<dt.h
>

25 
	~<r.h
>

26 
	~<sys/.h
>

27 
	~<sys/tys.h
>

28 
	~<s.h
>

29 
	~<unid.h
>

30 
	~<ݒs/s.h
>

31 
	~<ݒs/oc.h
>

33 
	~"-rvi.h
"

34 
	~"-rvi-ut.h
"

35 
	~"-rvi-debug.h
"

36 
	~"-rvi-oss.h
"

38 
	#g_ASN1_INTEGER
(
x

	`ASN1_INTEGER_g
((x))

	)

39 
	#g_ASN1_OBJECT
(
x

	`OBJ_nid2
(
	`OBJ_obj2nid
((x)))

	)

40 
	#g_X509_NAME
(
x

	`X509_NAME_ږe
((x), 
NULL
, 0)

	)

43 
	svify_cڋxt
 {

44 
	mdth
;

48 * 
	munName
;

49 * 
	maddss
;

50 
	mn
;

51 } 
	tme_fld
;

53 ** 
	$__g_fld_by_g
(* 
r
, *
g_n
, 
_svc_me_d_da
* 
d
)

56 cڡ * 
me
;

57 
n
;

58 **
fld
;

59 } 
gs
[] = {

60 {"C=", 2, &(
d
->
couryName
)},

61 {"ST=", 3, &(
d
->
eOrProvName
)},

62 {"L=", 2, &(
d
->
lolyName
)},

63 {"O=", 2, &(
d
->
giziName
)},

64 {"OU=", 3, &(
d
->
giziUnName
)},

65 {"CN=", 3, &(
d
->
commName
)},

66 {"emaAddss=", 13, &(
d
->
emaAddss
)}

68 **
fld
 = 
NULL
;

69 i(
r
[0] == '/') {

70 
i
 = (
gs
) / (tags[0]) - 1;

71 
i
 >0 && 
	`cmp
((cڡ *)(
r
 + 1), (cڡ *)(
gs
[i].
me
),ags[i].
n
)) {

72 
i
--;

74 i(
i
 >= 0) {

75 *
g_n
 = 
gs
[
i
].
n
 + 1;

76 
fld
 = 
gs
[
i
].field;

79  
fld
;

80 
	}
}

83 
	$r_me_d_da
(* 
r
, 
_svc_me_d_da
* 
d
)

85 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

86 **
ev_fld
 = 
NULL
;

87 
i
 = 0, 
l
 = 0;

88 i(
d
 =
NULL
) {

89 
t
 = 
CERT_SVC_ERR_INVALID_PARAMETER
;

90  
t
;

92 
	`memt
(
d
, 0, (
_svc_me_d_da
));

93 
r
[
i
] != '\0') {

94 
g_n
;

95 **
fld
 = 
	`__g_fld_by_g
(
r
 + 
i
, &
g_n
, 
d
);

96 
fld
 =
NULL
 && 
r
[
i
] != '\0') {

97 
i
++;

98 
fld
 = 
	`__g_fld_by_g
(
r
 + 
i
, &
g_n
, 
d
);

100 i(
ev_fld
 !
NULL
) {

101 *
ev_fld
 = (*)
	`dup
((cڡ *)(
r
 + 
l
), 
i
 -);

103 i(
fld
 !
NULL
) {

104 
i
 +
g_n
;

105 
l
 = 
i
;

106 
ev_fld
 = 
fld
;

109  
t
;

110 
	}
}

112 
	$r_time_d_da
(* 
befe
, * 
a
, 
_svc_vidy_d_da
* 
d
)

114 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

115 * 
dex
 = 
NULL
;

116 
yr
[5] = {0, };

117 
mth
[3] = {0, };

118 
day
[3] = {0, };

119 
hour
[3] = {0, };

120 
mu
[3] = {0, };

121 
cd
[3] = {0, };

123 if((
	`
((*)
befe
< 15|| (((*)
a
) < 15)) {

124 
	`SLOGE
("[ERR][%s] Faطrimd.", 
__func__
);

125 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

126 
r
;

130 
dex
 = (*)
befe
;

131 
	`y
(
yr
, 
dex
, 4);

132 (*
d
).
fYr
 = ()(
	`oul
(
yr
, 
NULL
, 10));

133 
	`y
(
mth
, (
dex
 + 4), 2);

134 (*
d
).
fMth
 = ()(
	`oul
(
mth
, 
NULL
, 10));

135 
	`y
(
day
, (
dex
 + 6), 2);

136 (*
d
).
fDay
 = ()(
	`oul
(
day
, 
NULL
, 10));

137 
	`y
(
hour
, (
dex
 + 8), 2);

138 (*
d
).
fHour
 = ()(
	`oul
(
hour
, 
NULL
, 10));

139 
	`y
(
mu
, (
dex
 + 10), 2);

140 (*
d
).
fMu
 = ()(
	`oul
(
mu
, 
NULL
, 10));

141 
	`y
(
cd
, (
dex
 + 12), 2);

142 (*
d
).
fSecd
 = ()(
	`oul
(
cd
, 
NULL
, 10));

145 
dex
 = (*)
a
;

146 
	`y
(
yr
, 
dex
, 4);

147 (*
d
).
cdYr
 = ()(
	`oul
(
yr
, 
NULL
, 10));

148 
	`y
(
mth
, (
dex
 + 4), 2);

149 (*
d
).
cdMth
 = ()(
	`oul
(
mth
, 
NULL
, 10));

150 
	`y
(
day
, (
dex
 + 6), 2);

151 (*
d
).
cdDay
 = ()(
	`oul
(
day
, 
NULL
, 10));

152 
	`y
(
hour
, (
dex
 + 8), 2);

153 (*
d
).
cdHour
 = ()(
	`oul
(
hour
, 
NULL
, 10));

154 
	`y
(
mu
, (
dex
 + 10), 2);

155 (*
d
).
cdMu
 = ()(
	`oul
(
mu
, 
NULL
, 10));

156 
	`y
(
cd
, (
dex
 + 12), 2);

157 (*
d
).
cdSecd
 = ()(
	`oul
(
cd
, 
NULL
, 10));

159 
r
:

160  
t
;

161 
	}
}

163 
_svc_lked_li
* 
	$fd_issu_om_li
(
_svc_lked_li
* 
li
, ct_svc_lked_li* 
p
)

166 
_svc_lked_li
* 
q
 = 
NULL
;

167 
_svc__dest
* 
tmp1
 = 
NULL
;

168 
_svc__dest
* 
tmp2
 = 
NULL
;

170 
tmp1
 = (
_svc__dest
*)
	`mloc
((cert_svc_cert_descriptor));

171 i(
tmp1
 =
NULL
) {

172 
	`SLOGE
("[ERR][%s] Faخlo ctifi dest.", 
__func__
);

173  
NULL
;

176 
	`memt
(
tmp1
, 0x00, (
_svc__dest
));

178 if(
	`_exa_ifi_da
(
p
->
ifi
, 
tmp1
!
CERT_SVC_ERR_NO_ERROR
) {

179 
	`SLOGE
("[ERR][%s] Faexa ctifi da.", 
__func__
);

180 
r
;

183 
q
 = 
li
; q !
NULL
; q = q->
xt
) {

184 
tmp2
 = (
_svc__dest
*)
	`mloc
((cert_svc_cert_descriptor));

185 i(
tmp2
 =
NULL
) {

186 
	`SLOGE
("[ERR][%s] Faخlo ctifi dest.", 
__func__
);

187 
r
;

190 
	`memt
(
tmp2
, 0x00, (
_svc__dest
));

192 
	`_exa_ifi_da
(
q
->
ifi
, 
tmp2
);

194 if(!
	`cmp
((cڡ *)(
tmp2
->
fo
.
subjeS
), (cڡ *)(
tmp1
->fo.
issuS
), 
	`
((const *)(tmp1->info.issuerStr)))) {

195 
	`a_ifi_da
(
tmp1
);

196 
	`a_ifi_da
(
tmp2
);

197  
q
;

199 
	`a_ifi_da
(
tmp2
);

200 
tmp2
 = 
NULL
;

203 
r
:

204 
	`a_ifi_da
(
tmp1
);

205 
	`a_ifi_da
(
tmp2
);

206  
NULL
;

207 
	}
}

209 
	$st__cha
(
_svc_lked_li
** 
uns܋d
, ct_svc_lked_li** 
s܋d
)

211 
_svc_lked_li
* 
p
 = 
NULL
;

212 
_svc_lked_li
* 
q
 = 
NULL
;

213 
_svc_lked_li
* 
r
 = 
NULL
;

215 
_svc__dest
* 
tmp1
 = 
NULL
;

216 
_svc__dest
* 
tmp2
 = 
NULL
;

218 if((*
uns܋d
=
NULL
) {

219 
p
 = (*
s܋d
);->
xt
 !
NULL
; =->next) {

220 
tmp1
 = (
_svc__dest
*)
	`mloc
((cert_svc_cert_descriptor));

221 if(
tmp1
 =
NULL
) {

222 
	`SLOGE
("[ERR][%s] Faخlo ctifi dest.", 
__func__
);

223  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

225 
	`memt
(
tmp1
, 0x00, (
_svc__dest
));

226 
tmp2
 = (
_svc__dest
*)
	`mloc
((cert_svc_cert_descriptor));

227 if(
tmp2
 =
NULL
) {

228 
	`a_ifi_da
(
tmp1
);

229 
	`SLOGE
("[ERR][%s] Faخlo ctifi dest.", 
__func__
);

230  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

232 
	`memt
(
tmp2
, 0x00, (
_svc__dest
));

234 
	`_exa_ifi_da
(
p
->
ifi
, 
tmp1
);

235 
	`_exa_ifi_da
(
p
->
xt
->
ifi
, 
tmp2
);

237 if(
	`cmp
((cڡ *)(
tmp1
->
fo
.
issuS
), (cڡ *)(
tmp2
->fo.
subjeS
), 
	`
((const *)(tmp2->info.subjectStr)))) {

238 
	`SLOGE
("[ERR][%s] Ctifi cha ibrok.", 
__func__
);

239 
	`a_ifi_da
(
tmp1
);

240 
	`a_ifi_da
(
tmp2
);

241  
CERT_SVC_ERR_BROKEN_CHAIN
;

244 
	`a_ifi_da
(
tmp1
);

245 
tmp1
 = 
NULL
;

246 
	`a_ifi_da
(
tmp2
);

247 
tmp2
 = 
NULL
;

250 
	`a_ifi_da
(
tmp1
);

251 
	`a_ifi_da
(
tmp2
);

252  
CERT_SVC_ERR_NO_ERROR
;

254 if((*
uns܋d
)->
xt
 =
NULL
) {

255 (*
uns܋d
)->
xt
 = *
s܋d
;

256 *
s܋d
 = *
uns܋d
;

257 *
uns܋d
 = 
NULL
;

260 
r
 = (*
uns܋d
);

261 
p
 = (*
uns܋d
); !
NULL
; =->
xt
) {

262 if((
q
 = 
	`fd_issu_om_li
((*
uns܋d
), 
p
)=
NULL
)

265 
r
 = 
p
;

268 if(
q
 !
NULL
) {

269 
	`SLOGE
("[ERR][%s] Ctifi cha ibrok.", 
__func__
);

270  
CERT_SVC_ERR_BROKEN_CHAIN
;

273 if(
r
 =
p
) {

274 
q
 = (*
uns܋d
)->
xt
;

275 (*
uns܋d
)->
xt
 = (*
s܋d
);

276 (*
s܋d
(*
uns܋d
);

277 (*
uns܋d

q
;

279 if((*
s܋d
=
NULL
) {

280 (*
s܋d

p
;

281 
r
->
xt
 = 
p
->next;

282 (*
s܋d
)->
xt
 = 
NULL
;

285 
r
->
xt
 = 
p
->next;

286 
p
->
xt
 = (*
s܋d
);

287 (*
s܋d

p
;

291  
	`st__cha
(
uns܋d
, 
s܋d
);

292 
	}
}

294 
	$is_CACt
(
_svc_mem_buff
* 

, * 
isCA
)

296 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

297 
X509
* 
x
 = 
NULL
;

298 cڡ * 
p
 = 
NULL
;

300 
p
 = 

->
da
;

301 
	`d2i_X509
(&
x
, &
p
, 

->
size
);

303 if(
x
 =
NULL
) {

304 
	`SLOGE
("[ERR][%s] Ctifi cn brd.", 
__func__
);

305 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

306 
r
;

309 if(
	`X509_check_
(
x
) > 0)

310 (*
isCA
) = 1;

312 (*
isCA
) = 0;

314 
r
:

315 if(
x
 !
NULL
)

316 
	`X509_
(
x
);

318  
t
;

319 
	}
}

321 
	$VifyClbackfunc
(
ok
, 
X509_STORE_CTX
* 
e
)

323 
buf
[256] = {0, };

324 
vify_cڋxt
* vify_cڋx(vify_cڋxt*)
	`X509_STORE_CTX_g_p_da
(
e
);

326 if(
vify_cڋxt
 !
NULL
) {

327 
vify_cڋxt
->
dth
 += 1;

330 if(
e
->
cut_
 !
NULL
)

331 
	`X509_NAME_ږe
(
	`X509_g_subje_me
(
e
->
cut_
), 
buf
, 256);

333 
	`y
(
buf
, "test", 4);

335 if(
vify_cڋxt
 !
NULL
) {

336 
	`SLOGD
("[%s] Ctifi %i: %s", 
__func__
, 
vify_cڋxt
->
dth
, 
buf
);

339  
ok
;

340 
	}
}

342 
	$_is_deu_sdk_auth
(
_svc_mem_buff
* 
sigr_
, *
is_deu
)

344 cڡ * 
_sdk_deu_auth_
 =

358 
codeL
 = (((
sigr_
->
size
 + 2) / 3) * 4) + 1;

359 
codedL
 = 0;

360 *
codedBufr
 = (*)
	`mloc
((* 
codeL
);

361 i(
codedBufr
 =
NULL
)

362  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

364 
t
 = 
	`_svc_ut_ba64_code
(
sigr_
->
da
, sigr_->
size
, 
codedBufr
, &
codedL
);

365 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

367 
	`SLOGE
("Failedoncode certificate");

368 
	`
(
codedBufr
);

369  
CERT_SVC_ERR_INVALID_CERTIFICATE
;

372 if(!
	`memcmp
(
_sdk_deu_auth_
, 
codedBufr
, 
codedL
))

374 
	`SLOGE
("Error! Author signature signed by SDK default certificate.");

375 *
is_deu
 = 1;

376 
	`
(
codedBufr
);

377  
CERT_SVC_ERR_INVALID_SDK_DEFAULT_AUTHOR_CERT
;

380 
	`
(
codedBufr
);

381 *
is_deu
 = 0;

382  
CERT_SVC_ERR_NO_ERROR
;

383 
	}
}

385 
	$_move_lfsigd___cha
(
_svc_lked_li
** 
Li
)

387 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

388 
_svc_lked_li
* 
ev
 = 
NULL
;

389 
_svc_lked_li
* 
cut
 = 
NULL
;

390 
_svc_lked_li
* 
t
 = 
NULL
;

391 
_svc_lked_li
* 
ded
 = 
NULL
;

392 
_svc__dest
* 
desc
 = 
NULL
;

393 
f_g
 = 0;

395 
t
 = (*
Li
);

396 
ev
 = 
t
;

398 
cut
 = (*
Li
); cu!
NULL
; cucut->
xt
) {

399 
ded
 = 
cut
;

401 
desc
 = (
_svc__dest
*)
	`mloc
((cert_svc_cert_descriptor));

402 if(
desc
 =
NULL
) {

403 
	`SLOGE
("[ERR][%s] Faخlo ctifi dest.", 
__func__
);

404  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

406 
	`memt
(
desc
, 0x00, (
_svc__dest
));

408 if((
t
 = 
	`_exa_ifi_da
(
cut
->
ifi
, 
desc
)!
CERT_SVC_ERR_NO_ERROR
) {

409 
	`SLOGE
("[ERR][%s] Faexa ctifi da.", 
__func__
);

410 
r
;

413 if(!
	`cmp
((cڡ *)(
desc
->
fo
.
subjeS
), (cڡ *)(desc->fo.
issuS
), 
	`
((const *)(certdesc->info.issuerStr)))) {

414 if(
f_g
 == 0) {

415 
t
 = s->
xt
;

416 
ev
 = 
t
;

418 
ded
->
xt
 = 
NULL
;

419 
	`a__li
(
ded
);

421 
	`a_ifi_da
(
desc
);

422 
desc
 = 
NULL
;

426 
ev
->
xt
 = 
cut
->next;

428 
ded
->
xt
 = 
NULL
;

429 
	`a__li
(
ded
);

433 
ev
 = 
cut
;

436 
	`a_ifi_da
(
desc
);

437 
desc
 = 
NULL
;

439 
f_g
 = 1;

442 (*
Li

t
;

444 
r
:

445 if(
desc
 !
NULL
)

446 
	`a_ifi_da
(
desc
);

448  
t
;

449 
	}
}

451 
	$_vify_ifi_wh_ag
(
_svc_mem_buff
* 
Buf
, 
_svc_lked_li
** 
Li
, 
checkCaFg
, 
_svc_fame_li
* 
roPh
, * 
vidy
)

453 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

454 
_svc_lked_li
* 
s܋d
 = 
NULL
;

455 
_svc_lked_li
* 
p
 = 
NULL
;

456 
_svc_lked_li
* 
q
 = 
NULL
;

457 
_svc__dest
* 
fdRo
 = 
NULL
;

458 
_svc_fame_li
* 
feNames
 = 
NULL
;

459 
_svc_mem_buff
* 
CACt
 = 
NULL
;

460 
isCA
 = -1;

462 
Num
 = 0;

463 
Index
 = 0, 
i
 = 0;

464 cڡ * 
Cڋ
 = 
NULL
;

465 
X509_STORE_CTX
* 
eCtx
 = 
NULL
;

466 
X509
* 
roCt
 = 
NULL
;

467 
X509
** 
rCt
 = 
NULL
;

468 
X509
* 
rgCt
 = 
NULL
;

469 
	`STACK_OF
(
X509
*
tcha
, *
ucha
;

470 
	`STACK_OF
(
X509
*
suCha
;

471 
X509
* 
tmpCt
 = 
NULL
;

472 
FgVidy
;

473 
is_deu_auth
 = 0;

475 
	`OnSSL_add_l_gܙhms
();

476 
tcha
 = 
	`sk_X509_w_nu
();

477 
ucha
 = 
	`sk_X509_w_nu
();

479 
t
 = 
	`_is_deu_sdk_auth
(
Buf
, &
is_deu_auth
);

480 if(
t
 =
CERT_SVC_ERR_INVALID_SDK_DEFAULT_AUTHOR_CERT
 && 
is_deu_auth
)

481  
CERT_SVC_ERR_INVALID_SDK_DEFAULT_AUTHOR_CERT
;

483 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

484  
CERT_SVC_ERR_INVALID_CERTIFICATE
;

486 
fdRo
 = (
_svc__dest
*)
	`mloc
((cert_svc_cert_descriptor));

487 if(
fdRo
 =
NULL
) {

488 
	`SLOGE
("[ERR][%s] Faedخlo memy f ctifi dest.", 
__func__
);

489 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

490 
r
;

493 
	`memt
(
fdRo
, 0x00, (
_svc__dest
));

495 if((*
Li
!
NULL
) {

497 if((
t
 = 
	`_move_lfsigd___cha
(
Li
)!
CERT_SVC_ERR_NO_ERROR
) {

498 
	`SLOGE
("[ERR][%s] Faػmovlf-sigd ctifi icha.", 
__func__
);

499 
r
;

502 if((
t
 = 
	`st__cha
(
Li
, &
s܋d
)!
CERT_SVC_ERR_NO_ERROR
) {

503 
	`SLOGE
("[ERR][%s] Fas܈ifi cha.", 
__func__
);

504 
r
;

508 
p
 = 
s܋d
;

509 
p
->
xt
 !
NULL
) {

510 
Num
++;

511 
p
 =->
xt
;

513 
Num
++;

515 
t
 = 
	`_exa_ifi_da
(
p
->
ifi
, 
fdRo
);

518 
t
 = 
	`_exa_ifi_da
(
Buf
, 
fdRo
);

520 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

521 
	`SLOGE
("[ERR][%s] Faexa ctifi da", 
__func__
);

522 
r
;

525 if((
t
 = 
	`_ch_ifi
(&
feNames
, 
SUBJECT_STR
, (*)
fdRo
->
fo
.
issuS
)!
CERT_SVC_ERR_NO_ERROR
) {

526 
	`SLOGE
("[ERR][%s] Faأcho ctifi", 
__func__
);

527 
r
;

530 if(
feNames
->
fame
 =
NULL
) {

531 
	`SLOGE
("[ERR][%s] ThinCA ctifi.", 
__func__
);

532 
t
 = 
CERT_SVC_ERR_NO_ROOT_CERT
;

533 
r
;

536 
CACt
 = (
_svc_mem_buff
*)
	`mloc
((cert_svc_mem_buff));

537 if(
CACt
 =
NULL
) {

538 
	`SLOGE
("[ERR][%s] Faedخlo memy f c.", 
__func__
);

539 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

540 
r
;

543 
	`memt
(
CACt
, 0x00, (
_svc_mem_buff
));

546 if((
t
 = 
	`_svc_ut_ld_fe_to_bufr
(
feNames
->
fame
, 
CACt
)!
CERT_SVC_ERR_NO_ERROR
) {

547 
	`SLOGE
("[ERR][%s] Fald CA ctbufr.", 
__func__
);

548 
r
;

552 
	`y
(
roPh
->
fame
, 
feNames
->fame, 
CERT_SVC_MAX_FILE_NAME_SIZE
 - 1);

553 
roPh
->
fame
[
CERT_SVC_MAX_FILE_NAME_SIZE
 - 1] = '\0';

555 if((
t
 = 
	`is_CACt
(
CACt
, &
isCA
)!
CERT_SVC_ERR_NO_ERROR
) {

556 
	`SLOGE
("[ERR][%s] CA ctifi ivid.", 
__func__
);

557 
r
;

560 if(
isCA
 != 1) {

561 
	`SLOGE
("[ERR][%s] Found ctifi iNOT CA ctifi.", 
__func__
);

562 
t
 = 
CERT_SVC_ERR_NO_ROOT_CERT
;

563 
r
;

568 
Cڋ
 = 
CACt
->
da
;

569 
	`d2i_X509
(&
roCt
, &
Cڋ
, 
CACt
->
size
);

570 if(!(
	`sk_X509_push
(
tcha
, 
roCt
))) {

571 
	`SLOGE
("[ERR][%s] Fapush ctifi iءack.", 
__func__
);

572 
t
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

573 
r
;

576 
Cڋ
 = 
Buf
->
da
;

577 
	`d2i_X509
(&
rgCt
, &
Cڋ
, 
Buf
->
size
);

579 
q
 = 
s܋d
;

582 if(
q
 !
NULL
) {

583 
Index
 = 0;

584 
rCt
 = (
X509
**)
	`mloc
((X509** 
Num
);

585 if(
rCt
 =
NULL
) {

586 
	`SLOGE
("[ERR][%s] Faedخlo memy f iim ctifi.", 
__func__
);

587 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

588 
r
;

591 
	`memt
(
rCt
, 0x00, ((
X509
** 
Num
));

593 
Cڋ
 = 
q
->
ifi
->
da
;

594 if(!
	`d2i_X509
(&
rCt
[
Index
], &
Cڋ
, 
q
->
ifi
->
size
)) {

595 
	`SLOGE
("[ERR][%s] Fald ctifi imemy.", 
__func__
);

596 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

597 
r
;

599 if(!(
	`sk_X509_push
(
ucha
, 
rCt
[
Index
]))) {

600 
	`SLOGE
("[ERR][%s] Fapush ctifi iءack.", 
__func__
);

601 
t
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

602 
r
;

605 if(
q
->
xt
 =
NULL
)

608 
q
 = q->
xt
;

609 
Index
++;

614 
eCtx
 = 
	`X509_STORE_CTX_w
();

616 if(!
	`X509_STORE_CTX_
(
eCtx
, 0, 
rgCt
, 
ucha
)) {

617 
	`SLOGE
("[ERR][%s] FaؚlizX509 stܐcڋxt.", 
__func__
);

618 
r
;

620 
vify_cڋxt
 verify_context = { 0 };

621 
	`X509_STORE_CTX_t_p_da
(
eCtx
, &
vify_cڋxt
);

622 
	`X509_STORE_CTX_t_vify_cb
(
eCtx
, 
VifyClbackfunc
);

623 
	`X509_STORE_CTX_ued_ack
(
eCtx
, 
tcha
);

625 
	`SLOGD
("verify signer certificate");

626 if(((*
vidy

	`X509_vify_
(
eCtx
)) != 1) {

627 
r
 = 
	`X509_STORE_CTX_g_r
(
eCtx
);

629 
	`SLOGE
("[ERR][%s] Favify ctifi cha, vidy: [%d]", 
__func__
, (*
vidy
));

630 
	`SLOGE
("r: [%s]", 
	`X509_vify__r_rg
(
r
));

633 
_ty
=0;

634 *
fgt
 = 
NULL
;

635 *
da
 = 
NULL
;

636 
Size
 = 0;

638 
da
 = 
CACt
->
da
;

639 
Size
 = 
CACt
->
size
;

641 
t
 = 
	`g_ifi_fgt
(
da
, 
Size
, &
fgt
);

642 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

644 
	`SLOGE
("Faedg fgda! %d", 
t
);

645 
r
;

648 
t
 = 
	`g_ty_by_fgt
(
fgt
, &
_ty
);

649 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

651 
	`SLOGE
("Faedgev! %d", 
t
);

652 
r
;

655 
	`SLOGD
("_ty = %d", 
_ty
);

656 if(
_ty
 !
CERT_SVC_TYPE_TEST
 && ct_ty !
CERT_SVC_TYPE_VERIFY
){

658 
	`SLOGD
("Level isot Test or Verity");

659 if
r
 =
X509_V_ERR_CERT_NOT_YET_VALID
 ||

660 
r
 =
X509_V_ERR_CERT_HAS_EXPIRED
 ||

661 
r
 =
X509_V_ERR_CRL_NOT_YET_VALID
 ||

662 
r
 =
X509_V_ERR_CRL_HAS_EXPIRED
 ||

663 
r
 =
X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD
 ||

664 
r
 =
X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD
 ||

665 
r
 =
X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD
 ||

666 
r
 =
X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD
) {

668 
	`SLOGD
("Skip checking validime of signer cert");

669 (*
vidy
) = 1;

673 
t
 = 
CERT_SVC_ERR_IS_EXPIRED
;

674 
r
;

678 if(
checkCaFg
) {

679 
suCha
 = 
	`X509_STORE_CTX_g1_cha
(
eCtx
);

680 (
tmpCt
 = 
	`sk_X509_p
(
suCha
))) {

681 
FgVidy
 = 
	`X509_check_
(
tmpCt
);

682 if(
FgVidy
 !1 && (
	`sk_X509_p
(
suCha
)!
NULL
) {

683 (*
vidy
) = 0;

684 
	`SLOGE
("[ERR][%s] Invid CA Fg f CA Ctifi, vidy: [%d]", 
__func__
, (*
vidy
));

690 
r
:

691 if(
roCt
 !
NULL
)

692 
	`X509_
(
roCt
);

693 if(
rgCt
 !
NULL
)

694 
	`X509_
(
rgCt
);

695 if(
eCtx
 !
NULL
)

696 
	`X509_STORE_CTX_
(
eCtx
);

697 if(
tcha
 !
NULL
)

698 
	`sk_X509_
(
tcha
);

699 if(
ucha
 !
NULL
)

700 
	`sk_X509_
(
ucha
);

702 if(
rCt
 !
NULL
) {

703 
i
 = 0; i < 
Num
; i++) {

704 if(
rCt
[
i
] !
NULL
)

705 
	`X509_
(
rCt
[
i
]);

707 
	`
(
rCt
);

711 
	`a_ifi_buf
(
CACt
);

712 
	`a_ifi_da
(
fdRo
);

713 
	`a_fame_li
(
feNames
);

714 
	`a__li
(
s܋d
);

716  
t
;

717 
	}
}

719 
	$_vify_sigtu
(
_svc_mem_buff
* 
Buf
, * 
mesge
, 
msgL
, * 
sigtu
, * 
go
, * 
vidy
)

721 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

722 
X509
* 
x
 = 
NULL
;

723 cڡ * 
p
 = 
NULL
;

725 
EVP_MD_CTX
* 
mdx
 = 
NULL
;

726 cڡ 
EVP_MD
* 
md
 = 
NULL
;

728 * 
decodedSig
 = 
NULL
;

729 
decodedSigL
 = 0;

730 
sigL
 = 0;

732 
EVP_PKEY
 *
pkey
 = 
NULL
;

734 
	`OnSSL_add_l_diges
();

737 
p
 = 
Buf
->
da
;

738 
	`d2i_X509
(&
x
, &
p
, 
Buf
->
size
);

739 if(
x
 =
NULL
) {

740 
	`SLOGE
("[ERR][%s] Faخlo X509 suu.", 
__func__
);

741 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

742 
r
;

746 
sigL
 = 
	`
((cڡ *)
sigtu
);

747 
decodedSigL
 = ((
sigL
 / 4) * 3) + 1;

749 if(!(
decodedSig
 = (*)
	`mloc
((* 
decodedSigL
))) {

750 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

751 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

752 
r
;

754 
	`memt
(
decodedSig
, 0x00, 
decodedSigL
);

755 if((
t
 = 
	`_svc_ut_ba64_decode
(
sigtu
, 
sigL
, 
decodedSig
, &
decodedSigL
)!
CERT_SVC_ERR_NO_ERROR
) {

756 
	`SLOGE
("[ERR][%s] Faba64 decode.", 
__func__
);

757 
t
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

758 
r
;

762 
pkey
 = 
	`X509_g_pubkey
(
x
);

765 if(!(
mdx
 = 
	`EVP_MD_CTX_
())) {

766 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

767 
r
;

770 if(
go
 =
NULL
) {

771 if(!(
md
 = 
	`EVP_g_digebyobj
(
x
->
_fo
->
sigtu
->
gܙhm
))) {

772 
	`SLOGE
("[ERR][%s] Fag hashlgܙhm.", 
__func__
);

773 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

774 
r
;

778 if(!(
md
 = 
	`EVP_g_digebyme
(
go
))) {

779 
	`SLOGE
("[ERR][%s] Fag hashlgܙhm.", 
__func__
);

780 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

781 
r
;

786 if(
	`EVP_VifyIn_ex
(
mdx
, 
md
, 
NULL
) != 1) {

787 
	`SLOGE
("[ERR][%s] Faexecu EVP_VifyIn_ex().", 
__func__
);

788 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

789 
r
;

791 if(
	`EVP_VifyUpde
(
mdx
, 
mesge
, 
msgL
) != 1) {

792 
	`SLOGE
("[ERR][%s] Faexecu EVP_VifyUpde().", 
__func__
);

793 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

794 
r
;

796 if(((*
vidy

	`EVP_VifyF
(
mdx
, 
decodedSig
, 
decodedSigL
, 
pkey
)) != 1) {

797 
	`SLOGE
("[ERR][%s] Favify sigtu.", 
__func__
);

798 
t
 = 
CERT_SVC_ERR_INVALID_SIGNATURE
;

799 
r
;

802 
r
:

803 if(
x
 !
NULL
)

804 
	`X509_
(
x
);

805 if(
decodedSig
 !
NULL
)

806 
	`
(
decodedSig
);

807 if(
pkey
 !
NULL
)

808 
	`EVP_PKEY_
(
pkey
);

809 if(
mdx
 !
NULL
)

810 
	`EVP_MD_CTX_deroy
(
mdx
);

813  
t
;

814 
	}
}

816 
	$_exa_ifi_da
(
_svc_mem_buff
* 

, 
_svc__dest
* 
Desc
)

818 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

819 
X509
* 
x
 = 
NULL
;

820 cڡ * 
p
 = 
NULL
;

821 
i
 = 0;

823 * 
sigtuAlgo
 = 
NULL
;

824 
sigL
 = 0;

826 
issuSL
 = 0;

827 * 
tmpIssuS
 = 
NULL
;

829 
ASN1_GENERALIZEDTIME
* 
timeNBefe
 = 
NULL
;

830 
ASN1_GENERALIZEDTIME
* 
timeNA
 = 
NULL
;

832 
subjeSL
 = 0;

833 * 
tmpSubjeS
 = 
NULL
;

835 * 
publicKeyAlgo
 = 
NULL
;

836 
publicKeyAlgoL
 = 0;

838 * 
pubkeyTmp
 = 
NULL
;

839 
pkeyL
 = 0;

840 
EVP_PKEY
* 
evp
 = 
NULL
;

841 
issuUidL
 = 0, 
subjeUidL
 = 0;

843 
X509_EXTENSION
* 
ext
 = 
NULL
;

844 * 
extObje
 = 
NULL
;

845 
extObjL
 = 0;

846 * 
extVue
 = 
NULL
;

847 
extVL
 = 0;

850 * 
sigAlgo
 = 
NULL
;

851 
sigAlgoL
 = 0, 
sigDaL
 = 0;

853 
	`memt
(
Desc
, 0x00, (
_svc__dest
));

855 
p
 = 

->
da
;

856 
	`d2i_X509
(&
x
, &
p
, 

->
size
);

857 if(
x
 =
NULL
) {

858 
	`SLOGE
("[ERR][%s] Faخlo X509 suu.", 
__func__
);

859 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

860 
r
;

864 
	`y
(
Desc
->
ty
, 

->type, 3);

865 
Desc
->
ty
[3] = '\0';

867 
Desc
->
fo
.
vsi
 = 
	`g_ASN1_INTEGER
(
x
->
_fo
->version) + 1;

868 
Desc
->
fo
.
rlNumb
 = 
	`g_ASN1_INTEGER
(
x
->
_fo
->serialNumber);

870 
sigtuAlgo
 = (*)
	`g_ASN1_OBJECT
(
x
->
_fo
->
sigtu
->
gܙhm
);

871 if(
sigtuAlgo
 =
NULL
) {

872 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

873 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

874 
r
;

876 
sigL
 = 
	`
((cڡ *)
sigtuAlgo
);

877 
Desc
->
fo
.
sigAlgo
 = (*)
	`mloc
((* (
sigL
 + 1));

878 if(
Desc
->
fo
.
sigAlgo
 =
NULL
) {

879 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

880 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

881 
r
;

883 
	`memt
(
Desc
->
fo
.
sigAlgo
, 0x00, (
sigL
 + 1));

884 
	`memy
(
Desc
->
fo
.
sigAlgo
, 
sigtuAlgo
, 
sigL
);

886 
tmpIssuS
 = (*)
	`g_X509_NAME
(
x
->
_fo
->
issu
);

887 
issuSL
 = 
	`
((cڡ *)
tmpIssuS
);

888 
Desc
->
fo
.
issuS
 = (*)
	`mloc
((* (
issuSL
 + 1));

889 if(
Desc
->
fo
.
issuS
 =
NULL
) {

890 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

891 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

892 
r
;

894 
	`memt
(
Desc
->
fo
.
issuS
, 0x00, (
issuSL
 + 1));

895 
	`memy
(
Desc
->
fo
.
issuS
, 
tmpIssuS
, 
issuSL
);

897 if((
t
 = 
	`r_me_d_da
(
tmpIssuS
, &(
Desc
->
fo
.
issu
))!
CERT_SVC_ERR_NO_ERROR
) {

898 
	`SLOGE
("[ERR][%s] Faطr ct_svc_me_d_da.", 
__func__
);

899 
r
;

902 
	`ASN1_TIME_to_gizedtime
(
x
->
_fo
->
vidy
->
nBefe
, &
timeNBefe
);

903 
	`ASN1_TIME_to_gizedtime
(
x
->
_fo
->
vidy
->
nA
, &
timeNA
);

904 if((
t
 = 
	`r_time_d_da
(
timeNBefe
->
da
, 
timeNA
->da, &(
Desc
->
fo
.
vidPiod
))!
CERT_SVC_ERR_NO_ERROR
) {

905 
	`SLOGE
("[ERR][%s] Faطr ct_svc_vidy_d_da.", 
__func__
);

906 
r
;

909 
tmpSubjeS
 = (*)
	`g_X509_NAME
(
x
->
_fo
->
subje
);

910 
subjeSL
 = 
	`
((cڡ *)
tmpSubjeS
);

911 
Desc
->
fo
.
subjeS
 = (*)
	`mloc
((* (
subjeSL
 + 1));

912 if(
Desc
->
fo
.
subjeS
 =
NULL
) {

913 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

914 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

915 
r
;

917 
	`memt
(
Desc
->
fo
.
subjeS
, 0x00, (
subjeSL
 + 1));

918 
	`memy
(
Desc
->
fo
.
subjeS
, 
tmpSubjeS
, 
subjeSL
);

920 if((
t
 = 
	`r_me_d_da
(
tmpSubjeS
, &(
Desc
->
fo
.
subje
))!
CERT_SVC_ERR_NO_ERROR
) {

921 
	`SLOGE
("[ERR][%s] Faطr ct_svc_me_d_da.", 
__func__
);

922 
r
;

925 
publicKeyAlgo
 = (*)
	`g_ASN1_OBJECT
(
x
->
_fo
->
key
->
g
->
gܙhm
);

926 if(
publicKeyAlgo
 =
NULL
) {

927 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

928 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

929 
r
;

932 
publicKeyAlgoL
 = 
	`
((cڡ *)
publicKeyAlgo
);

933 
Desc
->
fo
.
pubKeyAlgo
 = (*)
	`mloc
((* (
publicKeyAlgoL
 + 1));

934 if(
Desc
->
fo
.
pubKeyAlgo
 =
NULL
) {

935 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

936 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

937 
r
;

939 
	`memt
(
Desc
->
fo
.
pubKeyAlgo
, 0x00, (
publicKeyAlgoL
 + 1));

940 
	`memy
(
Desc
->
fo
.
pubKeyAlgo
, 
publicKeyAlgo
, 
publicKeyAlgoL
);

942 if((
evp
 = 
	`X509_g_pubkey
(
x
)=
NULL
) {

943 
	`SLOGE
("[ERR][%s] Publikey inu.", 
__func__
);

944 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

945 
r
;

947 
pkeyL
 = 
	`i2d_PublicKey
(
x
->
_fo
->
key
->
pkey
, 
NULL
);

948 
Desc
->
fo
.
pubKey
 = (*)
	`mloc
((* (
pkeyL
 + 1));

949 if(
Desc
->
fo
.
pubKey
 =
NULL
) {

950 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

951 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

952 
r
;

954 
pubkeyTmp
 = 
Desc
->
fo
.
pubKey
;

955 
	`i2d_PublicKey
(
x
->
_fo
->
key
->
pkey
, &
pubkeyTmp
);

956 
Desc
->
fo
.
pubKeyL
 = 
pkeyL
;

958 if(
x
->
_fo
->
issuUID
 !
NULL
) {

959 
issuUidL
 = 
x
->
_fo
->
issuUID
->
ngth
;

960 
Desc
->
fo
.
issuUID
 = (*)
	`mloc
((* (
issuUidL
 + 1));

961 if(
Desc
->
fo
.
issuUID
 =
NULL
) {

962 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

963 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

964 
r
;

966 
	`memt
(
Desc
->
fo
.
issuUID
, 0x00, (
issuUidL
 + 1));

967 
	`memy
(
Desc
->
fo
.
issuUID
, 
x
->
_fo
->issuUID->
da
, 
issuUidL
);

970 
Desc
->
fo
.
issuUID
 = 
NULL
;

973 if(
x
->
_fo
->
subjeUID
 !
NULL
) {

974 
subjeUidL
 = 
x
->
_fo
->
subjeUID
->
ngth
;

975 
Desc
->
fo
.
subjeUID
 = (*)
	`mloc
((* (
subjeUidL
 + 1));

976 if(
Desc
->
fo
.
subjeUID
 =
NULL
) {

977 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

978 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

979 
r
;

981 
	`memt
(
Desc
->
fo
.
subjeUID
, 0x00, (
subjeUidL
 + 1));

982 
	`memy
(
Desc
->
fo
.
subjeUID
, 
x
->
_fo
->subjeUID->
da
, 
subjeUidL
);

985 
Desc
->
fo
.
subjeUID
 = 
NULL
;

987 if(
x
->
_fo
->
exnsis
 !
NULL
) {

989 
Desc
->
ext
.
numOfFlds
 = 
	`sk_X509_EXTENSION_num
(
x
->
_fo
->
exnsis
);

990 
Desc
->
ext
.
flds
 = (
_svc__d_desc
*)
	`mloc
((_svc__d_desc* ctDesc->ext.
numOfFlds
);

991 if(
Desc
->
ext
.
flds
 =
NULL
) {

992 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

993 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

994 
r
;

997 
i
 = 0; i < ()
Desc
->
ext
.
numOfFlds
; i++) {

998 
ext
 = 
	`sk_X509_EXTENSION_vue
(
x
->
_fo
->
exnsis
, 
i
);

999 if(
ext
 !
NULL
) {

1000 
extObje
 = (*)
	`g_ASN1_OBJECT
(
ext
->
obje
);

1001 if(
extObje
 =
NULL
) {

1002 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

1003 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1004 
r
;

1006 
extObjL
 = 
	`
((cڡ *)
extObje
);

1007 
Desc
->
ext
.
flds
[
i
].
me
 = (*)
	`mloc
((* (
extObjL
 + 1));

1008 if(
Desc
->
ext
.
flds
[
i
].
me
 =
NULL
) {

1009 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

1010 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1011 
r
;

1013 
	`memt
(
Desc
->
ext
.
flds
[
i
].
me
, 0x00, (
extObjL
 + 1));

1014 
	`memy
(
Desc
->
ext
.
flds
[
i
].
me
, 
extObje
, 
extObjL
);

1016 
extVue
 = (*)
ext
->
vue
->
da
;

1017 
extVL
 = 
ext
->
vue
->
ngth
;

1018 
Desc
->
ext
.
flds
[
i
].
da
 = (*)
	`mloc
((* (
extVL
 + 1));

1019 if(
Desc
->
ext
.
flds
[
i
].
da
 =
NULL
) {

1020 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

1021 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1022 
r
;

1024 
	`memt
(
Desc
->
ext
.
flds
[
i
].
da
, 0x00, (
extVL
 + 1));

1025 
	`memy
(
Desc
->
ext
.
flds
[
i
].
da
, 
extVue
, 
extVL
);

1027 
Desc
->
ext
.
flds
[
i
].
dasize
 = 
extVL
;

1032 
sigAlgo
 = (*)
	`g_ASN1_OBJECT
(
x
->
sig_g
->
gܙhm
);

1033 if(
sigAlgo
 =
NULL
) {

1034 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

1035 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1036 
r
;

1038 
sigAlgoL
 = 
	`
((cڡ *)
sigAlgo
);

1039 
Desc
->
sigtuAlgo
 = (*)
	`mloc
((* (
sigAlgoL
 + 1));

1040 if(
Desc
->
sigtuAlgo
 =
NULL
) {

1041 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

1042 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1043 
r
;

1045 
	`memt
(
Desc
->
sigtuAlgo
, 0x00, (
sigAlgoL
 + 1));

1046 
	`memy
(
Desc
->
sigtuAlgo
, 
sigAlgo
, 
sigAlgoL
);

1048 
sigDaL
 = 
x
->
sigtu
->
ngth
;

1049 
Desc
->
sigtuL
 = 
sigDaL
;

1050 
Desc
->
sigtuDa
 = (*)
	`mloc
((* (
sigDaL
 + 1));

1051 if(
Desc
->
sigtuDa
 =
NULL
) {

1052 
	`SLOGE
("[ERR][%s] Faedخlo memy.", 
__func__
);

1053 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1054 
r
;

1056 
	`memt
(
Desc
->
sigtuDa
, 0x00, (
sigDaL
 + 1));

1057 
	`memy
(
Desc
->
sigtuDa
, 
x
->
sigtu
->
da
, 
sigDaL
);

1059 
r
:

1060 if(
x
 !
NULL

	`X509_
(x);

1061 if(
evp
 !
NULL

	`EVP_PKEY_
(evp);

1063 if(
tmpIssuS
 !
NULL

	`OPENSSL_
(tmpIssuerStr);

1064 if(
tmpSubjeS
 !
NULL

	`OPENSSL_
(tmpSubjectStr);

1066 if(
timeNBefe
 !
NULL

	`ASN1_GENERALIZEDTIME_
(timeNotBefore);

1067 if(
timeNA
 !
NULL

	`ASN1_GENERALIZEDTIME_
(timeNotAfter);

1069  
t
;

1070 
	}
}

1072 
	$ch_da_fld
(
ch_fld
 
dName
, * 
dDa
, 
_svc__dest
* 
Desc
)

1074 
t
 = -1;

1075 
n
 = 0;

1077 
dName
) {

1078 
ISSUER_COUNTRY
:

1079 if(
Desc
->
fo
.
issu
.
couryName
) {

1080 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
issu
.
couryName
));

1081 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
issu
.
couryName
), 
n
)) {

1082 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1083 
t
 = 0;

1085 
t
 = 0;

1087 
t
 = 0;

1089 
ISSUER_STATEORPROVINCE
:

1090 if(
Desc
->
fo
.
issu
.
eOrProvName
) {

1091 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
issu
.
eOrProvName
));

1092 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
issu
.
eOrProvName
), 
n
)) {

1093 if(()
	`
(
dDa
=
n

t
 = 1;

1094 
t
 = 0;

1096 
t
 = 0;

1098 
t
 = 0;

1100 
ISSUER_LOCALITY
:

1101 if(
Desc
->
fo
.
issu
.
lolyName
) {

1102 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
issu
.
lolyName
));

1103 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
issu
.
lolyName
), 
n
)) {

1104 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1105 
t
 = 0;

1107 
t
 = 0;

1109 
t
 = 0;

1111 
ISSUER_ORGANIZATION
:

1112 if(
Desc
->
fo
.
issu
.
giziName
) {

1113 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
issu
.
giziName
));

1114 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
issu
.
giziName
), 
n
)) {

1115 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1116 
t
 = 0;

1118 
t
 = 0;

1120 
t
 = 0;

1122 
ISSUER_ORGANIZATIONUNIT
:

1123 if(
Desc
->
fo
.
issu
.
giziUnName
) {

1124 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
issu
.
giziUnName
));

1125 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
issu
.
giziUnName
), 
n
)) {

1126 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1127 
t
 = 0;

1129 
t
 = 0;

1131 
t
 = 0;

1133 
ISSUER_COMMONNAME
:

1134 if(
Desc
->
fo
.
issu
.
commName
) {

1135 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
issu
.
commName
));

1136 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
issu
.
commName
), 
n
)) {

1137 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1138 
t
 = 0;

1140 
t
 = 0;

1142 
t
 = 0;

1144 
ISSUER_EMAILADDRESS
:

1145 if(
Desc
->
fo
.
issu
.
emaAddss
) {

1146 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
issu
.
emaAddss
));

1147 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
issu
.
emaAddss
), 
n
)) {

1148 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1149 
t
 = 0;

1151 
t
 = 0;

1153 
t
 = 0;

1155 
ISSUER_STR
:

1156 if(
Desc
->
fo
.
issuS
) {

1157 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
issuS
));

1158 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
issuS
), 
n
)) {

1159 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1160 
t
 = 0;

1162 
t
 = 0;

1164 
t
 = 0;

1166 
SUBJECT_COUNTRY
:

1167 if(
Desc
->
fo
.
subje
.
couryName
) {

1168 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
subje
.
couryName
));

1169 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
subje
.
couryName
), 
n
)) {

1170 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1171 
t
 = 0;

1173 
t
 = 0;

1175 
t
 = 0;

1177 
SUBJECT_STATEORPROVINCE
:

1178 if(
Desc
->
fo
.
subje
.
eOrProvName
) {

1179 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
subje
.
eOrProvName
));

1180 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
subje
.
eOrProvName
), 
n
)) {

1181 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1182 
t
 = 0;

1184 
t
 = 0;

1186 
t
 = 0;

1188 
SUBJECT_LOCALITY
:

1189 if(
Desc
->
fo
.
subje
.
lolyName
) {

1190 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
subje
.
lolyName
));

1191 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
subje
.
lolyName
), 
n
)) {

1192 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1193 
t
 = 0;

1195 
t
 = 0;

1197 
t
 = 0;

1199 
SUBJECT_ORGANIZATION
:

1200 if(
Desc
->
fo
.
subje
.
giziName
) {

1201 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
subje
.
giziName
));

1202 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
subje
.
giziName
), 
n
)) {

1203 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1204 
t
 = 0;

1206 
t
 = 0;

1208 
t
 = 0;

1210 
SUBJECT_ORGANIZATIONUNIT
:

1211 if(
Desc
->
fo
.
subje
.
giziUnName
) {

1212 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
subje
.
giziUnName
));

1213 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
subje
.
giziUnName
), 
n
)) {

1214 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1215 
t
 = 0;

1217 
t
 = 0;

1219 
t
 = 0;

1221 
SUBJECT_COMMONNAME
:

1222 if(
Desc
->
fo
.
subje
.
commName
) {

1223 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
subje
.
commName
));

1224 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
subje
.
commName
), 
n
)) {

1225 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1226 
t
 = 0;

1228 
t
 = 0;

1230 
t
 = 0;

1232 
SUBJECT_EMAILADDRESS
:

1233 if(
Desc
->
fo
.
subje
.
emaAddss
) {

1234 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
subje
.
emaAddss
));

1235 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
subje
.
emaAddss
), 
n
)) {

1236 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1237 
t
 = 0;

1239 
t
 = 0;

1241 
t
 = 0;

1243 
SUBJECT_STR
:

1244 if(
Desc
->
fo
.
subjeS
) {

1245 
n
 = 
	`
((cڡ *)(
Desc
->
fo
.
subjeS
));

1246 if(!
	`cmp
((cڡ *)
dDa
, (cڡ *)(
Desc
->
fo
.
subjeS
), 
n
)) {

1247 if(()
	`
((cڡ *)
dDa
=
n

t
 = 1;

1248 
t
 = 0;

1250 
t
 = 0;

1252 
t
 = 0;

1255 
t
 = 0;

1258  
t
;

1259 
	}
}

1261 
	$_g_l_ifis
(*cڡ *
ths
, 
_svc_fame_li
 **
l
) {

1262 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1263 
FTS
 *
s
 = 
NULL
;

1264 
FTSENT
 *

;

1266 
tmp
[10];

1267 
n
;

1268 
_svc_fame_li
 *
lol
 = 
NULL
;

1269 
_svc_fame_li
 *

;

1271 i(
NULL
 =(
s
 = 
	`s_ݒ
(
ths
, 
FTS_LOGICAL
, NULL))) {

1272 
t
 = 
CERT_SVC_ERR_FILE_IO
;

1273 
	`SLOGE
("[ERR][%s] Faݒ deܛs.", 
__func__
);

1274 
out
;

1277 (

 = 
	`s_ad
(
s
)!
NULL
) {

1279 i(

->
s_fo
 =
FTS_ERR
 || ft->s_f=
FTS_NS
) {

1280 
t
 = 
CERT_SVC_ERR_FILE_IO
;

1281 
	`SLOGE
("[ERR][%s] Faػad deܛs.", 
__func__
);

1282 
out
;

1285 i(

->
s_fo
 !
FTS_F
)

1288 i(-1 !
	`adlk
(

->
s_th
, 
tmp
, 10))

1291 
n
 = 
	`
((cڡ *)(

->
s_th
));

1292 i(
	`rcmp
((

->
s_th
 + 
n
 - 
	`
(".pem")), ".pem") != 0)

1295 

 = (
_svc_fame_li
*)
	`mloc
((cert_svc_filename_list));

1296 i(!

) {

1297 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1298 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

1299 
out
;

1301 

->
xt
 = 
lol
;

1302 
lol
 = 

;

1304 
lol
->
fame
 = (*)
	`mloc
(
n
+1);

1305 i(!
lol
->
fame
) {

1306 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1307 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

1308 
out
;

1310 
	`y
(
lol
->
fame
, 

->
s_th
, 
n
+1);

1313 *
l
 = 
lol
;

1314 
lol
 = 
NULL
;

1316 
out
:

1317 
lol
) {

1318 

 = 
lol
;

1319 
lol
 =ol->
xt
;

1320 
	`
(

->
fame
);

1321 
	`
(

);

1324 i(
s
 !
NULL
)

1325 
	`s_o
(
s
);

1326  
t
;

1327 
	}
}

1329 
	$g_l_ifis
(
_svc_fame_li
** 
lCts
)

1331 
t
;

1332 *
bufr
[2];

1334 
bufr
[0] = 
ROOT_CA_CERTS_DIR
;

1335 
bufr
[1] = 
NULL
;

1337 i(!
lCts
) {

1338 
	`SLOGE
("[ERR][%s] Invidrgumt.", 
__func__
);

1339  
CERT_SVC_ERR_INVALID_PARAMETER
;

1342 i((
t
 = 
	`_g_l_ifis
(
bufr
, 
lCts
)!
CERT_SVC_ERR_NO_ERROR
) {

1343 
	`SLOGE
("[ERR][%s] Fag fi.", 
__func__
);

1344  
t
;

1347  
CERT_SVC_ERR_NO_ERROR
;

1348 
	}
}

1350 
	$_ch_ifi
(
_svc_fame_li
** 
feNames
, 
ch_fld
 
dName
, * 
dDa
)

1352 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1353 
_svc_fame_li
* 
lCts
 = 
NULL
;

1354 
_svc_fame_li
* 
p
 = 
NULL
;

1355 
_svc_fame_li
* 
q
 = 
NULL
;

1356 
_svc_fame_li
* 
wNode
 = 
NULL
;

1357 
_svc_mem_buff
* 
Buf
 = 
NULL
;

1358 
_svc__dest
* 
Desc
 = 
NULL
;

1359 
mched
 = 0;

1360 

 
fe_fo
;

1362 if((
t
 = 
	`g_l_ifis
(&
lCts
)!
CERT_SVC_ERR_NO_ERROR
) {

1363 
	`SLOGE
("[ERR][%s] Fag ctifi fli,: [%d]", 
__func__
, 
t
);

1364 
r
;

1368 
p
 = 
lCts
;

1371 if((
	`l
(
p
->
fame
, &
fe_fo
)) < 0) {

1372 
	`SLOGE
("[ERR][%s] Fag fe(%sfmi.", 
__func__
, 
p
->
fame
);

1373 
t
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

1374 
r
;

1376 if((
fe_fo
.
_mode
 & 
S_IFLNK
) == S_IFLNK) {

1377 
	`SLOGD
("[LOG][%s] %isymbilk, igned.", 
__func__
, 
p
->
fame
);

1378 
_to_ld_fe
;

1382 if(!(
Buf
 = (
_svc_mem_buff
*)
	`mloc
((cert_svc_mem_buff)))) {

1383 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

1384 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1385 
r
;

1389 if((
t
 = 
	`_svc_ut_ld_fe_to_bufr
(
p
->
fame
, 
Buf
)!
CERT_SVC_ERR_NO_ERROR
) {

1390 
	`SLOGE
("[ERR][%s] Fald ftbufr, fame: [%s],: [%d]", 
__func__
, 
p
->
fame
, 
t
);

1391 
	`
(
Buf
);

1392 
Buf
 = 
NULL
;

1393 
_to_ld_fe
;

1397 if(!(
Desc
 = (
_svc__dest
*)
	`mloc
((cert_svc_cert_descriptor)))) {

1398 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

1399 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1400 
r
;

1404 if((
t
 = 
	`_exa_ifi_da
(
Buf
, 
Desc
)!
CERT_SVC_ERR_NO_ERROR
) {

1405 
	`SLOGE
("[ERR][%s] Faexa ctifi da, fame: [%s],: [%d]", 
__func__
, 
p
->
fame
, 
t
);

1406 
_to_exa_fe
;

1410 if(
	`ch_da_fld
(
dName
, 
dDa
, 
Desc
) == 1) {

1411 
mched
 = 1;

1413 if(!(
wNode
 = (
_svc_fame_li
*)
	`mloc
((cert_svc_filename_list)))) {

1414 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

1415 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1416 
r
;

1418 if(!(
wNode
->
fame
 = (*)
	`mloc
((* 
CERT_SVC_MAX_FILE_NAME_SIZE
))) {

1419 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

1420 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1421 
	`
(
wNode
);

1422 
r
;

1424 
	`memt
(
wNode
->
fame
, 0x00, 
CERT_SVC_MAX_FILE_NAME_SIZE
);

1426 
	`y
(
wNode
->
fame
, 
p
->fame, 
CERT_SVC_MAX_FILE_NAME_SIZE
 - 1);

1427 
wNode
->
fame
[
CERT_SVC_MAX_FILE_NAME_SIZE
 - 1] = '\0';

1429 
wNode
->
xt
 = 
NULL
;

1431 if((*
feNames
=
NULL
)

1432 (*
feNames

wNode
;

1434 
q
 = (*
feNames
);

1435 
q
->
xt
 !
NULL
)

1436 
q
 = q->
xt
;

1438 
q
->
xt
 = 
wNode
;

1442 
_to_exa_fe
:

1444 
	`a_ifi_buf
(
Buf
);

1445 
Buf
 = 
NULL
;

1446 
	`a_ifi_da
(
Desc
);

1447 
Desc
 = 
NULL
;

1449 
_to_ld_fe
:

1450 if(
p
->
xt
 =
NULL
)

1452 
p
 =->
xt
;

1455 if(
mched
 != 1) {

1456 
	`SLOGE
("[ERR][%s] Cn fdny ctifi you wt.", 
__func__
);

1457 
t
 = 
CERT_SVC_ERR_NO_MORE_CERTIFICATE
;

1460 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1462 
r
:

1463 
	`a_ifi_buf
(
Buf
);

1464 
	`a_ifi_da
(
Desc
);

1465 
	`a_fame_li
(
lCts
);

1467  
t
;

1468 
	}
}

1470 
X509
 *
	$__ldCt
(cڡ *
fe
)

1472 
FILE
 *

 = 
	`fݒ
(
fe
, "r");

1473 if(

 =
NULL
)

1474  
NULL
;

1475 
X509
 *

;

1476 if(!(

 = 
	`d2i_X509_
(

, 
NULL
))) {

1477 
	`fek
(

, 0, 
SEEK_SET
);

1478 

 = 
	`PEM_ad_X509
(

, 
NULL
, NULL, NULL);

1480 
	`fo
(

);

1481  

;

1482 
	}
}

1484 
__ldSyemCts
(
STACK_OF
(
X509
*
syemCts
)

1486 
	gt
 = 
CERT_SVC_ERR_NO_ERROR
;

1487 
_svc_fame_li
* 
	glCts
 = 
NULL
;

1488 
_svc_fame_li
* 
	gp
 = 
NULL
;

1489 

 
	gfe_fo
;

1490 
X509
 *
	g
;

1492 if((
	gt
 = 
g_l_ifis
(&
lCts
)!
CERT_SVC_ERR_NO_ERROR
) {

1493 
SLOGE
("[ERR][%s] Fag ctifi fli,: [%d]", 
__func__
, 
t
);

1494 
	gr
;

1497 
	gp
 = 
lCts
;

1499 if((
l
(
p
->
fame
, &
fe_fo
)) < 0) {

1500 
SLOGE
("[ERR][%s] Fag fe(%sfmi.", 
__func__
, 
p
->
fame
);

1501 
	gt
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

1502 
	gr
;

1504 if((
	gfe_fo
.
	g_mode
 & 
	gS_IFLNK
=
S_IFLNK
) {

1506 
_to_ld_fe
;

1509 
	g
 = 
__ldCt
(
p
->
fame
);

1510 if(
	g
 !
NULL
) {

1511 
sk_X509_push
(
syemCts
, 

);

1513 
	g_to_ld_fe
:

1514 if(
p
->
xt
 =
NULL
)

1516 
	gp
 = 
p
->
xt
;

1519 
	gt
 = 
CERT_SVC_ERR_NO_ERROR
;

1520 
	gr
:

1521 
a_fame_li
(
lCts
);

1523  
	gt
;

1526 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


1527 
__oc_vify
(
X509
 *

, X509 *
issu
, 
STACK_OF
(X509*
syemCts
, *
u
, *
ocStus
) {

1528 
OCSP_REQUEST
 *
	gq
 = 
NULL
;

1529 
OCSP_RESPONSE
 *
	g
 = 
NULL
;

1530 
OCSP_BASICRESP
 *
	gbs
 = 
NULL
;

1531 
OCSP_CERTID
 *
	gid
 = 
NULL
;

1532 
BIO
 *
	gcbio
 = 
NULL
;

1533 
SSL_CTX
 *
	gu_s_x
 = 
NULL
;

1534 *
	gho
 = 
NULL
, *
	gpt
 = NULL, *
	gth
 = NULL;

1535 
ASN1_GENERALIZEDTIME
 *
	gv
 = 
NULL
;

1536 
ASN1_GENERALIZEDTIME
 *
	gthisupd
 = 
NULL
;

1537 
ASN1_GENERALIZEDTIME
 *
	gxtupd
 = 
NULL
;

1538 
	gu_s
 = 0;

1539 
X509_OBJECT
 
	gobj
;

1540 
	gi
,
	gtmpIdx
;

1541 
	gnc
 = (5 * 60), 
	gmaxage
 = -1;

1542 
	gt
 = 0;

1543 
	gsubj_buf
[256];

1544 
	gas
;

1545 
X509_STORE
 *
	guedSte
=
NULL
;

1547 
ERR_ld_yo_rgs
();

1548 
OnSSL_add_l_gܙhms
();

1550 i(!
OCSP_r_u
(
u
, &
ho
, &
pt
, &
th
, &
u_s
)) {

1552  
	gCERT_SVC_ERR_OCSP_NO_SUPPORT
;

1555 
	gcbio
 = 
BIO_w_c
(
ho
);

1556 i(!
	gcbio
) {

1559  
	gCERT_SVC_ERR_OCSP_NO_SUPPORT
;

1562 i(
	gpt
) {

1563 
BIO_t_cn_pt
(
cbio
, 
pt
);

1566 i(
	gu_s
 == 1) {

1567 
BIO
 *
sbio
;

1568 
	gu_s_x
 = 
SSL_CTX_w
(
SSLv23__mhod
());

1569 i(!
	gu_s_x
) {

1571  
	gCERT_SVC_ERR_OCSP_INTERNAL
;

1574 
SSL_CTX_t_mode
(
u_s_x
, 
SSL_MODE_AUTO_RETRY
);

1575 
	gsbio
 = 
BIO_w_s
(
u_s_x
, 1);

1576 i(!
	gsbio
) {

1578  
	gCERT_SVC_ERR_OCSP_INTERNAL
;

1581 
	gcbio
 = 
BIO_push
(
sbio
, 
cbio
);

1582 i(!
	gcbio
) {

1584  
	gCERT_SVC_ERR_OCSP_INTERNAL
;

1588 i(
BIO_do_c
(
cbio
) <= 0) {

1592 i(
ho
)

1593 
OPENSSL_
(
ho
);

1594 i(
	gpt
)

1595 
OPENSSL_
(
pt
);

1596 i(
	gth
)

1597 
OPENSSL_
(
th
);

1598 
	gho
 = 
pt
 = 
th
 = 
NULL
;

1599 i(
	gu_s
 && 
	gu_s_x
)

1600 
SSL_CTX_
(
u_s_x
);

1601 
	gu_s_x
 = 
NULL
;

1602 i(
	gcbio
)

1603 
BIO__l
(
cbio
);

1604 
	gcbio
 = 
NULL
;

1605  
	gCERT_SVC_ERR_OCSP_NETWORK_FAILED
;

1608 
	gq
 = 
OCSP_REQUEST_w
();

1609 if(!
	gq
) {

1610  
	gCERT_SVC_ERR_OCSP_INTERNAL
;

1612 
	gid
 = 
OCSP__to_id
(
NULL
, 

, 
issu
);

1613 if(
	gid
 =
NULL
) {

1614  
CERT_SVC_ERR_OCSP_INTERNAL
;

1617 if(!
OCSP_que_add0_id
(
q
, 
id
)) {

1618  
	gCERT_SVC_ERR_OCSP_INTERNAL
;

1621 
	g
 = 
OCSP_ndq_bio
(
cbio
, 
th
, 
q
);

1624 i(
	gho
)

1625 
OPENSSL_
(
ho
);

1626 i(
	gpt
)

1627 
OPENSSL_
(
pt
);

1628 i(
	gth
)

1629 
OPENSSL_
(
th
);

1630 
	gho
 = 
pt
 = 
th
 = 
NULL
;

1631 i(
	gu_s
 && 
	gu_s_x
)

1632 
SSL_CTX_
(
u_s_x
);

1633 
	gu_s_x
 = 
NULL
;

1634 i(
	gcbio
)

1635 
BIO__l
(
cbio
);

1636 
	gcbio
 = 
NULL
;

1638 i(!
	g
) {

1642 
OCSP_REQUEST_
(
q
);

1643  
	gCERT_SVC_ERR_OCSP_NETWORK_FAILED
;

1646 
	gi
 = 
OCSP_ڣ_us
(

);

1648 i(
	gi
 != 0) {

1653 
OCSP_REQUEST_
(
q
);

1654 
OCSP_RESPONSE_
(

);

1655  
	gCERT_SVC_ERR_OCSP_REMOTE
;

1658 
	gbs
 = 
OCSP_ڣ_g1_basic
(

);

1659 i(!
	gbs
) {

1663 
OCSP_REQUEST_
(
q
);

1664 
OCSP_RESPONSE_
(

);

1665  
	gCERT_SVC_ERR_OCSP_REMOTE
;

1668 if(
	gsyemCts
 !
NULL
) {

1669 
uedSte
 = 
X509_STORE_w
();

1670 
	gtmpIdx
=0;mpIdx<
sk_X509_num
(
syemCts
);mpIdx++) {

1671 
X509_STORE_add_
(
uedSte
, 
sk_X509_vue
(
syemCts
, 
tmpIdx
));

1673 
X509_STORE_add_
(
uedSte
, 
issu
);

1676 
	gڣ
 = 
OCSP_basic_vify
(
bs
, 
NULL
, 
uedSte
, 0);

1677 i(
	gڣ
 <= 0) {

1678 
OCSP_REQUEST_
(
q
);

1679 
OCSP_RESPONSE_
(

);

1680 
OCSP_BASICRESP_
(
bs
);

1681 
X509_STORE_
(
uedSte
);

1686  
	gCERT_SVC_ERR_OCSP_VERIFICATION_ERROR
;

1689 i((
	gi
 = 
OCSP_check_n
(
q
, 
bs
)) <= 0) {

1690 i(
i
 == -1) {

1696 
OCSP_REQUEST_
(
q
);

1697 
OCSP_RESPONSE_
(

);

1698 
OCSP_BASICRESP_
(
bs
);

1699 
X509_STORE_
(
uedSte
);

1700  
	gCERT_SVC_ERR_OCSP_REMOTE
;

1704 
	gt
 = 
CERT_SVC_ERR_NO_ERROR
;

1706 ()
X509_NAME_ږe
(
X509_g_subje_me
(

), 
subj_buf
, 255);

1707 if(!
OCSP__fd_us
(
bs
, 
id
, 
ocStus
, &
as
,

1708 &
v
, &
thisupd
, &
xtupd
)) {

1712 
OCSP_RESPONSE_
(

);

1713 
OCSP_REQUEST_
(
q
);

1714 
OCSP_BASICRESP_
(
bs
);

1715 
X509_STORE_
(
uedSte
);

1717  
	gCERT_SVC_ERR_OCSP_REMOTE
;

1723 i(!
OCSP_check_vidy
(
thisupd
, 
xtupd
, 
nc
, 
maxage
)) {

1728 
OCSP_REQUEST_
(
q
);

1729 
OCSP_RESPONSE_
(

);

1730 
OCSP_BASICRESP_
(
bs
);

1731 
X509_STORE_
(
uedSte
);

1733  
	gCERT_SVC_ERR_OCSP_VERIFICATION_ERROR
;

1736 i(
	gq
) {

1737 
OCSP_REQUEST_
(
q
);

1738 
	gq
 = 
NULL
;

1741 i(
	g
) {

1742 
OCSP_RESPONSE_
(

);

1743 
	g
 = 
NULL
;

1746 i(
	gbs
) {

1747 
OCSP_BASICRESP_
(
bs
);

1748 
	gbs
 = 
NULL
;

1751 if(
	guedSte
) {

1752 
X509_STORE_
(
uedSte
);

1753 
	guedSte
 = 
NULL
;

1756 i(
	gas
 != -1) {

1757 *
as_r
 = 
NULL
;

1758 
	gas_r
 = 
OCSP_l_as_r
(
as
);

1762  
	gt
;

1765 
	$_check_oc_us
(
_svc_mem_buff
* 
Buf
, 
_svc_lked_li
** 
Li
, cڡ * 
uri
)

1767 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1768 
ocStus
;

1769 
_svc_lked_li
* 
s܋d
 = 
NULL
;

1770 
_svc_lked_li
* 
p
 = 
NULL
;

1771 
_svc_lked_li
* 
q
 = 
NULL
;

1772 
_svc__dest
* 
fdRo
 = 
NULL
;

1773 
_svc_fame_li
* 
feNames
 = 
NULL
;

1774 
_svc_mem_buff
* 
CACt
 = 
NULL
;

1776 
Num
 = 0;

1777 
_svc_mem_buff
* 
chdCt
;

1778 
_svc_mem_buff
* 
Ct
;

1780 
fdRo
 = (
_svc__dest
*)
	`mloc
((cert_svc_cert_descriptor));

1781 if(
fdRo
 =
NULL
) {

1782 
	`SLOGE
("[ERR][%s] Faedخlo memy f ctifi dest.", 
__func__
);

1783 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1784 
r
;

1787 
	`memt
(
fdRo
, 0x00, (
_svc__dest
));

1788 if(
Li
 !
NULL
 && (*certList) != NULL) {

1790 if((
t
 = 
	`_move_lfsigd___cha
(
Li
)!
CERT_SVC_ERR_NO_ERROR
) {

1791 
	`SLOGE
("[ERR][%s] Faػmovlf-sigd ctifi icha.", 
__func__
);

1792 
r
;

1795 if((
t
 = 
	`st__cha
(
Li
, &
s܋d
)!
CERT_SVC_ERR_NO_ERROR
) {

1796 
	`SLOGE
("[ERR][%s] Fas܈ifi cha.", 
__func__
);

1797 
r
;

1801 
p
 = 
s܋d
;

1802 
p
->
xt
 !
NULL
) {

1803 
Num
++;

1804 
p
 =->
xt
;

1806 
Num
++;

1807 
t
 = 
	`_exa_ifi_da
(
p
->
ifi
, 
fdRo
);

1810 
t
 = 
	`_exa_ifi_da
(
Buf
, 
fdRo
);

1813 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

1814 
	`SLOGE
("[ERR][%s] Faexa ctifi da", 
__func__
);

1815 
r
;

1817 if((
t
 = 
	`_ch_ifi
(&
feNames
, 
SUBJECT_STR
, 
fdRo
->
fo
.
issuS
)!
CERT_SVC_ERR_NO_ERROR
) {

1818 
t
 = 
CERT_SVC_ERR_NO_ROOT_CERT
;

1819 
	`SLOGE
("[ERR][%s] Faأcho ctifi", 
__func__
);

1820 
r
;

1822 if(
feNames
->
fame
 =
NULL
) {

1823 
	`SLOGE
("[ERR][%s] ThinCA ctifi.", 
__func__
);

1824 
t
 = 
CERT_SVC_ERR_NO_ROOT_CERT
;

1825 
r
;

1828 
CACt
 = (
_svc_mem_buff
*)
	`mloc
((cert_svc_mem_buff));

1829 if(
CACt
 =
NULL
) {

1830 
	`SLOGE
("[ERR][%s] Faedخlo memy f c.", 
__func__
);

1831 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1832 
r
;

1834 
	`memt
(
CACt
, 0x00, (
_svc_mem_buff
));

1836 if((
t
 = 
	`_svc_ut_ld_fe_to_bufr
(
feNames
->
fame
, 
CACt
)!
CERT_SVC_ERR_NO_ERROR
) {

1837 
	`SLOGE
("[ERR][%s] Fald CA ctbufr.", 
__func__
);

1838 
r
;

1841 
q
 = 
s܋d
;

1843 
chdCt
 = 
Buf
;

1845 if(
q
 !
NULL
) {

1846  ; 
q
 !
NULL
; q = q->
xt
) {

1847 
Ct
 = 
q
->
ifi
;

1849 if(
CERT_SVC_ERR_NO_ERROR
 !(
t
 = 
	`_vify_oc
(
chdCt
, 
Ct
, 
uri
, &
ocStus
))) {

1850 
	`SLOGE
("[ERR][%s] E Occued durg OCSP Checkg.", 
__func__
);

1851 
r
;

1853 if(
ocStus
 != 0) {

1854 
	`SLOGE
("[ERR][%s] Invid Ctifi OCSP Stus. ocStus=%d.", 
__func__
, 
ocStus
);

1856 
ocStus
) {

1858 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1861 
t
 = 
CERT_SVC_ERR_OCSP_REVOKED
;

1864 
t
 = 
CERT_SVC_ERR_OCSP_UNKNOWN
;

1867 
t
 = 
CERT_SVC_ERR_OCSP_REMOTE
;

1870 
r
;

1874 
chdCt
 = 
Ct
;

1879 
Ct
 = 
CACt
;

1880 if(
CERT_SVC_ERR_NO_ERROR
 !(
t
 = 
	`_vify_oc
(
chdCt
, 
Ct
, 
uri
, &
ocStus
))) {

1881 
	`SLOGE
("[ERR][%s] E Occued durg OCSP Checkg.", 
__func__
);

1882 
r
;

1884 
ocStus
) {

1886 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1889 
t
 = 
CERT_SVC_ERR_OCSP_REVOKED
;

1892 
t
 = 
CERT_SVC_ERR_OCSP_UNKNOWN
;

1895 
t
 = 
CERT_SVC_ERR_OCSP_REMOTE
;

1898 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

1899 
	`SLOGE
("[ERR][%s] Invid Ctifi OCSP Stus. ocStus=%d.", 
__func__
, 
ocStus
);

1900 
r
;

1903 
r
:

1904 
	`a_ifi_buf
(
CACt
);

1905 
	`a_fame_li
(
feNames
);

1906 
	`a_ifi_da
(
fdRo
);

1907 
	`a__li
(
s܋d
);

1908  
t
;

1909 
	}
}

1911 
	$_vify_oc
(
_svc_mem_buff
* 
chd
, ct_svc_mem_buff* 

, cڡ * 
uri
, * 
ocStus
)

1913 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1915 
X509
 *
chdCt
 = 
NULL
;

1916 
X509
 *
Ct

NULL
;

1917 *
chdDa
=
NULL
;

1918 *
Da
=
NULL
;

1919 *
AU

NULL
;

1920 *
rgU

NULL
;

1921 
	`STACK_OF
(
OPENSSL_STRING
*
a
 = 
NULL
;

1922 
	`STACK_OF
(
X509
*
syemCts
=
NULL
;

1923 
i
;

1924 
chdDa
 = 
	`mloc
(
chd
->
size
 + 1);

1925 
	`memt
(
chdDa
, 0x00, (
chd
->
size
 + 1));

1926 
	`memy
(
chdDa
, (
chd
->
da
), chd->
size
);

1927 
Da
 = 
	`mloc
(

->
size
 + 1);

1928 
	`memt
(
Da
, 0x00, (

->
size
 + 1));

1929 
	`memy
(
Da
, (

->
da
),t->
size
);

1930 
	`d2i_X509
(&
chdCt
, &
chdDa
, 
chd
->
size
);

1931 
	`d2i_X509
(&
Ct
, &
Da
, 

->
size
);

1936 
a
 = 
	`X509_g1_oc
(
chdCt
);

1937 i(
a
) {

1938 
AU
 = 
	`sk_OPENSSL_STRING_vue
(
a
, 0);

1940 if(
uri
 !
NULL
) {

1941 
rgU
 = 
uri
;

1943 
rgU
 = 
AU
;

1945 if(
rgU
 =
NULL
) {

1946 
	`SLOGE
("[ERR][%s] NURI f OCSP.", 
__func__
);

1947 
t
 = 
CERT_SVC_ERR_OCSP_NO_SUPPORT
;

1948 
r
;

1952 
syemCts
 = 
	`sk_X509_w_nu
();

1953 
t
 = 
	`__ldSyemCts
(
syemCts
) ;

1954 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

1955 
	`SLOGE
("[ERR][%s] Faexa ctifi da", 
__func__
);

1956 
r
;

1960 
t
 = 
	`__oc_vify
(
chdCt
, 
Ct
, 
syemCts
, 
rgU
, 
ocStus
);

1961 
	`SLOGD
("[%s] OCSP Reڣ. ocaus=%d,=%d.", 
__func__
, *
ocStus
, 
t
);

1963 
r
:

1964 if(
chdDa
 !
NULL
 && *childData != NULL)

1965 
	`
(
chdDa
);

1966 if(
Da
 !
NULL
 && *parentData != NULL)

1967 
	`
(
Da
);

1968 if(
chdCt
 !
NULL
)

1969 
	`X509_
(
chdCt
);

1970 if(
Ct
 !
NULL
)

1971 
	`X509_
(
Ct
);

1972 if(
a
 !
NULL
)

1973 
	`X509_ema_
(
a
);

1974 if(
syemCts
 !
NULL
) {

1975 
i
=0; i<
	`sk_X509_num
(
syemCts
); i++)

1976 
	`X509_
(
	`sk_X509_vue
(
syemCts
,
i
));

1977 
	`sk_X509_
(
syemCts
);

1979  
t
;

1980 
	}
}

1983 
	$a_ifi_buf
(
_svc_mem_buff
* 
Buf
)

1985 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1987 if(
Buf
 =
NULL
)

1988  
t
;

1990 if(
Buf
->
da
 !
NULL
) {

1991 
	`
(
Buf
->
da
);

1992 
Buf
->
da
 = 
NULL
;

1994 
	`
(
Buf
);

1995 
Buf
 = 
NULL
;

1997  
t
;

1998 
	}
}

2000 
	$a_ifi_da
(
_svc__dest
* 
Desc
)

2002 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

2003 
i
 = 0;

2005 if(
Desc
 =
NULL
)

2006  
t
;

2009 if(
Desc
->
fo
.
sigAlgo
 !
NULL

	`
(certDesc->info.sigAlgo);

2010 if(
Desc
->
fo
.
issuS
 !
NULL

	`
(certDesc->info.issuerStr);

2011 if(
Desc
->
fo
.
issu
.
couryName
 !
NULL

	`
(certDesc->info.issuer.countryName);

2012 if(
Desc
->
fo
.
issu
.
lolyName
 !
NULL

	`
(certDesc->info.issuer.localityName);

2013 if(
Desc
->
fo
.
issu
.
eOrProvName
 !
NULL

	`
(certDesc->info.issuer.stateOrProvinceName);

2014 if(
Desc
->
fo
.
issu
.
giziName
 !
NULL

	`
(certDesc->info.issuer.organizationName);

2015 if(
Desc
->
fo
.
issu
.
giziUnName
 !
NULL

	`
(certDesc->info.issuer.organizationUnitName);

2016 if(
Desc
->
fo
.
issu
.
commName
 !
NULL

	`
(certDesc->info.issuer.commonName);

2017 if(
Desc
->
fo
.
issu
.
emaAddss
 !
NULL

	`
(certDesc->info.issuer.emailAddress);

2018 if(
Desc
->
fo
.
subjeS
 !
NULL

	`
(certDesc->info.subjectStr);

2019 if(
Desc
->
fo
.
subje
.
couryName
 !
NULL

	`
(certDesc->info.subject.countryName);

2020 if(
Desc
->
fo
.
subje
.
lolyName
 !
NULL

	`
(certDesc->info.subject.localityName);

2021 if(
Desc
->
fo
.
subje
.
eOrProvName
 !
NULL

	`
(certDesc->info.subject.stateOrProvinceName);

2022 if(
Desc
->
fo
.
subje
.
giziName
 !
NULL

	`
(certDesc->info.subject.organizationName);

2023 if(
Desc
->
fo
.
subje
.
giziUnName
 !
NULL

	`
(certDesc->info.subject.organizationUnitName);

2024 if(
Desc
->
fo
.
subje
.
commName
 !
NULL

	`
(certDesc->info.subject.commonName);

2025 if(
Desc
->
fo
.
subje
.
emaAddss
 !
NULL

	`
(certDesc->info.subject.emailAddress);

2026 if(
Desc
->
fo
.
pubKeyAlgo
 !
NULL

	`
(certDesc->info.pubKeyAlgo);

2027 if(
Desc
->
fo
.
pubKey
 !
NULL

	`
(certDesc->info.pubKey);

2028 if(
Desc
->
fo
.
issuUID
 !
NULL

	`
(certDesc->info.issuerUID);

2029 if(
Desc
->
fo
.
subjeUID
 !
NULL

	`
(certDesc->info.subjectUID);

2032 if(
Desc
->
ext
.
numOfFlds
 > 0) {

2033 
i
 = 0; i < ()
Desc
->
ext
.
numOfFlds
; i++) {

2034 if(
Desc
->
ext
.
flds
[
i
].
me
 !
NULL

	`
(certDesc->ext.fields[i].name);

2035 if(
Desc
->
ext
.
flds
[
i
].
da
 !
NULL

	`
(certDesc->ext.fields[i].data);

2037 if(
Desc
->
ext
.
flds
 !
NULL

	`
(certDesc->ext.fields);

2041 if(
Desc
->
sigtuAlgo
 !
NULL

	`
(certDesc->signatureAlgo);

2042 if(
Desc
->
sigtuDa
 !
NULL

	`
(certDesc->signatureData);

2044 if(
Desc
 !
NULL

	`
(certDesc);

2046  
t
;

2047 
	}
}

2049 
	$a__li
(
_svc_lked_li
* 
Li
)

2051 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

2052 
_svc_lked_li
* 
tCt
 = 
NULL
;

2053 
_svc_lked_li
* 
curCt
 = 
NULL
;

2055 if(
Li
 =
NULL
)

2056  
t
;

2058 
tCt
 = 
Li
;

2061 
curCt
 = 
tCt
;

2062 
tCt
 = sCt->
xt
;

2064 if(
curCt
->
ifi
 !
NULL
) {

2065 if(
curCt
->
ifi
->
da
 !
NULL
) {

2066 
	`
(
curCt
->
ifi
->
da
);

2067 
curCt
->
ifi
->
da
 = 
NULL
;

2069 
	`
(
curCt
->
ifi
);

2070 
curCt
->
ifi
 = 
NULL
;

2073 
curCt
->
xt
 = 
NULL
;

2075 if(
curCt
 !
NULL
) {

2076 
	`
(
curCt
);

2077 
curCt
 = 
NULL
;

2080 if(
tCt
 =
NULL
)

2084  
t
;

2085 
	}
}

2087 
	$a_fame_li
(
_svc_fame_li
* 
feNames
)

2089 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

2090 
_svc_fame_li
* 
tLi
 = 
NULL
;

2091 
_svc_fame_li
* 
curLi
 = 
NULL
;

2093 if(
feNames
 =
NULL
)

2094  
t
;

2096 
tLi
 = 
feNames
;

2099 
curLi
 = 
tLi
;

2100 
tLi
 = sLi->
xt
;

2102 if(
curLi
->
fame
 !
NULL
) {

2103 
	`
(
curLi
->
fame
);

2104 
curLi
->
fame
 = 
NULL
;

2106 
curLi
->
xt
 = 
NULL
;

2107 if(
curLi
 !
NULL
) {

2108 
	`
(
curLi
);

2109 
curLi
 = 
NULL
;

2112 if(
tLi
 =
NULL
)

2116  
t
;

2117 
	}
}

2119 
	$g_visiby
(
CERT_CONTEXT
* 
cڋxt
, * 
visiby
)

2121 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

2122 * 

 = 
NULL
;

2123 
Size
 = 0;

2124 *
fgt
 = 
NULL
;

2126 if(!
cڋxt
->
Buf
)

2128 
	`SLOGE
("certBuf is NULL!");

2129  
CERT_SVC_ERR_INVALID_PARAMETER
;

2131 if(!
cڋxt
->
Buf
->
size
)

2133 
	`SLOGE
("certBuf size is wrong");

2134  
CERT_SVC_ERR_INVALID_PARAMETER
;

2137 

 = 
cڋxt
->
Buf
->
da
;

2138 
Size
 = 
cڋxt
->
Buf
->
size
;

2140 if(

 =
NULL
 || !
Size
)

2142 
	`SLOGE
("cert is or invalid!");

2143  
CERT_SVC_ERR_INVALID_CERTIFICATE
;

2146 
t
 = 
	`g_ifi_fgt
(

, 
Size
, &
fgt
);

2147 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

2149 
	`SLOGE
("Faedg fgda! %d", 
t
);

2150  
t
;

2153 
t
 = 
	`g_visiby_by_fgt
(
fgt
, 
visiby
);

2154 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

2156 
	`SLOGE
("Faedg visiby! %d", 
t
);

2157  
t
;

2160  
CERT_SVC_ERR_NO_ERROR
;

2161 
	}
}

2163 
	$g_ifi_ty
(
CERT_CONTEXT
* 
cڋxt
, * 
_ty
)

2165 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

2166 * 

 = 
NULL
;

2167 
Size
 = 0;

2168 *
fgt
 = 
NULL
;

2170 if(!
cڋxt
->
Buf
)

2172 
	`SLOGE
("certBuf is NULL!");

2173  
CERT_SVC_ERR_INVALID_PARAMETER
;

2175 if(!
cڋxt
->
Buf
->
size
)

2177 
	`SLOGE
("certBuf size is wrong");

2178  
CERT_SVC_ERR_INVALID_PARAMETER
;

2181 

 = 
cڋxt
->
Buf
->
da
;

2182 
Size
 = 
cڋxt
->
Buf
->
size
;

2184 if(

 =
NULL
 || !
Size
)

2186 
	`SLOGE
("cert is or invalid!");

2187  
CERT_SVC_ERR_INVALID_CERTIFICATE
;

2190 
t
 = 
	`g_ifi_fgt
(

, 
Size
, &
fgt
);

2191 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

2193 
	`SLOGE
("Faedg fgda! %d", 
t
);

2194  
t
;

2197 
t
 = 
	`g_ty_by_fgt
(
fgt
, 
_ty
);

2198 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

2200 
	`SLOGE
("Faedg visiby! %d", 
t
);

2201  
t
;

2204  
CERT_SVC_ERR_NO_ERROR
;

2205 
	}
}

	@srcs/cert-service-store.c

22 
	~<dio.h
>

23 
	~<rg.h
>

24 
	~<dlib.h
>

25 
	~<o.h
>

26 
	~<unid.h
>

28 
	~<ݒs/x509.h
>

30 
	~"-rvi.h
"

31 
	~"-rvi-ut.h
"

32 
	~"-rvi-debug.h
"

33 
	~"-rvi-e.h
"

35 
	$g_fe_fu_th
(* 
igName
, cڡ * 
loti
, * 
outBuf
)

37 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

38 
thLoti
[
CERT_SVC_MAX_FILE_NAME_SIZE
];

39 
buf
[
CERT_SVC_MAX_FILE_NAME_SIZE
];

40 * 
tok
 = 
NULL
;

41 * 
cڋxt
 = 
NULL
;

42 
ps
[] = "_";

43 
meSize
 = 0 ;

45 i(
igName
 =
NULL
) {

46 
	`SLOGE
("[ERR][%s] Check youm. Maybfth iNULL.", 
__func__
);

47 
t
 = 
CERT_SVC_ERR_INVALID_PARAMETER
;

48 
r
;

51 
meSize
 = 
	`
(
igName
);

53 i(
meSize
 <0 ||ameSiz>
CERT_SVC_MAX_FILE_NAME_SIZE
) {

54 
	`SLOGE
("[ERR][%s] Check youm. Fth itolg.", 
__func__
);

55 
t
 = 
CERT_SVC_ERR_INVALID_PARAMETER
;

56 
r
;

59 
	`memt
(
buf
, 0x00, (buf));

60 
	`memt
(
thLoti
, 0x00, (pathLocation));

62 if(
loti
 =
NULL
) {

63 
	`y
(
buf
, 
CERTSVC_SSL_CERTS_DIR
, (buf) - 1);

66 
locSize
 = 
	`
(
loti
+ sn(
CERTSVC_DIR
);

68 i(
locSize
 <0 ||ocSiz>
CERT_SVC_MAX_FILE_NAME_SIZE
) {

69 
	`SLOGE
("[ERR][%s] Check youm. Loti itolg.", 
__func__
);

70 
t
 = 
CERT_SVC_ERR_INVALID_PARAMETER
;

71 
r
;

74 
	`y
(
thLoti
, 
loti
, (pathLocation) - 1);

76 
	`y
(
buf
, 
CERTSVC_DIR
, (buf) - 1);

78 
tok
 = 
	`ok_r
(
thLoti
, 
ps
, &
cڋxt
);

79 
size_t
 
sizeBuf
 = (
buf
);

80 
tok
) {

81 i(
sizeBuf
 < (
	`
(
buf
+ sn(
tok
) + 2)) {

82 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

83 
r
;

85 
	`t
(
buf
, 
tok
, 
	`
(token));

86 
	`t
(
buf
, "/", 1);

87 
tok
 = 
	`ok_r
(
NULL
, 
ps
, &
cڋxt
);

91 i((
meSize
 + 
	`
(
buf
)>
CERT_SVC_MAX_FILE_NAME_SIZE
) {

92 
	`SLOGE
("[ERR][%s] Check youm. Fth itolg.", 
__func__
);

93 
t
 = 
CERT_SVC_ERR_INVALID_PARAMETER
;

94 
r
;

97 
	`t
(
buf
, 
igName
, 
meSize
);

98 
	`y
(
outBuf
, 
buf
, 
CERT_SVC_MAX_FILE_NAME_SIZE
 - 1);

99 
outBuf
[ 
CERT_SVC_MAX_FILE_NAME_SIZE
 - 1] = '\0';

101 
r
:

102  
t
;

103 
	}
}

105 
	$_add_ifi_to_e
(cڡ * 
fePh
, cڡ * 
loti
)

107 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

109 * 
FeName
 = 
NULL
;

110 * 
feFuPh
 = 
NULL
;

112 
FILE
* 
_
 = 
NULL
;

113 
FILE
* 
_out
 = 
NULL
;

114 
FeL
 = 0;

115 * 
feCڋ
 = 
NULL
;

118 
feFuPh
 = (*)
	`mloc
((* 
CERT_SVC_MAX_FILE_NAME_SIZE
);

119 if(
feFuPh
 =
NULL
) {

120 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

121 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

122 
r
;

124 
	`memt
(
feFuPh
, 0x00, 
CERT_SVC_MAX_FILE_NAME_SIZE
);

127 
FeName
 = 
	`chr
(
fePh
, '/');

128 if(
FeName
 =
NULL
) {

129 
	`SLOGE
("[ERR][%s] Fth MUST babsuh", 
__func__
);

130 
t
 = 
CERT_SVC_ERR_FILE_IO
;

131 
r
;

135 
	`g_fe_fu_th
((
FeName
 + 1), 
loti
, 
feFuPh
);

138 if(!(
_
 = 
	`fݒ
(
fePh
, "rb"))) {

139 
	`SECURE_SLOGE
("[ERR][%s] Faݒ fe, [%s]", 
__func__
, 
fePh
);

140 
t
 = 
CERT_SVC_ERR_FILE_IO
;

141 
r
;

143 if(!(
_out
 = 
	`fݒ
(
feFuPh
, "wb"))) {

144 
	`SECURE_SLOGE
("[ERR][%s] Faݒ fe, [%s]", 
__func__
, 
feFuPh
);

145 if(
o
 =
EACCES
)

146 
t
 = 
CERT_SVC_ERR_PERMISSION_DENIED
;

148 
t
 = 
CERT_SVC_ERR_FILE_IO
;

149 
r
;

152 if((
t
 = 
	`_svc_ut_g_fe_size
(
fePh
, &
FeL
)!
CERT_SVC_ERR_NO_ERROR
) {

153 
	`SECURE_SLOGE
("[ERR][%s] Fag fsize, [%s]", 
__func__
, 
fePh
);

154 
r
;

157 
feCڋ
 = (*)
	`mloc
((* ()
FeL
);

158 if(
feCڋ
 =
NULL
) {

159 
	`SLOGE
("[ERR][%s] Faخlo memy", 
__func__
);

160 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

161 
r
;

163 
	`memt
(
feCڋ
, 0x00, 
FeL
);

165 if(
	`d
(
feCڋ
, (), 
FeL
, 
_
) != inFileLen) {

166 
	`SECURE_SLOGE
("[ERR][%s] Faػad fe, [%s]", 
__func__
, 
fePh
);

167 
t
 = 
CERT_SVC_ERR_FILE_IO
;

168 
r
;

170 if(
	`fwre
(
feCڋ
, (), 
FeL
, 
_out
) != inFileLen) {

171 
	`SECURE_SLOGE
("[ERR][%s] Fawrfe, [%s]", 
__func__
, 
feFuPh
);

172 
t
 = 
CERT_SVC_ERR_FILE_IO
;

173 
r
;

176 
r
:

177 if(
_
 !
NULL
)

178 
	`fo
(
_
);

179 if(
_out
 !
NULL
)

180 
	`fo
(
_out
);

182 if(
feCڋ
 !
NULL
)

183 
	`
(
feCڋ
);

184 if(
feFuPh
 !
NULL
)

185 
	`
(
feFuPh
);

187  
t
;

188 
	}
}

190 
	$_de_ifi_om_e
(cڡ * 
feName
, cڡ * 
loti
)

192 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

193 * 
feFuPh
 = 
NULL
;

196 
feFuPh
 = (*)
	`mloc
((* 
CERT_SVC_MAX_FILE_NAME_SIZE
);

197 if(
feFuPh
 =
NULL
) {

198 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

199 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

200 
r
;

202 
	`memt
(
feFuPh
, 0x00, 
CERT_SVC_MAX_FILE_NAME_SIZE
);

205 
	`g_fe_fu_th
((*)
feName
, 
loti
, 
feFuPh
);

208 if(
	`uƚk
(
feFuPh
) == -1) {

209 
	`SECURE_SLOGE
("[ERR][%s] Fadfe, [%s]", 
__func__
, 
feName
);

210 if(
o
 =
EACCES
)

211 
t
 = 
CERT_SVC_ERR_PERMISSION_DENIED
;

213 
t
 = 
CERT_SVC_ERR_FILE_IO
;

216 
r
:

217 if(
feFuPh
 !
NULL
)

218 
	`
(
feFuPh
);

220  
t
;

221 
	}
}

	@srcs/cert-service-util.c

22 
	~<dio.h
>

23 
	~<rg.h
>

24 
	~<dlib.h
>

26 
	~<ݒs/pkcs12.h
>

27 
	~<ݒs/m.h
>

29 
	~"-rvi.h
"

30 
	~"-rvi-ut.h
"

31 
	~"-rvi-debug.h
"

32 
	~"-rvi-oss.h
"

34 
	~<libxml/rr.h
>

35 
	~<libxml/.h
>

37 #ide
CERT_SVC_API


38 
	#CERT_SVC_API
 
	`__ibu__
((
	`visiby
("deu")))

	)

41 
	#CERT_BODY_PREFIX
 "-----BEGIN CERTIFICATE-----"

	)

42 
	#CERT_BODY_SUFIX
 "-----END CERTIFICATE-----"

	)

43 
	#ICERT_BODY_PREFIX
 "-----BEGIN TRUSTED CERTIFICATE-----"

	)

44 
	#ICERT_BODY_SUFIX
 "-----END TRUSTED CERTIFICATE-----"

	)

47 cڡ 
	gba64Tab
[] = {

53 
	gba64DecodeTab
[256] = {

72 
	$g_cڋ_to_buf_PEM
(* 
cڋ
, 
_svc_mem_buff
* 

)

74 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

75 *
tPEM
, *
dPEM
;

76 * 
ig
 = 
NULL
;

77 
size
 = 0;

78 * 
decoded
 = 
NULL
;

79 
decodedSize
 = 0;

80 
i
 = 0, 
j
 = 0;

82 if(!
cڋ
) {

83 
t
 = 
CERT_SVC_ERR_INVALID_PARAMETER
;

84 
r
;

86 
tPEM
 = 
	`rr
((cڡ *)
cڋ
, 
CERT_BODY_PREFIX
);

87 
tPEM
 = (tPEM? sPEM + 
	`
(
CERT_BODY_PREFIX
: 
NULL
;

88 
dPEM
 = 
	`rr
((cڡ *)
cڋ
, 
CERT_BODY_SUFIX
);

89 if(!
tPEM
 || !
dPEM
) {

90 
tPEM
 = 
	`rr
((cڡ *)
cڋ
, 
ICERT_BODY_PREFIX
);

91 
tPEM
 = (tPEM? sPEM + 
	`
(
ICERT_BODY_PREFIX
: 
NULL
;

92 
dPEM
 = 
	`rr
((cڡ *)
cڋ
, 
ICERT_BODY_SUFIX
);

94 if(!
tPEM
 || !
dPEM
) {

95 
t
 = 
CERT_SVC_ERR_UNKNOWN_ERROR
;

96 
r
;

99 ++
tPEM
;

100 --
dPEM
;

101 
size
 = ()
dPEM
 - ()
tPEM
;

104 if(!(
ig
 = (*)
	`mloc
((* (
size
 + 1)))) {

105 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

106 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

107 
r
;

109 
	`memt
(
ig
, 0x00, (
size
 + 1));

111 
i
 = 0, 
j
 = 0; i < 
size
; i++) {

112 if(
tPEM
[
i
] != '\n')

113 
ig
[
j
++] = 
tPEM
[
i
];

116 
size
 = 
	`
((*)
ig
);

117 
decodedSize
 = ((
size
 / 4) * 3) + 1;

119 if(!(
decoded
 = (*)
	`mloc
((* 
decodedSize
))) {

120 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

121 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

122 
r
;

124 
	`memt
(
decoded
, 0x00, 
decodedSize
);

125 if((
t
 = 
	`_svc_ut_ba64_decode
(
ig
, 
size
, 
decoded
, &
decodedSize
)!
CERT_SVC_ERR_NO_ERROR
) {

126 
	`SLOGE
("[ERR][%s] Faba64 decode.", 
__func__
);

127 
	`
(
decoded
);

128 
t
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

129 
r
;

132 

->
da
 = 
decoded
;

133 

->
size
 = 
decodedSize
;

135 
r
:

136 
	`
(
ig
);

138  
t
;

139 
	}
}

141 
	$g_cڋ_to_buf_DER
(* 
cڋ
, 
_svc_mem_buff
* 

)

143 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

144 * 
Da
 = 
NULL
;

146 
Da
 = (*)
	`mloc
((* (

->
size
));

147 if(
Da
 =
NULL
) {

148 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

149 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

150 
r
;

153 
	`memy
(
Da
, 
cڋ
, 

->
size
);

154 

->
da
 = 
Da
;

156 
r
:

157  
t
;

158 
	}
}

160 
	$_svc_ut_g_fe_size
(cڡ * 
fh
, * 
ngth
)

162 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

163 
FILE
* 
_
 = 
NULL
;

165 if(!(
_
 = 
	`fݒ
(
fh
, "r"))) {

166 
	`SLOGE
("[ERR][%s] Faݒ fe, [%s]", 
__func__
, 
fh
);

167 
t
 = 
CERT_SVC_ERR_FILE_IO
;

168 
r
;

171 
	`fek
(
_
, 0L, 
SEEK_END
);

172 (*
ngth

	`l
(
_
);

174 
r
:

175 if(
_
 !
NULL
)

176 
	`fo
(
_
);

178  
t
;

179 
	}
}

182 
	$_svc_ut_g_exnsi
(cڡ * 
fePh
, 
_svc_mem_buff
* 
Buf
) {

183 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

184 
FILE
 *

 = 
NULL
;

185 
X509
 *
x
 = 
NULL
;

187 i((

 = 
	`fݒ
(
fePh
, "r")=
NULL
) {

188 
	`SLOGE
("[ERR] E ong f%s", 
fePh
);

189 
t
 = 
CERT_SVC_ERR_FILE_IO
;

190 
d
;

193 i((
x
 = 
	`PEM_ad_X509
(

, 
NULL
, NULL, NULL)) != NULL) {

194 
	`y
(
Buf
->
ty
, "PEM", (certBuf->type));

195 
d
;

198 
	`fek
(

, 0L, 
SEEK_SET
);

200 i((
x
 = 
	`PEM_ad_X509_AUX
(

, 
NULL
, NULL, NULL)) != NULL) {

201 
	`y
(
Buf
->
ty
, "PEM", (certBuf->type));

202 
d
;

205 
	`fek
(

, 0L, 
SEEK_SET
);

207 i((
x
 = 
	`d2i_X509_
(

, 
NULL
)) != NULL) {

208 
	`y
(
Buf
->
ty
, "DER", (certBuf->type));

209 
d
;

212 
	`SLOGE
("[ERR] Unknowfty: %s", 
fePh
);

213 
t
 = 
CERT_SVC_ERR_FILE_IO
;

215 
d
:

216 i(

 && 
	`fo
(in)) {

217 
	`SLOGE
("[ERR] Fail in fclose.");

218 
t
 = 
CERT_SVC_ERR_FILE_IO
;

220 
	`X509_
(
x
);

221  
t
;

222 
	}
}

224 
	$_svc_ut_ld_fe_to_bufr
(cڡ * 
fePh
, 
_svc_mem_buff
* 
Buf
)

226 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

228 
FILE
* 
_
 = 
NULL
;

229 * 
cڋ
 = 
NULL
;

230 
feSize
 = 0;

233 if((
t
 = 
	`_svc_ut_g_fe_size
(
fePh
, &
feSize
)!
CERT_SVC_ERR_NO_ERROR
) {

234 
	`SLOGE
("[ERR][%s] Fag fsize, [%s]", 
__func__
, 
fePh
);

235 
r
;

237 
Buf
->
size
 = 
feSize
;

240 if(!(
_
 = 
	`fݒ
(
fePh
, "rb"))) {

241 
	`SLOGE
("[ERR][%s] Faݒ fe, [%s]", 
__func__
, 
fePh
);

242 
t
 = 
CERT_SVC_ERR_FILE_IO
;

243 
r
;

246 if(!(
cڋ
 = (*)
	`mloc
((* ()(
feSize
 + 1)))) {

247 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

248 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

249 
r
;

251 
	`memt
(
cڋ
, 0x00, (
feSize
 + 1));

252 if(
	`d
(
cڋ
, (), 
feSize
, 
_
) != fileSize) {

253 
	`SLOGE
("[ERR][%s] Faػad fe, [%s]", 
__func__
, 
fePh
);

254 
t
 = 
CERT_SVC_ERR_FILE_IO
;

255 
r
;

257 
cڋ
[
feSize
] = 0;

260 
	`memt
(
Buf
->
ty
, 0x00, 4);

261 i(
	`_svc_ut_g_exnsi
(
fePh
, 
Buf
!
CERT_SVC_ERR_NO_ERROR
) {

262 
	`SLOGE
("[ERR] ct_svc_ut_g_exnsi faedidtify %s", 
fePh
);

263 
t
 = 
CERT_SVC_ERR_FILE_IO
;

264 
r
;

268 if(!
	`cmp
(
Buf
->
ty
, "PEM", (certBuf->type))) {

269 if((
t
 = 
	`g_cڋ_to_buf_PEM
(
cڋ
, 
Buf
)!
CERT_SVC_ERR_NO_ERROR
) {

270 
	`SLOGE
("[ERR][%s] Fald ftbufr, [%s]", 
__func__
, 
fePh
);

271 
r
;

274 if(!
	`cmp
(
Buf
->
ty
, "DER", (certBuf->type))) {

275 if((
t
 = 
	`g_cڋ_to_buf_DER
(
cڋ
, 
Buf
)!
CERT_SVC_ERR_NO_ERROR
) {

276 
	`SLOGE
("[ERR][%s] Fald ftbufr, [%s]", 
__func__
, 
fePh
);

277 
r
;

281 
r
:

282 if(
_
 !
NULL
)

283 
	`fo
(
_
);

285 if(
cڋ
 !
NULL
)

286 
	`
(
cڋ
);

288  
t
;

289 
	}
}

291 
	$push__to_lked_li
(
_svc_lked_li
** 
Lk
, 
X509
* 
pedCt
)

293 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

294 
_svc_lked_li
* 
cur
 = 
NULL
;

295 
_svc_lked_li
* 
wNode
 = 
NULL
;

296 * 
pCt
 = 
NULL
;

297 * 
bufCt
 = 
NULL
;

298 
L
 = 0;

300 if(!(
wNode
 = (
_svc_lked_li
*)
	`mloc
((cert_svc_linked_list)))) {

301 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

302 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

303 
r
;

305 if(!(
wNode
->
ifi
 = (
_svc_mem_buff
*)
	`mloc
((cert_svc_mem_buff)))) {

306 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

307 
	`
(
wNode
);

308 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

309 
r
;

313 if((
L
 = 
	`i2d_X509
(
pedCt
, 
NULL
)) < 0) {

314 
	`SLOGE
("[ERR][%s] Facvifi.", 
__func__
);

315 
	`a__li
(
wNode
);

316 
t
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

317 
r
;

319 if(!(
bufCt
 = (*)
	`mloc
((* 
L
))) {

320 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

321 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

322 
	`a__li
(
wNode
);

323 
r
;

325 
pCt
 = 
bufCt
;

326 
	`i2d_X509
(
pedCt
, &
pCt
);

328 
wNode
->
ifi
->
da
 = 
bufCt
;

329 
wNode
->
ifi
->
size
 = 
L
;

330 
wNode
->
xt
 = 
NULL
;

332 if(
NULL
 =*
Lk
) {

333 *
Lk
 = 
wNode
;

337 
cur
 = *
Lk
;

338 
cur
->
xt
)

339 
cur
 = cur->
xt
;

340 
cur
->
xt
 = 
wNode
;

343 
r
:

344  
t
;

345 
	}
}

347 
	$_svc_ut_ld_PFX_fe_to_bufr
(cڡ * 
fePh
, 
_svc_mem_buff
* 
Buf
, 
_svc_lked_li
** 
Lk
, ** 
iveKey
, * 
iKeyL
, * 
ssPh
)

349 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

351 
EVP_PKEY
* 
pkey
 = 
NULL
;

352 
X509
* 

 = 
NULL
;

353 
	`STACK_OF
(
X509
)* 

 = 
NULL
;

354 
X509
* 
pedCt
 = 
NULL
;

355 
PKCS12
* 
p12
 = 
NULL
;

357 
FILE
* 
_
 = 
NULL
;

359 * 
pCt
 = 
NULL
;

360 * 
bufCt
 = 
NULL
;

361 
L
 = 0;

362 * 
pPrikey
 = 
NULL
;

363 * 
bufPrikey
 = 
NULL
;

364 
ikeyL
 = 0;

366 
	`OnSSL_add_l_gܙhms
();

369 if(!(
_
 = 
	`fݒ
(
fePh
, "rb"))) {

370 
	`SLOGE
("[ERR][%s] Faݒ fe, [%s]", 
__func__
, 
fePh
);

371 
t
 = 
CERT_SVC_ERR_FILE_IO
;

372 
r
;

374 if(!(
p12
 = 
	`d2i_PKCS12_
(
_
, 
NULL
))) {

375 
	`SLOGE
("[ERR][%s] Fag ctifi da.", 
__func__
);

376 
t
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

377 
r
;

381 if((
t
 = 
	`PKCS12_r
(
p12
, 
ssPh
, &
pkey
, &

, &

)) != 1) {

382 
	`SLOGE
("[ERR][%s] Faطr PKCS#12 ctifi.", 
__func__
);

383 
t
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

384 
r
;

386 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

388 
	`memt
(
Buf
->
ty
, 0x00, 4);

389 
	`y
(
Buf
->
ty
, "PFX", (certBuf->type));

392 if((
L
 = 
	`i2d_X509
(

, 
NULL
)) < 0) {

393 
	`SLOGE
("[ERR][%s] Facvifi.", 
__func__
);

394 
t
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

395 
r
;

397 if(!(
bufCt
 = (*)
	`mloc
((* 
L
))) {

398 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

399 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

400 
r
;

402 
pCt
 = 
bufCt
;

403 
	`i2d_X509
(

, &
pCt
);

405 
Buf
->
da
 = 
bufCt
;

406 
Buf
->
size
 = 
L
;

409 if((
ikeyL
 = 
	`i2d_PriveKey
(
pkey
, 
NULL
)) < 0) {

410 
	`SLOGE
("[ERR][%s] Facvivkey.", 
__func__
);

411 
t
 = 
CERT_SVC_ERR_INVALID_OPERATION
;

412 
r
;

414 
	`SLOGE
("[LOG]rivkeygth: [%d]", 
ikeyL
);

415 if(!(
bufPrikey
 = (*)
	`mloc
((* 
ikeyL
))) {

416 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

417 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

418 
r
;

420 
pPrikey
 = 
bufPrikey
;

421 
	`i2d_PriveKey
(
pkey
, &
pPrikey
);

423 (*
iveKey

bufPrikey
;

424 (*
iKeyL

ikeyL
;

427 (
pedCt
 = 
	`sk_X509_p
(

)!
NULL
) {

428 if((
t
 = 
	`push__to_lked_li
(
Lk
, 
pedCt
)!
CERT_SVC_ERR_NO_ERROR
) {

429 
	`SLOGE
("[ERR][%s] Famaklkedi.", 
__func__
);

430 
r
;

434 
r
:

435 if(
_
 !
NULL
)

436 
	`fo
(
_
);

437 if(
p12
 !
NULL
)

438 
	`PKCS12_
(
p12
);

439 if(

 !
NULL
)

440 
	`X509_
(

);

441 if(
pkey
 !
NULL
)

442 
	`EVP_PKEY_
(
pkey
);

443 if(

 !
NULL
)

444 
	`sk_X509_p_
(

, 
X509_
);

447  
t
;

448 
	}
}

450 
CERT_SVC_API


451 
	$_svc_ut_ba64_code
(cڡ *

, 
L
, *
out
, *
outL
)

453 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

454 
putL
 = 0, 
i
 = 0;

455 cڡ *
cur
 = 
NULL
;

457 if((

 =
NULL
|| (
L
 < 1)) {

458 
	`SLOGE
("[ERR][%s] Check youm.", 
__func__
);

459 
t
 = 
CERT_SVC_ERR_INVALID_PARAMETER
;

460 
r
;

463 
cur
 = 

;

464 
putL
 = 
L
;

467 
putL
 > 2) {

468 
out
[
i
++] = 
ba64Tab
[
cur
[0] >> 2];

469 
out
[
i
++] = 
ba64Tab
[((
cur
[0] & 0x03) << 4) + (cur[1] >> 4)];

470 
out
[
i
++] = 
ba64Tab
[((
cur
[1] & 0x0f) << 2) + (cur[2] >> 6)];

471 
out
[
i
++] = 
ba64Tab
[
cur
[2] & 0x3f];

473 
cur
 += 3;

474 
putL
 -= 3;

478 if(
putL
 != 0) {

479 
out
[
i
++] = 
ba64Tab
[
cur
[0] >> 2];

480 if(
putL
 > 1) {

481 
out
[
i
++] = 
ba64Tab
[((
cur
[0] & 0x03) << 4) + (cur[1] >> 4)];

482 
out
[
i
++] = 
ba64Tab
[(
cur
[1] & 0x0f) << 2];

483 
out
[
i
++] = '=';

486 
out
[
i
++] = 
ba64Tab
[(
cur
[0] & 0x03) << 4];

487 
out
[
i
++] = '=';

488 
out
[
i
++] = '=';

492 
out
[
i
] = '\0';

493 (*
outL

i
;

495 
r
:

496  
t
;

497 
	}
}

499 
CERT_SVC_API


500 
	$_svc_ut_ba64_decode
(cڡ *

, 
L
, *
out
, * 
outL
)

502 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

503 
putL
 = 0, 
i
 = 0, 
j
 = 0, 

 = 0;

504 cڡ *
cur
 = 
NULL
;

505 
tmpBuf
[4];

507 if((

 =
NULL
|| (
L
 < 1)) {

508 
	`SLOGE
("[ERR][%s] Check youm.", 
__func__
);

509 
t
 = 
CERT_SVC_ERR_INVALID_PARAMETER
;

510 
r
;

513 
cur
 = 

;

514 
putL
 = 
L
;

515 
	`memt
(
tmpBuf
, 0x00, 4);

518 
putL
 > 1) {

519 
j
 = 0; j < 4; j++) {

520 if(
cur
[
j
] == '=') {

521 

++;

522 
tmpBuf
[
j
] = 0x00;

525 
tmpBuf
[
j
] = ()
ba64DecodeTab
[()
cur
[j]];

528 
out
[
i
++] = ((
tmpBuf
[0] & 0x3f) << 2) + ((tmpBuf[1] & 0x30) >> 4);

529 
out
[
i
++] = ((
tmpBuf
[1] & 0x0f) << 4) + ((tmpBuf[2] & 0x3c) >> 2);

530 
out
[
i
++] = ((
tmpBuf
[2] & 0x03) << 6) + (tmpBuf[3] & 0x3f);

532 
cur
 += 4;

533 
putL
 -= 4;

535 
	`memt
(
tmpBuf
, 0x00, 4);

538 
i
 -

;

539 
out
[
i
] = '\0';

540 (*
outL

i
;

542 
r
:

543  
t
;

544 
	}
}

548 
	$g_ifi_fgt
(cڡ *

, 
_size
, ** 
fgt
)

550 
X509
* 
x509Ct
 = 
NULL
;

551 
x509_fgt
[
EVP_MAX_MD_SIZE
] = {0};

552 
unifmedFgt
[
EVP_MAX_MD_SIZE
 * 3] = {0};

553 
_n
 = 0;

554 
buff
[8] = {0};

555 
x509_ngth
 = 0;

556 
i
 = 0;

558 if(!
	`d2i_X509
(&
x509Ct
, &

, 
_size
))

560 
	`SLOGE
("d2i_x509 failed!");

561 *
fgt
 = 
NULL
;

562  
CERT_SVC_ERR_INVALID_CERTIFICATE
;

565 if(!
	`X509_dige
(
x509Ct
, 
	`EVP_sha1
(), 
x509_fgt
, &
x509_ngth
))

567 
	`SLOGE
("X509_digest failed");

568 
	`X509_
(
x509Ct
);

569 *
fgt
 = 
NULL
;

570  
CERT_SVC_ERR_INVALID_CERTIFICATE
;

573 
i
 = 0; i < 
x509_ngth
; i++)

575 
	`tf
(
buff
, (buff), "%02X:", 
x509_fgt
[
i
]);

576 
	`t
(
unifmedFgt
, 
buff
, 3);

578 
unifmedFgt
[
x509_ngth
 * 3 - 1] = 0;

579 
_n
 = 
	`
(
unifmedFgt
);

581 *
fgt
 = (*)
	`oc
((), 
_n
 + 1);

582 if(*
fgt
 =
NULL
)

584 
	`SLOGE
("Failedollocate memory");

585 
	`X509_
(
x509Ct
);

586 *
fgt
 = 
NULL
;

587  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

590 
	`memy
(*
fgt
, 
unifmedFgt
, 
_n
 + 1);

592 
	`SLOGD
("fg: %s", *
fgt
);

594 
	`X509_
(
x509Ct
);

596  
CERT_SVC_ERR_NO_ERROR
;

597 
	}
}

599 
	$g_visiby_by_fgt
(cڡ * 
fgt
, * 
visiby
)

601 
	`SLOGD
("fg: %s", 
fgt
);

602 
t
 = 0;

603 
xmlCh
 *
xmlPhDomaPtfm
 = (xmlChar*) "tizen-platform";

604 
xmlCh
 *
xmlPhDomaPublic
 = (xmlChar*) "tizen-public";

605 
xmlCh
 *
xmlPhDomaP
 = (xmlChar*) "tizen-partner";

606 
xmlCh
 *
xmlPhDomaDevݔ
 = (xmlChar*) "tizen-developer";

609 
xmlDocP
 
doc
 = 
	`xmlPFe
(
FINGERPRINT_LIST_PATH
);

610 i((
doc
 =
NULL
|| (
	`xmlDocGRoEmt
(doc) == NULL))

612 
	`SLOGE
("Failedorase fingerprint_list.xml");

613  
CERT_SVC_ERR_FILE_IO
;

616 
xmlNodeP
 
curP
 = 
	`xmlFEmtChd
(
	`xmlDocGRoEmt
(
doc
));

617 if(
curP
 =
NULL
)

619 
	`SLOGE
("Canot findoot");

620 
	`xmlFeDoc
(
doc
);

621  
CERT_SVC_ERR_FILE_IO
;

624 
curP
 !
NULL
)

626 
xmlAr
* 

 = 
curP
->
ݔts
;

627 if(!

->
chdn
 || !->chdn->
cڋ
)

629 
	`SLOGE
("Failedo get fingerprints fromist");

630 
t
 = 
CERT_SVC_ERR_NO_ROOT_CERT
;

631 
out
;

634 
xmlCh
* 
rLev
 = 

->
chdn
->
cڋ
;

635 
xmlNodeP
 
FpP
 = 
	`xmlFEmtChd
(
curP
);

646 
FpP
)

648 
xmlCh
 *
cڋ
 = 
	`xmlNodeGCڋ
(
FpP
);

649 if(
	`xmlScmp
(
cڋ
, (
xmlCh
*)
fgt
) == 0)

651 
	`SLOGD
("fg: %%s", 
cڋ
, 
rLev
);

652 if(!
	`xmlScmp
(
rLev
, 
xmlPhDomaPtfm
)){

653 *
visiby
 = 
CERT_SVC_VISIBILITY_PLATFORM
;

654 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

655 
out
;

657 if(!
	`xmlScmp
(
rLev
, 
xmlPhDomaPublic
)){

658 *
visiby
 = 
CERT_SVC_VISIBILITY_PUBLIC
;

659 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

660 
out
;

662 if(!
	`xmlScmp
(
rLev
, 
xmlPhDomaP
)){

663 *
visiby
 = 
CERT_SVC_VISIBILITY_PARTNER
;

664 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

665 
out
;

667 if(!
	`xmlScmp
(
rLev
, 
xmlPhDomaDevݔ
)){

668 *
visiby
 = 
CERT_SVC_VISIBILITY_DEVELOPER
;

669 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

670 
out
;

673 
FpP
 = 
	`xmlNextEmtSiblg
(FpPtr);

675 
curP
 = 
	`xmlNextEmtSiblg
(curPtr);

678 
	`SLOGE
("Couldot find fingerrpint");

680 
	`xmlFeDoc
(
doc
);

681  
CERT_SVC_ERR_NO_ROOT_CERT
;

683 
out
:

684 
	`xmlFeDoc
(
doc
);

685  
t
;

686 
	}
}

688 
	$g_ty_by_fgt
(cڡ * 
fgt
, * 
_ty
)

690 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

691 
xmlCh
 *
xmlPhDomaTe
 = (xmlChar*) "tizen-test";

692 
xmlCh
 *
xmlPhDomaVify
 = (xmlChar*) "tizen-verify";

693 
xmlCh
 *
xmlPhDomaSte
 = (xmlChar*) "tizen-store";

696 
xmlDocP
 
doc
 = 
	`xmlPFe
(
FINGERPRINT_LIST_PATH
);

697 i((
doc
 =
NULL
|| (
	`xmlDocGRoEmt
(doc) == NULL))

699 
	`SLOGE
("Failedorase fingerprint_list.xml");

700  
CERT_SVC_ERR_FILE_IO
;

703 
xmlNodeP
 
curP
 = 
	`xmlFEmtChd
(
	`xmlDocGRoEmt
(
doc
));

704 if(
curP
 =
NULL
)

706 
	`SLOGE
("Canot findoot");

707 
	`xmlFeDoc
(
doc
);

708  
CERT_SVC_ERR_FILE_IO
;

711 
curP
 !
NULL
)

713 
xmlAr
* 

 = 
curP
->
ݔts
;

714 if(!

->
chdn
 || !->chdn->
cڋ
)

716 
	`SLOGE
("Failedo get fingerprints fromist");

717 
t
 = 
CERT_SVC_ERR_NO_ROOT_CERT
;

718 
out
;

721 
xmlCh
* 
rLev
 = 

->
chdn
->
cڋ
;

722 
xmlNodeP
 
FpP
 = 
	`xmlFEmtChd
(
curP
);

724 
FpP
)

726 
xmlCh
 *
cڋ
 = 
	`xmlNodeGCڋ
(
FpP
);

727 if(
	`xmlScmp
(
cڋ
, (
xmlCh
*)
fgt
) == 0)

729 
	`SLOGD
("fg: %mched %s", 
cڋ
, 
rLev
);

730 if(!
	`xmlScmp
(
rLev
, 
xmlPhDomaTe
)){

731 *
_ty
 = 
CERT_SVC_TYPE_TEST
;

732 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

733 
out
;

735 if(!
	`xmlScmp
(
rLev
, 
xmlPhDomaVify
)){

736 *
_ty
 = 
CERT_SVC_TYPE_VERIFY
;

737 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

738 
out
;

740 if(!
	`xmlScmp
(
rLev
, 
xmlPhDomaSte
)){

741 *
_ty
 = 
CERT_SVC_TYPE_STORE
;

742 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

743 
out
;

746 
FpP
 = 
	`xmlNextEmtSiblg
(FpPtr);

748 
curP
 = 
	`xmlNextEmtSiblg
(curPtr);

751 
	`SLOGD
("Couldot find fingerprint");

752 
	`xmlFeDoc
(
doc
);

753 *
_ty
 = 
CERT_SVC_TYPE_NO_TYPE
;

754  
CERT_SVC_ERR_NO_ERROR
;

756 
out
:

757 
	`xmlFeDoc
(
doc
);

758  
t
;

759 
	}
}

763 
	$g_visiby_by_ifi
(cڡ *
_da
, 
da_n
, * 
visiby
)

765 if(!
_da
 || !
da_n
)

767  
CERT_SVC_ERR_INVALID_PARAMETER
;

770 
decodedSize
 = ((
da_n
 / 4) * 3) + 1;

771 *
decoded
 = 
NULL
;

772 *
fgt
 = 
NULL
;

773 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

775 if(!(
decoded
 = (*)
	`mloc
((* 
decodedSize
))) {

776 
	`SLOGE
("Failollocate memory.");

777  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

779 
	`memt
(
decoded
, 0x00, 
decodedSize
);

781 if((
t
 = 
	`_svc_ut_ba64_decode
(
_da
, 
da_n
, 
decoded
, &
decodedSize
)!
CERT_SVC_ERR_NO_ERROR
)

783 
	`SLOGE
("Faeddecodd%d", 
t
);

784 
	`
(
decoded
);

785  
t
;

788 
t
 = 
	`g_ifi_fgt
(
decoded
, 
decodedSize
, &
fgt
);

789 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

791 
	`SLOGE
("C g fgt! %d", 
t
);

792  
t
;

795 
t
 = 
	`g_visiby_by_fgt
(
fgt
, 
visiby
);

796 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

798 
	`SLOGE
("C fd visiby %d", 
t
);

799  
t
;

802 
	`
(
decoded
);

803 
	`
(
fgt
);

804  
CERT_SVC_ERR_NO_ERROR
;

805 
	}
}

	@srcs/cert-service.c

22 
	~<rg.h
>

23 
	~<dlib.h
>

24 
	~<o.h
>

25 
	~<unid.h
>

26 
	~<dlf.h
>

27 
	~<f.h
>

29 
	~"-rvi.h
"

30 
	~"-rvi-ut.h
"

31 
	~"-rvi-debug.h
"

32 
	~"-rvi-e.h
"

33 
	~"-rvi-oss.h
"

35 #ide
CERT_SVC_API


36 
	#CERT_SVC_API
 
	`__ibu__
((
	`visiby
("deu")))

	)

39 
	#AUTHOR_SIGNATURE
 "auth-sigtu.xml"

	)

40 
	#DISTRIBUTOR_SIGNATURE
 "sigtu1.xml"

	)

42 
	$__is_ifd_devi
(cڡ * 

, 
Size
)

44 (*
CheckFunc
)(cڡ *, 
NULL
;

45 (*
CheckFe
)(
NULL
;

46 *
hd
 = 
NULL
;

47 
su
;

48 *
ba64
 = 
NULL
;

49 
ba64Size
 = 0;

51 
hd
 = 
	`dlݒ
("lib-svc-vce.so", 
RTLD_LAZY
 | 
RTLD_GLOBAL
);

52 i(!
hd
) {

53 
	`SLOGE
("Failedo openotification binary");

57 
CheckFe
 = ((*)())(
	`dlsym
(
hd
, "CheckProfileFile"));

58 i(!
CheckFe
) {

59 
	`SLOGE
("Failedo open symbol CheckProfileFile");

60 
su
 = 0;

61 
r
;

64 
su
 = 
	`CheckFe
();

65 i(!
su
){

66 
	`SLOGD
("checking file. devicerofile doseotxist.");

67 
su
 = -1;

68 
r
;

71 
ba64
 = (*)
	`oc
(
Size
*2, 1);

72 i(!
ba64
) {

73 
su
 = 0;

74 
r
;

76 
	`_svc_ut_ba64_code
(

, 
Size
, 
ba64
, &
ba64Size
);

78 
CheckFunc
 = ((*)(cڡ *, ))(
	`dlsym
(
hd
, "CheckDevice"));

79 i(!
CheckFunc
) {

80 
	`SLOGE
("Failedo open symbol CheckDevice");

81 
su
 = 0;

82 
r_t_a_
;

85 
su
 = 
	`CheckFunc
(
ba64
, 
ba64Size
);

86 
	`SLOGD
("Resu ocheckg devi : %d", 
su
);

88 
r_t_a_
:

89 
	`
(
ba64
);

91 
r
:

92 
	`dlo
(
hd
);

93  
su
;

94 
	}
}

96 
	$_svc_g_ifi_ty
(
CERT_CONTEXT
 *
x
, * 
_ty
)

98 
CERT_CONTEXT
* 
cڋxt
 = 
NULL
;

99 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

101 i(!
x
 || !
_ty
) {

102 
	`SLOGE
("Invalidrameters");

103  
CERT_SVC_ERR_INVALID_PARAMETER
;

106 i(!
x
->
feNames
 || !x->feNames->
fame
) {

107 
	`SLOGE
("Canot findoot certificateath");

108  
CERT_SVC_ERR_INVALID_PARAMETER
;

111 
cڋxt
 = 
	`_svc__cڋxt_
();

112 i(!
cڋxt
) {

113 
	`SLOGE
("Out of memory");

114  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

117 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
cڋxt
, 
x
->
feNames
->
fame
);

118 i(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

119 
	`SLOGE
("failedooadoot certficiate");

120 
	`_svc__cڋxt_f
(
cڋxt
);

121  
CERT_SVC_ERR_INVALID_CERTIFICATE
;

124 
t
 = 
	`g_ifi_ty
(
cڋxt
, 
_ty
);

126 
	`_svc__cڋxt_f
(
cڋxt
);

128  
t
;

129 
	}
}

131 
	$__svc_vify_ifi_wh_ag
(
CERT_CONTEXT
* 
x
, 
checkCAFg
, * 
vidy
)

133 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

135 
_ty
 = 0;

136 *

 = 
NULL
;

137 
size
=0;

138 
su
 = 0;

140 i(!
x
 || !x->
Buf
 || !x->
Lk
 || !x->Lk->
ifi
 || ctx->
feNames
) {

141 
	`SLOGE
("[ERR][%s] Check youm. Cn fd ctifi.", 
__func__
);

142  
CERT_SVC_ERR_INVALID_PARAMETER
;

145 
size
 = 
x
->
Lk
->
ifi
->size;

146 

 = (*)
	`oc
(
size
, 1);

147 i(!

)

148  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

150 
	`memy
(

, 
x
->
Lk
->
ifi
->
da
, 
size
);

152 if(!(
x
->
feNames
 = (
_svc_fame_li
*)
	`mloc
((cert_svc_filename_list)))) {

153 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

154 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

155 
r
;

157 if(!(
x
->
feNames
->
fame
 = (*)
	`mloc
((* 
CERT_SVC_MAX_FILE_NAME_SIZE
))) {

158 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

159 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

160 
r
;

162 
	`memt
(
x
->
feNames
->
fame
, 0x00, 
CERT_SVC_MAX_FILE_NAME_SIZE
);

163 
x
->
feNames
->
xt
 = 
NULL
;

165 if((
t
 = 
	`_vify_ifi_wh_ag
(
x
->
Buf
, &(x->
Lk
), 
checkCAFg
, ctx->
feNames
, 
vidy
)!
CERT_SVC_ERR_NO_ERROR
) {

166 
	`SLOGE
("[ERR][%s] Favify ctifi.", 
__func__
);

167 
r
;

170 
	`SECURE_LOGD
("ro cth : %s", 
x
->
feNames
->
fame
);

171 
t
 = 
	`_svc_g_ifi_ty
(
x
, &
_ty
);

172 i(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

173 
	`SLOGE
("failedo cert_svc_get_certificate_type");

174 
r
;

177 
	`SLOGD
("_ty = %d", 
_ty
);

178 i(
_ty
 =
CERT_SVC_TYPE_TEST
) {

179 
	`SLOGD
("Checking DUID");

180 
su
 = 
	`__is_ifd_devi
(

, 
size
);

182 i(
su
 == -1){

183 
	`SLOGE
("Devicerofile file doesotxist in Device.");

184 
t
 = 
CERT_SVC_ERR_INVALID_NO_DEVICE_PROFILE
;

185 
r
;

186 } i(
su
 == 0) {

187 
	`SLOGE
("Device Unique ID (DUID) isotegistered.");

188 
t
 = 
CERT_SVC_ERR_INVALID_DEVICE_UNIQUE_ID
;

189 
r
;

193 
	`SLOGD
("[%s] Sucstvify ctifi.", 
__func__
);

195 
r
:

196 
	`
(

);

197  
t
;

198 
	}
}

202 
CERT_SVC_API


203 
	$_svc_add_ifi_to_e
(cڡ * 
fePh
, cڡ * 
loti
)

205 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

206 
_fePh
[
CERT_SVC_MAX_FILE_NAME_SIZE
];

207 
thSize
 = 0;

209 i(!
fePh
) {

210 
	`SLOGE
("[ERR][%s] Check youm. Maybfth iNULL.", 
__func__
);

211  
CERT_SVC_ERR_INVALID_PARAMETER
;

214 
thSize
 = 
	`
(
fePh
);

216 i(
thSize
 <0 ||hSiz>
CERT_SVC_MAX_FILE_NAME_SIZE
) {

217 
	`SLOGE
("[ERR][%s] Check youm. Maybfth iNULL.", 
__func__
);

218  
CERT_SVC_ERR_INVALID_PARAMETER
;

221 
	`memt
(
_fePh
, 0x0, (_filePath));

223 i(
fePh
[0] != '/') {

224 i(!
	`gcwd
(
_fePh
, (_filePath))) {

225 
	`SLOGE
("[ERR][%s] Check youm. Maybfth iNULL.", 
__func__
);

226  
CERT_SVC_ERR_INVALID_OPERATION
;

229 
cwdSize
 = 0;

230 
_fePh
[(_filePath) - 1] = '\0';

232 
cwdSize
 = 
	`
(
_fePh
);

234 i(
cwdSize
 <=0 || (cwdSiz+ 
thSize
 + 1>
CERT_SVC_MAX_FILE_NAME_SIZE
) {

235 
	`SLOGE
("[ERR][%s] Check youm. Maybfth iNULL.", 
__func__
);

236  
CERT_SVC_ERR_INVALID_OPERATION
;

239 
	`t
(
_fePh
, "/", 1);

240 
	`t
(
_fePh
, 
fePh
, 
thSize
);

242 
	`y
(
_fePh
, 
fePh
, 
thSize
);

245 
t
 = 
	`_add_ifi_to_e
(
_fePh
, 
loti
);

247 i(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

248 
	`SLOGE
("[ERR][%s] Faءܐifi, [%s]", 
__func__
, 
_fePh
);

249  
t
;

251 
	`SLOGD
("[%s] Sucstadd ctifi [%s].", 
__func__
, 
fePh
);

253  
CERT_SVC_ERR_NO_ERROR
;

254 
	}
}

256 
CERT_SVC_API


257 
	$_svc_de_ifi_om_e
(cڡ * 
feName
, cڡ * 
loti
)

259 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

261 i(!
feName
 || fileName[0] == '/') {

262 
	`SLOGE
("[ERR][%s] Check youm. MaybfmiNULL oin sg˂ame.", 
__func__
);

263  
CERT_SVC_ERR_INVALID_PARAMETER
;

266 
t
 = 
	`_de_ifi_om_e
(
feName
, 
loti
);

267 i(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

268 
	`SLOGE
("[ERR][%s] Fadifi, [%s]", 
__func__
, 
feName
);

269  
t
;

272 
	`SLOGD
("[%s] Sucstdifi [%s].", 
__func__
, 
feName
);

274  
CERT_SVC_ERR_NO_ERROR
;

275 
	}
}

278 
CERT_SVC_API


279 
	$_svc_vify_ckage_ifi
(
CERT_CONTEXT
* 
x
, * 
vidy
, cڡ * 
sigtuFe
)

281 
	`SLOGD
("cert_svc_verify_package_certificate");

282 
_cag_check_l
 = 0;

284 
t
 = 
	`__svc_vify_ifi_wh_ag
(
x
, 
_cag_check_l
, 
vidy
);

285 i(
t
 !
CERT_SVC_ERR_NO_ERROR
)

286  
t
;

288 
visiby
 = 0;

289 
t
 = 
	`_svc_g_visiby
(
x
, &
visiby
);

290 i(
t
 !
CERT_SVC_ERR_NO_ERROR
)

291  
t
;

293 * 
sig_fe_me
 = 
NULL
;

294 i((
sig_fe_me
 = 
	`rr
(
sigtuFe
, 
AUTHOR_SIGNATURE
))) {

295 
	`SLOGD
("sigtu f: %%d", 
sig_fe_me
, 
visiby
);

296 i(
	`cmp
(
sig_fe_me
, 
AUTHOR_SIGNATURE
, 
	`
(sig_file_name)) == 0) {

297 i(
visiby
 !
CERT_SVC_VISIBILITY_DEVELOPER
) {

298 
	`SLOGE
("Author signature signeds distributor signature. Invalid!");

299 *
vidy
 = 0;

300  
CERT_SVC_ERR_IN_AUTHOR_CASE_DISTRIBUTOR_CERT
;

303 } i((
sig_fe_me
 = 
	`rr
(
sigtuFe
, 
DISTRIBUTOR_SIGNATURE
))) {

304 
	`SLOGD
("sigtu f: %%d", 
sig_fe_me
, 
visiby
);

305 i(
	`cmp
(
sig_fe_me
, 
DISTRIBUTOR_SIGNATURE
, 
	`
(sig_file_name)) == 0) {

306 i(
visiby
 =
CERT_SVC_VISIBILITY_DEVELOPER
) {

307 
	`SLOGE
("Distributor signature signedsuthor signature. Invalid!");

308 *
vidy
 = 0;

309  
CERT_SVC_ERR_IN_DISTRIBUTOR_CASE_AUTHOR_CERT
;

314  
CERT_SVC_ERR_NO_ERROR
;

315 
	}
}

317 
CERT_SVC_API


318 
	$_svc_vify_ifi
(
CERT_CONTEXT
* 
x
, * 
vidy
)

320  
	`__svc_vify_ifi_wh_ag
(
x
, 0, 
vidy
);

321 
	}
}

323 
CERT_SVC_API


324 
	$_svc_vify_ifi_wh_ag
(
CERT_CONTEXT
* 
x
, * 
vidy
)

326  
	`__svc_vify_ifi_wh_ag
(
x
, 1, 
vidy
);

327 
	}
}

333 
CERT_SVC_API


334 
	$_svc_vify_sigtu
(
CERT_CONTEXT
* 
x
, * 
mesge
, 
msgL
, * 
sigtu
, * 
go
, * 
vidy
)

336 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

338 i(!
mesge
 || !
sigtu
 || !
x
 || !x->
Buf
) {

339 
	`SLOGE
("[ERR][%s] Invidam,a check youm", 
__func__
);

340  
CERT_SVC_ERR_INVALID_PARAMETER
;

343 i((
t
 = 
	`_vify_sigtu
(
x
->
Buf
, 
mesge
, 
msgL
, 
sigtu
, 
go
, 
vidy
)!
CERT_SVC_ERR_NO_ERROR
) {

344 
	`SLOGE
("[ERR][%s] Favify sigtu.", 
__func__
);

345  
t
;

348 
	`SLOGD
("[%s] Sucstvify sigtu.", 
__func__
);

350  
CERT_SVC_ERR_NO_ERROR
;

351 
	}
}

353 
CERT_SVC_API


354 
	$_svc_exa_ifi_da
(
CERT_CONTEXT
* 
x
)

356 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

358 i(!
x
 || !x->
Buf
) {

359 
	`SLOGE
("[ERR][%s] Check youm.", 
__func__
);

360  
CERT_SVC_ERR_INVALID_PARAMETER
;

363 i(
x
->
Desc
 !
NULL
) {

364 
	`SLOGE
("[ERR][%s] ctDesfld̗dy bud.", 
__func__
);

365  
CERT_SVC_ERR_INVALID_OPERATION
;

368 i(!(
x
->
Desc
 = (
_svc__dest
*)
	`mloc
((cert_svc_cert_descriptor)))) {

369 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

370  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

372 
	`memt
(
x
->
Desc
, 0x00, (
_svc__dest
));

374 i((
t
 = 
	`_exa_ifi_da
(
x
->
Buf
, ctx->
Desc
)!
CERT_SVC_ERR_NO_ERROR
) {

375 
	`SLOGE
("[ERR][%s] Faexa ctifi da.", 
__func__
);

376 
	`
(
x
->
Desc
);

377 
x
->
Desc
 = 
NULL
;

378  
t
;

381 
	`SLOGD
("[%s] Sucstexa ctifi.", 
__func__
);

383  
CERT_SVC_ERR_NO_ERROR
;

384 
	}
}

386 
CERT_SVC_API


387 
	$_svc_ch_ifi
(
CERT_CONTEXT
* 
x
, 
ch_fld
 
dName
, * 
dDa
)

389 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

391 i(!
x
 || 
dName
 > 
SEARCH_FIELD_END
 || !
dDa
) {

392 
	`SLOGE
("[ERR][%s] Invidam. Check youm", 
__func__
);

393  
CERT_SVC_ERR_INVALID_PARAMETER
;

396 i(
x
->
feNames
 !
NULL
) {

397 
	`SLOGE
("[ERR][%s] feNamefld̗dy bud.", 
__func__
);

398  
CERT_SVC_ERR_INVALID_OPERATION
;

401 i((
t
 = 
	`_ch_ifi
(&(
x
->
feNames
), 
dName
, 
dDa
)!
CERT_SVC_ERR_NO_ERROR
) {

402 
	`SLOGE
("[ERR][%s] Faأch ctifi.", 
x
->
feNames
);

403  
t
;

406 
	`SLOGD
("[%s] Sucstأch ctifi(s).", 
__func__
);

408  
CERT_SVC_ERR_NO_ERROR
;

409 
	}
}

411 
CERT_SVC_API


412 
CERT_CONTEXT
* 
	$_svc__cڋxt_
()

414 
CERT_CONTEXT
* 
x
 = 
NULL
;

416 i(!(
x
 = (
CERT_CONTEXT
*)
	`mloc
((CERT_CONTEXT)))) {

417 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

418  
NULL
;

421 
x
->
Buf
 = 
NULL
;

422 
x
->
Desc
 = 
NULL
;

423 
x
->
Lk
 = 
NULL
;

424 
x
->
feNames
 = 
NULL
;

426 
	`SLOGD
("[%s] Sucstؚlizcڋxt.", 
__func__
);

428  
x
;

429 
	}
}

431 
CERT_SVC_API


432 
	$_svc__cڋxt_f
(
CERT_CONTEXT
* 
cڋxt
)

434 i(!
cڋxt
)

435  
CERT_SVC_ERR_NO_ERROR
;

437 i(
cڋxt
->
Buf
) {

438 
	`
(
cڋxt
->
Buf
->
da
);

439 
	`
(
cڋxt
->
Buf
);

440 
cڋxt
->
Buf
 = 
NULL
;

443 
	`a_ifi_da
(
cڋxt
->
Desc
);

444 
	`a__li
(
cڋxt
->
Lk
);

445 
	`a_fame_li
(
cڋxt
->
feNames
);

447 
	`
(
cڋxt
);

448 
cڋxt
 = 
NULL
;

450 
	`SLOGD
("[%s] Sucstfizcڋxt.", 
__func__
);

452  
CERT_SVC_ERR_NO_ERROR
;

453 
	}
}

455 
CERT_SVC_API


456 
	$_svc_ld_buf_to_cڋxt
(
CERT_CONTEXT
* 
x
, *
buf
)

458 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

459 
size
 = 0;

460 *
decodedBuf
 = 
NULL
;

461 
decodedSize
 = 0;

463 i(!
x
 || !
buf
) {

464 
	`SLOGE
("[ERR][%s] cڋx buiNULL.", 
__func__
);

465  
CERT_SVC_ERR_INVALID_PARAMETER
;

468 i(
x
->
Buf
) {

469 
	`SLOGE
("[ERR][%s] ctBuiady ud. wنd bufcڋ.", 
__func__
);

470  
CERT_SVC_ERR_INVALID_OPERATION
;

473 i(!(
x
->
Buf
 = (
_svc_mem_buff
*)
	`mloc
((cert_svc_mem_buff)))) {

474 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

475  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

477 
	`memt
(
x
->
Buf
, 0x00, (
_svc_mem_buff
));

479 
size
 = 
	`
((*)
buf
);

480 
decodedSize
 = ((
size
 / 4) * 3) + 1;

482 i(!(
decodedBuf
 = (*)
	`mloc
((* 
decodedSize
))) {

483 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

484  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

487 i((
t
 = 
	`_svc_ut_ba64_decode
(
buf
, 
size
, 
decodedBuf
, &
decodedSize
)!
CERT_SVC_ERR_NO_ERROR
) {

488 
	`SLOGE
("[ERR][%s] Fadecodrg,: [%d]", 
__func__
, 
t
);

489 
	`
(
decodedBuf
);

490  
CERT_SVC_ERR_INVALID_OPERATION
;

493 
x
->
Buf
->
da
 = 
decodedBuf
;

494 
x
->
Buf
->
size
 = 
decodedSize
;

496 
	`SLOGD
("[%s] Sucstld ctifi bufcڋcڋxt.", 
__func__
);

498  
CERT_SVC_ERR_NO_ERROR
;

499 
	}
}

501 
CERT_SVC_API


502 
	$_svc_ld_fe_to_cڋxt
(
CERT_CONTEXT
* 
x
, cڡ * 
fePh
)

504 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

506 i(!
x
 || !
fePh
) {

507 
	`SLOGE
("[ERR][%s] cڋx fth iNULL.", 
__func__
);

508  
CERT_SVC_ERR_INVALID_PARAMETER
;

511 i(
x
->
Buf
) {

512 
	`SLOGE
("[ERR][%s] ctBuiady ud. wنd fe.", 
__func__
);

513  
CERT_SVC_ERR_INVALID_OPERATION
;

516 i(!(
x
->
Buf
 = (
_svc_mem_buff
*)
	`mloc
((cert_svc_mem_buff)))) {

517 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

518  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

520 
	`memt
(
x
->
Buf
, 0x00, (
_svc_mem_buff
));

522 i((
t
 = 
	`_svc_ut_ld_fe_to_bufr
(
fePh
, 
x
->
Buf
)!
CERT_SVC_ERR_NO_ERROR
) {

523 
	`SLOGE
("[ERR][%s] Fald fe, fh: [%s],: [%d]", 
__func__
, 
fePh
, 
t
);

524 
	`
(
x
->
Buf
);

525 
x
->
Buf
 = 
NULL
;

526  
CERT_SVC_ERR_INVALID_OPERATION
;

529 
	`SLOGD
("[%s] Sucstld ctifi fcڋcڋxt.", 
__func__
);

531  
CERT_SVC_ERR_NO_ERROR
;

532 
	}
}

534 
CERT_SVC_API


535 
	$_svc_push_buf_to_cڋxt
(
CERT_CONTEXT
 *
x
, * 
buf
)

537 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

538 
_svc_lked_li
* 
cur
 = 
NULL
;

539 
_svc_lked_li
* 
w
 = 
NULL
;

540 
size
 = 0;

541 * 
decodedBuf
 = 
NULL
;

542 
decodedSize
 = 0;

544 i(!
x
 || !
buf
) {

545 
	`SLOGE
("[ERR][%s] cڋx buiNULL.", 
__func__
);

546  
CERT_SVC_ERR_INVALID_PARAMETER
;

550 i(!(
w
 = (
_svc_lked_li
*)
	`mloc
((cert_svc_linked_list)))) {

551 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

552  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

555 i(!(
w
->
ifi
 = (
_svc_mem_buff
*)
	`mloc
((cert_svc_mem_buff)))) {

556 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

557 
	`
(
w
);

558  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

561 
size
 = 
	`
((*)
buf
);

562 
decodedSize
 = ((
size
 / 4) * 3) + 1;

564 i(!(
decodedBuf
 = (*)
	`mloc
((* 
decodedSize
))) {

565 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

566 
	`a__li
(
w
);

567  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

570 i((
t
 = 
	`_svc_ut_ba64_decode
(
buf
, 
size
, 
decodedBuf
, &
decodedSize
)!
CERT_SVC_ERR_NO_ERROR
) {

571 
	`SLOGE
("[ERR][%s] Fadecodrg,: [%d]", 
__func__
, 
t
);

572 
	`a__li
(
w
);

573 
	`
(
decodedBuf
);

574  
CERT_SVC_ERR_INVALID_OPERATION
;

577 
w
->
ifi
->
da
 = 
decodedBuf
;

578 
w
->
ifi
->
size
 = 
decodedSize
;

579 
w
->
xt
 = 
NULL
;

582 i(!
x
->
Lk
) {

583 
x
->
Lk
 = 
w
;

585 
cur
 = 
x
->
Lk
;

586 
cur
->
xt
)

587 
cur
 = cur->
xt
;

589 
cur
->
xt
 = 
w
;

592 
	`SLOGD
("[%s] Sucstpush ctifi bufcڋcڋxt.", 
__func__
);

594  
CERT_SVC_ERR_NO_ERROR
;

595 
	}
}

597 
CERT_SVC_API


598 
	$_svc_push_fe_to_cڋxt
(
CERT_CONTEXT
 *
x
, cڡ * 
fePh
)

600 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

601 
_svc_lked_li
* 
cur
 = 
NULL
;

602 
_svc_lked_li
* 
w
 = 
NULL
;

604 i(!
x
 || !
fePh
) {

605 
	`SLOGE
("[ERR][%s] cڋx fth iNULL.", 
__func__
);

606  
CERT_SVC_ERR_INVALID_PARAMETER
;

609 i(!(
w
 = (
_svc_lked_li
*)
	`mloc
((cert_svc_linked_list)))) {

610 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

611  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

613 
	`memt
(
w
, 0x00, (
_svc_lked_li
));

615 i(!(
w
->
ifi
 = (
_svc_mem_buff
*)
	`mloc
((cert_svc_mem_buff)))) {

616 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

617 
	`
(
w
);

618  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

620 
	`memt
(
w
->
ifi
, 0x00, (
_svc_mem_buff
));

622 i((
t
 = 
	`_svc_ut_ld_fe_to_bufr
(
fePh
, 
w
->
ifi
)!
CERT_SVC_ERR_NO_ERROR
) {

623 
	`SLOGE
("[ERR][%s] Fald fe, fh: [%s],: [%d]", 
__func__
, 
fePh
, 
t
);

624 
	`a__li
(
w
);

625  
CERT_SVC_ERR_INVALID_OPERATION
;

627 
w
->
xt
 = 
NULL
;

630 i(!
x
->
Lk
) {

631 
x
->
Lk
 = 
w
;

633 
cur
 = 
x
->
Lk
;

634 
cur
->
xt
)

635 
cur
 = cur->
xt
;

637 
cur
->
xt
 = 
w
;

640 
	`SLOGD
("[%s] Sucstpush ctifi fcڋcڋxt.", 
__func__
);

642  
CERT_SVC_ERR_NO_ERROR
;

643 
	}
}

645 
CERT_SVC_API


646 
	$_svc_ld_PFX_fe_to_cڋxt
(
CERT_CONTEXT
* 
x
, ** 
iveKey
, * 
iKeyL
, cڡ * 
fePh
, * 
ssPh
)

648 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

650 i(!
x
 || !
fePh
) {

651 
	`SLOGE
("[ERR][%s] cڋx fth iNULL.", 
__func__
);

652  
CERT_SVC_ERR_INVALID_PARAMETER
;

655 i(
x
->
Buf
) {

656 
	`SLOGE
("[ERR][%s] ctBuiady ud. wنd fe.", 
__func__
);

657  
CERT_SVC_ERR_INVALID_OPERATION
;

660 i(!(
x
->
Buf
 = (
_svc_mem_buff
*)
	`mloc
((cert_svc_mem_buff)))) {

661 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

662  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

664 
	`memt
(
x
->
Buf
, 0x00, (
_svc_mem_buff
));

666 i((
t
 = 
	`_svc_ut_ld_PFX_fe_to_bufr
(
fePh
, 
x
->
Buf
, &x->
Lk
, 
iveKey
, 
iKeyL
, 
ssPh
)!
CERT_SVC_ERR_NO_ERROR
) {

667 
	`SLOGE
("[ERR][%s] Fald fe, fh: [%s],: [%d]", 
__func__
, 
fePh
, 
t
);

668 
	`
(
x
->
Buf
);

669 
x
->
Buf
 = 
NULL
;

670  
CERT_SVC_ERR_INVALID_OPERATION
;

673 
	`SLOGD
("[%s] Sucstld ctifi fcڋcڋxt.", 
__func__
);

675  
CERT_SVC_ERR_NO_ERROR
;

676 
	}
}

678 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


679 
CERT_SVC_API


680 
	$_svc_check_oc_us
(
CERT_CONTEXT
* 
x
, cڡ * 
uri
)

682 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

683 
_svc_lked_li
** 
Li
=
NULL
;

685 i(!
x
 || !x->
Buf
) {

686 
	`SLOGE
("[ERR][%s] ctBumu havvue.", 
__func__
);

687  
CERT_SVC_ERR_INVALID_PARAMETER
;

690 i(
x
->
Lk
) {

691 
Li
 = &(
x
->
Lk
);

693 i((
t
 = 
	`_check_oc_us
(
x
->
Buf
, 
Li
, 
uri
)!
CERT_SVC_ERR_NO_ERROR
) {

694 
	`SLOGE
("[ERR][%s] Facheckevoti stus.", 
__func__
);

695  
t
;

698  
CERT_SVC_ERR_NO_ERROR
;

702 
CERT_SVC_API


703 * 
	`_svc_g_ifi_t_fe_th
()

705  
CERTSVC_CRT_FILE_PATH
;

708 
CERT_SVC_API


709 
	`_svc_g_visiby
(
CERT_CONTEXT
 *
x
, * 
visiby
)

711 
CERT_CONTEXT
* 
cڋxt
 = 
NULL
;

712 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

714 i(!
x
 || !
visiby
) {

715 
	`SLOGE
("Invalidrameters");

716  
CERT_SVC_ERR_INVALID_PARAMETER
;

719 i(!
x
->
feNames
 || !x->feNames->
fame
) {

720 
	`SLOGE
("Canot findoot certificateath");

721  
CERT_SVC_ERR_INVALID_PARAMETER
;

724 
cڋxt
 = 
	`_svc__cڋxt_
();

725 i(!
cڋxt
) {

726 
	`SLOGE
("Out of memory");

727  
CERT_SVC_ERR_MEMORY_ALLOCATION
;

730 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
cڋxt
, 
x
->
feNames
->
fame
);

731 i(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

732 
	`SLOGE
("failedooadoot certficiate");

733 
	`_svc__cڋxt_f
(
cڋxt
);

734  
CERT_SVC_ERR_INVALID_CERTIFICATE
;

737 
t
 = 
	`g_visiby
(
cڋxt
, 
visiby
);

739 
	`_svc__cڋxt_f
(
cڋxt
);

741  
t
;

745 
CERT_SVC_API


746 
	`_svc_g_visiby_by_ro_ifi
(cڡ * 
ba64_coded_da
, 
da_n
, * 
visiby
)

748 i(!
ba64_coded_da
|| !
da_n
) {

749  
CERT_SVC_ERR_INVALID_PARAMETER
;

752 
t
 = 
	`g_visiby_by_ifi
((cڡ *)
ba64_coded_da
, 
da_n
, 
visiby
);

753 i(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

754 
	`SLOGE
("Faedg_visiby :%d", 
t
);

755  
t
;

758  
CERT_SVC_ERR_NO_ERROR
;

761 
CERT_SVC_API


762 
	`_svc_ut_r_me_d_da
(* 
r
, 
_svc_me_d_da
* 
d
)

764  
	`r_me_d_da
(
r
, 
d
);

767 
	`hex_cod
(cڡ *
c
, 
cL
, *
out
)

769 
i
 = 0;

770 
cLow
 = 0;

771 
cHigh
 = 0;

773 
i
 = 0; i < 
cL
 ; i++) {

774 
cLow
 = 
c
[
i
] & 0x0f;

775 
cHigh
 = (
c
[
i
] >> 4) & 0x0f;

777 i(
cLow
 <= 9)

778 
out
[
i
 * 2 + 1] = 
cLow
 + '0';

780 
out
[
i
 * 2 + 1] = 
cLow
 - 10 + 'A';

782 i(
cHigh
 <= 9)

783 
out
[
i
 * 2] = 
cHigh
 + '0';

785 
out
[
i
 * 2] = 
cHigh
 - 10 + 'A';

	@tests/capi/api_tests.cpp

22 
	~<d//_ru.h
>

24 
	~<-svc/c.h
>

29 
CtSvcIn
 
	gv
;

31 
	$ma
 (
gc
, *
gv
[])

33 
	`svc__w
(&
v
);

34 
us
 = 
DPL
::
Te
::
TeRuSgt
::
	`In
().
	`ExecTeRu
(
gc
, 
gv
);

35 
	`svc__
(
v
);

36  
us
;

37 
	}
}

	@tests/capi/api_tests.h

23 
	~<-svc/c.h
>

24 
	~<-svc/c.h
>

25 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


26 
	~<-svc/cl.h
>

27 
	~<-svc/coc.h
>

29 
	~<-svc/kcs12.h
>

30 
	~<-svc/rimives.h
>

32 
CtSvcIn
 
v
;

	@tests/capi/crl_cache.h

22 #ide
_CRL_MEMORY_CACHE_H_


23 
	#_CRL_MEMORY_CACHE_H_


	)

25 
	~<m
>

26 
	~<rg
>

27 
	~<ve
>

29 
	~<rg.h
>

30 
	~<time.h
>

32 
	gd
::
	tve
<> 
	tByBufr
;

34 
	sCRecd_t
 {

35 
ByBufr
 
	mbufr
;

36 
time_t
 
	mxtUpde
;

37 } 
	tCRecd
;

39 
	gd
::
	tm
<
	td
::
	trg
,
	tCRecd
> 
	tMemyCache
;

41 
	$memyCacheWre
(

42 cڡ *
diributiPot
,

43 cڡ *
body
,

44 
bodySize
,

45 
time_t
 
xtUpdeTime
,

46 *
urPam
)

48 
MemyCache
 *
che
 = 
ic_
<MemyCache*>(
urPam
);

50 
CRecd
 
cd
;

51 
cd
.
bufr
.
	`size
(
bodySize
);

52 
	`memy
(&
cd
.
bufr
[0], 
body
, 
bodySize
);

53 
cd
.
xtUpde
 = 
xtUpdeTime
;

55 
che
->
	`
(
d
::
	`make_
(d::
	`rg
(
diributiPot
),
cd
));

56 
	}
}

58 
	$memyCacheRd
(

59 cڡ *
diributPot
,

60 **
body
,

61 *
bodySize
,

62 
time_t
 *
xtUpdeTime
,

63 *
urPam
)

65 
MemyCache
 *
che
 = 
ic_
<MemyCache*>(
urPam
);

66 aut

 = 
che
->
	`fd
(
diributPot
);

67 i(

 =
che
->
	`d
()) {

70 
CRecd
 
cd
 = 

->
cd
;

71 *
bodySize
 = 
cd
.
bufr
.
	`size
();

72 *
body
 = 
w
 [*
bodySize
];

73 
	`memy
(*
body
, &
cd
.
bufr
[0], *
bodySize
);

74 *
xtUpdeTime
 = 
cd
.
xtUpde
;

76 
	}
}

78 
	$memyCacheFe
(

79 *
bufr
,

82 
de
[] 
bufr
;

83 
	}
}

	@tests/capi/test_suite_01.cpp

16 
	~<rg
>

18 
	~<ݒs/x509.h
>

20 
	~<d//_ru.h
>

21 
	~<d/log/log.h
>

23 
	~<i_s.h
>

25 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


26 
	~"l_che.h
"

27 
	~<vce/VCe.h
>

30 
	$RUNNER_TEST_GROUP_INIT
(
CAPI
)

38 
	$RUNNER_TEST
(
01_ifi_w_om_fe
)

40 
CtSvcCtifi
 

;

41 
su
 = 
	`svc_ifi_w_om_fe
(

42 
v
,

44 &

);

45 
	`RUNNER_ASSERT_MSG
(
CERTSVC_TRUE
 =
su
, "Erroreading certificate");

47 
CtSvcSg
 
rg
;

49 
	`svc_ifi_g_rg_fld
(

50 

,

51 
CERTSVC_SUBJECT_COMMON_NAME
,

52 &
rg
);

54 cڡ *
r
 = "Samsung";

56 cڡ *
bufr
;

57 
n
;

59 
	`svc_rg_to_crg
(
rg
, &
bufr
, &
n
);

61 
su
 = 
	`cmp
(

62 
bufr
,

63 
r
,

64 
	`
(
r
));

66 
	`RUNNER_ASSERT_MSG
(0 =
su
, "Erroreading commoname");

68 
	`svc_ifi_
(

);

69 
	}
}

77 
	$RUNNER_TEST
(
02_ifi_ch
)

79 
CtSvcCtifiLi
 
hdr
;

80 
su
 = 
	`svc_ifi_ch
(
v
,

81 
CERTSVC_SUBJECT_COMMON_NAME
,

83 &
hdr
);

85 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in search method.rrcode : " <<esult);

87 
CtSvcCtifi
 

;

89 
su
 = 
	`svc_ifi_li_g_e
(
hdr
, 0, &

);

91 
	`RUNNER_ASSERT_MSG
(
CERTSVC_TRUE
 =
su
, "Erroreading certificate.rrcode : " <<esult);

93 
CtSvcSg
 
rg
;

95 
	`svc_ifi_g_rg_fld
(

96 

,

97 
CERTSVC_SUBJECT_COUNTRY_NAME
,

98 &
rg
);

100 cڡ *
r
 = "GB";

101 cڡ *
bufr
;

103 
	`svc_rg_to_crg
(
rg
, &
bufr
, 
NULL
);

105 
su
 = 
	`cmp
(

106 
bufr
,

107 
r
,

108 
	`
(
r
));

110 
	`RUNNER_ASSERT_MSG
(0 =
su
, "Country doesot match.esult : " <<esult);

111 
	}
}

119 
	$RUNNER_TEST
(
03_is_sigd_by
)

121 
su
;

122 
d
::
rg
 
googCA
 =

136 
d
::
rg
 
goog2nd
 =

155 
CtSvcCtifi
 
1
, 
2
;

157 
su
 = 
	`svc_ifi_w_om_memy
(

158 
v
,

159 (cڡ *)
googCA
.
	`c_r
(),

160 
googCA
.
	`size
(),

161 
CERTSVC_FORM_DER_BASE64
,

162 &
1
);

164 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Erroreading certificate");

166 
su
 = 
	`svc_ifi_w_om_memy
(

167 
v
,

168 (cڡ *)
goog2nd
.
	`c_r
(),

169 
goog2nd
.
	`size
(),

170 
CERTSVC_FORM_DER_BASE64
,

171 &
2
);

173 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Erroreading certificate");

175 
us
;

176 
su
 = 
	`svc_ifi_is_sigd_by
(
2
, 
1
, &
us
);

178 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Chain verification failed");

179 
	`RUNNER_ASSERT_MSG
(
CERTSVC_TRUE
 =
us
, "Chain verification failed");

180 
	}
}

188 
	$RUNNER_TEST
(
04_n_befe_n_a
)

190 
d
::
rg
 
goog2nd
 =

209 
CtSvcCtifi
 

;

210 
su
;

212 
su
 = 
	`svc_ifi_w_om_memy
(

213 
v
,

214 (cڡ *)
goog2nd
.
	`c_r
(),

215 
goog2nd
.
	`size
(),

216 
CERTSVC_FORM_DER_BASE64
,

217 &

);

219 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Erroreading certificate");

221 
time_t
 
befe
, 
a
;

222 
su
 = 
	`svc_ifi_g_n_befe
(

, &
befe
);

224 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Errorxtracting NOT_BEFORE");

225 
	`RUNNER_ASSERT_MSG
(
befe
 == 1084406400, "TODO");

227 
su
 = 
	`svc_ifi_g_n_a
(

, &
a
);

229 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Errorxtracting NOT_AFTER");

231 
	`RUNNER_ASSERT_MSG
(
a
 == 1399939199, "TODO");

232 
	}
}

234 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


241 
	$RUNNER_TEST
(
05_g_r_di_pots
)

243 
d
::
rg
 
goog2nd
 =

262 
CtSvcCtifi
 

;

264 
su
 = 
	`svc_ifi_w_om_memy
(

265 
v
,

266 (cڡ *)
goog2nd
.
	`c_r
(),

267 
goog2nd
.
	`size
(),

268 
CERTSVC_FORM_DER_BASE64
,

269 &

);

271 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate");

273 
CtSvcSgLi
 
rgLi
;

275 
su
 = 
	`svc_ifi_g_l_diributi_pots
(

, &
rgLi
);

277 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading distributionoints");

279 
size
;

281 
su
 = 
	`svc_rg_li_g_ngth
(
rgLi
, &
size
);

283 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in stringist");

287 
CtSvcSg
 
vrg
;

289 
su
 = 
	`svc_rg_li_g_e
(
rgLi
, 0, &
vrg
);

291 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error inxtractingesult fromist");

293 
n
;

294 cڡ *
r
;

296 
	`svc_rg_to_crg
(
vrg
, &
r
, &
n
);

298 
	`RUNNER_ASSERT_MSG
(0 =
	`cmp
(
r
,"hp://l.visign.com/p3.l", 
n
), "Check distributionoints failed!");

299 
	}
}

308 
	$RUNNER_TEST
(
06__g_fld
)

310 
d
::
rg
 
goog2nd
 =

329 
CtSvcCtifi
 

;

331 
su
 = 
	`svc_ifi_w_om_memy
(

332 
v
,

333 (cڡ *)
goog2nd
.
	`c_r
(),

334 
goog2nd
.
	`size
(),

335 
CERTSVC_FORM_DER_BASE64
,

336 &

);

338 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

340 
CtSvcSg
 
subje
, 
issu
;

342 
su
 = 
	`svc_ifi_g_rg_fld
(

343 

,

344 
CERTSVC_SUBJECT
,

345 &
subje
);

347 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading SUBJECT field.");

349 
su
 = 
	`svc_ifi_g_rg_fld
(

350 

,

351 
CERTSVC_ISSUER
,

352 &
issu
);

354 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading ISSUER field.");

356 
size
;

357 cڡ *
r
;

359 
	`svc_rg_to_crg
(
subje
, &
r
, &
size
);

360 
	`RUNNER_ASSERT_MSG
(0 =
	`cmp
(
r
, "/C=ZA/O=Thaw Csuɚg (PtyLtd./CN=Thaw SGC CA", 
size
), "Subject doesot match.");

362 
	`svc_rg_to_crg
(
issu
, &
r
, &
size
);

363 
	`RUNNER_ASSERT_MSG
(0 =
	`cmp
(
r
, "/C=US/O=ViSign, Inc./OU=Cs3 PubliPrimy Ctifiti Authܙy", 
size
), "Issuer doesot match.");

364 
	}
}

372 
	$RUNNER_TEST
(
07_cha_st
)

374 
d
::
rg
 
EE
 =

393 
d
::
rg
 
CA
 =

412 
d
::
rg
 
RCA
 =

426 
CtSvcCtifi
 
1
, 
2
, 
3
;

428 
su
 = 
	`svc_ifi_w_om_memy
(

429 
v
,

430 (cڡ *)
EE
.
	`c_r
(),

431 
EE
.
	`size
(),

432 
CERTSVC_FORM_DER_BASE64
,

433 &
1
);

435 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

437 
su
 = 
	`svc_ifi_w_om_memy
(

438 
v
,

439 (cڡ *)
CA
.
	`c_r
(),

440 
CA
.
	`size
(),

441 
CERTSVC_FORM_DER_BASE64
,

442 &
2
);

443 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

445 
su
 = 
	`svc_ifi_w_om_memy
(

446 
v
,

447 (cڡ *)
RCA
.
	`c_r
(),

448 
RCA
.
	`size
(),

449 
CERTSVC_FORM_DER_BASE64
,

450 &
3
);

451 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

453 
CtSvcCtifi
 
ci
[3];

454 
ci
[0] = 
1
;

455 
ci
[1] = 
3
;

456 
ci
[2] = 
2
;

458 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
	`svc_ifi_cha_st
(
ci
, 3), "FAIL TO SORT CERTIFICATE");

460 
	`RUNNER_ASSERT_MSG
(
ci
[2].
iveHdr
 =
3
.privateHandler, "certsvc_certificate_chain_sort failed");

462 
ci
[0] = 
1
;

463 
ci
[1] = 
3
;

465 
	`RUNNER_ASSERT_MSG
(
CERTSVC_FAIL
 =
	`svc_ifi_cha_st
(
ci
, 2), "certsvc_certificate_chain_sort failed");

466 
	}
}

474 
	$RUNNER_TEST
(
08_mesge_vify_d_sha1
)

476 
d
::
rg
 
magda
 =

500 
d
::
rg
 
mesge
 = "c2lnbmVkIGRhdGEK";

501 
d
::
rg
 
sigtu
 = "MC0CFQCL2pDA4S/zsHkDUCWOq7K6ebG14gIUHHoLsbeUd+BEqBXB6XjmcTncBRA=";

503 
CtSvcSg
 
msgb64
, 
sigb64
, 
msg
, 
sig
;

505 
su
 = 
	`svc_rg_w
(
v
, 
mesge
.
	`c_r
(), mesge.
	`size
(), &
msgb64
);

506 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading messsage.");

508 
su
 = 
	`svc_rg_w
(
v
, 
sigtu
.
	`c_r
(), sigtu.
	`size
(), &
sigb64
);

509 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading signature.");

511 
CtSvcCtifi
 

;

513 
su
 = 
	`svc_ifi_w_om_memy
(

514 
v
,

515 (cڡ *)
magda
.
	`c_r
(),

516 
magda
.
	`size
(),

517 
CERTSVC_FORM_DER_BASE64
,

518 &

);

520 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

522 
su
 = 
	`svc_ba64_decode
(
msgb64
, &
msg
);

523 
	`RUNNER_ASSERT_MSG
(
su
 =
CERTSVC_TRUE
, "Error in decoding base64.");

524 
su
 = 
	`svc_ba64_decode
(
sigb64
, &
sig
);

525 
	`RUNNER_ASSERT_MSG
(
su
 =
CERTSVC_TRUE
, "Error in decoding base64.");

527 
us
;

528 
su
 = 
	`svc_mesge_vify
(

, 
msg
, 
sig
, "sha1", &
us
);

530 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in verify message.");

531 
	`RUNNER_ASSERT_MSG
(
us
 =
CERTSVC_TRUE
, "Error in verify message.");

532 
	}
}

540 
	$RUNNER_TEST
(
09_mesge_vify_r_sha1
)

542 
d
::
rg
 
f
 =

560 
d
::
rg
 
mesge
 = "Q3plZ28gdHUgc3p1a2Fzej8K";

561 
d
::
rg
 
sigtu
 =

566 
CtSvcSg
 
msgb64
, 
sigb64
, 
msg
, 
sig
;

568 
su
 = 
	`svc_rg_w
(
v
, 
mesge
.
	`c_r
(), mesge.
	`size
(), &
msgb64
);

569 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading messsage.");

571 
su
 = 
	`svc_rg_w
(
v
, 
sigtu
.
	`c_r
(), sigtu.
	`size
(), &
sigb64
);

572 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading signature.");

574 
CtSvcCtifi
 

;

576 
su
 = 
	`svc_ifi_w_om_memy
(

577 
v
,

578 (cڡ *)
f
.
	`c_r
(),

579 
f
.
	`size
(),

580 
CERTSVC_FORM_DER_BASE64
,

581 &

);

583 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

585 
su
 = 
	`svc_ba64_decode
(
msgb64
, &
msg
);

586 
	`RUNNER_ASSERT_MSG
(
su
 =
CERTSVC_TRUE
, "Error in decoding base64.");

588 
su
 = 
	`svc_ba64_decode
(
sigb64
, &
sig
);

589 
	`RUNNER_ASSERT_MSG
(
su
 =
CERTSVC_TRUE
, "Error in decoding base64.");

591 
us
;

592 
su
 = 
	`svc_mesge_vify
(

, 
msg
, 
sig
, "sha1", &
us
);

594 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in verify message.");

595 
	`RUNNER_ASSERT_MSG
(
us
 =
CERTSVC_SUCCESS
, "Error in verify message.");

597 
mesge
[0] = 'q';

599 
su
 = 
	`svc_rg_w
(
v
, 
mesge
.
	`c_r
(), mesge.
	`size
(), &
msgb64
);

600 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading messsage.");

602 
su
 = 
	`svc_ba64_decode
(
msgb64
, &
msg
);

603 
	`RUNNER_ASSERT_MSG
(
su
 =
CERTSVC_TRUE
, "Error in decoding base64.");

605 
su
 = 
	`svc_mesge_vify
(

, 
msg
, 
sig
, "sha1", &
us
);

607 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in verify message.");

608 
	`RUNNER_ASSERT_MSG
(
us
 =
CERTSVC_INVALID_SIGNATURE
, "Error in verify message.");

609 
	}
}

617 
	$RUNNER_TEST
(
10_mesge_vify_r_sha256
)

619 
d
::
rg
 
f
 =

637 
d
::
rg
 
mesge
 = "Q3plZ28gdHUgc3p1a2Fzej8K";

638 
d
::
rg
 
sigtu
 =

643 
CtSvcSg
 
msgb64
, 
sigb64
, 
msg
, 
sig
;

645 
su
 = 
	`svc_rg_w
(
v
, 
mesge
.
	`c_r
(), mesge.
	`size
(), &
msgb64
);

646 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading messsage.");

648 
su
 = 
	`svc_rg_w
(
v
, 
sigtu
.
	`c_r
(), sigtu.
	`size
(), &
sigb64
);

649 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading signature.");

651 
CtSvcCtifi
 

;

653 
su
 = 
	`svc_ifi_w_om_memy
(

654 
v
,

655 (cڡ *)
f
.
	`c_r
(),

656 
f
.
	`size
(),

657 
CERTSVC_FORM_DER_BASE64
,

658 &

);

660 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

662 
su
 = 
	`svc_ba64_decode
(
msgb64
, &
msg
);

663 
	`RUNNER_ASSERT_MSG
(
su
 =
CERTSVC_TRUE
, "Error in decoding base64.");

665 
su
 = 
	`svc_ba64_decode
(
sigb64
, &
sig
);

666 
	`RUNNER_ASSERT_MSG
(
su
 =
CERTSVC_TRUE
, "Error in decoding base64.");

668 
us
;

669 
su
 = 
	`svc_mesge_vify
(

, 
msg
, 
sig
, "sha256", &
us
);

671 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in verify message.");

672 
	`RUNNER_ASSERT_MSG
(
us
 =
CERTSVC_SUCCESS
, "Error in verify message.");

674 
mesge
[0] = 'q';

676 
su
 = 
	`svc_rg_w
(
v
, 
mesge
.
	`c_r
(), mesge.
	`size
(), &
msgb64
);

677 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading messsage.");

679 
su
 = 
	`svc_ba64_decode
(
msgb64
, &
msg
);

680 
	`RUNNER_ASSERT_MSG
(
su
 =
CERTSVC_TRUE
, "Error in decoding base64.");

682 
su
 = 
	`svc_mesge_vify
(

, 
msg
, 
sig
, "sha256", &
us
);

684 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in verify message.");

685 
	`RUNNER_ASSERT_MSG
(
us
 =
CERTSVC_INVALID_SIGNATURE
, "Error in verify message.");

686 
	}
}

688 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


695 
	$RUNNER_TEST
(
11_oc
)

697 
VidiCe
::
	`VCeIn
();

699 
d
::
rg
 
EE
 =

729 
d
::
rg
 
CA
 =

758 
d
::
rg
 
RCA
 =

776 
CtSvcCtifi
 
1
, 
2
, 
3
;

778 
su
 = 
	`svc_ifi_w_om_memy
(

779 
v
,

780 (cڡ *)
EE
.
	`c_r
(),

781 
EE
.
	`size
(),

782 
CERTSVC_FORM_DER_BASE64
,

783 &
1
);

785 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

787 
su
 = 
	`svc_ifi_w_om_memy
(

788 
v
,

789 (cڡ *)
CA
.
	`c_r
(),

790 
CA
.
	`size
(),

791 
CERTSVC_FORM_DER_BASE64
,

792 &
2
);

793 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

795 
su
 = 
	`svc_ifi_w_om_memy
(

796 
v
,

797 (cڡ *)
RCA
.
	`c_r
(),

798 
RCA
.
	`size
(),

799 
CERTSVC_FORM_DER_BASE64
,

800 &
3
);

801 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

803 
CtSvcCtifi
 
ci
[3];

804 
ci
[0] = 
1
;

805 
ci
[1] = 
2
;

806 
ci
[2] = 
3
;

808 
us
;

809 
su
 = 
	`svc_oc_check
(
ci
, 3, ci, 3, 
NULL
, &
us
);

810 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in ocsp check.");

812 
	`RUNNER_ASSERT_MSG
(
us
 & 
CERTSVC_OCSP_GOOD
, "Error in ocsp.");

813 
VidiCe
::
	`VCeDe
();

814 
	}
}

822 
	$RUNNER_TEST
(
12_oc
)

824 
VidiCe
::
	`VCeIn
();

826 
d
::
rg
 
googCA
 =

840 
d
::
rg
 
goog2nd
 =

859 
d
::
rg
 
goog3rd
 =

878 
CtSvcCtifi
 
1
, 
2
, 
3
;

880 
su
 = 
	`svc_ifi_w_om_memy
(

881 
v
,

882 (cڡ *)
goog3rd
.
	`c_r
(),

883 
goog3rd
.
	`size
(),

884 
CERTSVC_FORM_DER_BASE64
,

885 &
1
);

887 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

889 
su
 = 
	`svc_ifi_w_om_memy
(

890 
v
,

891 (cڡ *)
goog2nd
.
	`c_r
(),

892 
goog2nd
.
	`size
(),

893 
CERTSVC_FORM_DER_BASE64
,

894 &
2
);

895 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

897 
su
 = 
	`svc_ifi_w_om_memy
(

898 
v
,

899 (cڡ *)
googCA
.
	`c_r
(),

900 
googCA
.
	`size
(),

901 
CERTSVC_FORM_DER_BASE64
,

902 &
3
);

903 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error ineading certificate.");

905 
CtSvcCtifi
 
ci
[3];

906 
ci
[0] = 
1
;

907 
ci
[1] = 
2
;

908 
ci
[2] = 
3
;

910 
us
;

911 
su
 = 
	`svc_oc_check
(
ci
, 3, ci, 3, 
NULL
, &
us
);

912 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in ocsp check.");

914 
	`RUNNER_ASSERT_MSG
(
us
 & 
CERTSVC_OCSP_GOOD
, "Error in ocsp.");

917 
su
 = 
	`svc_oc_check
(
ci
, 3, ci, 3, "hp://127.0.0.1:9999", &
us
);

918 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in ocsp check.");

920 
	`RUNNER_ASSERT_MSG
(
us
 & 
CERTSVC_OCSP_CONNECTION_FAILED
, "Error in ocsp.");

921 
VidiCe
::
	`VCeDe
();

922 
	}
}

930 
	$RUNNER_TEST
(
13_l
)

932 cڡ 
MAXC
 = 3;

933 
d
::
rg
 

[
MAXC
];

934 

[0] =

953 

[1] =

972 

[2] =

987 
CtSvcCtifi
 
ifi
[
MAXC
];

989 
su
, 
us
;

991 
i
=0; i<
MAXC
; ++i) {

992 
	`LogDebug
("Rdg ctifi: " << 
i
);

993 
su
 = 
	`svc_ifi_w_om_memy
(

994 
v
,

995 (cڡ *)

[
i
].
	`c_r
(),

996 

[
i
].
	`size
(),

997 
CERTSVC_FORM_DER_BASE64
,

998 &
ifi
[
i
]);

999 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Erroreading certificate");

1002 
	`svc_l_che_funis
(

1003 
v
,

1004 
memyCacheWre
,

1005 
memyCacheRd
,

1006 
memyCacheFe
);

1008 
MemyCache
 
mche
;

1010 
i
=0; i<
MAXC
; ++i) {

1011 
	`LogDebug
("Check " << 
i
 << " certificate.");

1012 
su
 = 
	`svc_l_check
(
ifi
[
i
], ctifi, 
MAXC
, 0, &
us
, &
mche
);

1013 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in crl.");

1014 i(
i
<2) {

1015 
	`RUNNER_ASSERT_MSG
(
CERTSVC_CRL_GOOD
 & 
us
, "Check of crl status failed.");

1017 
	`RUNNER_ASSERT_MSG
(
CERTSVC_CRL_NO_SUPPORT
 & 
us
, "Check of crl status failed.");

1019 
	`LogDebug
("Stus: " << 
us
);

1021 
	}
}

1030 
	$RUNNER_TEST
(
14_ifi_vify
)

1032 cڡ 
MAXC
 = 3;

1033 
d
::
rg
 

[
MAXC
];

1034 

[0] =

1055 

[1] =

1075 

[2] =

1095 
CtSvcCtifi
 
ifi
[
MAXC
];

1097 
su
, 
us
;

1099 
i
=0; i<
MAXC
; ++i) {

1100 
	`LogDebug
("Rdg ctifi: " << 
i
);

1101 
su
 = 
	`svc_ifi_w_om_memy
(

1102 
v
,

1103 (cڡ *)

[
i
].
	`c_r
(),

1104 

[
i
].
	`size
(),

1105 
CERTSVC_FORM_DER_BASE64
,

1106 &
ifi
[
i
]);

1107 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Erroreading certificate");

1110 
su
 = 
	`svc_ifi_vify
(
ifi
[0], &ifi[1], 
MAXC
-1, 
NULL
, 0, &
us
);

1111 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1112 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
us
, "Error in certificate verificationrocess.");

1114 
su
 = 
	`svc_ifi_vify
(
ifi
[0], ctifi, 
MAXC
-1, 
NULL
, 0, &
us
);

1115 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1116 
	`RUNNER_ASSERT_MSG
(
CERTSVC_FAIL
 =
us
, "Error in certificate verificationrocess.");

1118 
su
 = 
	`svc_ifi_vify
(
ifi
[0], ctifi, 1, ctifi, 
MAXC
, &
us
);

1119 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1120 
	`RUNNER_ASSERT_MSG
(
CERTSVC_FAIL
 =
us
, "Error in certificate verificationrocess.");

1122 
su
 = 
	`svc_ifi_vify
(
ifi
[0], &ifi[2], 1, ctifi, 
MAXC
, &
us
);

1123 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1124 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
us
, "Error in certificate verificationrocess.");

1128 
su
 = 
	`svc_ifi_vify_wh_ag
(
ifi
[0], ctifi, 
MAXC
, 
NULL
, 0, &
us
);

1129 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1130 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
us
, "Error in certificate verificationrocess.");

1132 
su
 = 
	`svc_ifi_vify_wh_ag
(
ifi
[0], ctifi, 
MAXC
-1, 
NULL
, 0, &
us
);

1133 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1134 
	`RUNNER_ASSERT_MSG
(
CERTSVC_FAIL
 =
us
, "Error in certificate verificationrocess.");

1136 
su
 = 
	`svc_ifi_vify_wh_ag
(
ifi
[0], ctifi, 1, ctifi, 
MAXC
, &
us
);

1137 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1138 
	`RUNNER_ASSERT_MSG
(
CERTSVC_FAIL
 =
us
, "Error in certificate verificationrocess.");

1140 
su
 = 
	`svc_ifi_vify_wh_ag
(
ifi
[0], &ifi[2], 1, ctifi, 
MAXC
, &
us
);

1141 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1142 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
us
, "Error in certificate verificationrocess.");

1143 
	}
}

1151 
	$RUNNER_TEST
(
15_rimives
)

1153 cڡ 
MAXB
 = 1024;

1154 cڡ 
d
::
rg
 

 =

1168 
CtSvcCtifi
 
ifi
;

1170 
su
;

1172 
su
 = 
	`svc_ifi_w_om_memy
(

1173 
v
,

1174 (cڡ *)

.
	`c_r
(),

1175 

.
	`size
(),

1176 
CERTSVC_FORM_DER_BASE64
,

1177 &
ifi
);

1179 
X509
 *
x509
 = 
NULL
;

1180 
su
 = 
	`svc_ifi_dup_x509
(
ifi
, &
x509
);

1182 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certsvc_certificate_dup_x509.");

1183 
	`RUNNER_ASSERT_MSG
(
x509
 !
NULL
, "Error in certsvc_certificate_dup_x509.");

1185 
X509_NAME
 *
me
 = 
	`X509_g_subje_me
(
x509
);

1186 
bufr
[
MAXB
];

1187 
	`X509_NAME_ږe
(
me
, 
bufr
, 
MAXB
);

1188 
d
::
rg
 
exed
 = "/C=US/O=VeriSign, Inc./OU=Class 3 Public Primary Certification Authority";

1190 
	`LogDebug
("NAME: " << 
bufr
);

1192 
	`RUNNER_ASSERT_MSG
(
exed
 =
bufr
, "Content doesot match");

1194 
	`svc_ifi__x509
(
x509
);

1195 
	}
}

1204 
	$RUNNER_TEST
(
16_ifi_vify_wh_ag_lfsign_ro
)

1206 cڡ 
MAXC
 = 2;

1207 
d
::
rg
 

[
MAXC
];

1208 

[0] =

1224 

[1] =

1240 
CtSvcCtifi
 
ifi
[
MAXC
];

1242 
su
, 
us
;

1244 
i
=0; i<
MAXC
; ++i) {

1245 
	`LogDebug
("Rdg ctifi: " << 
i
);

1246 
su
 = 
	`svc_ifi_w_om_memy
(

1247 
v
,

1248 (cڡ *)

[
i
].
	`c_r
(),

1249 

[
i
].
	`size
(),

1250 
CERTSVC_FORM_DER_BASE64
,

1251 &
ifi
[
i
]);

1252 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Erroreading certificate");

1255 
su
 = 
	`svc_ifi_vify
(
ifi
[0], ctifi, 
MAXC
, 
NULL
, 0, &
us
);

1256 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1257 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
us
, "Error in certificate verificationrocess.");

1259 
su
 = 
	`svc_ifi_vify_wh_ag
(
ifi
[0], ctifi, 
MAXC
, 
NULL
, 0, &
us
);

1260 
	`RUNNER_ASSERT_MSG
(
CERTSVC_SUCCESS
 =
su
, "Error in certificate verification function.");

1261 
	`RUNNER_ASSERT_MSG
(
CERTSVC_FAIL
 =
us
, "Error in certificate verificationrocess.");

1262 
	}
}

	@tests/capi/test_suite_02.cpp

16 
	~<rg
>

18 
	~<ݒs/x509.h
>

20 
	~<d//_ru.h
>

21 
	~<d/log/log.h
>

22 
	~<memy
>

24 
	~<i_s.h
>

26 
	~<-rvi.h
>

28 
	$RUNNER_TEST_GROUP_INIT
(
DEPRECATED_API
)

30 
d
::
	tunique_r
<
	tCERT_CONTEXT
, 
	td
::
	tfuni
<(CERT_CONTEXT*)>> 
	tScedCtCtx
;

38 
	$RUNNER_TEST
(
dd_i_01_m_posive
)

40 
ScedCtCtx
 
	`x
(
	`_svc__cڋxt_
(), 
_svc__cڋxt_f
);

41 
	`RUNNER_ASSERT
(
CERT_SVC_ERR_NO_ERROR
 ==

42 
	`_svc_ld_fe_to_cڋxt
(
x
.
	`g
(), "/usr/share/cert-svc/cert-type/cert0.pem"));

43 
	}
}

51 
	$RUNNER_TEST
(
dd_i_02_d_posive
)

53 
ScedCtCtx
 
	`x
(
	`_svc__cڋxt_
(), 
_svc__cڋxt_f
);

54 
	`RUNNER_ASSERT
(
CERT_SVC_ERR_NO_ERROR
 ==

55 
	`_svc_ld_fe_to_cڋxt
(
x
.
	`g
(), "/usr/share/cert-svc/cert-type/cert1.der"));

56 
	}
}

64 
	$RUNNER_TEST
(
dd_i_03_m_give
)

66 
ScedCtCtx
 
	`x
(
	`_svc__cڋxt_
(), 
_svc__cڋxt_f
);

67 
	`RUNNER_ASSERT
(
CERT_SVC_ERR_NO_ERROR
 !=

68 
	`_svc_ld_fe_to_cڋxt
(
x
.
	`g
(), "/usr/share/cert-svc/cert-type/cert2fake.pem"));

69 
	}
}

77 
	$RUNNER_TEST
(
dd_i_03_d_give
)

79 
ScedCtCtx
 
	`x
(
	`_svc__cڋxt_
(), 
_svc__cڋxt_f
);

80 
	`RUNNER_ASSERT
(
CERT_SVC_ERR_NO_ERROR
 !=

81 
	`_svc_ld_fe_to_cڋxt
(
x
.
	`g
(), "/usr/share/cert-svc/cert-type/cert3fake.der"));

82 
	}
}

	@tests/cert-svc/delete_test.c

1 
	~<dio.h
>

2 
	~<unid.h
>

4 
	~"-rvi.h
"

6 
	#RELATIVE_PATH
 "./da/Bro.d"

	)

7 
	#ABSOLUTE_PATH
 "./data/Broot.der"

8 

	)

9 
	$t_1_sucss
()

11 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

14 
t
 = 
	`_svc_de_ifi_om_e
("Broot.der", "code-signing_java_operator");

15 if(
t
 =
CERT_SVC_ERR_NO_ERROR
) {

16 if((
	`acss
("/u/she/-svc/s/code-signg/java/ݔ/Bro.d", 
F_OK
)) != 0)

23 
	}
}

25 
	$t_2_sucss
()

27 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

30 
t
 = 
	`_svc_de_ifi_om_e
("Bro.d", 
NULL
);

31 if(
t
 =
CERT_SVC_ERR_NO_ERROR
) {

32 if((
	`acss
("/u/she/-svc/s/s/Bro.d", 
F_OK
)) != 0)

39 
	}
}

41 
	$t_3_
()

43 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

46 
t
 = 
	`_svc_de_ifi_om_e
(
NULL
, "code-signing_java_operator");

47 if(
t
 =
CERT_SVC_ERR_INVALID_PARAMETER
)

51 
	}
}

53 
	$t_4_
()

55 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

58 
t
 = 
	`_svc_de_ifi_om_e
("Broot.der", "code-signing_debian");

59 if(
t
 =
CERT_SVC_ERR_FILE_IO
)

63 
	}
}

65 
	$ma
()

67 
t
 = -1;

70 
	`_svc_add_ifi_to_e
(
RELATIVE_PATH
, "code-signing_java_operator");

71 
	`_svc_add_ifi_to_e
(
RELATIVE_PATH
, 
NULL
);

74 
t
 = 
	`t_1_sucss
();

75 if(
t
 == 0)

76 
	`rtf
(
dout
, "** Successo deleteest 1 -estpath: code-signing **\n");

78 
	`rtf
(
dout
, "** Failo deleteest1 **\n");

81 
t
 = 
	`t_2_sucss
();

82 if(
t
 == 0)

83 
	`rtf
(
dout
, "** Successo deleteest 2 -estpath: ssl **\n");

85 
	`rtf
(
dout
, "** Failo deleteest2 **\n");

88 
t
 = 
	`t_3_
();

89 if(
t
 == 0)

90 
	`rtf
(
dout
, "** Successo deleteest 3 -o filename **\n");

92 
	`rtf
(
dout
, "** Failo deleteest3 **\n");

95 
t
 = 
	`t_4_
();

96 if(
t
 == 0)

97 
	`rtf
(
dout
, "** Successo deleteest 4 - invalid dirath **\n");

99 
	`rtf
(
dout
, "** Failo deleteest4 **\n");

102 
	}
}

	@tests/cert-svc/extract_test.c

1 
	~<dio.h
>

2 
	~<rg.h
>

3 
	~<dlib.h
>

5 
	~"-rvi.h
"

7 
	#DER_CERT
 "./da/Bro.m"

	)

8 
	#PEM_CERT
 "./da/Bro.d"

	)

9 
	#PFX_CERT
 "./da/pfx/mp/rv.pfx"

	)

10 
	#INVALID_CERT
 "./da/vidCt.d"

	)

12 
	$t_1_sucss
()

14 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

15 
CERT_CONTEXT
* 
x
 = 
NULL
;

18 
x
 = 
	`_svc__cڋxt_
();

21 if((
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
DER_CERT
)!
CERT_SVC_ERR_NO_ERROR
)

22 
r
;

25 if((
t
 = 
	`_svc_exa_ifi_da
(
x
)!
CERT_SVC_ERR_NO_ERROR
)

26 
r
;

28 
r
:

30 
	`_svc__cڋxt_f
(
x
);

31  
t
;

32 
	}
}

34 
	$t_2_sucss
()

36 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

37 
CERT_CONTEXT
* 
x
 = 
NULL
;

40 
x
 = 
	`_svc__cڋxt_
();

43 if((
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
PEM_CERT
)!
CERT_SVC_ERR_NO_ERROR
)

44 
r
;

47 if((
t
 = 
	`_svc_exa_ifi_da
(
x
)!
CERT_SVC_ERR_NO_ERROR
)

48 
r
;

50 
r
:

52 
	`_svc__cڋxt_f
(
x
);

53  
t
;

54 
	}
}

56 
	$t_3_sucss
()

58 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

59 
CERT_CONTEXT
* 
x
 = 
NULL
;

60 * 
ikey
 = 
NULL
;

61 * 
ss
 = "test\0";

64 
x
 = 
	`_svc__cڋxt_
();

67 if((
t
 = 
	`_svc_ld_PFX_fe_to_cڋxt
(
x
, &
ikey
, 
PFX_CERT
, 
ss
)!
CERT_SVC_ERR_NO_ERROR
)

68 
r
;

69 
	`tf
(" ******rikey: [%s]\n", 
ikey
);

72 if((
t
 = 
	`_svc_exa_ifi_da
(
x
)!
CERT_SVC_ERR_NO_ERROR
)

73 
r
;

75 
r
:

77 
	`_svc__cڋxt_f
(
x
);

78 if(
ikey
 !
NULL
)

79 
	`
(
ikey
);

80  
t
;

81 
	}
}

83 
	$t_4_
()

85 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

86 
CERT_CONTEXT
* 
x
 = 
NULL
;

89 
x
 = 
	`_svc__cڋxt_
();

92 if((
t
 = 
	`_svc_exa_ifi_da
(
x
)!
CERT_SVC_ERR_INVALID_PARAMETER
)

93 
r
;

94 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

96 
r
:

98 
	`_svc__cڋxt_f
(
x
);

99  
t
;

100 
	}
}

102 
	$t_5_
()

104 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

105 
CERT_CONTEXT
* 
x
 = 
NULL
;

108 
x
 = 
	`_svc__cڋxt_
();

111 if((
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
INVALID_CERT
)!
CERT_SVC_ERR_NO_ERROR
)

112 
r
;

115 if((
t
 = 
	`_svc_exa_ifi_da
(
x
)!
CERT_SVC_ERR_INVALID_CERTIFICATE
)

116 
r
;

117 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

119 
r
:

121 
	`_svc__cڋxt_f
(
x
);

122  
t
;

123 
	}
}

125 
	$ma
(
gc
, * 
gv
[])

127 
t
 = -1;

130 
	`_svc_add_ifi_to_e
(
DER_CERT
, 
NULL
);

131 
	`_svc_add_ifi_to_e
(
PEM_CERT
, 
NULL
);

132 
	`_svc_add_ifi_to_e
(
PFX_CERT
, 
NULL
);

135 
t
 = 
	`t_1_sucss
();

136 if(
t
 == 0)

137 
	`rtf
(
dout
, "** Successoxtract certificate: DERype **\n");

139 
	`rtf
(
dout
, "** Failoxtract certificate: DERype **\n");

142 
t
 = 
	`t_2_sucss
();

143 if(
t
 == 0)

144 
	`rtf
(
dout
, "** Successoxtract certificate: PEMype **\n");

146 
	`rtf
(
dout
, "** Failoxtract certificate: PEMype **\n");

149 
t
 = 
	`t_3_sucss
();

150 if(
t
 == 0)

151 
	`rtf
(
dout
, "** Successoxtract certificate: PFXype **\n");

153 
	`rtf
(
dout
, "** Failoxtract certificate: PFXype **\n");

156 
t
 = 
	`t_4_
();

157 if(
t
 == 0)

158 
	`rtf
(
dout
, "** Successoxtract certificate:o certificate **\n");

160 
	`rtf
(
dout
, "** Failoxtract certificate:o certificate **\n");

163 
t
 = 
	`t_5_
();

164 if(
t
 == 0)

165 
	`rtf
(
dout
, "** Successoxtract certificate: invalid certificate **\n");

167 
	`rtf
(
dout
, "** Failoxtract certificate: invalid certificate **\n");

170 
	`_svc_de_ifi_om_e
("Bro.m", 
NULL
);

171 
	`_svc_de_ifi_om_e
("Bro.d", 
NULL
);

172 
	`_svc_de_ifi_om_e
("rv.pfx", 
NULL
);

175 
	}
}

	@tests/cert-svc/extract_test_pfx.c

1 
	~<dio.h
>

2 
	~<rg.h
>

3 
	~<dlib.h
>

5 
	~"-rvi.h
"

7 
	$ma
(
gc
, * 
gv
[])

9 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

10 
CERT_CONTEXT
* 
x
 = 
NULL
;

11 
_svc__dest
* 
Desc
 = 
NULL
;

12 
i
 = 0, 
keyL
 = 0;

13 
extNum
 = 0, 
j
 = 0;

16 
x
 = 
	`_svc__cڋxt_
();

18 if((
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
gv
[1])!
CERT_SVC_ERR_NO_ERROR
) {

19 
	`tf
("fe: [%s]\n", 
gv
[1]);

20 
	`tf
("*** Fald fe,: [%d]\n", 
t
);

27 if((
t
 = 
	`_svc_exa_ifi_da
(
x
)!
CERT_SVC_ERR_NO_ERROR
)

28 
	`tf
("*** Faexa ctifi,: [%d]\n", 
t
);

32 
Desc
 = 
x
->certDesc;

34 
	`tf
("ty: [%s]\n", 
Desc
->
ty
);

35 
	`tf
("vsi: [%d]\n", 
Desc
->
fo
.
vsi
);

36 
	`tf
("rnumb: [%d]\n", 
Desc
->
fo
.
rlNumb
);

37 
	`tf
("sigtulgܙhm: [%s]\n", 
Desc
->
fo
.
sigAlgo
);

38 
	`tf
("issu: [%s]\n", 
Desc
->
fo
.
issuS
);

39 
	`tf
(" couryame: [%s]\n", 
Desc
->
fo
.
issu
.
couryName
);

40 
	`tf
(" s oovame: [%s]\n", 
Desc
->
fo
.
issu
.
eOrProvName
);

41 
	`tf
("olyame: [%s]\n", 
Desc
->
fo
.
issu
.
lolyName
);

42 
	`tf
(" orgiziڂame: [%s]\n", 
Desc
->
fo
.
issu
.
giziName
);

43 
	`tf
(" orgizi uname: [%s]\n", 
Desc
->
fo
.
issu
.
giziUnName
);

44 
	`tf
(" commڂame: [%s]\n", 
Desc
->
fo
.
issu
.
commName
);

45 
	`tf
("maddss: [%s]\n", 
Desc
->
fo
.
issu
.
emaAddss
);

46 
	`tf
("validity:\n");

47 
	`tf
(" befe: [%d].[%d].[%d]/[%d]:[%d]:[%d]\n", 
Desc
->
fo
.
vidPiod
.
fYr
,

48 
Desc
->
fo
.
vidPiod
.
fMth
,

49 
Desc
->
fo
.
vidPiod
.
fDay
,

50 
Desc
->
fo
.
vidPiod
.
fHour
,

51 
Desc
->
fo
.
vidPiod
.
fMu
,

52 
Desc
->
fo
.
vidPiod
.
fSecd
);

53 
	`tf
("ه: [%d].[%d].[%d]/[%d]:[%d]:[%d]\n", 
Desc
->
fo
.
vidPiod
.
cdYr
,

54 
Desc
->
fo
.
vidPiod
.
cdMth
,

55 
Desc
->
fo
.
vidPiod
.
cdDay
,

56 
Desc
->
fo
.
vidPiod
.
cdHour
,

57 
Desc
->
fo
.
vidPiod
.
cdMu
,

58 
Desc
->
fo
.
vidPiod
.
cdSecd
);

59 
	`tf
("subje: [%s]\n", 
Desc
->
fo
.
subjeS
);

60 
	`tf
(" couryame: [%s]\n", 
Desc
->
fo
.
subje
.
couryName
);

61 
	`tf
(" s oovame: [%s]\n", 
Desc
->
fo
.
subje
.
eOrProvName
);

62 
	`tf
("olyame: [%s]\n", 
Desc
->
fo
.
subje
.
lolyName
);

63 
	`tf
(" orgiziڂame: [%s]\n", 
Desc
->
fo
.
subje
.
giziName
);

64 
	`tf
(" orgizi uname: [%s]\n", 
Desc
->
fo
.
subje
.
giziUnName
);

65 
	`tf
(" commڂame: [%s]\n", 
Desc
->
fo
.
subje
.
commName
);

66 
	`tf
("maddss: [%s]\n", 
Desc
->
fo
.
subje
.
emaAddss
);

107 if((
t
 = 
	`_svc__cڋxt_f
(
x
)!
CERT_SVC_ERR_NO_ERROR
)

108 
	`tf
("*** Fafizcڋxt,: [%d]\n", 
t
);

110  
t
;

111 
	}
}

	@tests/cert-svc/mem_test.c

1 
	~<dio.h
>

2 
	~<dlib.h
>

3 
	~<rg.h
>

5 
	~"-rvi.h
"

7 
	#CERT_FILE
 "./da/Bro.m"

	)

8 
	#PFX_FILE
 "./da/pfx/pfx.pfx"

	)

10 
	$ma
()

12 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

13 
CERT_CONTEXT
* 
x
 = 
NULL
;

14 * 
ikey
 = 
NULL
;

15 * 
s
 = 
NULL
;

18 
x
 = 
	`_svc__cڋxt_
();

22 
t
 = 
	`_svc_ld_PFX_fe_to_cڋxt
(
x
, &
ikey
, 
PFX_FILE
, 
s
);

23 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

24 
	`tf
("\n!!!! FILE LOAD ERROR !!!!\n");

32 if(
ikey
 !
NULL
)

33 
	`
(
ikey
);

34 
t
 = 
	`_svc__cڋxt_f
(
x
);

35 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

36 
	`tf
("\n!!!! CONTEXT FINAL ERROR !!!!\n");

39 
	}
}

	@tests/cert-svc/search_test.c

1 
	~<dio.h
>

2 
	~<rg.h
>

3 
	~<dlib.h
>

5 
	~"-rvi.h
"

7 
	$ma
(
gc
, * 
gv
[])

9 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

10 
ch_fld
 
dNo
 = 
ISSUER_EMAILADDRESS
;

11 * 
dDa
 = "EmailR";

12 
_svc_fame_li
* 
t
 = 
NULL
;

13 
CERT_CONTEXT
* 
x
 = 
NULL
;

15 
x
 = 
	`_svc__cڋxt_
();

17 
t
 = 
	`_svc_ch_ifi
(
x
, 
dNo
, 
dDa
);

18 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

19 
	`tf
("[ERROR]܂o: [%d]\n", 
t
);

20 
r
;

23 
t
 = 
x
->
feNames
;

24 if(
t
 =
NULL
) {

25 
	`tf
("Cannot findny certificate.\n");

26 
r
;

30 
	`tf
("fame: [%s]\n", 
t
->
fame
);

31 if(
t
->
xt
 =
NULL
)

33 
t
 = s->
xt
;

37 
r
:

38 
	`_svc__cڋxt_f
(
x
);

40 
	}
}

	@tests/cert-svc/store_test.c

1 
	~<dio.h
>

2 
	~<unid.h
>

4 
	~"-rvi.h
"

6 
	#RELATIVE_PATH
 "./da/Bro.d"

	)

7 
	#ABSOLUTE_PATH
 "./da/Bro.d"

	)

9 
	$t_1_sucss
()

11 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

14 
t
 = 
	`_svc_add_ifi_to_e
(
RELATIVE_PATH
, "code-signing_java_thirdparty");

15 if(
t
 =
CERT_SVC_ERR_NO_ERROR
) {

16 if((
	`acss
("/u/she/-svc/s/code-signg/java/thdy/Bro.d", 
F_OK
)) != 0)

25 
	}
}

27 
	$t_2_sucss
()

29 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

32 
t
 = 
	`_svc_add_ifi_to_e
(
RELATIVE_PATH
, 
NULL
);

33 if(
t
 =
CERT_SVC_ERR_NO_ERROR
) {

34 if((
	`acss
("/u/she/-svc/s/s/Bro.d", 
F_OK
)) != 0)

41 
	}
}

43 
	$t_3_
()

45 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

48 
t
 = 
	`_svc_add_ifi_to_e
(
NULL
, "code-signing_wac");

49 if(
t
 =
CERT_SVC_ERR_INVALID_PARAMETER
)

53 
	}
}

55 
	$t_4_
()

57 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

60 
t
 = 
	`_svc_add_ifi_to_e
(
RELATIVE_PATH
, "code-signing_debian");

61 if(
t
 =
CERT_SVC_ERR_FILE_IO
)

65 
	}
}

67 
	$fize_
()

70 if((
	`uƚk
("/usr/share/cert-svc/certs/code-signing/java/thirdparty/Broot.der")) != 0)

72 if((
	`uƚk
("/usr/share/cert-svc/certs/ssl/Broot.der")) != 0)

76 
	}
}

78 
	$ma
()

80 
t
 = -1;

83 
t
 = 
	`t_1_sucss
();

84 if(
t
 == 0)

85 
	`rtf
(
dout
, "** Successo storeest 1 -estpath: code_signing **\n");

87 
	`rtf
(
dout
, "** Failo storeest 1 **\n");

90 
t
 = 
	`t_2_sucss
();

91 if(
t
 == 0)

92 
	`rtf
(
dout
, "** Successo storeest 2 -estpath: ssl **\n");

94 
	`rtf
(
dout
, "** Failo storeest 2 **\n");

97 
t
 = 
	`t_3_
();

98 if(
t
 == 0)

99 
	`rtf
(
dout
, "** Successo storeest 3 -o filename **\n");

101 
	`rtf
(
dout
, "** Failo storeest 3 **\n");

104 
t
 = 
	`t_4_
();

105 if(
t
 == 0)

106 
	`rtf
(
dout
, "** Successo storeest 4 - invalid dirath **\n");

108 
	`rtf
(
dout
, "** Failo storeest 4 **\n");

111 
t
 = 
	`fize_
();

112 if(
t
 == 0)

113 
	`rtf
(
dout
, "** Finalize storeest **\n");

115 
	`rtf
(
dout
, "** Fafizܐ,: [%d] **\n", 
t
);

118 
	}
}

	@tests/cert-svc/test_caflag.c

22 
	~<_sue.h
>

23 
	~<dio.h
>

24 
	~<rg.h
>

25 
	~<dlib.h
>

26 
	~<-rvi.h
>

27 
	~<-rvi-ut.h
>

29 
	#CERT_FILE_ROOT_CA
 "/u/she/-svc/s/ig_c/da/ag/ro_.d"

	)

30 
	#CERT_FILE_SECOND_CA
 "/u/she/-svc/s/ig_c/da/ag/cd_.d"

	)

31 
	#CERT_FILE_SIGNER_AIA
 "/u/she/-svc/s/ig_c/da/ag/a_sigr.d"

	)

32 
	#CERT_FILE_SIGNER_REVOKED
 "/u/she/-svc/s/ig_c/da/ag/v_sigr.d"

	)

33 
	#CERT_FILE_SIGNER_NOAIA
 "/u/she/-svc/s/ig_c/da/ag/nߟ_sigr.d"

	)

34 
	#CERT_FILE_ROOT_CA_V1
 "/u/she/-svc/s/ig_c/da/ag/ro__v1.d"

	)

35 
	#CERT_FILE_SIGNER_V1
 "/u/she/-svc/s/ig_c/da/ag/v1_sigr.d"

	)

38 
	$_vify_ifi_succ_ag_
() {

39 
vidy
;

40 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

41 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

44 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_SIGNER_AIA
);

45 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

46 
	`tf
("......_svc_ld_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

47 
r
;

50 
t
 = 
	`_svc_push_fe_to_cڋxt
(
x
, 
CERT_FILE_SECOND_CA
);

51 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

52 
	`tf
("......_svc_push_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

53 
r
;

56 
t
 = 
	`_svc_vify_ifi
(
x
, &
vidy
);

57 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

58 
	`tf
("......_svc_vify_ifi.=%d\n", 
t
); 
	`fush
(
dr
);

59 
r
;

62 if(
vidy
 != 1) {

63 
	`tf
("......_svc_vify_ifi. vidy=%d\n", 
vidy
); 
	`fush
(
dr
);

64 
t
 = -1;

65 
r
;

68 
r
:

69 
	`_svc__cڋxt_f
(
x
);

70  
t
;

71 
	}
}

73 
	$_vify_ifi_succ_noag_
() {

74 
vidy
;

75 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

76 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

79 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_SIGNER_V1
);

80 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

81 
	`tf
("......_svc_ld_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

82 
r
;

85 
t
 = 
	`_svc_vify_ifi
(
x
, &
vidy
);

86 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

87 
	`tf
("......_svc_vify_ifi.=%d\n", 
t
); 
	`fush
(
dr
);

88 
r
;

91 if(
vidy
 != 1) {

92 
	`tf
("......_svc_vify_ifi. vidy=%d\n", 
vidy
); 
	`fush
(
dr
);

93 
t
 = -1;

94 
r
;

97 
r
:

98 
	`_svc__cڋxt_f
(
x
);

99  
t
;

100 
	}
}

102 
	$_vify_ifi_wh_ag_succ
() {

103 
vidy
;

104 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

105 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

108 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_SIGNER_AIA
);

109 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

110 
	`tf
("......_svc_ld_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

111 
r
;

114 
t
 = 
	`_svc_push_fe_to_cڋxt
(
x
, 
CERT_FILE_SECOND_CA
);

115 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

116 
	`tf
("......_svc_push_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

117 
r
;

120 
t
 = 
	`_svc_vify_ifi_wh_ag
(
x
, &
vidy
);

121 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

122 
	`tf
("......_svc_vify_ifi.=%d\n", 
t
); 
	`fush
(
dr
);

123 
r
;

126 if(
vidy
 != 1) {

127 
	`tf
("......_svc_vify_ifi. vidy=%d\n", 
vidy
); 
	`fush
(
dr
);

128 
t
 = -1;

129 
r
;

132 
r
:

133 
	`_svc__cڋxt_f
(
x
);

134  
t
;

135 
	}
}

138 
	$_vify_ifi_wh_ag_
() {

139 
vidy
;

140 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

141 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

144 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_SIGNER_V1
);

145 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

146 
	`tf
("......_svc_ld_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

147 
r
;

150 
t
 = 
	`_svc_vify_ifi_wh_ag
(
x
, &
vidy
);

151 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

152 
	`tf
("......_svc_vify_ifi.=%d\n", 
t
); 
	`fush
(
dr
);

153 
r
;

156 if(
vidy
 == 1) {

157 
	`tf
("......_svc_vify_ifi. vidy=%d\n", 
vidy
); 
	`fush
(
dr
);

158 
t
 = -1;

159 
r
;

162 
r
:

163 
	`_svc__cڋxt_f
(
x
);

164  
t
;

165 
	}
}

168 
	$_ag
(){

169 
t
;

170 
	`tf
("\n[test_caflag started]\n");

172 
	`tf
("\n--est_verify_certificate_succ_caflag_cert start\n");

173 
t
 = 
	`_vify_ifi_succ_ag_
();

174 
	`tf
("----esult : ");

175 if(
t
 == 0) {

176 
	`tf
("success\n");

178 
	`tf
("fail\n");

181 
	`tf
("\n--est_verify_certificate_succ_nocaflag_cert start\n");

182 
t
 = 
	`_vify_ifi_succ_noag_
();

183 
	`tf
("----esult : ");

184 if(
t
 == 0) {

185 
	`tf
("success\n");

187 
	`tf
("fail\n");

190 
	`tf
("\n--est_verify_certificate_with_caflag_succ start\n");

191 
t
 = 
	`_vify_ifi_wh_ag_succ
();

192 
	`tf
("----esult : ");

193 if(
t
 == 0) {

194 
	`tf
("success\n");

196 
	`tf
("fail\n");

199 
	`tf
("\n--est_verify_certificate_with_caflag_fail start\n");

200 
t
 = 
	`_vify_ifi_wh_ag_
();

201 
	`tf
("----esult : ");

202 if(
t
 == 0) {

203 
	`tf
("success\n");

205 
	`tf
("fail\n");

208  
t
;

209 
	}
}

	@tests/cert-svc/test_ocsp.c

20 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


21 
	~<-rvi.h
>

22 
	~<ݒs/bio.h
>

23 
	~<ݒs/r.h
>

24 
	~<-rvi-ut.h
>

25 
	~<dio.h
>

26 
	~<rg.h
>

27 
	~<dlib.h
>

30 
	#CERT_FILE_ROOT_CA
 "/u/she/-svc/s/ig_c/da/oc/ro_.d"

	)

31 
	#CERT_FILE_SECOND_CA
 "/u/she/-svc/s/ig_c/da/oc/cd_.d"

	)

32 
	#CERT_FILE_SIGNER_AIA
 "/u/she/-svc/s/ig_c/da/oc/a_sigr.d"

	)

33 
	#CERT_FILE_SIGNER_REVOKED
 "/u/she/-svc/s/ig_c/da/oc/v_sigr.d"

	)

34 
	#CERT_FILE_SIGNER_NOAIA
 "/u/she/-svc/s/ig_c/da/oc/nߟ_sigr.d"

	)

36 
	#CERT_FILE_NO_ROOT_CERT
 "/u/she/-svc/s/ig_c/da/oc/no_.m"

	)

38 
	#CERT_FILE_REAL_LEVEL1_CERT
 "/u/she/-svc/s/ig_c/da/oc/oc_v1.t"

	)

39 
	#CERT_FILE_REAL_LEVEL2_CA
 "/u/she/-svc/s/ig_c/da/oc/oc_v2.t"

	)

40 
	#CERT_FILE_REAL_ROOT_CA
 "/u/she/-svc/s/ig_c/da/oc/oc_ro.t"

	)

48 
	$oc_sucss_wh_a
() {

49 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

50 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

53 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_SIGNER_AIA
);

54 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

55 
	`tf
("......_svc_push_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

56 
r
;

60 
t
 = 
	`_svc_check_oc_us
(
x
, 
NULL
);

61 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

62 
	`tf
("......_svc_check_oc_us.=%d\n", 
t
); 
	`fush
(
dr
);

63 
r
;

66 
r
:

67 
	`_svc__cڋxt_f
(
x
);

68  
t
;

69 
	}
}

78 
	$oc_sucss_wh_no_a
()

80 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

81 *
uri
 = "http://127.0.0.1:8888";

82 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

85 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_SIGNER_NOAIA
);

86 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

87 
	`tf
("......_svc_push_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

88 
r
;

92 
t
 = 
	`_svc_check_oc_us
(
x
, 
uri
);

93 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

94 
	`tf
("......_svc_check_oc_us.=%d\n", 
t
); 
	`fush
(
dr
);

95 
r
;

98 
r
:

99 
	`_svc__cڋxt_f
(
x
);

100  
t
;

101 
	}
}

109 
	$oc__voki
()

111 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

112 *
uri
 = "http://127.0.0.1:8888";

113 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

116 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_SIGNER_REVOKED
);

117 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

118 
	`tf
("......_svc_push_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

119 
r
;

123 
t
 = 
	`_svc_check_oc_us
(
x
, 
uri
);

124 if(
t
 !
CERT_SVC_ERR_OCSP_REVOKED
) {

125 
	`tf
("......CERT_SVC_ERR_OCSP_REVOKED E܃xed.=%d\n", 
t
); 
	`fush
(
dr
);

126 
r
;

129 
t
 = 0;

130 
r
:

131 
	`_svc__cڋxt_f
(
x
);

132  
t
;

133 
	}
}

142 
	$oc__no_uri
()

144 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

145 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

148 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_SIGNER_NOAIA
);

149 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

150 
	`tf
("......_svc_push_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

151 
r
;

155 
t
 = 
	`_svc_check_oc_us
(
x
, 
NULL
);

156 if(
t
 !
CERT_SVC_ERR_OCSP_NO_SUPPORT
) {

157 
	`tf
("......CERT_SVC_ERR_OCSP_NO_SUPPORT E܃xed.=%d\n", 
t
); 
	`fush
(
dr
);

158 
r
;

160 
t
 = 0;

161 
r
:

162 
	`_svc__cڋxt_f
(
x
);

163  
t
;

164 
	}
}

172 
	$oc__no_twk
()

174 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

175 *
uri
 = "http://127.0.0.1:7171";

176 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

179 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_SIGNER_NOAIA
);

180 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

181 
	`tf
("......_svc_push_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

182 
r
;

186 
t
 = 
	`_svc_check_oc_us
(
x
, 
uri
);

187 if(
t
 !
CERT_SVC_ERR_OCSP_NETWORK_FAILED
) {

188 
	`tf
("......CERT_SVC_ERR_OCSP_NETWORK_FAILED E܃xed.=%d\n", 
t
); 
	`fush
(
dr
);

189 
r
;

191 
t
 = 0;

192 
r
:

193 
	`_svc__cڋxt_f
(
x
);

194  
t
;

195 
	}
}

203 
	$oc__vid__cha
()

205 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

206 *
u
 = 
NULL
;

207 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

210 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_NO_ROOT_CERT
);

211 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

212 
	`tf
("......_svc_push_fe_to_cڋxt.=%d\n", 
t
); 
	`fush
(
dr
);

213 
r
;

217 
t
 = 
	`_svc_check_oc_us
(
x
, 
NULL
);

218 if(
t
 !
CERT_SVC_ERR_NO_ROOT_CERT
) {

219 
	`tf
("......CERT_SVC_ERR_NO_ROOT_CERT E܃xed.=%d\n", 
t
); 
	`fush
(
dr
);

220 
r
;

222 
t
 = 0;

223 
r
:

224 
	`_svc__cڋxt_f
(
x
);

225  
t
;

226 
	}
}

234 
	$oc__nu_
()

236 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

237 *
uri
 = "http://127.0.0.1:8888";

238 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

243 
t
 = 
	`_svc_check_oc_us
(
x
, 
uri
);

244 if(
t
 !
CERT_SVC_ERR_INVALID_PARAMETER
) {

245 
	`tf
("......CERT_SVC_ERR_INVALID_PARAMETER E܃xed.=%d\n", 
t
); 
	`fush
(
dr
);

246 
r
;

248 
t
 = 0;

249 
r
:

250 
	`_svc__cڋxt_f
(
x
);

251  
t
;

252 
	}
}

260 
	$oc_sucss__
()

263 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

264 *
u
 = 
NULL
;

265 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

268 
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_FILE_REAL_LEVEL1_CERT
);

269 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

270 
	`tf
("......_svc_push_fe_to_cڋxt. fe=%s,=%d\n", 
CERT_FILE_REAL_LEVEL1_CERT
, 
t
); 
	`fush
(
dr
);

271 
r
;

274 
t
 = 
	`_svc_push_fe_to_cڋxt
(
x
, 
CERT_FILE_REAL_LEVEL2_CA
);

275 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

276 
	`tf
("......_svc_push_fe_to_cڋxt. fe=%s,=%d\n", 
CERT_FILE_REAL_LEVEL2_CA
, 
t
); 
	`fush
(
dr
);

277 
r
;

287 
t
 = 
	`_svc_check_oc_us
(
x
, 
NULL
);

288 if(
t
 !
CERT_SVC_ERR_NO_ERROR
) {

289 
	`tf
("......_svc_check_oc_us.=%d\n", 
t
); 
	`fush
(
dr
);

290 
r
;

293 
r
:

294 
	`_svc__cڋxt_f
(
x
);

295  
t
;

296 
	}
}

300 
	msize
,
	msidt
,
	mshe
,
	mxt
,
	mlib
,
	mda
,
	mdt
;

301 } 
	tm_t
;

303 
	$ad_off_memy_us
(
m_t
 *
su
)

305 
dummy
;

306 cڡ * 
m_th
 = "/proc/self/statm";

320 
FILE
 *
f
 = 
	`fݒ
(
m_th
,"r");

321 if(!
f
){

322 
	`
(
m_th
);

323 
	`abt
();

325 if(7 !
	`fsnf
(
f
,"%ld %ld %ld %ld %ld %ld %ld",

326 &
su
->
size
,&su->
sidt
,&su->
she
,&su->
xt
,&su->
lib
,&su->
da
,&su->
dt
))

328 
	`
(
m_th
);

329 
	`abt
();

331 
	`fo
(
f
);

332 
	}
}

340 
	$oc_sucss_memy_ak
()

342 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

343 
m_t
 
memStus
;

344 
_svc_lked_li
* 
s܋d
 = 
NULL
;

345 
i
;

347 
i
=0; i<100; i++ ){

348 
	`oc_sucss_wh_a
();

349 
	`oc_sucss_wh_no_a
();

350 
	`oc__voki
();

351 
	`oc__no_uri
();

352 
	`oc__no_twk
();

353 
	`oc__vid__cha
();

354 
	`oc__nu_
();

355 
	`ad_off_memy_us
(&
memStus
);

356 
	`tf
("lo %dh : size=%d,esidt=%d, she=%d,ext=%d,ib=%d, da=%d, dt=%d\n", 
i
,

357 
memStus
.
size
, memStus.
sidt
, memStus.
she
, memStus.
xt
,

358 
memStus
.
lib
, memStus.
da
, memStus.
dt
);

360 
	}
}

362 
run_
((*
funi
)(), cڡ *
funi_me
) {

363 
	gt
 = 0;

365 
tf
("\n-- %t\n", 
funi_me
);

366 
	gt
 = (*
funi
)();

367 
tf
("----esult : ");

368 if(
	gt
 == 0) {

369 
tf
("success\n");

371 
tf
("fail\n");

375 
	$_oc
(){

376 
t
;

377 
	`tf
("\n[test_ocsp started]\n");

379 
	`syem
("cert-svc-tests-start-ocsp-server.sh");

380 
	`p
(1);

382 
	`run_
(&
oc_sucss_wh_a
, "ocsp_success_with_aia");

383 
	`run_
(&
oc_sucss_wh_no_a
, "ocsp_success_with_no_aia");

384 
	`run_
(&
oc__voki
, "ocsp_fail_revokation");

385 
	`run_
(&
oc__no_uri
, "ocsp_fail_no_uri");

386 
	`run_
(&
oc__no_twk
, "ocsp_fail_no_network");

387 
	`run_
(&
oc__vid__cha
, "ocsp_fail_invalid_cert_chain");

388 
	`run_
(&
oc__nu_
, "ocsp_fail_null_cert");

389 
	`run_
(&
oc_sucss__
, "ocsp_success_real_cert");

392 
	`tf
("\n");

393 
	`syem
("cert-svc-tests-kill-ocsp-server.sh");

395 
	`tf
("\n[test_ocsp finished]\n");

396  
t
;

397 
	}
}

	@tests/cert-svc/test_suite.h

22 #ide
TEST_SUITE_H_


23 
	#TEST_SUITE_H_


	)

25 
_ag
();

27 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


28 
_oc
();

	@tests/cert-svc/test_suite_main.c

22 
	~<_sue.h
>

23 
	~<dio.h
>

24 
	~<rg.h
>

25 
	~<dlib.h
>

27 
	$ma
() {

28 
t
;

29 
t
 = 
	`_ag
();

30 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


31 
t
 = 
	`_oc
();

33  
t
;

34 
	}
}

	@tests/cert-svc/verify_sig.c

1 
	~<dio.h
>

2 
	~<dlib.h
>

3 
	~<rg.h
>

5 
	~"-rvi.h
"

7 
	#CERT_PATH
 "./da/signg/cha1.t"

	)

8 
	#MSG_PATH
 "./da/signg/msg"

	)

10 
	#SIG_PATH
 "./da/signg/msg.sig.c"

	)

12 
	$ma
(
gc
, * 
gv
[])

14 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

15 
vidy
 = 0;

16 
CERT_CONTEXT
* 
x
 = 
NULL
;

17 * 
msg
 = 
NULL
;

18 
msgL
 = 0;

19 * 
sig
 = 
NULL
;

20 * 
tmpSig
 = 
NULL
;

21 
sigL
 = 0;

22 
FILE
* 
_msg
 = 
NULL
;

23 
FILE
* 
_sig
 = 
NULL
;

24 
i
 = 0, 
j
 = 0;

26 
x
 = 
	`_svc__cڋxt_
();

29 if((
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CERT_PATH
)!
CERT_SVC_ERR_NO_ERROR
) {

30 
	`tf
("Fald ftbufr, [%s]\n", 
CERT_PATH
);

31 
r
;

35 if(!(
_msg
 = 
	`fݒ
(
MSG_PATH
, "rb"))) {

36 
	`tf
("Faݒ fe, [%s]\n", 
MSG_PATH
);

37 
r
;

39 
	`fek
(
_msg
, 0L, 
SEEK_END
);

40 
msgL
 = 
	`l
(
_msg
);

41 
	`fek
(
_msg
, 0L, 
SEEK_SET
);

43 
msg
 = (*)
	`mloc
((* (
msgL
 + 1));

44 
	`memt
(
msg
, 0x00, (
msgL
 + 1));

45 
	`d
(
msg
, (), 
msgL
, 
_msg
);

48 if(!(
_sig
 = 
	`fݒ
(
SIG_PATH
, "rb"))) {

49 
	`tf
("Faݒ fe, [%s]\n", 
SIG_PATH
);

50 
r
;

52 
	`fek
(
_sig
, 0L, 
SEEK_END
);

53 
sigL
 = 
	`l
(
_sig
);

54 
	`fek
(
_sig
, 0L, 
SEEK_SET
);

56 
sig
 = (*)
	`mloc
((* (
sigL
 + 1));

57 
tmpSig
 = (*)
	`mloc
((* (
sigL
 + 1));

58 
	`memt
(
sig
, 0x00, (
sigL
 + 1));

59 
	`memt
(
tmpSig
, 0x00, (
sigL
 + 1));

61 
	`d
(
sig
, (), 
sigL
, 
_sig
);

62 
i
 = 0; i < 
sigL
; i++) {

63 if(
sig
[
i
] != '\n') {

64 
tmpSig
[
j
] = 
sig
[
i
];

65 
j
++;

71 if((
t
 = 
	`_svc_vify_sigtu
(
x
, 
msg
, 
msgL
, 
tmpSig
, 
NULL
, &
vidy
)!
CERT_SVC_ERR_NO_ERROR
) {

72 
	`tf
("Failo verify signature.\n");

73 
r
;

75 
	`tf
("[RESULT]: [%d]\n", 
vidy
);

77 
r
:

78 if(
_msg
 !
NULL

	`fo
(fp_msg);

79 if(
_sig
 !
NULL

	`fo
(fp_sig);

80 if(
msg
 !
NULL

	`
(msg);

81 if(
sig
 !
NULL

	`
(sig);

82 if(
tmpSig
 !
NULL

	`
(tmpSig);

83 
	`_svc__cڋxt_f
(
x
);

86 
	}
}

	@tests/cert-svc/verify_test.c

1 
	~<dio.h
>

2 
	~<rg.h
>

3 
	~<dlib.h
>

5 
	~"-rvi.h
"

7 
	#TARGET_CERT
 "./da/_cha/rv.t"

	)

8 
	#CHAIN1_CERT
 "./da/_cha/cha1.t"

	)

9 
	#CHAIN2_CERT
 "./da/_cha/cha2.t"

	)

10 
	#CHAIN3_CERT
 "./da/_cha/cha3.t"

	)

11 
	#CHAIN4_CERT
 "./da/_cha/cha4.t"

	)

12 
	#CHAIN5_CERT
 "./da/_cha/cha5.t"

	)

14 
	$ma
()

16 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

17 
vidy
 = 0;

18 
CERT_CONTEXT
* 
x
 = 
	`_svc__cڋxt_
();

22 if((
t
 = 
	`_svc_ld_fe_to_cڋxt
(
x
, 
CHAIN1_CERT
)!
CERT_SVC_ERR_NO_ERROR
) {

23 
	`tf
("ERR!!: [%d]\n", 
t
);

24 
r
;

56 
t
 = 
	`_svc_vify_ifi
(
x
, &
vidy
);

57 if(
t
 !
CERT_SVC_ERR_NO_ERROR
)

58 
	`tf
("t: [%d]\n", 
t
);

60 
	`tf
("[RESULT] vidy: [%d]\n", 
vidy
);

61 
	`tf
("[RESULT]o CAh: [%s]\n", 
x
->
feNames
->
fame
);

63 
r
:

64 
	`_svc__cڋxt_f
(
x
);

66 
	}
}

	@tests/pkcs12/new_test_cases.cpp

23 
	~<rg.h
>

24 
	~<unid.h
>

25 
	~<dlib.h
>

26 
	~<sys/tys.h
>

27 
	~<sys/wa.h
>

28 
	~<d//_ru.h
>

29 
	~<-svc/c.h
>

30 
	~<-svc/c.h
>

31 
	~<glib.h
>

32 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


33 
	~<-svc/cl.h
>

34 
	~<-svc/coc.h
>

36 
	~<-svc/kcs12.h
>

37 
	~<-svc/.h
>

38 
	~<-svc/rimives.h
>

39 
	~<-rvi.h
>

40 
	~<-rvi-debug.h
>

41 
	~<ݒs/r.h
>

42 
	~<ݒs/pkcs12.h
>

43 
	~<ݒs/sha.h
>

44 
	~<ݒs/x509.h
>

45 
	~<ݒs/m.h
>

46 
	~<time.h
>

48 
CtSvcIn
 
	g
;

50 
	#CREATE_INSTANCE
 \

51 
	`svc__w
(&

);

	)

52 
	#FREE_INSTANCE
 \

53 
	`svc__
(

);

	)

56 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1001_svc_g_ro__li
) {

58 
CtSteTy
 
eTy
 = 
SYSTEM_STORE
;

59 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

60 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

61 
ngth
 = 0;

62 
su
;

63 
cou
 = 0;

64 
CREATE_INSTANCE


67 
ock_t
 
tic
 = 
	`ock
();

68 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

69 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

70 
ock_t
 
toc
 = 
	`ock
();

72 if(
su
 =
CERTSVC_SUCCESS
)

74 
tmpNode
 = 
Li
;

75 
tmpNode
 !
NULL
)

77 
cou
++;

78 
tmpNode
 =mpNode->
xt
;

81 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

82 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

85 
FREE_INSTANCE


86 
	}
}

89 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1002_svc_t__to_dibd_d_g_us_f_syem_e
) {

91 *
gme
 = "Certum_Root_CA.pem";

92 
CtSteTy
 
eTy
 = 
SYSTEM_STORE
;

93 
CtStus
 
Stus
;

94 
us
 = -1;

95 
su
;

96 
CtSvcSg
 
Als
;

98 
CREATE_INSTANCE


100 
Als
.
iveHdr
 = 
gme
;

101 
Als
.
iveLgth
 = 
	`
((cڡ *)
gme
);

103 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, 
eTy
, 
Als
, &
us
);

104 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

107 i(
us
 =
DISABLED
) {

108 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, 
eTy
, 
DISABLED
, 
Als
, 
ENABLED
);

109 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Roll back certificate statuso system store failed.");

112 
Stus
=
DISABLED
;

113 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, 
eTy
, 
DISABLED
, 
Als
, 
Stus
);

114 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

116 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, 
eTy
, 
Als
, &
us
);

117 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

119 
Stus
=
ENABLED
;

120 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, 
eTy
, 
DISABLED
, 
Als
, 
Stus
);

121 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

123 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, 
eTy
, 
Als
, &
us
);

124 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

126 
FREE_INSTANCE


127 
	}
}

130 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1003_add_m_fe__dividu_e
) {

132 
th
[] = "/usr/share/cert-svc/tests/wifi-server.pem";

133 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

134 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

135 
CtSvcSteCtLi
* 
tmp
 = 
NULL
;

136 * 
ss
 = 
NULL
;

137 
CtSteTy
 
ty
;

138 
su
;

139 
ngth
 = 0;

140 
cou
 = 0;

142 
CtSvcSteCtLi
* 
Li1
 = 
NULL
;

143 
CtSvcSg
 
bufr1
, 
gme
;

144 
CtSvcSg
 
bufr2
;

145 cڡ *
mp
 = 
NULL
;

146 
CtSvcCtifi
 
ifi
;

148 
CREATE_INSTANCE


149 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

151 
Pass
.
iveHdr
 = 
ss
;

152 
Ph
.
iveHdr
 = 
th
;

153 
Ph
.
iveLgth
 = 
	`
(
th
);

155 
ty
 = 
WIFI_STORE
;

156 
Als
.
iveHdr
 = "PEM-wifi-server-1";

157 
Als
.
iveLgth
 = 
	`
(Als.
iveHdr
);

158 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

159 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PEM fileo WIFI store failed.");

161 
ty
 = 
VPN_STORE
;

162 
Als
.
iveHdr
 = "PEM-wifi-server-2";

163 
Als
.
iveLgth
 = 
	`
(Als.
iveHdr
);

164 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

165 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PEM fileo VPN store failed.");

167 
ty
 = 
EMAIL_STORE
;

168 
Als
.
iveHdr
 = "PEM-wifi-server-3";

169 
Als
.
iveLgth
 = 
	`
(Als.
iveHdr
);

170 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

171 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PEM fileo EMAIL store failed.");

173 
ty
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

174 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
ty
, 
DISABLED
, &
Li
, &
ngth
);

175 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

177 if(
su
 =
CERTSVC_SUCCESS
)

180 
tmpNode
 = 
Li
;

181 
tmpNode
 !
NULL
)

183 
cou
++;

184 
tmp
 = 
tmpNode
;

185 
tmpNode
 =mpNode->
xt
;

187 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

188 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

192 
Li
 = 
NULL
;

193 
ty
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

194 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
ty
, 
DISABLED
, &
Li
, &
ngth
);

195 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

196 
Li1
=
Li
;

197 
cou
 = 0;

198 
Li
!=
NULL
)

200 
gme
.
iveHdr
 = (*)
Li
->gname;

201 
gme
.
iveLgth
 = 
	`
(
Li
->gname);

202 
su
 = 
	`svc_pkcs12_g_ifi_om_e
(

, 
Li
->
eTy
, ctLi->
gme
, &
ifi
);

203 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get certificate from store.");

205 
su
 = 
	`svc_ifi_g_rg_fld
(
ifi
, 
CERTSVC_SUBJECT
, &
bufr1
);

206 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

208 
su
 = 
	`svc_ifi_g_rg_fld
(
ifi
, 
CERTSVC_ISSUER_COMMON_NAME
, &
bufr2
);

209 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

211 
	`svc_rg_to_crg
(
bufr1
, &
mp
, &
ngth
);

212 
	`svc_rg_to_crg
(
bufr2
, &
mp
, &
ngth
);

214 
	`svc_rg_
(
bufr1
);

215 
	`svc_rg_
(
bufr2
);

216 
	`svc_ifi_
(
ifi
);

217 
Li
 = ctLi->
xt
;

218 
cou
++;

220 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li1
);

221 i(
Li1
 !
NULL
)

223 
Li
=
NULL
;

224 
Li1
=
NULL
;

226 
FREE_INSTANCE


227 
	}
}

230 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1004_add_m_fe__l_e
) {

232 cڡ 
th
[] = "/usr/share/cert-svc/tests/wifi-server.pem";

233 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

234 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

235 
CtSvcSteCtLi
* 
tmp
 = 
NULL
;

236 * 
ss
 = 
NULL
;

237 *
s
 = "PEM-wifi-server-all-store";

238 
CtSteTy
 
ty
;

239 
su
;

240 
cou
 = 0;

241 
ngth
 = 0;

243 
CREATE_INSTANCE


244 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

246 
Als
.
iveHdr
 = 
s
;

247 
Als
.
iveLgth
 = 
	`
(
s
);

248 
Pass
.
iveHdr
 = 
ss
;

249 
Ph
.
iveHdr
 = (*)
th
;

250 
Ph
.
iveLgth
 = 
	`
(
th
);

252 
ty
 = (
CtSteTy
(
VPN_STORE
 | 
EMAIL_STORE
 | 
WIFI_STORE
);

253 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

254 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PEM fileoll store failed.");

256 
ty
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

257 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
ty
, 
DISABLED
, &
Li
, &
ngth
);

258 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

260 if(
su
 =
CERTSVC_SUCCESS
)

262 
tmpNode
 = 
Li
;

263 
tmpNode
 !
NULL
)

265 
cou
++;

266 
tmp
 = 
tmpNode
;

267 
tmpNode
 =mpNode->
xt
;

269 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

270 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

273 
FREE_INSTANCE


274 
	}
}

277 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1005_add_t_fe__dividu_e
) {

279 cڡ 
th
[] = "/usr/share/cert-svc/tests/Testing.crt";

280 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

281 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

282 
CtSvcSteCtLi
* 
tmp
 = 
NULL
;

283 * 
ss
 = 
NULL
;

284 *
s
 = "CRT-TestingCRT1";

285 
CtSteTy
 
ty
;

286 
su
;

287 
ngth
 = 0;

288 
cou
 = 0;

290 
CtSvcSteCtLi
* 
Li1
 = 
NULL
;

291 
CtSvcSg
 
bufr1
, 
gme
;

292 
CtSvcSg
 
bufr2
;

293 cڡ *
mp
 = 
NULL
;

294 
CtSvcCtifi
 
ifi
;

296 
CREATE_INSTANCE


297 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

299 
Als
.
iveHdr
 = 
s
;

300 
Als
.
iveLgth
 = 
	`
(
s
);

301 
Pass
.
iveHdr
 = 
ss
;

302 
Ph
.
iveHdr
 = (*)
th
;

303 
Ph
.
iveLgth
 = 
	`
(
th
);

305 
ty
 = 
WIFI_STORE
;

306 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

307 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing CRT fileo WIFI store failed.");

309 
ty
 = 
VPN_STORE
;

310 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

311 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing CRT fileo VPN store failed.");

313 
ty
 = 
EMAIL_STORE
;

314 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

315 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing CRT fileo EMAIL store failed.");

317 
ty
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

318 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
ty
, 
DISABLED
, &
Li
, &
ngth
);

319 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

321 if(
su
 =
CERTSVC_SUCCESS
)

323 
tmpNode
 = 
Li
;

324 
tmpNode
 !
NULL
)

326 
cou
++;

327 
tmp
 = 
tmpNode
;

328 
tmpNode
 =mpNode->
xt
;

330 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

331 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

334 
Li
 = 
NULL
;

335 
ty
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

336 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
ty
, 
DISABLED
, &
Li
, &
ngth
);

337 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

338 
Li1
=
Li
;

339 
cou
 = 0;

340 
Li
!=
NULL
)

342 
gme
.
iveHdr
 = (*)
Li
->gname;

343 
gme
.
iveLgth
 = 
	`
(
Li
->gname);

344 
su
 = 
	`svc_pkcs12_g_ifi_om_e
(

, 
Li
->
eTy
, ctLi->
gme
, &
ifi
);

345 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get certificate from store.");

347 
su
 = 
	`svc_ifi_g_rg_fld
(
ifi
, 
CERTSVC_SUBJECT
, &
bufr1
);

348 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

350 
su
 = 
	`svc_ifi_g_rg_fld
(
ifi
, 
CERTSVC_ISSUER_COMMON_NAME
, &
bufr2
);

351 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

353 
	`svc_rg_to_crg
(
bufr1
, &
mp
, &
ngth
);

354 
	`svc_rg_to_crg
(
bufr2
, &
mp
, &
ngth
);

356 
	`svc_rg_
(
bufr1
);

357 
	`svc_rg_
(
bufr2
);

358 
	`svc_ifi_
(
ifi
);

359 
Li
 = ctLi->
xt
;

360 
cou
++;

362 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li1
);

363 
Li
=
NULL
;

364 
Li1
=
NULL
;

366 
FREE_INSTANCE


367 
	}
}

370 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1006_add_t_fe__l_e
) {

372 cڡ 
th
[] = "/usr/share/cert-svc/tests/Testing.crt";

373 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

374 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

375 
CtSvcSteCtLi
* 
tmp
 = 
NULL
;

376 * 
ss
 = 
NULL
;

377 *
s
 = "CRT-TestingCRT1-all-store";

378 
CtSteTy
 
ty
;

379 
su
;

380 
cou
 = 0;

381 
ngth
 = 0;

383 
CREATE_INSTANCE


384 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

386 
Als
.
iveHdr
 = 
s
;

387 
Als
.
iveLgth
 = 
	`
(
s
);

388 
Pass
.
iveHdr
 = 
ss
;

389 
Ph
.
iveHdr
 = (*)
th
;

390 
Ph
.
iveLgth
 = 
	`
(
th
);

392 
ty
 = (
CtSteTy
 )(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

393 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

394 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing CRT fileoll store failed.");

396 
ty
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

397 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
ty
, 
DISABLED
, &
Li
, &
ngth
);

398 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

400 if(
su
 =
CERTSVC_SUCCESS
)

402 
tmpNode
 = 
Li
;

403 
tmpNode
 !
NULL
)

405 
cou
++;

406 
tmp
 = 
tmpNode
;

407 
tmpNode
 =mpNode->
xt
;

409 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

410 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

414 
FREE_INSTANCE


415 
	}
}

418 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1007_l_p12_fe_to_dividu_e
) {

420 cڡ 
th
[] = "/usr/share/cert-svc/tests/wifiuser.p12";

421 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

422 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

423 
CtSvcSteCtLi
* 
tmp
 = 
NULL
;

424 cڡ 
ss
[] = "wifi";

425 *
s
 = "P12-WifiUser";

426 
CtSteTy
 
eTy
;

427 
su
;

428 
ngth
 = 0;

429 
cou
 = 0;

431 
CREATE_INSTANCE


432 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

434 
Als
.
iveHdr
 = (*)
s
;

435 
Als
.
iveLgth
 = 
	`
(
s
);

436 
Pass
.
iveHdr
 = (*)
ss
;

437 
Pass
.
iveLgth
 = 
	`
(
ss
);

438 
Ph
.
iveHdr
 = (*)
th
;

439 
Ph
.
iveLgth
 = 
	`
(
th
);

446 
eTy
 = 
WIFI_STORE
;

447 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

448 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing12 fileo WIFI store failed.");

450 
eTy
 = 
VPN_STORE
;

451 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

452 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing12 fileo VPN store failed.");

454 
eTy
 = 
EMAIL_STORE
;

455 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

456 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing12 fileo EMAIL store failed.");

458 
eTy
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

459 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

460 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

462 if(
su
 =
CERTSVC_SUCCESS
)

464 
tmpNode
 = 
Li
;

465 
tmpNode
 !
NULL
)

467 
cou
++;

468 
tmp
 = 
tmpNode
;

469 
tmpNode
 =mpNode->
xt
;

471 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

472 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

475 
FREE_INSTANCE


476 
	}
}

479 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1008_l_p12_fe_to_l_e
) {

481 cڡ 
th
[] = "/usr/share/cert-svc/tests/wifiuser.p12";

482 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

483 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

484 
CtSvcSteCtLi
* 
tmp
 = 
NULL
;

485 cڡ 
ss
[] = "wifi";

486 *
s
 = "P12-WifiUser-all-store";

487 
CtSteTy
 
eTy
;

488 
su
;

489 
ngth
 = 0;

490 
cou
 =0;

492 
CREATE_INSTANCE


493 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

495 
Als
.
iveHdr
 = (*)
s
;

496 
Als
.
iveLgth
 = 
	`
(
s
);

497 
Pass
.
iveHdr
 = (*)
ss
;

498 
Pass
.
iveLgth
 = 
	`
(
ss
);

499 
Ph
.
iveHdr
 = (*)
th
;

500 
Ph
.
iveLgth
 = 
	`
(
th
);

502 
eTy
 = (
CtSteTy
 )(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

503 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

504 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing12 fileo WIFI store failed.");

506 
eTy
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

507 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

508 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

510 if(
su
 =
CERTSVC_SUCCESS
)

512 
tmpNode
 = 
Li
;

513 
tmpNode
 !
NULL
)

515 
cou
++;

516 
tmp
 = 
tmpNode
;

517 
tmpNode
 =mpNode->
xt
;

519 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

520 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

523 
FREE_INSTANCE


524 
	}
}

527 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1009_l_pfx_fe_to_dividu_e
) {

529 cڡ 
th
[] = "/usr/share/cert-svc/tests/wifiserver.pfx";

530 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

531 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

532 
CtSvcSteCtLi
* 
tmp
 = 
NULL
;

533 cڡ 
ss
[] = "wifi";

534 *
s
 = "PFX-WifiServer";

535 
CtSteTy
 
eTy
;

536 
su
;

537 
cou
 = 0;

538 
ngth
 = 0;

540 
CREATE_INSTANCE


541 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

543 
Als
.
iveHdr
 = (*)
s
;

544 
Als
.
iveLgth
 = 
	`
(
s
);

545 
Pass
.
iveHdr
 = (*)
ss
;

546 
Pass
.
iveLgth
 = 
	`
(
ss
);

547 
Ph
.
iveHdr
 = (*)
th
;

548 
Ph
.
iveLgth
 = 
	`
(
th
);

550 
eTy
 = 
WIFI_STORE
;

551 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

552 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PFX fileo WIFI store failed.");

554 
eTy
 = 
VPN_STORE
;

555 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

556 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PFX fileo VPN store failed.");

558 
eTy
 = 
EMAIL_STORE
;

559 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

560 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PFX fileo EMAIL store failed.");

562 
eTy
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

563 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

564 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

566 if(
su
 =
CERTSVC_SUCCESS
)

568 
tmpNode
 = 
Li
;

569 
tmpNode
 !
NULL
)

571 
cou
++;

572 
tmp
 = 
tmpNode
;

573 
tmpNode
 =mpNode->
xt
;

575 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

576 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

579 
FREE_INSTANCE


580 
	}
}

582 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1010_l_pfx_fe_to_l_e
) {

584 cڡ 
th
[] = "/usr/share/cert-svc/tests/wifiserver.pfx";

585 cڡ 
ss
[] = "wifi";

586 *
s
 = "PFX-WifiServer-all-store";

587 
CtSteTy
 
eTy
;

588 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

589 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

590 
CtSvcSteCtLi
* 
tmp
 = 
NULL
;

591 
ngth
 = 0;

592 
cou
 = 0;

593 
su
;

595 
CREATE_INSTANCE


596 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

598 
Als
.
iveHdr
 = (*)
s
;

599 
Als
.
iveLgth
 = 
	`
(
s
);

600 
Pass
.
iveHdr
 = (*)
ss
;

601 
Pass
.
iveLgth
 = 
	`
(
ss
);

602 
Ph
.
iveHdr
 = (*)
th
;

603 
Ph
.
iveLgth
 = 
	`
(
th
);

605 
eTy
 = (
CtSteTy
(
VPN_STORE
 | 
EMAIL_STORE
 | 
WIFI_STORE
);

606 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

607 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PFX fileo WIFI store failed.");

609 
eTy
 = (
CtSteTy
(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

610 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

611 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

613 if(
su
 =
CERTSVC_SUCCESS
)

616 
tmpNode
 = 
Li
;

617 
tmpNode
 !
NULL
)

619 
cou
++;

620 
tmp
 = 
tmpNode
;

621 
tmpNode
 =mpNode->
xt
;

623 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

624 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

627 
FREE_INSTANCE


628 
	}
}

631 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1011_g_l_d_ur_ifi_om_e
) {

633 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

634 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

635 
CtSteTy
 
eTy
 = (CtSteTy(
WIFI_STORE
);

636 
su
;

637 
ngth
;

639 
CREATE_INSTANCE


641 
su
 = 
	`svc_pkcs12_g_d_ur_ifi_li_om_e
(

, 
eTy
, &
Li
, &
ngth
);

642 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Gettingnd user certificateist from store failed.");

643 
tmpNode
=
Li
;

644 
tmpNode
!=
NULL
)

646 
tmpNode
 =mpNode->
xt
;

648 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

649 
Li
 = 
NULL
;

650 
tmpNode
 = 
NULL
;

652 
eTy
 = (
CtSteTy
(
VPN_STORE
);

653 
su
 = 
	`svc_pkcs12_g_d_ur_ifi_li_om_e
(

, 
eTy
, &
Li
, &
ngth
);

654 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Gettingnd user certificateist from store failed.");

655 
tmpNode
=
Li
;

656 
tmpNode
!=
NULL
)

658 
tmpNode
 =mpNode->
xt
;

660 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

661 
Li
 = 
NULL
;

662 
tmpNode
 = 
NULL
;

664 
eTy
 = (
CtSteTy
(
EMAIL_STORE
);

665 
su
 = 
	`svc_pkcs12_g_d_ur_ifi_li_om_e
(

, 
eTy
, &
Li
, &
ngth
);

666 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Gettingnd user certificateist from store failed.");

667 
tmpNode
=
Li
;

668 
tmpNode
!=
NULL
)

670 
tmpNode
 =mpNode->
xt
;

672 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

673 
Li
 = 
NULL
;

674 
tmpNode
 = 
NULL
;

676 
eTy
 = (
CtSteTy
(
WIFI_STORE
);

677 
su
 = 
	`svc_pkcs12_g_ro_ifi_li_om_e
(

, 
eTy
, &
Li
, &
ngth
);

678 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Gettingnd user certificateist from store failed.");

679 
tmpNode
=
Li
;

680 
tmpNode
!=
NULL
)

682 
tmpNode
 =mpNode->
xt
;

684 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

685 
Li
 = 
NULL
;

686 
tmpNode
 = 
NULL
;

688 
eTy
 = (
CtSteTy
(
VPN_STORE
);

689 
su
 = 
	`svc_pkcs12_g_ro_ifi_li_om_e
(

, 
eTy
, &
Li
, &
ngth
);

690 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Gettingnd user certificateist from store failed.");

691 
tmpNode
=
Li
;

692 
tmpNode
!=
NULL
)

694 
tmpNode
 =mpNode->
xt
;

696 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

697 
Li
 = 
NULL
;

698 
tmpNode
 = 
NULL
;

700 
eTy
 = (
CtSteTy
(
EMAIL_STORE
);

701 
su
 = 
	`svc_pkcs12_g_ro_ifi_li_om_e
(

, 
eTy
, &
Li
, &
ngth
);

702 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Gettingnd user certificateist from store failed.");

703 
tmpNode
=
Li
;

704 
tmpNode
!=
NULL
)

706 
tmpNode
 =mpNode->
xt
;

708 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

709 
Li
 = 
NULL
;

710 
tmpNode
 = 
NULL
;

712 
FREE_INSTANCE


713 
	}
}

716 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1012_de_l__om_muɝ_e
) {

718 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

719 
CtSvcSteCtLi
* 
Li1
 = 
NULL
;

720 
CtSteTy
 
eTy
 = (CtSteTy(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

721 
su
;

722 
ngth
;

723 
CtSvcSg
 
gme
;

725 
CREATE_INSTANCE


727 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

728 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

729 
Li1
=
Li
;

730 
Li1
!=
NULL
)

732 
gme
.
iveHdr
 = (*)
Li1
->gname;

733 
gme
.
iveLgth
 = 
	`
(
Li1
->gname);

734 
su
 = 
	`svc_pkcs12_de_ifi_om_e
(

, (
CtSteTy

Li1
->
eTy
, 
gme
);

735 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Deleting certificate from store failed.");

736 
Li1
 = ctLi1->
xt
;

738 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

739 
Li
=
NULL
;

741 
FREE_INSTANCE


742 
	}
}

745 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1013_l_pfx_fe_to_e_e_d_g_li_om_muɝ_e
) {

747 cڡ 
th
[] = "/usr/share/cert-svc/tests/wifiserver.pfx";

748 cڡ 
ss
[] = "wifi";

749 *
s
 = "PFX-WifiServer-one-store";

750 
CtSteTy
 
eTy
;

751 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

752 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

753 
CtSvcSteCtLi
* 
tmp
 = 
NULL
;

754 
ngth
 = 0;

755 
cou
 = 0;

756 
su
 = -1;

757 
gboޗn
 
exis
 = 
FALSE
;

759 
CREATE_INSTANCE


760 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

762 
Als
.
iveHdr
 = (*)
s
;

763 
Als
.
iveLgth
 = 
	`
(
s
);

764 
Pass
.
iveHdr
 = (*)
ss
;

765 
Pass
.
iveLgth
 = 
	`
(
ss
);

766 
Ph
.
iveHdr
 = (*)
th
;

767 
Ph
.
iveLgth
 = 
	`
(
th
);

769 
eTy
 = (
CtSteTy
(
VPN_STORE
 | 
WIFI_STORE
 | 
EMAIL_STORE
);

770 
su
 = 
	`svc_pkcs12_check_s_exis__e
(

, 
eTy
, 
Als
, &
exis
);

771 i(
exis
==
TRUE
) {

773 
eTy
 = (
CtSteTy

EMAIL_STORE
 );

774 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

775 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PFX fileo WIFI store failed.");

777 
eTy
 = (
CtSteTy

VPN_STORE
 | 
WIFI_STORE
 );

778 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

779 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PFX fileo WIFI store failed.");

781 
eTy
 = (
CtSteTy

VPN_STORE
 | 
WIFI_STORE
 | 
EMAIL_STORE
);

782 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

783 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from system store failed");

785 if(
su
 =
CERTSVC_SUCCESS
)

787 
tmpNode
 = 
Li
;

788 
tmpNode
 !
NULL
)

790 
cou
++;

791 
tmp
 = 
tmpNode
;

792 
tmpNode
 =mpNode->
xt
;

794 
su
 = 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li
);

795 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Freeing certificateist from system store failed");

799 
FREE_INSTANCE


800 
	}
}

803 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1014_lg_pfx_whout_sswd_to_dividu_e
) {

805 cڡ 
th
[] = "/usr/share/cert-svc/tests/without_pass.p12";

806 cڡ 
ss
[] = "";

807 *
s
 = "PFX-WifiServer-without-password";

808 
CtSteTy
 
eTy
;

809 
su
;

810 
gboޗn
 
exis
 = 
FALSE
;

812 
CREATE_INSTANCE


813 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

815 
Als
.
iveHdr
 = (*)
s
;

816 
Als
.
iveLgth
 = 
	`
(
s
);

817 
Pass
.
iveHdr
 = (*)
ss
;

818 
Pass
.
iveLgth
 = 
	`
(
ss
);

819 
Ph
.
iveHdr
 = (*)
th
;

820 
Ph
.
iveLgth
 = 
	`
(
th
);

822 
eTy
 = (
CtSteTy
(
VPN_STORE
 | 
WIFI_STORE
 | 
EMAIL_STORE
);

823 
su
 = 
	`svc_pkcs12_check_s_exis__e
(

, 
eTy
, 
Als
, &
exis
);

824 i(
exis
==
TRUE
) {

825 
eTy
 = (
CtSteTy
(
VPN_STORE
 | 
WIFI_STORE
 | 
EMAIL_STORE
);

826 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

827 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Importing PFX fileo WIFI store failed.");

830 
FREE_INSTANCE


831 
	}
}

834 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1015_g_ifi_om_e
) {

836 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

837 
CtSvcSteCtLi
* 
Li1
 = 
NULL
;

838 
CtSteTy
 
eTy
 = (CtSteTy(
WIFI_STORE
 | 
VPN_STORE
 | 
EMAIL_STORE
);

839 
su
;

840 
ngth
;

841 
CtSvcSg
 
bufr1
, 
gme
;

842 
CtSvcSg
 
bufr2
;

843 cڡ *
mp
 = 
NULL
;

844 
CtSvcCtifi
 
ifi
;

846 
CREATE_INSTANCE


848 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

849 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

850 
Li1
=
Li
;

851 
Li
!=
NULL
)

853 
gme
.
iveHdr
 = (*)
Li
->gname;

854 
gme
.
iveLgth
 = 
	`
(
Li
->gname);

855 
su
 = 
	`svc_pkcs12_g_ifi_om_e
(

, 
Li
->
eTy
, ctLi->
gme
, &
ifi
);

856 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get certificate from store.");

858 
su
 = 
	`svc_ifi_g_rg_fld
(
ifi
, 
CERTSVC_SUBJECT
, &
bufr1
);

859 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

861 
	`svc_rg_to_crg
(
bufr1
, &
mp
, &
ngth
);

863 
su
 = 
	`svc_ifi_g_rg_fld
(
ifi
, 
CERTSVC_ISSUER_COMMON_NAME
, &
bufr2
);

864 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

866 
	`svc_rg_to_crg
(
bufr2
, &
mp
, &
ngth
);

868 
	`svc_rg_
(
bufr1
);

869 
	`svc_rg_
(
bufr2
);

870 
	`svc_ifi_
(
ifi
);

871 
Li
 = ctLi->
xt
;

873 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li1
);

874 
Li
=
NULL
;

875 
Li1
=
NULL
;

877 
FREE_INSTANCE


878 
	}
}

881 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1016_g_ifi_om_syem_e
) {

883 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

884 
CtSvcSteCtLi
* 
Li1
 = 
NULL
;

885 
CtSteTy
 
eTy
 = (CtSteTy(
SYSTEM_STORE
);

886 
su
 = 
CERTSVC_SUCCESS
;

887 
ngth
 = 0;

888 
cou
 = 0;

889 
CtSvcSg
 
bufr1
, 
gme
;

890 
CtSvcSg
 
bufr2
;

891 cڡ *
mp
 = 
NULL
;

892 
CtSvcCtifi
 
ifi
;

894 
CREATE_INSTANCE


896 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

897 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

898 
Li1
=
Li
;

899 
Li
!=
NULL
)

901 
gme
.
iveHdr
 = (*)
Li
->gname;

902 
gme
.
iveLgth
 = 
	`
(
Li
->gname);

903 
su
 = 
	`svc_pkcs12_g_ifi_om_e
(

, 
Li
->
eTy
, ctLi->
gme
, &
ifi
);

904 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get certificate from store.");

906 
su
 = 
	`svc_ifi_g_rg_fld
(
ifi
, 
CERTSVC_SUBJECT
, &
bufr1
);

907 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

909 
su
 = 
	`svc_ifi_g_rg_fld
(
ifi
, 
CERTSVC_ISSUER_COMMON_NAME
, &
bufr2
);

910 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

912 
	`svc_rg_to_crg
(
bufr1
, &
mp
, &
ngth
);

913 
	`svc_rg_to_crg
(
bufr2
, &
mp
, &
ngth
);

915 
	`svc_rg_
(
bufr1
);

916 
	`svc_rg_
(
bufr2
);

917 
	`svc_ifi_
(
ifi
);

918 
Li
 = ctLi->
xt
;

919 
cou
++;

921 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
Li1
);

923 
Li
=
NULL
;

924 
Li1
=
NULL
;

926 
FREE_INSTANCE


927 
	}
}

930 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1017_ld__li_om_e
) {

932 
CtSteTy
 
eTy
;

933 
CtSvcCtifiLi
 
Li
;

934 
CtSvcSteCtLi
* 
Li1
 = 
NULL
;

935 
CtSvcCtifi
 

;

936 
su
 = 
CERTSVC_SUCCESS
;

937 
ngth
 = 0;

938 
i
=0;

939 
Lingth
 = 0;

940 cڡ *
mp
 = 
NULL
;

941 
CtSvcSg
 
bufr1
,
bufr2
, 
gme
;

943 
CREATE_INSTANCE


945 
eTy
 = (
CtSteTy
(
VPN_STORE
);

946 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li1
, &
ngth
);

947 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

948 
Li1
!=
NULL
)

950 
gme
.
iveHdr
 = (*)
Li1
->gname;

951 
gme
.
iveLgth
 = 
	`
(
Li1
->gname);

953 
su
 = 
	`svc_pkcs12_ld_ifi_li_om_e
(

, 
eTy
, 
gme
, &
Li
);

954 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Load certificateist form store failed.");

956 
su
 = 
	`svc_ifi_li_g_ngth
(
Li
, &
Lingth
);

957 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificateist getength failed.");

959 
i
=0; i<
Lingth
; i++)

961 
su
 = 
	`svc_ifi_li_g_e
(
Li
, 
i
, &

);

962 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "certsvc_certificate_list_get_oneeturnedot CERTSVC_SUCCESS");

964 
su
 = 
	`svc_ifi_g_rg_fld
(

, 
CERTSVC_SUBJECT
, &
bufr1
);

965 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

967 
	`svc_rg_to_crg
(
bufr1
, &
mp
, &
ngth
);

969 
su
 = 
	`svc_ifi_g_rg_fld
(

, 
CERTSVC_ISSUER_COMMON_NAME
, &
bufr2
);

970 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo get string field.");

972 
	`svc_rg_to_crg
(
bufr2
, &
mp
, &
ngth
);

977 
FREE_INSTANCE


978 
	}
}

981 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1018_g_dui_ive_key
) {

983 
CtSteTy
 
eTy
;

984 
CtSvcSteCtLi
* 
Li1
 = 
NULL
;

985 
FILE
 *

 = 
NULL
;

986 
su
 = 
CERTSVC_SUCCESS
;

987 
ngth
 = 0;

988 
CtSvcSg
 
gme
;

989 
gch
 *
ivekey_th
 = 
NULL
;

990 
EVP_PKEY
 *
ivekey
 = 
NULL
;

992 
CREATE_INSTANCE


994 
eTy
 = (
CtSteTy
(
VPN_STORE
);

995 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li1
, &
ngth
);

996 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

997 
Li1
!=
NULL
)

999 
gme
.
iveHdr
 = (*)
Li1
->gname;

1000 
gme
.
iveLgth
 = 
	`
(
Li1
->gname);

1001 
su
 = 
	`svc_pkcs12_dup_evp_pkey_om_e
(

, 
eTy
, 
gme
, &
ivekey
);

1002 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting duplicaterivate key from store failed.");

1004 
ivekey_th
 = 
	`g_rdup_tf
("%s", "/usr/share/cert-svc/pkcs12/temp.txt");

1005 i((

 = 
	`fݒ
(
ivekey_th
, "w")=
NULL
) {

1006 
su
 = 
CERTSVC_FAIL
;

1007 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo open file for writing.");

1010 
su
 = 
	`PEM_wre_PriveKey
(

, 
ivekey
, 
NULL
, NULL, 0, NULL, NULL);

1011 
	`RUNNER_ASSERT_MSG
(
su
!=0, "Failedo writerivate key onto file.");

1012 
	`fo
(

);

1014 
	`svc_pkcs12__evp_pkey
(
ivekey
);

1019 
FREE_INSTANCE


1020 
	}
}

1023 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1019_check_s_exis
) {

1025 *
s
 = "PFX-WifiServer-without-password";

1026 
CtSteTy
 
eTy
;

1027 
su
 = 
CERTSVC_SUCCESS
;

1028 
gboޗn
 
exis
 = 
FALSE
;

1030 
CREATE_INSTANCE


1031 
CtSvcSg
 
Als
;

1033 
Als
.
iveHdr
 = (*)
s
;

1034 
Als
.
iveLgth
 = 
	`
(
s
);

1035 
eTy
 = (
CtSteTy
(
VPN_STORE
 | 
WIFI_STORE
 | 
EMAIL_STORE
);

1036 
su
 = 
	`svc_pkcs12_check_s_exis__e
(

, 
eTy
, 
Als
, &
exis
);

1037 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

1039 
FREE_INSTANCE


1040 
	}
}

1043 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1020_svc_t__to_dibd_d_g_us_f_dividu_e
) {

1045 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

1046 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

1047 
y
[3]={
VPN_STORE
,
WIFI_STORE
,
EMAIL_STORE
};

1048 
su
 = 
CERTSVC_SUCCESS
;

1049 
CtSvcSg
 
Als
;

1050 
CtStus
 
Stus
;

1051 
us
 = -1;

1052 
ngth
 = 0;

1053 
cou
 = 0;

1054 
i
;

1056 
CREATE_INSTANCE


1058 
j
=0;j<3;j++)

1060 
i
 = 
y
[
j
];

1062 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, (
CtSteTy
)
i
, 
DISABLED
, &
Li
, &
ngth
);

1063 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

1064 
tmpNode
 = 
Li
;

1065 
Li
!=
NULL
)

1067 
cou
++;

1068 
Als
.
iveHdr
 = 
Li
->
gme
;

1069 
Als
.
iveLgth
 = 
	`
((cڡ *)
Li
->
gme
);

1071 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)
i
, 
Als
, &
us
);

1072 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1074 
Stus
=
DISABLED
;

1075 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, (
CtSteTy
)
i
, 
DISABLED
, 
Als
, 
Stus
);

1076 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

1078 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)
i
, 
Als
, &
us
);

1079 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1081 
Stus
=
ENABLED
;

1082 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, (
CtSteTy
)
i
, 
DISABLED
, 
Als
, 
Stus
);

1083 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

1085 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)
i
, 
Als
, &
us
);

1086 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1088 
Li
 = ctLi->
xt
;

1091 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
tmpNode
);

1094 
FREE_INSTANCE


1095 
	}
}

1099 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1021_add_m_fe_to_vid_e
) {

1101 cڡ 
th
[] = "/usr/share/cert-svc/tests/wifi-server.pem";

1102 * 
ss
 = 
NULL
;

1103 *
s
 = "PFX-WifiServer-one-store";

1104 
su
;

1105 
CtSteTy
 
eTy
 = (CertStoreType) (-1);

1106 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

1108 
CREATE_INSTANCE


1110 
Als
.
iveHdr
 = 
s
;

1111 
Als
.
iveLgth
 = 
	`
(
s
);

1112 
Pass
.
iveHdr
 = 
ss
;

1113 
Ph
.
iveHdr
 = (*)
th
;

1114 
Ph
.
iveLgth
 = 
	`
(
th
);

1116 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

1117 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_INVALID_STORE_TYPE
, "Importing certifcate withxistingliaso WIFI store failed.");

1119 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

1120 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_INVALID_STORE_TYPE
, "Importing certifcate withxistingliaso VPN store failed.");

1122 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

1123 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_INVALID_STORE_TYPE
, "Importing certifcate withxistingliaso EMAIL store failed.");

1126 
eTy
 = 
SYSTEM_STORE
;

1127 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

1128 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing PEM fileo EMAIL store failed.");

1131 
su
 = 
	`svc_pkcs12_de_ifi_om_e
(

, 
eTy
, 
Als
);

1132 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Deleting certificate from store failed.");

1135 
FREE_INSTANCE


1136 
	}
}

1139 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1022_svc_t__to_dibd_d_g_us_f_vid_e
) {

1141 * 
gme
 = "eb375c3e.0";

1142 
CtSteTy
 
eTy
 = (CtSteTy(
DISABLED
);

1143 
CtStus
 
Stus
;

1144 
us
 = -1;

1145 
su
;

1146 
CtSvcSg
 
Als
;

1148 
CREATE_INSTANCE


1150 
Als
.
iveHdr
 = 
gme
;

1151 
Als
.
iveLgth
 = 
	`
((cڡ *)
gme
);

1154 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, 
eTy
, 
Als
, &
us
);

1155 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1158 
Stus
=
DISABLED
;

1159 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, 
eTy
, 
DISABLED
, 
Als
, 
Stus
);

1160 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

1163 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, 
eTy
, 
Als
, &
us
);

1164 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1167 
Stus
=
ENABLED
;

1168 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, 
eTy
, 
DISABLED
, 
Als
, 
Stus
);

1169 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

1172 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, 
eTy
, 
Als
, &
us
);

1173 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1176 
FREE_INSTANCE


1177 
	}
}

1180 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1023_svc_t__to_dibd_d_g_us_f_vid_e
) {

1182 
CtSteTy
 
eTy
 = (CertStoreType) (0);

1183 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

1184 
CtStus
 
Stus
;

1185 
us
 = -1;

1186 
ngth
;

1187 
su
;

1188 
CtSvcSg
 
Als
;

1190 
CREATE_INSTANCE


1193 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

1194 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

1195 
Li
!=
NULL
)

1197 
Als
.
iveHdr
 = 
Li
->
gme
;

1198 
Als
.
iveLgth
 = 
	`
((cڡ *)
Li
->
gme
);

1200 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, 
eTy
, 
Als
, &
us
);

1201 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1203 
Stus
=
DISABLED
;

1204 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, 
eTy
, 
DISABLED
, 
Als
, 
Stus
);

1205 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

1207 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, 
eTy
, 
Als
, &
us
);

1208 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1210 
Stus
=
ENABLED
;

1211 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, 
eTy
, 
DISABLED
, 
Als
, 
Stus
);

1212 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

1214 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, 
eTy
, 
Als
, &
us
);

1215 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1217 
Li
 = ctLi->
xt
;

1220 
FREE_INSTANCE


1221 
	}
}

1224 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1024_svc_t_d_g_f_vid_e
) {

1226 cڡ 
th
[] = "/usr/share/cert-svc/tests/Invalidcrt.crt";

1227 * 
ss
 = 
NULL
;

1228 *
s
 = "TestingCRT1";

1229 
CtSteTy
 
ty
;

1230 
su
;

1232 
CREATE_INSTANCE


1233 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

1235 
Als
.
iveHdr
 = 
s
;

1236 
Als
.
iveLgth
 = 
	`
(
s
);

1237 
Pass
.
iveHdr
 = 
ss
;

1238 
Ph
.
iveHdr
 = (*)
th
;

1239 
Ph
.
iveLgth
 = 
	`
(
th
);

1242 
ty
 = 
WIFI_STORE
;

1243 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

1244 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing CRT fileo WIFI store failed.");

1247 
ty
 = 
VPN_STORE
;

1248 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

1249 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing CRT fileo VPN store failed.");

1252 
ty
 = 
EMAIL_STORE
;

1253 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

1254 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing CRT fileo EMAIL store failed.");

1257 
ty
 = (
CtSteTy
) 0;

1258 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
ty
, 
Ph
, 
Pass
, 
Als
);

1259 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing CRT fileo EMAIL store failed.");

1261 
FREE_INSTANCE


1262 
	}
}

1265 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1025_l_vid_pfx_fe_to_dividu_d_l_e
) {

1267 cڡ 
th
[] = "/usr/share/cert-svc/tests/test.pfx";

1268 cڡ 
ss
[] = "wifi";

1269 *
s
 = "WifiServer-123";

1270 
CtSteTy
 
eTy
;

1271 
su
;

1273 
CREATE_INSTANCE


1274 
CtSvcSg
 
Als
, 
Ph
, 
Pass
;

1276 
Als
.
iveHdr
 = (*)
s
;

1277 
Als
.
iveLgth
 = 
	`
(
s
);

1278 
Pass
.
iveHdr
 = (*)
ss
;

1279 
Pass
.
iveLgth
 = 
	`
(
ss
);

1280 
Ph
.
iveHdr
 = (*)
th
;

1281 
Ph
.
iveLgth
 = 
	`
(
th
);

1284 
eTy
 = 
SYSTEM_STORE
;

1285 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

1286 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing PFX fileo WIFI store failed.");

1289 
eTy
 = 
WIFI_STORE
;

1290 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

1291 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing PFX fileo WIFI store failed.");

1294 
eTy
 = 
VPN_STORE
;

1295 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

1296 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing PFX fileo VPN store failed.");

1299 
eTy
 = 
EMAIL_STORE
;

1300 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

1301 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing PFX fileo EMAIL store failed.");

1304 
eTy
 = (
CtSteTy
(
EMAIL_STORE
 | 
VPN_STORE
 | 
WIFI_STORE
);

1305 
su
 = 
	`svc_pkcs12_impt_om_fe_to_e
(

, 
eTy
, 
Ph
, 
Pass
, 
Als
);

1306 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Importing PFX fileo EMAIL store failed.");

1308 
FREE_INSTANCE


1309 
	}
}

1312 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1026_dg_a_ifi_om_vid_e
) {

1314 
CtSteTy
 
eTy
 = (CtSteTy(
WIFI_STORE
);

1315 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

1316 
CtStus
 
Stus
;

1317 
us
 = -1;

1318 
ngth
;

1319 
su
;

1320 
CtSvcSg
 
Als
;

1322 
CREATE_INSTANCE


1325 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

1326 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

1327 
Li
!=
NULL
)

1329 
Als
.
iveHdr
 = 
Li
->
gme
;

1330 
Als
.
iveLgth
 = 
	`
((cڡ *)
Li
->
gme
);

1332 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)-1, 
Als
, &
us
);

1333 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1335 
Stus
=
DISABLED
;

1336 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, (
CtSteTy
)-1, 
DISABLED
, 
Als
, 
Stus
);

1337 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

1339 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)-1, 
Als
, &
us
);

1340 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1342 
Stus
=
ENABLED
;

1343 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, (
CtSteTy
)-1, 
DISABLED
, 
Als
, 
Stus
);

1344 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Set certificate statuso system store failed.");

1346 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)-1, 
Als
, &
us
);

1347 
	`RUNNER_ASSERT_MSG
(
su
!=
CERTSVC_SUCCESS
, "Get certificate status from system store failed.");

1349 
Li
 = ctLi->
xt
;

1352 
FREE_INSTANCE


1353 
	}
}

1355 
	#EAP_TLS_USER_CERT_PATH
 "ur_.m"

	)

1356 
	#EAP_TLS_PATH
 "/tmp/"

	)

1357 
	#EAP_TLS_CA_CERT_PATH
 "_.m"

	)

1358 
	#EAP_TLS_PRIVATEKEY_PATH
 "ivekey.m"

	)

1361 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1027_g_s_me_om_gme_om_e
) {

1363 
CtSteTy
 
eTy
 = (CtSteTy(
WIFI_STORE
);

1364 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

1365 
CtSvcCtifi
 
ur_ifi
;

1366 
CtSvcCtifiLi
 
_li
;

1367 
CtSvcCtifi
 
_ifi
;

1368 
CtSvcCtifi
 *
ed_ifi
 = 
NULL
;

1369 
ngth
;

1370 
su
;

1371 
cou
=1;

1372 
vidy
;

1373 
_cous
 = 0;

1374 
CtSvcSg
 
Als
;

1375 *
s
 = 
NULL
;

1376 
X509
 *
x509
 = 
NULL
;

1377 
FILE
 *

 = 
NULL
;

1378 
EVP_PKEY
 *
ivekey
 = 
NULL
;

1379 
gch
 *
ivekey_th
 = 
NULL
;

1380 
gch
 *
__th
 = 
NULL
;

1381 
gch
 *
ur__th
 = 
NULL
;

1382 
_dex
 = 0;

1384 
CREATE_INSTANCE


1387 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, 
eTy
, 
DISABLED
, &
Li
, &
ngth
);

1388 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

1389 
Li
!=
NULL
) {

1390 
Als
.
iveHdr
 = 
Li
->
gme
;

1391 
Als
.
iveLgth
 = 
	`
((cڡ *)
Li
->
gme
);

1393 
su
 = 
	`svc_pkcs12_g_s_me_f_ifi__e
(

, 
Li
->
eTy
, 
Als
, &
s
);

1394 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Gettingliasame from gname failed.");

1396 
su
 = 
	`svc_pkcs12_ld_ifi_li_om_e
(

, 
Li
->
eTy
, 
Als
, &
_li
);

1397 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "failedo certsvc_pkcs12_load_certificate_list");

1399 
su
 = 
	`svc_ifi_li_g_ngth
(
_li
, &
_cous
);

1400 
	`RUNNER_ASSERT_MSG
(
_cous
 >= 1, "there iso certificates");

1402 
ed_ifi
 = 
	`g_y_w0
(
CtSvcCtifi
, 
_cous
);

1403 
	`RUNNER_ASSERT_MSG
(
ed_ifi
 !
NULL
, "failedollocate memory");

1405 
su
 = 
	`svc_ifi_li_g_e
(
_li
, 0, &
ur_ifi
);

1406 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "failedo certsvc_certificate_list_get_one");

1408 
su
 = 
	`svc_ifi_dup_x509
(
ur_ifi
, &
x509
);

1410 
ur__th
 = 
	`g_rdup_tf
("/u/she/-svc/pkcs12/fe_%d", 
cou
++);

1411 

 = 
	`fݒ
(
ur__th
, "w");

1412 
	`RUNNER_ASSERT_MSG
(

 !
NULL
, "Failedo openhe file for writing");

1414 i(
cou
==5) ;

1416 
su
 = 
	`PEM_wre_X509
(

, 
x509
);

1417 
	`fo
(

);

1418 
	`svc_ifi__x509
(
x509
);

1419 
Li
 = ctLi->
xt
;

1421 
_dex
 = 
_cous
 - 1;

1422 
ed_ifi
[0] = 
ur_ifi
;

1424 
__th
 = 
	`g_rdup_tf
("%s%s_%s", 
EAP_TLS_PATH
, 
Li
->
gme
, 
EAP_TLS_CA_CERT_PATH
);

1425 
_dex
) {

1426 
su
 = 
	`svc_ifi_li_g_e
(
_li
, 
_dex
, &
_ifi
);

1427 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo certsvc_certificate_list_get_one");

1429 
ed_ifi
[
_cous
-
_dex
] = 
_ifi
;

1430 
_dex
--;

1432 
su
 = 
	`svc_ifi_dup_x509
(
_ifi
, &
x509
);

1434 

 = 
	`fݒ
(
__th
, "a");

1435 
	`RUNNER_ASSERT_MSG
(

 !
NULL
, "Failedo openhe file for writing");

1437 
su
 = 
	`PEM_wre_X509
(

, 
x509
);

1438 
	`fo
(

);

1439 
	`svc_ifi__x509
(
x509
);

1441 
su
 = 
	`svc_ifi_vify
(
ed_ifi
[0], seed_ifi, 
_cous
, 
NULL
, 0, &
vidy
);

1442 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo verify ca_certificate");

1443 
	`RUNNER_ASSERT_MSG
(
vidy
 != 0, "Invalid certificate");

1445 
su
 = 
	`svc_pkcs12_dup_evp_pkey_om_e
(

, 
WIFI_STORE
, 
Als
, &
ivekey
);

1446 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Failedo duplicateherivate key for certificate from wifi store");

1448 
ivekey_th
 = 
	`g_rdup_tf
("%s%s_%s", 
EAP_TLS_PATH
, 
Li
->
gme
, 
EAP_TLS_PRIVATEKEY_PATH
);

1450 

 = 
	`fݒ
(
ivekey_th
, "w");

1451 
	`RUNNER_ASSERT_MSG
(

 !
NULL
, "Failedo openhe file for writing");

1453 
su
 = 
	`PEM_wre_PriveKey
(

, 
ivekey
, 
NULL
, NULL, 0, NULL, NULL);

1454 
	`fo
(

);

1455 
	`svc_pkcs12__evp_pkey
(
ivekey
);

1458 
FREE_INSTANCE


1459 
	}
}

1462 
	$RUNNER_TEST
(
CERTSVC_PKCS12_1028_svc_t__to_dibd_d_g_us_f_dividu_e
) {

1464 
CtSvcSteCtLi
* 
Li
 = 
NULL
;

1465 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

1466 
y
[3]={
VPN_STORE
,
WIFI_STORE
,
EMAIL_STORE
};

1467 
su
 = 
CERTSVC_SUCCESS
;

1468 
CtSvcSg
 
Als
;

1469 
CtStus
 
Stus
;

1470 
us
 = -1;

1471 
ngth
 = 0;

1472 
cou
 = 0;

1473 
i
;

1475 
CREATE_INSTANCE


1477 
j
=0;j<3;j++)

1479 
i
 = 
y
[
j
];

1481 
su
 = 
	`svc_pkcs12_g_ifi_li_om_e
(

, (
CtSteTy
)
i
, 
ENABLED
, &
Li
, &
ngth
);

1482 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Getting certificateist from store failed.");

1483 
tmpNode
 = 
Li
;

1484 
Li
!=
NULL
)

1486 
cou
++;

1487 
Als
.
iveHdr
 = 
Li
->
gme
;

1488 
Als
.
iveLgth
 = 
	`
((cڡ *)
Li
->
gme
);

1490 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)
i
, 
Als
, &
us
);

1491 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from store failed.");

1493 
Stus
=
DISABLED
;

1494 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, (
CtSteTy
)
i
, 
ENABLED
, 
Als
, 
Stus
);

1495 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Set certificate statuso store failed.");

1497 
us
 = 
DISABLED
;

1498 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)
i
, 
Als
, &
us
);

1499 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from store failed.");

1501 
Stus
=
ENABLED
;

1502 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, (
CtSteTy
)
i
, 
ENABLED
, 
Als
, 
Stus
);

1503 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Set certificate statuso store failed.");

1505 
us
 = 
DISABLED
;

1506 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)
i
, 
Als
, &
us
);

1507 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from store failed.");

1509 
Stus
=
DISABLED
;

1510 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, (
CtSteTy
)
i
, 
DISABLED
, 
Als
, 
Stus
);

1511 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Set certificate statuso store failed.");

1513 
us
 = 
DISABLED
;

1514 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)
i
, 
Als
, &
us
);

1515 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from store failed.");

1517 
Stus
=
ENABLED
;

1518 
su
 = 
	`svc_pkcs12_t_ifi_us_to_e
(

, (
CtSteTy
)
i
, 
DISABLED
, 
Als
, 
Stus
);

1519 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Set certificate statuso store failed.");

1521 
us
 = 
DISABLED
;

1522 
su
 = 
	`svc_pkcs12_g_ifi_us_om_e
(

, (
CtSteTy
)
i
, 
Als
, &
us
);

1523 
	`RUNNER_ASSERT_MSG
(
su
==
CERTSVC_SUCCESS
, "Get certificate status from store failed.");

1525 
Li
 = ctLi->
xt
;

1528 
	`svc_pkcs12__ifi_li_lded_om_e
(

, &
tmpNode
);

1531 
FREE_INSTANCE


1532 
	}
}

	@tests/pkcs12/pkcs12_test.cpp

22 
	~<d//_ru.h
>

23 
	~<-svc/c.h
>

25 
CtSvcIn
 
	gv
;

27 
	$ma
 (
gc
, *
gv
[]) {

28 
	`svc__w
(&
v
);

29 
us
 = 
DPL
::
Te
::
TeRuSgt
::
	`In
().
	`ExecTeRu
(
gc
, 
gv
);

30 
	`svc__
(
v
);

31  
us
;

32 
	}
}

	@tests/vcore/TestCRL.cpp

16 
	~<gܙhm
>

17 
	~<crg
>

18 
	~<ݒs/x509v3.h
>

19 
	~<fe_put_mpg.h
>

20 
	~<d/log/log.h
>

21 
	~"TeCRL.h
"

23 
usg
 
mea
 
	gVidiCe
;

24 
usg
 
mea
 
	gd
;

27 
	gmea
 {

28 cڡ *
	gCRL_LOOKUP_DIR
 = "/opt/etc/ssl/certs/";

29 cڡ *
	gbegCtifi
 = "-----BEGIN CERTIFICATE-----";

30 cڡ *
	gdCtifi
 = "-----END CERTIFICATE-----";

31 cڡ *
	gbegTruedCtifi
 = "-----BEGIN TRUSTED CERTIFICATE-----";

32 cڡ *
	gdTruedCtifi
 = "-----END TRUSTED CERTIFICATE-----";

35 
bo
 
wheCha
(
a
){

36  
	ga
 == '\n';

41 
	gTeCRL
::
	$TeCRL
()

42 : 
	$CRLIm
 (
w
 
CRLCacheDAO
)

45 
rv
 = 
	`X509_LOOKUP_add_d
(
m_lookup
, 
CRL_LOOKUP_DIR
, 
X509_FILETYPE_PEM
);

46 i(!
rv
) {

47 
	`LogE
("Failedoddookup dir for PEM files.");

48 
	`ThrowMsg
(
CRLExi
::
StageE
,

51 
	`LogInfo
("CRL storage initialization complete.");

52 
	}
}

54 
	gd
::
rg
 
TeCRL
::
	$gFeCڋ
(cڡ 
d
::
rg
 &
fame
)

57 
	`LogInfo
("Rd fe: " << 
fame
);

58 
FeIutMpg
 
	`fe
(
fame
);

59 
rg
 
	`cڋ
(
t_
<cڡ *>(
fe
.
	`GAddss
()),

60 
fe
.
	`GSize
());

62 
size_t
 
posBeg
 = 
cڋ
.
	`fd
(
begCtifi
);

63 
size_t
 
posEnd
 = 
cڋ
.
	`fd
(
dCtifi
);

64 i(
posBeg
 !
rg
::
os
 &&

65 
posEnd
 !
rg
::
os
) {

66 
posBeg
 +
	`
(
begCtifi
);

68 
posBeg
 = 
cڋ
.
	`fd
(
begTruedCtifi
);

69 
posEnd
 = 
cڋ
.
	`fd
(
dTruedCtifi
);

70 i(
posBeg
 !
rg
::
os
 &&

71 
posEnd
 !
rg
::
os
) {

72 
posBeg
 +
	`
(
begTruedCtifi
);

74 
	`LogE
("Failedoarse PEM file");

75  
	`rg
();

79 
rg
 
	`
(
cڋ
, 
posBeg
, 
posEnd
 -osBegin);

80 

.
	`a
(
d
::
	`move_if
(.
	`beg
(), ct.
	`d
(), 
wheCha
),

81 

.
	`d
());

83  

;

84 
	}
}

86 
	gTeCRL
::
	$addCRLToSte
(cڡ 
rg
 &
fame
, cڡ sg &
uri
)

88 
	`LogInfo
("Rd fe: " << 
fame
);

90 
FeIutMpg
 
	`fe
(
fame
);

91 *
bufr
 = 
w
 [
fe
.
	`GSize
()];

92 
	`memy
(
bufr
, 
fe
.
	`GAddss
(), fe.
	`GSize
());

93 
CRLDaP
 
	`l
(
w
 
	`CRLDa
(
bufr
, 
fe
.
	`GSize
(), 
uri
));

94 
	`updeCRL
(
l
);

95 
	}
}

	@tests/vcore/TestCRL.h

16 #ide
_TEST_CRL_H


17 
	#_TEST_CRL_H


	)

19 
	~<rg
>

20 
	~<vce/CRLIm.h
>

21 
	~<vce/CRLCacheDAO.h
>

23 as
	cTeCRL
 : 
public
 
VidiCe
::
CRLIm


25 
public
:

26 
TeCRL
();

28 
addCRLToSte
(cڡ 
d
::
rg
 &
fame
, cڡ std::rg &
uri
);

31 
	md
::
rg
 
gFeCڋ
(cڡ 
d
::rg &
fame
);

	@tests/vcore/TestCases.cpp

17 
	~<rg
>

20 
	~<d//_ru.h
>

21 
	~<vce/CryoHash.h
>

22 
	~<vce/SigtuFd.h
>

23 
	~<vce/SigtuRd.h
>

24 
	~<vce/SigtuVid.h
>

25 
	~<vce/WSigtuVid.h
>

26 
	~"TeEnv.h
"

27 
	~<vce/RevotiCheckBa.h
>

29 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


30 
	~<vce/OCSP.h
>

31 
	~<vce/CachedOCSP.h
>

32 
	~<vce/SSLCڏs.h
>

33 
	~<vce/CRL.h
>

34 
	~<vce/CachedCRL.h
>

35 
	~<vce/CtifiCacheDAO.h
>

38 
	gmea
 {

40 cڡ 
	gd
::
rg
 
widg_th
 =

42 cڡ 
	gd
::
rg
 
widg_give_hash_th
 =

44 cڡ 
	gd
::
rg
 
widg_give_sigtu_th
 =

46 cڡ 
	gd
::
rg
 
widg_give_ifi_th
 =

48 cڡ 
	gd
::
rg
 
widg_r_th
 =

50 cڡ 
	gd
::
rg
 
widg_r_ݔ_th
 =

53 
le
 cڡ * 
GSigtuXmlSchema
()

59 cڡ 
	gd
::
rg
 
keys_th
 = "/usr/apps/widget/tests/vcore_keys/";

60 cڡ 
	gd
::
rg
 
widg_e_th
 = "/usr/apps/widget/tests/vcore_widgets/";

61 cڡ 
	gd
::
rg
 
_e_th
 = "/usr/apps/widget/tests/vcore_certs/";

62 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


63 cڡ 
	gd
::
rg
 
l_URI
 = "http://localhost/my.crl";

66 cڡ 
	gd
::
rg
 
ka_ec_key_ty
 = "urn:oid:1.2.840.10045.3.1.7";

67 cڡ 
	gd
::
rg
 
ka_ec_public_key
 =

71 cڡ 
	gd
::
rg
 
r_modulus
 =

75 cڡ 
	gd
::
rg
 
r_expڒt
 = "AQAB";

77 cڡ 
	gd
::
rg
 
magda_d_p
 =

81 cڡ 
	gd
::
rg
 
magda_d_q
 = "4p4JcDqz+S7CbWyd8txApZw0sik=";

82 cڡ 
	gd
::
rg
 
magda_d_g
 =

87 cڡ 
	gd
::
rg
 
tiz_r
 =

104 cڡ 
	gd
::
rg
 
tiz_r_ݔ
 =

121 cڡ 
	gd
::
rg
 
googCA
 =

135 cڡ 
	gd
::
rg
 
goog2nd
 =

154 cڡ 
	gd
::
rg
 
goog3rd
 =

173 cڡ 
	gd
::
rg
 
Visign
 =

213 cڡ 
	gd
::
rg
 
lExameCtifi
 =

315 
usg
 
mea
 
	gVidiCe
;

328 
	$RUNNER_TEST
(
01_sigtu_fd
)

330 
SigtuFeInfoS
 
sigtuS
;

331 
SigtuFd
 
	`sigtuFd
(
widg_th
);

332 
	`RUNNER_ASSERT_MSG
(

333 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

335 
	`RUNNER_ASSERT_MSG
(
sigtuS
.
	`size
() == 3,

338 
SigtuFeInfo
 
f
 = *(
sigtuS
.
	`beg
());

339 
	`RUNNER_ASSERT_MSG
(

340 
d
::
	`rg
("auth-sigtu.xml"=
f
.
	`gFeName
(),

342 
	`RUNNER_ASSERT_MSG
(-1 =
f
.
	`gFeNumb
(), "Wrong signatureumber.");

343 
f
 = *(
sigtuS
.
	`rbeg
());

344 
	`RUNNER_ASSERT_MSG
(
d
::
	`rg
("sigtu22.xml"=
f
.
	`gFeName
(),

346 
	`RUNNER_ASSERT_MSG
(22 =
f
.
	`gFeNumb
(), "Wrong signatureumber.");

347 
	}
}

356 
	$RUNNER_TEST
(
02_sigtu_ad
)

358 
SigtuFeInfoS
 
sigtuS
;

359 
SigtuFd
 
	`sigtuFd
(
widg_th
);

360 
	`RUNNER_ASSERT_MSG
(

361 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

364 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

366 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

367 
SigtuDa
 
	`da
(
widg_th
 + 

->
	`gFeName
(),

368 

->
	`gFeNumb
());

369 
SigtuRd
 
xml
;

370 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

371 
xml
.
	`ad
(
da
);

373 
	}
}

383 
	$RUNNER_TEST
(
03t01_wsigtu_vid
)

385 
SigtuFeInfoS
 
sigtuS
;

386 
SigtuFd
 
	`sigtuFd
(
widg_th
);

387 
	`RUNNER_ASSERT_MSG
(

388 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

391 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

392 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

393 
SigtuDa
 
	`da
(
widg_th
 + 

->
	`gFeName
(),

394 

->
	`gFeNumb
());

395 
SigtuRd
 
xml
;

396 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

397 
xml
.
	`ad
(
da
);

399 
WSigtuVid
 
	`vid
(

400 
WSigtuVid
::
WAC20
,

401 
l
,

402 
l
,

403 
l
);

405 i(
da
.
	`isAuthSigtu
()) {

406 
	`RUNNER_ASSERT_MSG
(

407 
WSigtuVid
::
SIGNATURE_DISREGARD
 ==

408 
vid
.
	`check
(
da
, 
widg_th
),

411 i(
da
.
	`gSigtuNumb
() == 1)

413 
WSigtuVid
::
Resu
 
mp
 = 
vid
.
	`check
(
da
, 
widg_th
);

415 
	`RUNNER_ASSERT_MSG
(

416 
WSigtuVid
::
SIGNATURE_DISREGARD
 ==

417 
mp
,

423 
WSigtuVid
::
Resu
 
mp
 = 
vid
.
	`check
(
da
, 
widg_th
);

425 
	`RUNNER_ASSERT_MSG
(

426 
WSigtuVid
::
SIGNATURE_VERIFIED
 ==

427 
mp
,

432 
	}
}

434 
	$RUNNER_TEST
(
03t02_wsigtu_vid_give_hash_put
)

436 
SigtuFeInfoS
 
sigtuS
;

437 
SigtuFd
 
	`sigtuFd
(
widg_give_hash_th
);

438 
	`RUNNER_ASSERT_MSG
(

439 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

442 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

443 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

444 
SigtuDa
 
	`da
(
widg_give_hash_th
 + 

->
	`gFeName
(),

445 

->
	`gFeNumb
());

446 
SigtuRd
 
xml
;

447 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

448 
xml
.
	`ad
(
da
);

450 
WSigtuVid
 
	`vid
(

451 
WSigtuVid
::
WAC20
,

452 
l
,

453 
l
,

454 
l
);

456 
mp
 = 
vid
.
	`check
(
da
, 
widg_give_hash_th
);

457 
	`RUNNER_ASSERT_MSG
(

458 (
WSigtuVid
::
SIGNATURE_INVALID
 =
mp


459 || 
WSigtuVid
::
SIGNATURE_DISREGARD
 =
mp
),

460 "Wrg iufbusucss.. Ecod: " << 
	`wVidEToSg
(
mp
));

462 
	}
}

464 
	$RUNNER_TEST
(
03t03_wsigtu_vid_give_sigtu_put
)

466 
SigtuFeInfoS
 
sigtuS
;

467 
SigtuFd
 
	`sigtuFd
(
widg_give_sigtu_th
);

468 
	`RUNNER_ASSERT_MSG
(

469 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

472 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

473 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

474 
SigtuDa
 
	`da
(
widg_give_sigtu_th
 + 

->
	`gFeName
(),

475 

->
	`gFeNumb
());

476 
SigtuRd
 
xml
;

477 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

478 
xml
.
	`ad
(
da
);

480 
WSigtuVid
 
	`vid
(

481 
WSigtuVid
::
WAC20
,

482 
l
,

483 
l
,

484 
l
);

486 
mp
 = 
vid
.
	`check
(
da
, 
widg_give_sigtu_th
);

487 
	`RUNNER_ASSERT_MSG
(

488 (
WSigtuVid
::
SIGNATURE_INVALID
 =
mp


489 || 
WSigtuVid
::
SIGNATURE_DISREGARD
 =
mp
),

490 "Wrg iufbusucss.. Ecod: " << 
	`wVidEToSg
(
mp
));

492 
	}
}

494 
	$RUNNER_TEST
(
03t04_wsigtu_vid_r
)

496 
SigtuFeInfoS
 
sigtuS
;

497 
SigtuFd
 
	`sigtuFd
(
widg_r_th
);

498 
	`RUNNER_ASSERT_MSG
(

499 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

502 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

503 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

504 
SigtuDa
 
	`da
(
widg_r_th
 + 

->
	`gFeName
(),

505 

->
	`gFeNumb
());

506 
SigtuRd
 
xml
;

507 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

508 
xml
.
	`ad
(
da
);

510 
WSigtuVid
 
	`vid
(

511 
WSigtuVid
::
WAC20
,

512 
l
,

513 
l
,

514 
l
);

516 
mp
 = 
vid
.
	`check
(
da
, 
widg_r_th
);

517 
	`RUNNER_ASSERT_MSG
(

518 
WSigtuVid
::
SIGNATURE_VERIFIED
 =
mp
,

519 "Wrg iufbusucss.. Ecod: " << 
	`wVidEToSg
(
mp
));

520 i(!
da
.
	`isAuthSigtu
()) {

521 
	`RUNNER_ASSERT_MSG
(

522 
da
.
	`gVisibyLev
(=
CtSteId
::
VIS_PARTNER
,

526 
	}
}

623 
	$RUNNER_TEST
(
04t01_sigtu_vid
)

625 
SigtuFeInfoS
 
sigtuS
;

626 
SigtuFd
 
	`sigtuFd
(
widg_th
);

627 
	`RUNNER_ASSERT_MSG
(

628 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

631 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

632 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

633 
SigtuDa
 
	`da
(
widg_th
 + 

->
	`gFeName
(),

634 

->
	`gFeNumb
());

635 
SigtuRd
 
xml
;

636 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

637 
xml
.
	`ad
(
da
);

639 
SigtuVid
 
	`vid
(

640 
SigtuVid
::
WAC20
,

641 
l
,

642 
l
,

643 
l
);

645 i(
da
.
	`isAuthSigtu
()) {

646 
	`RUNNER_ASSERT_MSG
(

647 
SigtuVid
::
SIGNATURE_DISREGARD
 ==

648 
vid
.
	`check
(
da
, 
widg_th
),

651 i(
da
.
	`gSigtuNumb
() == 1)

653 
SigtuVid
::
Resu
 
mp
 = 
vid
.
	`check
(
da
, 
widg_th
);

655 
	`RUNNER_ASSERT_MSG
(

656 
SigtuVid
::
SIGNATURE_DISREGARD
 ==

657 
mp
,

662 
SigtuVid
::
Resu
 
mp
 = 
vid
.
	`check
(
da
, 
widg_th
);

664 
	`RUNNER_ASSERT_MSG
(

665 
SigtuVid
::
SIGNATURE_VERIFIED
 ==

666 
mp
,

671 
	}
}

673 
	$RUNNER_TEST
(
04t02_sigtu_vid_give_hash_put
)

675 
SigtuFeInfoS
 
sigtuS
;

676 
SigtuFd
 
	`sigtuFd
(
widg_give_hash_th
);

677 
	`RUNNER_ASSERT_MSG
(

678 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

681 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

682 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

683 
SigtuDa
 
	`da
(
widg_give_hash_th
 + 

->
	`gFeName
(),

684 

->
	`gFeNumb
());

685 
SigtuRd
 
xml
;

686 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

687 
xml
.
	`ad
(
da
);

689 
SigtuVid
 
	`vid
(

690 
SigtuVid
::
WAC20
,

691 
l
,

692 
l
,

693 
l
);

695 
mp
 = 
vid
.
	`check
(
da
, 
widg_give_hash_th
);

696 
	`RUNNER_ASSERT_MSG
(

697 (
WSigtuVid
::
SIGNATURE_INVALID
 =
mp


698 || 
WSigtuVid
::
SIGNATURE_DISREGARD
 =
mp
),

699 "Wrg iufbusucss.. Ecod: " << 
	`wVidEToSg
(
mp
));

701 
	}
}

703 
	$RUNNER_TEST
(
04t03_sigtu_vid_give_sigtu_put
)

705 
SigtuFeInfoS
 
sigtuS
;

706 
SigtuFd
 
	`sigtuFd
(
widg_give_sigtu_th
);

707 
	`RUNNER_ASSERT_MSG
(

708 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

711 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

712 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

713 
SigtuDa
 
	`da
(
widg_give_sigtu_th
 + 

->
	`gFeName
(),

714 

->
	`gFeNumb
());

715 
SigtuRd
 
xml
;

716 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

717 
xml
.
	`ad
(
da
);

719 
SigtuVid
 
	`vid
(

720 
SigtuVid
::
WAC20
,

721 
l
,

722 
l
,

723 
l
);

725 
mp
 = 
vid
.
	`check
(
da
, 
widg_give_sigtu_th
);

726 
	`RUNNER_ASSERT_MSG
(

727 (
WSigtuVid
::
SIGNATURE_INVALID
 =
mp


728 || 
WSigtuVid
::
SIGNATURE_DISREGARD
 =
mp
),

729 "Wrg iufbusucss.. Ecod: " << 
	`wVidEToSg
(
mp
));

731 
	}
}

733 
	$RUNNER_TEST
(
04t04_sigtu_vid_r
)

735 
SigtuFeInfoS
 
sigtuS
;

736 
SigtuFd
 
	`sigtuFd
(
widg_r_th
);

737 
	`RUNNER_ASSERT_MSG
(

738 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

741 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

742 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

743 
SigtuDa
 
	`da
(
widg_r_th
 + 

->
	`gFeName
(),

744 

->
	`gFeNumb
());

745 
SigtuRd
 
xml
;

746 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

747 
xml
.
	`ad
(
da
);

749 
SigtuVid
 
	`vid
(

750 
SigtuVid
::
TIZEN
,

751 
l
,

752 
l
,

753 
l
);

755 
mp
 = 
vid
.
	`check
(
da
, 
widg_r_th
);

756 
	`RUNNER_ASSERT_MSG
(
SigtuVid
::
SIGNATURE_VERIFIED
 =
mp
,

757 "Wrg iufbusucss.. Ecod: " << 
	`wVidEToSg
(
mp
));

759 i(!
da
.
	`isAuthSigtu
()) {

760 
	`RUNNER_ASSERT_MSG
(

761 
da
.
	`gVisibyLev
(=
CtSteId
::
VIS_PARTNER
,

765 
	}
}

860 
	$RUNNER_TEST
(
05t01_sigtu_n
)

862 
SigtuFeInfoS
 
sigtuS
;

863 
SigtuFd
 
	`sigtuFd
(
widg_th
);

864 
	`RUNNER_ASSERT_MSG
(

865 
SigtuFd
::
NO_ERROR
 =
sigtuFd
.
	`fd
(
sigtuS
),

868 
SigtuFeInfoS
::
v_
 

 = 
sigtuS
.
	`rbeg
();

870 ; 

 !
sigtuS
.
	`nd
(); ++iter) {

871 
SigtuDa
 
	`da
(
widg_th
 + 

->
	`gFeName
(),

872 

->
	`gFeNumb
());

873 
SigtuRd
 
xml
;

874 
xml
.
	`lize
(
da
, 
	`GSigtuXmlSchema
());

875 
xml
.
	`ad
(
da
);

877 
WSigtuVid
 
	`sv
(

878 
WSigtuVid
::
WAC20
,

879 
l
,

880 
l
,

881 
l
);

883 i(
da
.
	`isAuthSigtu
()) {

884 
	`RUNNER_ASSERT_MSG
(

885 
WSigtuVid
::
SIGNATURE_DISREGARD
 ==

886 
sv
.
	`check
(
da
, 
widg_th
),

889 i(
da
.
	`gSigtuNumb
() == 1)

891 
	`RUNNER_ASSERT_MSG
(

892 
WSigtuVid
::
SIGNATURE_DISREGARD
 ==

893 
sv
.
	`check
(
da
, 
widg_th
),

898 
	`RUNNER_ASSERT_MSG
(

899 
WSigtuVid
::
SIGNATURE_VERIFIED
 ==

900 
sv
.
	`check
(
da
, 
widg_th
),

914 
	}
}

1045 
	$RUNNER_TEST
(
08t01_Ctifi
)

1047 
Ctifi
 
	`
(
Visign
, Ctifi::
FORM_BASE64
);

1048 
d
::
rg
 
su
;

1050 
su
 = 

.
	`gCommName
(
Ctifi
::
FIELD_SUBJECT
);

1051 
	`RUNNER_ASSERT_MSG
(!
su
.
	`emy
(), "No commoname");

1052 
	`RUNNER_ASSERT_MSG
(!
su
.
	`com
("www.verisign.com"), "CommonName mismatch");

1054 
su
 = 

.
	`gCommName
(
Ctifi
::
FIELD_ISSUER
);

1055 
	`RUNNER_ASSERT_MSG
(!
su
.
	`emy
(), "No commoname");

1056 
	`RUNNER_ASSERT_MSG
(!
su
.
	`com
("VeriSign Class 3 Extended Validation SSL SGC CA"),

1059 
su
 = 

.
	`gCouryName
();

1060 
	`RUNNER_ASSERT_MSG
(!
su
.
	`emy
(), "No country");

1061 
	`RUNNER_ASSERT_MSG
(!
su
.
	`com
("US"), "Country mismatch");

1062 
	}
}

1069 
	$RUNNER_TEST
(
08t02_Ctifi
)

1071 
Ctifi
 
	`
(
Visign
, Ctifi::
FORM_BASE64
);

1073 
Ctifi
::
Fgt
 
f
 =

1074 

.
	`gFgt
(
Ctifi
::
FINGERPRINT_SHA1
);

1076 
buff
[20] = {

1081 
	`RUNNER_ASSERT_MSG
(
f
.
	`size
() == 20, "Wrong size of fingerprint");

1083 
size_t
 
i
 = 0; i<20; ++i) {

1084 
	`RUNNER_ASSERT_MSG
(
f
[
i
] =
buff
[i], "Fingerprint mismatch");

1086 
	}
}

1094 
	$RUNNER_TEST
(
08t03_Ctifi
)

1096 
Ctifi
 
	`
(
Visign
, Ctifi::
FORM_BASE64
);

1098 
Ctifi
::
ANameS
 
meS
 = 

.
	`gAɔtiveNameDNS
();

1100 
	`RUNNER_ASSERT
(
meS
.
	`size
() == 8);

1102 
d
::
rg
 
	`r
("verisign.com");

1103 
	`RUNNER_ASSERT
(
meS
.
	`fd
(
r
!meS.
	`d
());

1105 
r
 = 
d
::
	`rg
("fake.com");

1106 
	`RUNNER_ASSERT
(
meS
.
	`fd
(
r
=meS.
	`d
());

1108 
	}
}

1115 
	$RUNNER_TEST
(
08t04_Ctifi_isCA
)

1117 
Ctifi
 
	`1
(
googCA
, Ctifi::
FORM_BASE64
);

1118 
	`RUNNER_ASSERT
(
1
.
	`isCA
() > 0);

1120 
Ctifi
 
	`2
(
goog2nd
, Ctifi::
FORM_BASE64
);

1121 
	`RUNNER_ASSERT
(
2
.
	`isCA
() > 0);

1123 
Ctifi
 
	`3
(
goog3rd
, Ctifi::
FORM_BASE64
);

1124 
	`RUNNER_ASSERT
(
3
.
	`isCA
() == 0);

1125 
	}
}

1127 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


1134 
	$RUNNER_TEST
(
09t01_CtifiCi
)

1136 
CtifiLi
 
li
;

1137 
li
.
	`push_back
(
	`CtifiP
(

1138 
w
 
	`Ctifi
(
goog2nd
, 
Ctifi
::
FORM_BASE64
)));

1139 
li
.
	`push_back
(
	`CtifiP
(

1140 
w
 
	`Ctifi
(
googCA
, 
Ctifi
::
FORM_BASE64
)));

1141 
li
.
	`push_back
(
	`CtifiP
(

1142 
w
 
	`Ctifi
(
goog3rd
, 
Ctifi
::
FORM_BASE64
)));

1144 
CtifiCi
 
ci
;

1145 
ci
.
	`ld
(
li
);

1147 
bo
 
exi
 = 
l
;

1149 
Try
 {

1150 
	`RUNNER_ASSERT
(
ci
.
	`isCha
());

1151 } 
	`Cch
 (
CtifiCi
::
Exi
::
WrgUge
) {

1152 
exi
 = 
ue
;

1155 
	`RUNNER_ASSERT_MSG
(
exi
, "Exceptionxpected!");

1157 
	`RUNNER_ASSERT_MSG
(
ci
.
	`st
(), "Sort failed");

1159 
	`RUNNER_ASSERT
(
ci
.
	`isCha
());

1161 
d
::
rg
 
coded
 = 
ci
.
	`toBa64Sg
();

1163 
ci
.
	`r
();

1165 
	`RUNNER_ASSERT_MSG
(
ci
.
	`size
() == 0, "Function clear failed.");

1167 
ci
.
	`ld
(
coded
);

1169 
	`RUNNER_ASSERT_MSG
(
ci
.
	`st
(), "Sort failed");

1171 
li
 = 
ci
.
	`gCha
();

1173 
	`RUNNER_ASSERT
(!
li
.
	`t
().
	`g
()->
	`gCommName
().
	`com
("mail.google.com"));

1174 
	`RUNNER_ASSERT
(!
li
.
	`back
().
	`g
()->
	`gOrgiziName
().
	`com
("VeriSign, Inc."));

1175 
	}
}

1184 
	$RUNNER_TEST
(
51t01_oc_vidi_give
)

1186 
CtifiCacheDAO
::
	`rCtifiCache
();

1188 
CtifiLi
 
lOCSPCtifis
;

1189 
CtifiP
 
ifiP
;

1190 
CtifiP
 
pCt0
;

1191 
CtifiP
 
pCt1
;

1192 
CtifiP
 
pCt2
;

1193 
CtifiP
 
pRoCt
;

1194 
d
::
rg
 
	`RoPh
(
keys_th
 + "ocsp_rootca.crt"),

1195 
	`Lev0Ph
(
keys_th
 + "ocsp_level0deprecated.crt"),

1196 
	`Lev1Ph
(
keys_th
 + "ocsp_level1.crt"),

1197 
	`Lev2Ph
(
keys_th
 + "ocsp_level2.crt");

1199 
pRoCt
 = 
RevotiCheckBa
::
	`ldPEMFe
(
RoPh
.
	`c_r
());

1200 i(!
pRoCt
) {

1201 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad ocsp_rootca.crt");

1203 
lOCSPCtifis
.
	`push_back
(
pRoCt
);

1205 
pCt0
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev0Ph
.
	`c_r
());

1206 i(!
pCt0
) {

1207 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad ocsp_level0.crt");

1209 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt0
));

1211 
pCt1
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev1Ph
.
	`c_r
());

1212 i(!
pCt1
) {

1213 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad ocsp_level1.crt");

1215 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt1
));

1217 
pCt2
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev2Ph
.
	`c_r
());

1218 i(!
pCt2
) {

1219 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad ocsp_level2.crt");

1221 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt2
));

1223 
OCSP
 
oc
;

1224 
oc
.
	`tDigeAlgܙhmFCtId
(
VidiCe
::
OCSP
::
SHA1
);

1225 
oc
.
	`tDigeAlgܙhmFReque
(
VidiCe
::
OCSP
::
SHA1
);

1227 
CtifiCi
 
ci
;

1228 
ci
.
	`ld
(
lOCSPCtifis
);

1229 
	`RUNNER_ASSERT
(
ci
.
	`st
());

1230 
CtifiLi
 
s܋d
 = 
ci
.
	`gCha
();

1232 
oc
.
	`tTruedSte
(
s܋d
);

1233 
VifitiStusS
 
us
 = 
oc
.
	`videCtifiLi
(
s܋d
);

1235 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_CONNECTION_FAILED
),

1237 
	`RUNNER_ASSERT_MSG
(
us
.
	`cڏs
(
VERIFICATION_STATUS_GOOD
),

1239 
	`RUNNER_ASSERT_MSG
(
us
.
	`cڏs
(
VERIFICATION_STATUS_VERIFICATION_ERROR
),

1242 
CtifiCacheDAO
::
	`rCtifiCache
();

1243 
	}
}

1250 
	$RUNNER_TEST
(
51t02_oc_vidi_posive
)

1252 
CtifiCacheDAO
::
	`rCtifiCache
();

1254 
CtifiLi
 
lOCSPCtifis
;

1255 
CtifiP
 
ifiP
;

1256 
CtifiP
 
pCt0
;

1257 
CtifiP
 
pCt1
;

1258 
CtifiP
 
pCt2
;

1259 
CtifiP
 
pRoCt
;

1260 
d
::
rg
 
	`RoPh
(
keys_th
 + "ocsp_rootca.crt"),

1261 
	`Lev1Ph
(
keys_th
 + "ocsp_level1.crt"),

1262 
	`Lev2Ph
(
keys_th
 + "ocsp_level2.crt");

1264 
pRoCt
 = 
RevotiCheckBa
::
	`ldPEMFe
(
RoPh
.
	`c_r
());

1265 i(!
pRoCt
) {

1266 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad ocsp_rootca.crt");

1268 
lOCSPCtifis
.
	`push_back
(
pRoCt
);

1270 
pCt1
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev1Ph
.
	`c_r
());

1271 i(!
pCt1
) {

1272 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad ocsp_level1.crt");

1274 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt1
));

1276 
pCt2
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev2Ph
.
	`c_r
());

1277 i(!
pCt2
) {

1278 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad ocsp_level2.crt");

1280 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt2
));

1282 
OCSP
 
oc
;

1283 
oc
.
	`tDigeAlgܙhmFCtId
(
VidiCe
::
OCSP
::
SHA1
);

1284 
oc
.
	`tDigeAlgܙhmFReque
(
VidiCe
::
OCSP
::
SHA1
);

1286 
CtifiCi
 
ci
;

1287 
ci
.
	`ld
(
lOCSPCtifis
);

1288 
	`RUNNER_ASSERT
(
ci
.
	`st
());

1289 
CtifiLi
 
s܋d
 = 
ci
.
	`gCha
();

1291 
oc
.
	`tTruedSte
(
s܋d
);

1292 
VifitiStusS
 
us
 = 
oc
.
	`videCtifiLi
(
s܋d
);

1294 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_CONNECTION_FAILED
),

1296 
	`RUNNER_ASSERT_MSG
(
us
.
	`cڏs
(
VERIFICATION_STATUS_GOOD
),

1298 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_VERIFICATION_ERROR
),

1301 
CtifiCacheDAO
::
	`rCtifiCache
();

1302 
	}
}

1309 
	$RUNNER_TEST
(
51t04_oc_que
)

1311 
CtifiLi
 
lTruedCts
;

1313 
lTruedCts
.
	`push_back
(
	`CtifiP
(

1314 
w
 
	`Ctifi
(
goog3rd
, 
Ctifi
::
FORM_BASE64
)));

1315 
lTruedCts
.
	`push_back
(
	`CtifiP
(

1316 
w
 
	`Ctifi
(
goog2nd
, 
Ctifi
::
FORM_BASE64
)));

1317 
lTruedCts
.
	`push_back
(
	`CtifiP
(

1318 
w
 
	`Ctifi
(
googCA
, 
Ctifi
::
FORM_BASE64
)));

1320 
CtifiCi
 
cha
;

1321 
cha
.
	`ld
(
lTruedCts
);

1322 
	`RUNNER_ASSERT
(
cha
.
	`st
());

1324 
OCSP
 
oc
;

1325 
oc
.
	`tDigeAlgܙhmFCtId
(
OCSP
::
SHA1
);

1326 
oc
.
	`tDigeAlgܙhmFReque
(
OCSP
::
SHA1
);

1327 
oc
.
	`tTruedSte
(
lTruedCts
);

1328 
VifitiStus
 
su
 = 
oc
.
	`checkEndEy
(
cha
);

1330 
	`RUNNER_ASSERT
(
VERIFICATION_STATUS_GOOD
 =
su
);

1331 
	}
}

1339 
	$RUNNER_TEST
(
51t05_ched_oc_vidi_give
)

1341 
CtifiCacheDAO
::
	`rCtifiCache
();

1343 
CtifiLi
 
lOCSPCtifis
;

1344 
CtifiP
 
ifiP
;

1345 
CtifiP
 
pCt0
;

1346 
CtifiP
 
pCt1
;

1347 
CtifiP
 
pCt2
;

1348 
CtifiP
 
pRoCt
;

1349 
d
::
rg
 
	`RoPh
(
keys_th
 + "ocsp_rootca.crt"),

1350 
	`Lev0Ph
(
keys_th
 + "ocsp_level0deprecated.crt"),

1351 
	`Lev1Ph
(
keys_th
 + "ocsp_level1.crt"),

1352 
	`Lev2Ph
(
keys_th
 + "ocsp_level2.crt");

1354 
pRoCt
 = 
RevotiCheckBa
::
	`ldPEMFe
(
RoPh
.
	`c_r
());

1355 
	`RUNNER_ASSERT_MSG
(
pRoCt
, "Couldn'toad ocsp_rootca.crt");

1356 
lOCSPCtifis
.
	`push_back
(
pRoCt
);

1358 
pCt0
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev0Ph
.
	`c_r
());

1359 
	`RUNNER_ASSERT_MSG
(
pCt0
, "Couldn'toad ocsp_level0.crt");

1360 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt0
));

1362 
pCt1
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev1Ph
.
	`c_r
());

1363 
	`RUNNER_ASSERT_MSG
(
pCt1
, "Couldn'toad ocsp_level1.crt");

1364 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt1
));

1366 
pCt2
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev2Ph
.
	`c_r
());

1367 
	`RUNNER_ASSERT_MSG
(
pCt2
, "Couldn'toad ocsp_level2.crt");

1368 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt2
));

1370 
CachedOCSP
 
oc
;

1372 
CtifiCi
 
ci
;

1373 
ci
.
	`ld
(
lOCSPCtifis
);

1374 
	`RUNNER_ASSERT
(
ci
.
	`st
());

1376 
VifitiStus
 
us
 = 
oc
.
	`check
(
ci
);

1378 
	`RUNNER_ASSERT_MSG
(
us
 !
VERIFICATION_STATUS_GOOD
,

1381 
OCSPCachedStusLi
 
Li
;

1382 
CtifiCacheDAO
::
	`gOCSPStusLi
(&
Li
);

1383 
n
 = 
Li
.
	`size
();

1385 
us
 = 
oc
.
	`check
(
ci
);

1387 
	`RUNNER_ASSERT_MSG
(
us
 !
VERIFICATION_STATUS_GOOD
,

1390 
Li
.
	`r
();

1391 
CtifiCacheDAO
::
	`gOCSPStusLi
(&
Li
);

1392 
	`RUNNER_ASSERT_MSG
(
Li
.
	`size
(=
n
 &&en > 0,

1395 
CtifiCacheDAO
::
	`rCtifiCache
();

1396 
	}
}

1404 
	$RUNNER_TEST
(
51t06_ched_oc_vidi_posive
)

1406 
CtifiCacheDAO
::
	`rCtifiCache
();

1408 
CtifiLi
 
lOCSPCtifis
;

1409 
CtifiP
 
ifiP
;

1410 
CtifiP
 
pCt0
;

1411 
CtifiP
 
pCt1
;

1412 
CtifiP
 
pCt2
;

1413 
CtifiP
 
pRoCt
;

1414 
d
::
rg
 
	`RoPh
(
keys_th
 + "ocsp_rootca.crt"),

1415 
	`Lev1Ph
(
keys_th
 + "ocsp_level1.crt"),

1416 
	`Lev2Ph
(
keys_th
 + "ocsp_level2.crt");

1418 
pRoCt
 = 
RevotiCheckBa
::
	`ldPEMFe
(
RoPh
.
	`c_r
());

1419 
	`RUNNER_ASSERT_MSG
(
pRoCt
, "Couldn'toad ocsp_rootca.crt");

1420 
lOCSPCtifis
.
	`push_back
(
pRoCt
);

1422 
pCt1
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev1Ph
.
	`c_r
());

1423 
	`RUNNER_ASSERT_MSG
(
pCt1
, "Couldn'toad ocsp_level1.crt");

1424 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt1
));

1426 
pCt2
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev2Ph
.
	`c_r
());

1427 
	`RUNNER_ASSERT_MSG
(
pCt2
, "Couldn'toad ocsp_level2.crt");

1428 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt2
));

1430 
CachedOCSP
 
oc
;

1432 
CtifiCi
 
ci
;

1433 
ci
.
	`ld
(
lOCSPCtifis
);

1434 
	`RUNNER_ASSERT
(
ci
.
	`st
());

1436 
VifitiStus
 
us
 = 
oc
.
	`check
(
ci
);

1438 
	`RUNNER_ASSERT_MSG
(
us
 =
VERIFICATION_STATUS_GOOD
,

1441 
OCSPCachedStusLi
 
Li
;

1442 
CtifiCacheDAO
::
	`gOCSPStusLi
(&
Li
);

1443 
n
 = 
Li
.
	`size
();

1445 
us
 = 
oc
.
	`check
(
ci
);

1447 
	`RUNNER_ASSERT_MSG
(
us
 =
VERIFICATION_STATUS_GOOD
,

1450 
Li
.
	`r
();

1451 
CtifiCacheDAO
::
	`gOCSPStusLi
(&
Li
);

1452 
	`RUNNER_ASSERT_MSG
(
Li
.
	`size
(=
n
 &&en > 0,

1455 
CtifiCacheDAO
::
	`rCtifiCache
();

1456 
	}
}

1463 
	$RUNNER_TEST
(
70_oc_lol_vidi_posive
)

1465 
CtifiCacheDAO
::
	`rCtifiCache
();

1467 
CtifiLi
 
lOCSPCtifis
;

1468 
CtifiP
 
ifiP
;

1469 
CtifiP
 
pCt0
;

1470 
CtifiP
 
pRoCt
;

1471 
d
::
rg
 
	`RoPh
(
_e_th
 + "cacert.pem"),

1472 
	`Lev0Ph
(
_e_th
 + "1second_level.pem");

1474 
pRoCt
 = 
RevotiCheckBa
::
	`ldPEMFe
(
RoPh
.
	`c_r
());

1475 i(!
pRoCt
) {

1476 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad cacert.pem");

1478 
lOCSPCtifis
.
	`push_back
(
pRoCt
);

1480 
pCt0
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev0Ph
.
	`c_r
());

1481 i(!
pCt0
) {

1482 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad 1second_level.pem");

1484 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt0
));

1486 
OCSP
 
oc
;

1487 
oc
.
	`tDigeAlgܙhmFCtId
(
VidiCe
::
OCSP
::
SHA1
);

1488 
oc
.
	`tDigeAlgܙhmFReque
(
VidiCe
::
OCSP
::
SHA1
);

1490 
CtifiCi
 
ci
;

1491 
ci
.
	`ld
(
lOCSPCtifis
);

1492 
	`RUNNER_ASSERT
(
ci
.
	`st
());

1493 
CtifiLi
 
s܋d
 = 
ci
.
	`gCha
();

1495 
oc
.
	`tTruedSte
(
s܋d
);

1496 
VifitiStusS
 
us
 = 
oc
.
	`videCtifiLi
(
s܋d
);

1498 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_CONNECTION_FAILED
),

1501 
	`RUNNER_ASSERT_MSG
(
us
.
	`cڏs
(
VERIFICATION_STATUS_GOOD
),

1503 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_VERIFICATION_ERROR
),

1506 
CtifiCacheDAO
::
	`rCtifiCache
();

1507 
	}
}

1514 
	$RUNNER_TEST
(
71_oc_lol_vidi_posive
)

1516 
CtifiCacheDAO
::
	`rCtifiCache
();

1518 
CtifiLi
 
lOCSPCtifis
;

1519 
CtifiP
 
ifiP
;

1520 
CtifiP
 
pCt0
;

1521 
CtifiP
 
pRoCt
;

1522 
d
::
rg
 
	`RoPh
(
_e_th
 + "cacert.pem"),

1523 
	`Lev0Ph
(
_e_th
 + "3second_level.pem");

1525 
pRoCt
 = 
RevotiCheckBa
::
	`ldPEMFe
(
RoPh
.
	`c_r
());

1526 i(!
pRoCt
) {

1527 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad cacert.pem");

1529 
lOCSPCtifis
.
	`push_back
(
pRoCt
);

1531 
pCt0
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev0Ph
.
	`c_r
());

1532 i(!
pCt0
) {

1533 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad 3second_level.pem");

1535 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt0
));

1537 
OCSP
 
oc
;

1538 
oc
.
	`tDigeAlgܙhmFCtId
(
VidiCe
::
OCSP
::
SHA1
);

1539 
oc
.
	`tDigeAlgܙhmFReque
(
VidiCe
::
OCSP
::
SHA1
);

1541 
CtifiCi
 
ci
;

1542 
ci
.
	`ld
(
lOCSPCtifis
);

1543 
	`RUNNER_ASSERT
(
ci
.
	`st
());

1544 
CtifiLi
 
s܋d
 = 
ci
.
	`gCha
();

1546 
oc
.
	`tTruedSte
(
s܋d
);

1547 
VifitiStusS
 
us
 = 
oc
.
	`videCtifiLi
(
s܋d
);

1549 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_CONNECTION_FAILED
),

1552 
	`RUNNER_ASSERT_MSG
(
us
.
	`cڏs
(
VERIFICATION_STATUS_GOOD
),

1554 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_VERIFICATION_ERROR
),

1557 
CtifiCacheDAO
::
	`rCtifiCache
();

1558 
	}
}

1565 
	$RUNNER_TEST
(
72_oc_lol_vidi_voked
)

1567 
CtifiCacheDAO
::
	`rCtifiCache
();

1569 
CtifiLi
 
lOCSPCtifis
;

1570 
CtifiP
 
ifiP
;

1571 
CtifiP
 
pCt0
;

1572 
CtifiP
 
pRoCt
;

1573 
d
::
rg
 
	`RoPh
(
_e_th
 + "cacert.pem"),

1574 
	`Lev0Ph
(
_e_th
 + "2second_level.pem");

1576 
pRoCt
 = 
RevotiCheckBa
::
	`ldPEMFe
(
RoPh
.
	`c_r
());

1577 i(!
pRoCt
) {

1578 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad cacert.pem");

1580 
lOCSPCtifis
.
	`push_back
(
pRoCt
);

1582 
pCt0
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev0Ph
.
	`c_r
());

1583 i(!
pCt0
) {

1584 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad 2second_level.pem");

1586 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt0
));

1588 
OCSP
 
oc
;

1589 
oc
.
	`tDigeAlgܙhmFCtId
(
VidiCe
::
OCSP
::
SHA1
);

1590 
oc
.
	`tDigeAlgܙhmFReque
(
VidiCe
::
OCSP
::
SHA1
);

1592 
CtifiCi
 
ci
;

1593 
ci
.
	`ld
(
lOCSPCtifis
);

1594 
	`RUNNER_ASSERT
(
ci
.
	`st
());

1595 
CtifiLi
 
s܋d
 = 
ci
.
	`gCha
();

1597 
oc
.
	`tTruedSte
(
s܋d
);

1598 
VifitiStusS
 
us
 = 
oc
.
	`videCtifiLi
(
s܋d
);

1600 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_CONNECTION_FAILED
),

1603 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_GOOD
),

1605 
	`RUNNER_ASSERT_MSG
(
us
.
	`cڏs
(
VERIFICATION_STATUS_REVOKED
),

1607 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_UNKNOWN
),

1609 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_VERIFICATION_ERROR
),

1612 
CtifiCacheDAO
::
	`rCtifiCache
();

1613 
	}
}

1621 
	$RUNNER_TEST
(
73_oc_lol_vidi_r_unknown_
)

1623 
CtifiCacheDAO
::
	`rCtifiCache
();

1625 
CtifiLi
 
lOCSPCtifis
;

1626 
CtifiP
 
ifiP
;

1627 
CtifiP
 
pCt0
;

1628 
CtifiP
 
pCt1
;

1629 
CtifiP
 
pRoCt
;

1630 
d
::
rg
 
	`RoPh
(
_e_th
 + "cacert.pem"),

1631 
	`Lev0Ph
(
_e_th
 + "1second_level.pem"),

1632 
	`Lev1Ph
(
_e_th
 + "1third_level.pem");

1634 
pRoCt
 = 
RevotiCheckBa
::
	`ldPEMFe
(
RoPh
.
	`c_r
());

1635 i(!
pRoCt
) {

1636 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad cacerr.pem");

1638 
lOCSPCtifis
.
	`push_back
(
pRoCt
);

1640 
pCt0
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev0Ph
.
	`c_r
());

1641 i(!
pCt0
) {

1642 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad 1second_level.pem");

1644 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt0
));

1646 
pCt1
 = 
RevotiCheckBa
::
	`ldPEMFe
(
Lev1Ph
.
	`c_r
());

1647 i(!
pCt1
) {

1648 
	`RUNNER_ASSERT_MSG
(
l
, "Couldn'toad 1third_level.pem");

1650 
lOCSPCtifis
.
	`push_back
(
	`CtifiP
(
pCt1
));

1652 
OCSP
 
oc
;

1653 
oc
.
	`tDigeAlgܙhmFCtId
(
VidiCe
::
OCSP
::
SHA1
);

1654 
oc
.
	`tDigeAlgܙhmFReque
(
VidiCe
::
OCSP
::
SHA1
);

1656 
CtifiCi
 
ci
;

1657 
ci
.
	`ld
(
lOCSPCtifis
);

1658 
	`RUNNER_ASSERT
(
ci
.
	`st
());

1659 
CtifiLi
 
s܋d
 = 
ci
.
	`gCha
();

1661 
oc
.
	`tTruedSte
(
s܋d
);

1662 
VifitiStusS
 
us
 = 
oc
.
	`videCtifiLi
(
s܋d
);

1664 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_CONNECTION_FAILED
),

1667 
	`RUNNER_ASSERT_MSG
(
us
.
	`cڏs
(
VERIFICATION_STATUS_GOOD
),

1669 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_REVOKED
),

1671 
	`RUNNER_ASSERT_MSG
(
us
.
	`cڏs
(
VERIFICATION_STATUS_VERIFICATION_ERROR
),

1673 
	`RUNNER_ASSERT_MSG
(!
us
.
	`cڏs
(
VERIFICATION_STATUS_UNKNOWN
),

1676 
CtifiCacheDAO
::
	`rCtifiCache
();

1677 
	}
}

1680 
	#CRYPTO_HASH_TEST
(
xt
,
exed
,
FUN
) \

1682 
VidiCe
::
Cryo
::
Hash
::
Ba
 *
yo
; \

1683 
yo
 = 
w
 
VidiCe
::
Cryo
::
Hash
::
	`FUN
(); \

1684 
d
::
rg
 
put
 = 
xt
; \

1685 
yo
->
	`Ad
(
xt
); \

1686 
yo
->
	`Fish
(); \

1687 
d
::
rg
 
su
 = 
yo
->
	`ToBa64Sg
(); \

1688 
	`RUNNER_ASSERT_MSG
(
su
 =
exed
, \

1690 } 0)

	)

1697 
	$RUNNER_TEST
(
80_yo_md4
)

1699 
	`CRYPTO_HASH_TEST
("Hi, myame is Bart.",

1701 
MD4
);

1702 
	}
}

1709 
	$RUNNER_TEST
(
81_yo_md5
)

1711 
	`CRYPTO_HASH_TEST
("Hi, myame is Bart.",

1713 
MD5
);

1714 
	}
}

1721 
	$RUNNER_TEST
(
82_yo_sha
)

1723 
	`CRYPTO_HASH_TEST
("Hi, myame is Bart.",

1725 
SHA
);

1726 
	}
}

1733 
	$RUNNER_TEST
(
83_yo_sha1
)

1735 
	`CRYPTO_HASH_TEST
("Hi, myame is Bart.",

1737 
SHA1
);

1738 
	}
}

1745 
	$RUNNER_TEST
(
84_yo_sha224
)

1747 
	`CRYPTO_HASH_TEST
("Hi, myame is Bart.",

1749 
SHA224
);

1750 
	}
}

1757 
	$RUNNER_TEST
(
85_yo_sha256
)

1759 
	`CRYPTO_HASH_TEST
("Hi, myame is Bart.",

1761 
SHA256
);

1762 
	}
}

1769 
	$RUNNER_TEST
(
86_yo_sha384
)

1771 
	`CRYPTO_HASH_TEST
("Hi, myame is Bart.",

1773 
SHA384
);

1774 
	}
}

1781 
	$RUNNER_TEST
(
87_yo_sha512
)

1783 
	`CRYPTO_HASH_TEST
("Hi, myame is Bart.",

1785 
SHA512
);

1786 
	}
}

1793 
	$RUNNER_TEST
(
88_yo_sha1_ifi
)

1795 
Ctifi
 
	`
(
Visign
, Ctifi::
FORM_BASE64
);

1797 
VidiCe
::
Cryo
::
Hash
::
SHA1
 
sha1
;

1798 
sha1
.
	`Ad
(

.
	`gDER
());

1799 
sha1
.
	`Fish
();

1800 
d
::
rg
 
su
 = 
sha1
.
	`ToBa64Sg
();

1802 
	`RUNNER_ASSERT_MSG
(
su
 == "uXIe1UntvzGE2CcM/gMRGd/CKwo=",

1804 
	}
}

	@tests/vcore/TestEnv.cpp

16 
	~<vce/WSigtuVid.h
>

18 
	~"TeEnv.h
"

20 
	#WRTSIGNATURE_ERRORDESCRIBE
(
me

VidiCe
::
WSigtuVid
::me:  #me

	)

21 cڡ *
	$wVidEToSg
(
r
)

23 
r
) {

24 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_VALID
);

25 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_INVALID
);

26 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_VERIFIED
);

27 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_DISREGARD
);

28 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_REVOKED
);

29 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_INVALID_CERT_CHAIN
);

30 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_INVALID_DISTRIBUTOR_CERT
);

31 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_INVALID_SDK_DEFAULT_AUTHOR_CERT
);

32 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_IN_DISTRIBUTOR_CASE_AUTHOR_CERT
);

33 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_INVALID_CERT_TIME
);

34 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_NO_DEVICE_PROFILE
);

35 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_INVALID_DEVICE_UNIQUE_ID
);

36 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_INVALID_NO_HASH_FILE
);

37 
	`WRTSIGNATURE_ERRORDESCRIBE
(
SIGNATURE_INVALID_HASH_SIGNATURE
);

41 
	}
}

42 #unde
WRTSIGNATURE_ERRORDESCRIBE


	@tests/vcore/TestEnv.h

16 #ide
_TESTENV_H_


17 
	#_TESTENV_H_


	)

19 cڡ *
wVidEToSg
(
r
);

	@tests/vcore/vcore_tests.cpp

22 
	~<d//_ru.h
>

24 
	~<vce/VCe.h
>

26 
	~<glib-obje.h
>

28 
	$ma
 (
gc
, *
gv
[])

30 
VidiCe
::
	`VCeIn
();

32 
VidiCe
::
	`AachToThadRW
();

33 
DPL
::
Te
::
TeRuSgt
::
	`In
().
	`ExecTeRu
(
gc
, 
gv
);

34 
VidiCe
::
	`DachFromThad
();

36 
VidiCe
::
	`VCeDe
();

39 
	}
}

	@vcore/src/cert-svc/ccert.h

22 #ide
_CERTSVC_CCERT_H_


23 
	#_CERTSVC_CCERT_H_


	)

25 
	~<time.h
>

27 
	~<-svc/c.h
>

28 
	~<-svc/crg.h
>

30 #ifde
__lulus


34 
	sCtSvcCtifi_t
 {

35 
iveHdr
;

36 
CtSvcIn
 
iveIn
;

37 } 
	tCtSvcCtifi
;

39 
	sCtSvcCtifiLi_t
 {

40 
iveHdr
;

41 
CtSvcIn
 
iveIn
;

42 } 
	tCtSvcCtifiLi
;

44 
	#MAX_STORE_ENUMS
 5

	)

45 
	eImptTy_t
 {

46 
NONE_STORE
 = 0,

47 
VPN_STORE
 = 1 << 0,

48 
WIFI_STORE
 = 1 << 1,

49 
EMAIL_STORE
 = 1 << 2,

50 
SYSTEM_STORE
 = 1 << 3,

51 
ALL_STORE
 = 
VPN_STORE
 | 
WIFI_STORE
 | 
EMAIL_STORE
 | 
SYSTEM_STORE


52 } 
	tCtSteTy
;

54 
	sCtSvcSteCtLi_t
{

55 * 
gme
;

56 * 
t
;

57 
us
;

58 
CtSteTy
 
eTy
;

59 
CtSvcSteCtLi_t
 *
xt
;

60 }
	tCtSvcSteCtLi
;

62 
	eTy_t
 {

63 
PEM_CRT
 = 1 << 0,

64 
P12_END_USER
 = 1 << 1,

65 
P12_INTERMEDIATE
 = 1 << 2,

66 
P12_TRUSTED
 = 1 << 3,

67 
P12_PKEY
 = 1 << 4,

68 
INVALID_DATA
 = 1 << 5,

69 } 
	tCtTy
;

71 
	eStus_t
 {

72 
DISABLED
 = 0,

73 
ENABLED
 = 1,

74 } 
	tCtStus
;

76 
	eCtSvcCtifiFm_t
 {

78 
CERTSVC_FORM_DER
,

79 
CERTSVC_FORM_DER_BASE64


80 } 
	tCtSvcCtifiFm
;

82 
	eCtSvcCtifiFld_t
 {

83 
CERTSVC_SUBJECT
,

84 
CERTSVC_SUBJECT_COMMON_NAME
,

85 
CERTSVC_SUBJECT_COUNTRY_NAME
,

86 
CERTSVC_SUBJECT_STATE_NAME
,

87 
CERTSVC_SUBJECT_ORGANIZATION_NAME
,

88 
CERTSVC_SUBJECT_ORGANIZATION_UNIT_NAME
,

89 
CERTSVC_SUBJECT_EMAIL_ADDRESS
,

90 
CERTSVC_ISSUER
,

91 
CERTSVC_ISSUER_COMMON_NAME
,

92 
CERTSVC_ISSUER_COUNTRY_NAME
,

93 
CERTSVC_ISSUER_STATE_NAME
,

94 
CERTSVC_ISSUER_ORGANIZATION_NAME
,

95 
CERTSVC_ISSUER_ORGANIZATION_UNIT_NAME
,

96 
CERTSVC_VERSION
,

97 
CERTSVC_SERIAL_NUMBER
,

98 
CERTSVC_KEY_USAGE
,

99 
CERTSVC_KEY
,

100 
CERTSVC_SIGNATURE_ALGORITHM


101 } 
	tCtSvcCtifiFld
;

103 
	eCtSvcVisiby_t
 {

104 
CERTSVC_VISIBILITY_DEVELOPER
 = 1,

105 
CERTSVC_VISIBILITY_TEST
 = 1 << 1,

106 
CERTSVC_VISIBILITY_PUBLIC
 = 1 << 6,

107 
CERTSVC_VISIBILITY_PARTNER
 = 1 << 7,

108 
CERTSVC_VISIBILITY_PARTNER_OPERATOR
 = 1 << 8,

109 
CERTSVC_VISIBILITY_PARTNER_MANUFACTURER
 = 1 << 9,

110 
CERTSVC_VISIBILITY_PLATFORM
 = 1 << 10

111 } 
	tCtSvcVisiby
;

122 
svc_g_ifi
(
CtSvcIn
 

,

123 
CtSteTy
 
eTy
,

124 *
gme
,

125 
CtSvcCtifi
 *
ifi
);

135 
svc_ifi_w_om_fe
(
CtSvcIn
 

,

136 cڡ *
loti
,

137 
CtSvcCtifi
 *
ifi
);

149 
svc_ifi_w_om_memy
(
CtSvcIn
 

,

150 cڡ *
memy
,

151 
n
,

152 
CtSvcCtifiFm
 
fm
,

153 
CtSvcCtifi
 *
ifi
);

160 
svc_ifi_
(
CtSvcCtifi
 
ifi
);

169 
svc_ifi_ve_fe
(
CtSvcCtifi
 
ifi
, cڡ *
loti
);

184 
svc_ifi_ch
(
CtSvcIn
 

,

185 
CtSvcCtifiFld
 
fld
,

186 cڡ *
vue
,

187 
CtSvcCtifiLi
 *
hdr
);

198 
svc_ifi_li_g_e
(
CtSvcCtifiLi
 
hdr
,

199 
posi
,

200 
CtSvcCtifi
 *
ifi
);

209 
svc_ifi_li_g_ngth
(
CtSvcCtifiLi
 
hdr
,

210 *
size
);

218 
svc_ifi_li_
(
CtSvcCtifiLi
 
hdr
);

228 
svc_ifi_is_sigd_by
(
CtSvcCtifi
 
chd
,

229 
CtSvcCtifi
 

,

230 *
us
);

242 
svc_ifi_g_rg_fld
(
CtSvcCtifi
 
ifi
,

243 
CtSvcCtifiFld
 
fld
,

244 
CtSvcSg
 *
bufr
);

253 
svc_ifi_g_n_a
(
CtSvcCtifi
 
ifi
, 
time_t
 *
su
);

262 
svc_ifi_g_n_befe
(
CtSvcCtifi
 
ifi
, 
time_t
 *
su
);

272 
svc_ifi_is_ro_
(
CtSvcCtifi
 
ifi
, *
us
);

297 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


298 
svc_ifi_g_l_diributi_pots
(
CtSvcCtifi
 
ifi
,

299 
CtSvcSgLi
 *
hdr
);

314 
svc_ifi_cha_st
(
CtSvcCtifi
 *
uns܋dCha
, 
size
);

324 
svc_ba64_code
(
CtSvcSg
 
mesge
, CtSvcSg *
ba64
);

334 
svc_ba64_decode
(
CtSvcSg
 
ba64
, CtSvcSg *
mesge
);

346 
svc_mesge_vify
(

347 
CtSvcCtifi
 
ifi
,

348 
CtSvcSg
 
mesge
,

349 
CtSvcSg
 
sigtu
,

350 cڡ *
gܙhm
,

351 *
us
);

370 
svc_ifi_vify
(

371 
CtSvcCtifi
 
ifi
,

372 
CtSvcCtifi
 *
ued
,

373 
uedSize
,

374 
CtSvcCtifi
 *
urued
,

375 
uruedSize
,

376 *
us
);

396 
svc_ifi_vify_wh_ag
(

397 
CtSvcCtifi
 
ifi
,

398 
CtSvcCtifi
 *
ued
,

399 
uedSize
,

400 
CtSvcCtifi
 *
urued
,

401 
uruedSize
,

402 *
us
);

412 
svc_ifi_g_visiby
(
CtSvcCtifi
 
ifi
, * 
visiby
);

415 #ifde
__lulus


	@vcore/src/cert-svc/ccrl.h

22 #ide
_CERTSVC_CCRL_H_


23 
	#_CERTSVC_CCRL_H_


	)

25 
	~<time.h
>

27 
	~<-svc/c.h
>

29 #ifde
__lulus


33 
	#CERTSVC_CRL_GOOD
 (1<<0)

	)

34 
	#CERTSVC_CRL_REVOKED
 (1<<1)

	)

35 
	#CERTSVC_CRL_VERIFICATION_ERROR
 (1<<3)

	)

36 
	#CERTSVC_CRL_NO_SUPPORT
 (1<<4)

	)

38 (*
CtSvcCCacheWre
)(

39 cڡ *
	tdiributiPot
,

40 cڡ *
	tbody
,

41 
	tbodySize
,

42 
	ttime_t
 
	txtUpdeTime
,

43 *
	turPam
);

45 (*
CtSvcCCacheRd
)(

46 cڡ *
	tdiributiPot
,

47 **
	tbody
,

48 *
	tbodySize
,

49 
	ttime_t
 *
	txtUpdeTime
,

50 *
	turPam
);

52 (*
CtSvcCFe
)(

53 *
	tbufr
,

54 *
	turPam
);

56 
svc_l_che_funis
(

57 
CtSvcIn
 

,

58 
CtSvcCCacheWre
 
wreP
,

59 
CtSvcCCacheRd
 
adP
,

60 
CtSvcCFe
 
P
);

62 
svc_l_check
(

63 
CtSvcCtifi
 
ifi
,

64 
CtSvcCtifi
 *
uedSte
,

65 
eSize
,

66 
f
,

67 *
us
,

68 *
urPam
);

70 #ifde
__lulus


	@vcore/src/cert-svc/cerror.h

23 #ide
_CERTSVC_CERROR_H_


24 
	#_CERTSVC_CERROR_H_


	)

26 #ifde
__lulus


30 
	#CERTSVC_TRUE
 (1)

	)

31 
	#CERTSVC_FALSE
 (0)

	)

33 
	#CERTSVC_SUCCESS
 (1)

	)

34 
	#CERTSVC_FAIL
 (0

	)

35 
	#CERTSVC_BAD_ALLOC
 (-2

	)

36 
	#CERTSVC_WRONG_ARGUMENT
 (-4

	)

37 
	#CERTSVC_INVALID_ALGORITHM
 (-5

	)

38 
	#CERTSVC_INVALID_SIGNATURE
 (-6

	)

39 
	#CERTSVC_IO_ERROR
 (-7

	)

40 
	#CERTSVC_INVALID_PASSWORD
 (-8

	)

41 
	#CERTSVC_DUPLICATED_ALIAS
 (-9

	)

42 
	#CERTSVC_ALIAS_DOES_NOT_EXIST
 (-10

	)

43 
	#CERTSVC_INVALID_STORE_TYPE
 (-11

	)

44 
	#CERTSVC_INVALID_STATUS
 (-12

	)

46 #ifde
__lulus


	@vcore/src/cert-svc/cinstance.h

22 #ide
_CERTSVC_CINSTANCE_H_


23 
	#_CERTSVC_CINSTANCE_H_


	)

25 
	~<-svc/.h
>

27 #ifde
__lulus


31 
	sCtSvcIn_t
 {

32 *
iveP
;

33 } 
	tCtSvcIn
;

43 
svc__w
(
CtSvcIn
 *

);

56 
svc__t
(
CtSvcIn
 

);

69 
svc__
(
CtSvcIn
 

);

71 #ifde
__lulus


	@vcore/src/cert-svc/cocsp.h

22 #ide
_CERTSVC_OCSP_C_API_H_


23 
	#_CERTSVC_OCSP_C_API_H_


	)

25 
	~<time.h
>

27 
	~<-svc/c.h
>

29 #ifde
__lulus


33 
	#CERTSVC_OCSP_GOOD
 (1<<0)

	)

34 
	#CERTSVC_OCSP_REVOKED
 (1<<1)

	)

35 
	#CERTSVC_OCSP_UNKNOWN
 (1<<2)

	)

36 
	#CERTSVC_OCSP_VERIFICATION_ERROR
 (1<<3)

	)

37 
	#CERTSVC_OCSP_NO_SUPPORT
 (1<<4)

	)

38 
	#CERTSVC_OCSP_CONNECTION_FAILED
 (1<<5)

	)

39 
	#CERTSVC_OCSP_ERROR
 (1<<6)

	)

55 
svc_oc_check
(
CtSvcCtifi
 *
cha
,

56 
chaSize
,

57 
CtSvcCtifi
 *
ued
,

58 
ueedSize
,

59 cڡ *
u
,

60 *
us
);

62 #ifde
__lulus


	@vcore/src/cert-svc/cpkcs12.h

22 #ide
_CERTSVC_CPKCS12_H_


23 
	#_CERTSVC_CPKCS12_H_


	)

25 
	~<-svc/c.h
>

26 
	~<-svc/crg.h
>

27 
	~<-svc/c.h
>

29 #ifde
__lulus


41 
svc_pkcs12_s_exis
(
CtSvcIn
 

,

42 
CtSvcSg
 
s
,

43 *
is_unique
);

54 
svc_pkcs12_impt_om_fe
(
CtSvcIn
 

,

55 
CtSvcSg
 
th
,

56 
CtSvcSg
 
sswd
,

57 
CtSvcSg
 
s
);

67 
svc_pkcs12_g_id_li
(
CtSvcIn
 

,

68 
CtSvcSgLi
 *
pfxIdSgLi
);

78 
svc_pkcs12_has_sswd
(
CtSvcIn
 

,

79 
CtSvcSg
 
fh
,

80 *
has_sswd
);

92 
svc_pkcs12_ld_ifi_li
(
CtSvcIn
 

,

93 
CtSvcSg
 
s
,

94 
CtSvcCtifiLi
* 
ifiLi
);

107 
svc_pkcs12_ive_key_dup
(
CtSvcIn
 

,

108 
CtSvcSg
 
s
,

109 **
bufr
,

110 
size_t
 *
size
);

117 
svc_pkcs12_ive_key_
(*
bufr
);

126 
svc_pkcs12_de
(
CtSvcIn
 

,

127 
CtSvcSg
 
s
);

141 
svc_pkcs12_ive_key_dup_om_e
(
CtSvcIn
 

,

142 
CtSteTy
 
eTy
,

143 
CtSvcSg
 
gme
,

144 **
Bufr
,

145 
size_t
 *
size
);

158 
svc_pkcs12_t_ifi_us_to_e
(
CtSvcIn
 

,

159 
CtSteTy
 
eTy
,

160 
is_ro_p
,

161 
CtSvcSg
 
gme
,

162 
CtStus
 
us
);

174 
svc_pkcs12_g_ifi_us_om_e
(
CtSvcIn
 

,

175 
CtSteTy
 
eTy
,

176 
CtSvcSg
 
gme
,

177 *
us
);

189 
svc_pkcs12_g_ifi_li_om_e
(
CtSvcIn
 

,

190 
CtSteTy
 
eTy
,

191 
is_ro_p
,

192 
CtSvcSteCtLi
** 
Li
,

193 * 
ngth
);

205 
svc_pkcs12_g_d_ur_ifi_li_om_e
(
CtSvcIn
 

,

206 
CtSteTy
 
eTy
,

207 
CtSvcSteCtLi
** 
Li
,

208 * 
ngth
);

220 
svc_pkcs12_g_ro_ifi_li_om_e
(
CtSvcIn
 

,

221 
CtSteTy
 
eTy
,

222 
CtSvcSteCtLi
** 
Li
,

223 * 
ngth
);

234 
svc_pkcs12__ifi_li_lded_om_e
(
CtSvcIn
 

,

235 
CtSvcSteCtLi
** 
Li
);

246 
svc_pkcs12_g_ifi_om_e
(
CtSvcIn
 

,

247 
CtSteTy
 
eTy
,

248 *
gme
,

249 
CtSvcCtifi
 *
ifi
);

262 
svc_pkcs12_g_ifi_fo_om_e
(
CtSvcIn
 

,

263 
CtSteTy
 
eTy
,

264 
CtSvcSg
 
gme
,

265 ** 
Bufr
,

266 
size_t
* 
Size
);

278 
svc_pkcs12_impt_om_fe_to_e
(
CtSvcIn
 

,

279 
CtSteTy
 
eTy
,

280 
CtSvcSg
 
th
,

281 
CtSvcSg
 
sswd
,

282 
CtSvcSg
 
s
);

292 
svc_pkcs12_de_ifi_om_e
(
CtSvcIn
 

,

293 
CtSteTy
 
eTy
,

294 
CtSvcSg
 
gme
);

305 
svc_pkcs12_check_s_exis__e
(
CtSvcIn
 

,

306 
CtSteTy
 
eTy
,

307 
CtSvcSg
 
s
,

308 *
is_unique
);

320 
svc_pkcs12_ld_ifi_li_om_e
(
CtSvcIn
 

,

321 
CtSteTy
 
eTy
,

322 
CtSvcSg
 
pfxIdSg
,

323 
CtSvcCtifiLi
 *
ifiLi
);

333 
svc_pkcs12_g_s_me_f_ifi__e
(
CtSvcIn
 

,

334 
CtSteTy
 
eTy
,

335 
CtSvcSg
 
gme
,

336 **
s
);

338 #ifde
__lulus


	@vcore/src/cert-svc/cprimitives.h

22 #ide
_CERTSVC_C_API_EXTENDED_H_


23 
	#_CERTSVC_C_API_EXTENDED_H_


	)

25 
	~<ݒs/evp.h
>

26 
	~<ݒs/x509.h
>

28 
	~<-svc/c.h
>

29 
	~<-svc/crg.h
>

31 #ifde
__lulus


45 
svc_ifi_dup_x509
(
CtSvcCtifi
 
ifi
, 
X509
** 

);

52 
svc_ifi__x509
(
X509
 *
x509_cy
);

64 
svc_pkcs12_dup_evp_pkey
(
CtSvcIn
 

,

65 
CtSvcSg
 
s
,

66 
EVP_PKEY
** 
pkey
);

79 
svc_pkcs12_dup_evp_pkey_om_e
(
CtSvcIn
 

,

80 
CtSteTy
 
eTy
,

81 
CtSvcSg
 
gme
,

82 
EVP_PKEY
** 
pkey
);

84 
svc_pkcs12__evp_pkey
(
EVP_PKEY
* 
pkey
);

86 #ifde
__lulus


	@vcore/src/cert-svc/cstring.h

22 #ide
_CERTSVC_CSTRING_H_


23 
	#_CERTSVC_CSTRING_H_


	)

25 
	~<-svc/c.h
>

26 
	~<-svc/crg.h
>

28 #ifde
__lulus


33 
	sCtSvcSgLi_t
 {

34 
iveHdr
;

35 
CtSvcIn
 
iveIn
;

36 } 
	tCtSvcSgLi
;

38 
	sCtSvcSg_t
 {

44 * 
iveHdr
;

45 
iveLgth
;

46 
CtSvcIn
 
iveIn
;

47 } 
	tCtSvcSg
;

58 
svc_rg_w
(

59 
CtSvcIn
 

,

60 cڡ *
put
,

61 
size
,

62 
CtSvcSg
 *
ouut
);

74 
svc_rg_n_maged
(

75 
CtSvcIn
 

,

76 cڡ *
put
,

77 
size
,

78 
CtSvcSg
 *
ouut
);

91 
svc_rg_li_g_e
(
CtSvcSgLi
 
hd
,

92 
posi
,

93 
CtSvcSg
 *
bufr
);

102 
svc_rg_li_g_ngth
(
CtSvcSgLi
 
hd
,*
size
);

109 
svc_rg_
(
CtSvcSg
 
rg
);

118 
svc_rg_li_
(
CtSvcSgLi
 
hdr
);

127 
svc_rg_to_crg
(
CtSvcSg
 
rg
, cڡ **
bufr
, *
n
);

129 #ifde
__lulus


	@vcore/src/dpl/core/include/dpl/abstract_input.h

22 #ide
DPL_ABSTRACT_INPUT_H


23 
	#DPL_ABSTRACT_INPUT_H


	)

25 
	~<d/exi.h
>

26 
	~<memy
>

28 
mea
 
	gVceDPL
 {

29 
ass
 
	gByQueue
;

30 
	gd
::
	tauto_r
<
	tByQueue
> 
	tByQueueAutoP
;

32 as
	cAbIut


34 
	gpublic
:

35 as
	cExi


37 
public
:

38 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

39 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
RdFaed
)

42 
	gpublic
:

43 
vtu
 ~
AbIut
() {}

54 
vtu
 
ByQueueAutoP
 
Rd
(
size_t
 
size
) = 0;

	@vcore/src/dpl/core/include/dpl/abstract_input_output.h

22 #ide
DPL_ABSTRACT_INPUT_OUTPUT_H


23 
	#DPL_ABSTRACT_INPUT_OUTPUT_H


	)

25 
	~<d/ab_put.h
>

26 
	~<d/ab_ouut.h
>

28 
mea
 
	gVceDPL
 {

29 
ass
 
	gAbIutOuut
 :

30 
public
 
AbIut
,

31 
public
 
	gAbOuut


33 
	gpublic
:

34 
vtu
 ~
AbIutOuut
() {}

	@vcore/src/dpl/core/include/dpl/abstract_output.h

22 #ide
DPL_ABSTRACT_OUTPUT_H


23 
	#DPL_ABSTRACT_OUTPUT_H


	)

25 
	~<d/exi.h
>

26 
	~<memy
>

28 
mea
 
	gVceDPL
 {

29 
ass
 
	gByQueue
;

30 
	gd
::
	tauto_r
<
	tByQueue
> 
	tByQueueAutoP
;

32 as
	cAbOuut


34 
	gpublic
:

35 as
	cExi


37 
public
:

38 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

39 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
WreFaed
)

42 
	gpublic
:

43 
vtu
 ~
AbOuut
() {}

56 
vtu
 
size_t
 
Wre
(cڡ 
ByQueue
 &
bufr
, size_
bufrSize
) = 0;

	@vcore/src/dpl/core/include/dpl/abstract_waitable_input.h

22 #ide
DPL_ABSTRACT_WAITABLE_INPUT_H


23 
	#DPL_ABSTRACT_WAITABLE_INPUT_H


	)

25 
	~<d/waab_hd.h
>

26 
	~<d/ab_put.h
>

28 
mea
 
	gVceDPL
 {

29 as
	cAbWaabIut
 :

30 
public
 
AbIut


32 
public
:

33 
vtu
 ~
AbWaabIut
() {}

35 
vtu
 
WaabHd
 
WaabRdHd
() const = 0;

	@vcore/src/dpl/core/include/dpl/assert.h

22 #ide
DPL_ASSERT_H


23 
	#DPL_ASSERT_H


	)

25 
mea
 
	gVceDPL
 {

29 
AsProc
(cڡ *
cdi
,

30 cڡ *
fe
,

31 
le
,

32 cڡ *
funi

__ibu__
 ((
__nܑu__
));

35 
	#As
(
Cdi
) \

37 i(!(
Cdi
)) { \

38 
VceDPL
::
	`AsProc
(#Cdi, 
__FILE__
, 
__LINE__
, 
__FUNCTION__
); \

40 } 0)

	)

42 
	#AsMsg
(
Cdi
, 
Msg
) \

44 i(!(
Cdi
)) { \

45 
VceDPL
::
	`AsProc
( \

46 (
d
::
	`rg
(d::rg(#Cdi)+" "+ 
Msg
).
	`c_r
(), \

47 
__FILE__
, 
__LINE__
, 
__FUNCTION__
); \

49 } 0)

	)

	@vcore/src/dpl/core/include/dpl/availability.h

21 #ide
DPL_AVAILABILITY_H


22 
	#DPL_AVAILABILITY_H


	)

24 
	#DPL_DEPRECATED
 
	`__ibu__
((
dd
))

	)

25 
	#DPL_DEPRECATED_WITH_MESSAGE
(
msg

	`__ibu__
((
	`dd
(msg)))

	)

27 
	#DPL_UNUSED
 
	`__ibu__
((
unud
))

	)

28 
	#DPL_UNUSED_PARAM
(
vb
()
	)
variable

	@vcore/src/dpl/core/include/dpl/binary_queue.h

22 #ide
DPL_BINARY_QUEUE_H


23 
	#DPL_BINARY_QUEUE_H


	)

25 
	~<d/ab_put_ouut.h
>

26 
	~<d/exi.h
>

27 
	~<d/ncyab.h
>

28 
	~<memy
>

29 
	~<li
>

31 
mea
 
	gVceDPL
 {

37 as
	cByQueue
 :

38 
public
 
AbIutOuut


40 
public
:

41 as
	cExi


43 
public
:

44 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

45 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
OutOfDa
)

48 (*
	gBufrD
)(cڡ *
	tbufr
, 
	tsize_t
 
	tbufrSize
,

49 *
	turPam
);

50 
BufrDFe
(cڡ *
bufr
,

51 
size_t
 
bufrSize
,

52 *
urPam
);

54 as
	cBuckVis


56 
	gpublic
:

60 
vtu
 ~
BuckVis
();

69 
vtu
 
OnVisBuck
(cڡ *
bufr
, 
size_t
 
bufrSize
) = 0;

72 
	give
:

73 
Buck
 :

74 
ive
 
Ncyab


76 cڡ *
bufr
;

77 cڡ *
	gr
;

78 
size_t
 
	gsize
;

79 
size_t
 
	g
;

81 
BufrD
 
	gd
;

82 *
	gm
;

84 
Buck
(cڡ *
bufr
,

85 
size_t
 
bufrSize
,

86 
BufrD
 
d
,

87 *
urPam
);

88 
	gvtu
 ~
Buck
();

91 
	gd
::
	tli
<
	tBuck
 *> 
	tBuckLi
;

92 
BuckLi
 
	gm_bucks
;

93 
size_t
 
	gm_size
;

95 
DeBuck
(
Buck
 *
buck
);

97 as
	cBuckVisCl


99 
	give
:

100 
BuckVis
 *
m_vis
;

102 
	gpublic
:

103 
BuckVisCl
(
BuckVis
 *
vis
);

104 
	gvtu
 ~
BuckVisCl
();

106 
ݔ
()(
Buck
 *
	gbuck
) const;

109 
	gpublic
:

113 
ByQueue
();

121 
ByQueue
(cڡ ByQueu&
h
);

126 
	gvtu
 ~
ByQueue
();

134 
	gByQueue
 &
	gݔ
=(cڡ 
ByQueue
 &
h
);

146 
AdCy
(cڡ *
bufr
, 
size_t
 
bufrSize
);

161 
AdUnmaged
(

162 cڡ *
bufr
,

163 
size_t
 
bufrSize
,

164 
BufrD
 
d
 =

165 &
ByQueue
::
BufrDFe
,

166 *
urPam
 = 
NULL
);

177 
AdCyFrom
(cڡ 
ByQueue
 &
h
);

190 
AdMoveFrom
(
ByQueue
 &
h
);

200 
AdCyTo
(
ByQueue
 &
h
) const;

213 
AdMoveTo
(
ByQueue
 &
h
);

220 
size_t
 
Size
() const;

227 
Cˬ
();

234 
bo
 
Emy
() const;

244 
Csume
(
size_t
 
size
);

256 
Fω
(*
bufr
, 
size_t
 
bufrSize
) const;

268 
FωCsume
(*
bufr
, 
size_t
 
bufrSize
);

277 
VisBucks
(
BuckVis
 *
vis
) const;

282 
vtu
 
ByQueueAutoP
 
Rd
(
size_t
 
size
);

287 
vtu
 
size_t
 
Wre
(cڡ 
ByQueue
 &
bufr
, size_
bufrSize
);

293 
	gd
::
	tauto_r
<
	tByQueue
> 
	tByQueueAutoP
;

	@vcore/src/dpl/core/include/dpl/char_traits.h

25 #ide
DPL_CHAR_TRAITS


26 
	#DPL_CHAR_TRAITS


	)

28 
	~<crg
>

29 
	~<rg
>

30 
	~<oam
>

31 
	~<gܙhm
>

32 
	~<d/exi.h
>

34 
mea
 
	gVceDPL
 {

35 
	gd
::
	tch_as
<
	twch_t
> 
	tChTs
;

	@vcore/src/dpl/core/include/dpl/colors.h

24 #ide
DPL_COLORS_H


25 
	#DPL_COLORS_H


	)

27 
mea
 
	gVceDPL
 {

28 
mea
 
	gCs
 {

29 
mea
 
	gText
 {

30 cڡ * 
BOLD_GREEN_BEGIN
;

31 cڡ * 
BOLD_GREEN_END
;

32 cڡ * 
PURPLE_BEGIN
;

33 cڡ * 
PURPLE_END
;

34 cڡ * 
RED_BEGIN
;

35 cڡ * 
RED_END
;

36 cڡ * 
GREEN_BEGIN
;

37 cڡ * 
GREEN_END
;

38 cڡ * 
CYAN_BEGIN
;

39 cڡ * 
CYAN_END
;

40 cڡ * 
BOLD_RED_BEGIN
;

41 cڡ * 
BOLD_RED_END
;

42 cڡ * 
BOLD_YELLOW_BEGIN
;

43 cڡ * 
BOLD_YELLOW_END
;

44 cڡ * 
BOLD_GOLD_BEGIN
;

45 cڡ * 
BOLD_GOLD_END
;

46 cڡ * 
BOLD_WHITE_BEGIN
;

47 cڡ * 
BOLD_WHITE_END
;

50 
mea
 
	gHtml
 {

51 cڡ * 
BOLD_GREEN_BEGIN
;

52 cڡ * 
BOLD_GREEN_END
;

53 cڡ * 
PURPLE_BEGIN
;

54 cڡ * 
PURPLE_END
;

55 cڡ * 
RED_BEGIN
;

56 cڡ * 
RED_END
;

57 cڡ * 
GREEN_BEGIN
;

58 cڡ * 
GREEN_END
;

59 cڡ * 
CYAN_BEGIN
;

60 cڡ * 
CYAN_END
;

61 cڡ * 
BOLD_RED_BEGIN
;

62 cڡ * 
BOLD_RED_END
;

63 cڡ * 
BOLD_YELLOW_BEGIN
;

64 cڡ * 
BOLD_YELLOW_END
;

65 cڡ * 
BOLD_GOLD_BEGIN
;

66 cڡ * 
BOLD_GOLD_END
;

67 cڡ * 
BOLD_WHITE_BEGIN
;

68 cڡ * 
BOLD_WHITE_END
;

	@vcore/src/dpl/core/include/dpl/errno_string.h

22 #ide
DPL_ERRNO_STRING_H


23 
	#DPL_ERRNO_STRING_H


	)

25 
	~<d/exi.h
>

26 
	~<rg
>

27 
	~<no
>

29 
mea
 
	gVceDPL
 {

30 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
InvidEnoVue
)

32 
	gd
::
rg
 
GEnoSg
(
r
 = 
o
);

	@vcore/src/dpl/core/include/dpl/exception.h

22 #ide
VceDPL_EXCEPTION_H


23 
	#VceDPL_EXCEPTION_H


	)

25 
	~<rg
>

26 
	~<crg
>

27 
	~<cdio
>

28 
	~<exi
>

29 
	~<cdlib
>

30 
	~<sam
>

32 
mea
 
	gVceDPL
 {

33 
LogUnhddExi
(cڡ 
d
::
rg
 &
r
);

34 
LogUnhddExi
(cڡ 
d
::
rg
 &
r
,

35 cڡ *
fame
,

36 
le
,

37 cڡ *
funi
);

40 
mea
 
	gVceDPL
 {

41 as
	cExi
 {

42 
	give
:

43 
m_exiCou
;

44 
Exi
* 
	gm_ϡExi
;

45 (*
	gm_rmeHdr
)();

47 
AddRef
(
Exi
* 
exi
)

49 i(!
	gm_exiCou
) {

50 
	gm_rmeHdr
 = 
d
::
t_rme
(&
TmeHdr
);

53 ++
	gm_exiCou
;

54 
	gm_ϡExi
 = 
exi
;

57 
UnRef
(
Exi
* 
e
)

59 i(
	gm_ϡExi
 =
e
) {

60 
m_ϡExi
 = 
NULL
;

63 --
	gm_exiCou
;

65 i(!
	gm_exiCou
) {

66 
	gd
::
t_rme
(
m_rmeHdr
);

67 
	gm_rmeHdr
 = 
NULL
;

71 
TmeHdr
()

73 i(
	gm_ϡExi
 !
NULL
) {

74 
DiyKnownExi
(*
m_ϡExi
);

75 
abt
();

77 
DiyUnknownExi
();

78 
abt
();

82 
Exi
 *
	gm_as
;

83 
	gd
::
rg
 
m_th
;

84 
	gd
::
rg
 
m_funi
;

85 
	gm_le
;

87 
	geed
:

88 
d
::
rg
 
m_mesge
;

89 
	gd
::
rg
 
m_assName
;

91 
	gpublic
:

92 
d
::
rg
 
KnownExiToSg
(cڡ 
Exi
 &
e
)

94 
d
::
orgam
 
mesge
;

95 
	gmesge
 <<

97 
	gmesge
 << "\033[1;33mExceptionrace:\033[m\n\n";

98 
	gmesge
 << 
	ge
.
DumpToSg
();

99 
	gmesge
 << "\033[1;31m\n=== Willowbort ===\033[m\n";

101  
	gmesge
.
r
();

104 
	gd
::
rg
 
UnknownExiToSg
()

106 
d
::
orgam
 
mesge
;

107 
	gmesge
 <<

109 
	gmesge
 << "\033[1;31m\n=== Willowbort ===\033[m\n";

111  
	gmesge
.
r
();

114 
DiyKnownExi
(cڡ 
Exi
& 
e
)

116 
LogUnhddExi
(
KnownExiToSg
(
e
).
c_r
());

119 
DiyUnknownExi
()

121 
LogUnhddExi
(
UnknownExiToSg
().
c_r
());

124 
Exi
(cڡ Exi &
h
)

127 i(
	gh
.
	gm_as
 !
NULL
) {

128 
m_as
 = 
w
 
Exi
(*
h
.m_reason);

130 
	gm_as
 = 
NULL
;

133 
	gm_mesge
 = 
h
.
m_mesge
;

134 
	gm_th
 = 
h
.
m_th
;

135 
	gm_funi
 = 
h
.
m_funi
;

136 
	gm_le
 = 
h
.
m_le
;

138 
	gm_assName
 = 
h
.
m_assName
;

140 
AddRef
(
this
);

143 cڡ 
	gExi
 &
	gݔ
 =(cڡ 
Exi
 &
h
)

145 i(
this
 =&
h
) {

146  *
this
;

150 i(
	gh
.
	gm_as
 !
NULL
) {

151 
m_as
 = 
w
 
Exi
(*
h
.m_reason);

153 
	gm_as
 = 
NULL
;

156 
	gm_mesge
 = 
h
.
m_mesge
;

157 
	gm_th
 = 
h
.
m_th
;

158 
	gm_funi
 = 
h
.
m_funi
;

159 
	gm_le
 = 
h
.
m_le
;

161 
	gm_assName
 = 
h
.
m_assName
;

163 
AddRef
(
this
);

165  *
	gthis
;

168 
Exi
(cڡ *
th
,

169 cڡ *
funi
,

170 
le
,

171 cڡ 
d
::
rg
 &
mesge
) :

172 
m_as
(
NULL
),

173 
m_th
(
th
),

174 
m_funi
(
funi
),

175 
m_le
(
le
),

176 
m_mesge
(
mesge
)

178 
AddRef
(
this
);

181 
Exi
(cڡ *
th
,

182 cڡ *
funi
,

183 
le
,

184 cڡ 
Exi
 &
as
,

185 cڡ 
d
::
rg
 &
mesge
) :

186 
m_as
(
w
 
Exi
(
as
)),

187 
m_th
(
th
),

188 
m_funi
(
funi
),

189 
m_le
(
le
),

190 
m_mesge
(
mesge
)

192 
AddRef
(
this
);

195 
	gvtu
 ~
Exi
(
throw
()

197 i(
	gm_as
 !
NULL
) {

198 
de
 
m_as
;

199 
	gm_as
 = 
NULL
;

202 
UnRef
(
this
);

205 
Dump
() const

208 i(
	gm_as
 !
NULL
) {

209 
m_as
->
Dump
();

213 cڡ *
	gfe
 = 
rchr
(
m_th
.
c_r
(), '/');

215 i(
	gfe
 =
NULL
) {

216 
fe
 = 
m_th
.
c_r
();

218 ++
	gfe
;

221 
tf
("\033[0;36m[%s:%i]\033[m %s() \033[4;35m%s\033[m: %s\033[m\n",

222 
fe
, 
m_le
,

223 
m_funi
.
c_r
(),

224 
m_assName
.
c_r
(),

225 
m_mesge
.
emy
(? "<EMPTY>" : m_mesge.
c_r
());

228 
	gd
::
rg
 
DumpToSg
() const

230 
d
::
rg
 
t
;

231 i(
	gm_as
 !
NULL
) {

232 
t
 = 
m_as
->
DumpToSg
();

235 cڡ *
	gfe
 = 
rchr
(
m_th
.
c_r
(), '/');

237 i(
	gfe
 =
NULL
) {

238 
fe
 = 
m_th
.
c_r
();

240 ++
	gfe
;

243 
	gbuf
[1024];

244 
tf
(
buf
,

245 (
buf
),

247 
fe
,

248 
m_le
,

249 
m_funi
.
c_r
(),

250 
m_assName
.
c_r
(),

251 
m_mesge
.
emy
(? "<EMPTY>" : m_mesge.
c_r
());

253 
	gbuf
[(
buf
) - 1] = '\n';

254 
	gt
 +
buf
;

256  
	gt
;

259 
Exi
 *
GRs
() const

261  
	gm_as
;

264 
	gd
::
rg
 
GPh
() const

266  
m_th
;

269 
	gd
::
rg
 
GFuni
() const

271  
m_funi
;

274 
GLe
() const

276  
	gm_le
;

279 
	gd
::
rg
 
GMesge
() const

281  
m_mesge
;

284 
	gd
::
rg
 
GCssName
() const

286  
m_assName
;

291 
	#Try
 
y


	)

293 
	#Throw
(
CssName
) \

294 
throw
 
	`CssName
(
__FILE__
, 
__FUNCTION__
, 
__LINE__
)

	)

296 
	#ThrowMsg
(
CssName
, 
Mesge
) \

299 
d
::
orgam
 
dLogggSm
; \

300 
dLogggSm
 << 
Mesge
; \

301 
throw
 
	`CssName
(
__FILE__
, 
__FUNCTION__
, 
__LINE__
, 
dLogggSm
.
	`r
()); \

302 } 0)

	)

304 
	#ReThrow
(
CssName
) \

305 
throw
 
	`CssName
(
__FILE__
, 
__FUNCTION__
, 
__LINE__
, 
_thrown_exi
)

	)

307 
	#ReThrowMsg
(
CssName
, 
Mesge
) \

308 
throw
 
	`CssName
(
__FILE__
, \

309 
__FUNCTION__
, \

310 
__LINE__
, \

311 
_thrown_exi
, \

312 
Mesge
)

	)

314 
	#Cch
(
CssName
) \

315 
	`tch
 (cڡ 
CssName
 &
_thrown_exi
)

	)

317 
	#DECLARE_EXCEPTION_TYPE
(
BaCss
, 
Css
) \

318 as
	cCss
 : 
public
 
BaCss
 { \

319 
public
: \

320 
	`Css
(cڡ *
th
, \

321 cڡ *
funi
, \

322 
le
, \

323 cڡ 
d
::
rg
 & 
mesge
 = std::
	`rg
()) \

324 : 
	$BaCss
(
th
, 
funi
, 
le
, 
mesge
) { \

326 
BaCss
::
m_assName
 = #Class; \

329 
	`Css
(cڡ *
th
, \

330 cڡ *
funi
, \

331 
le
, \

332 cڡ 
VceDPL
::
Exi
 & 
as
, \

333 cڡ 
d
::
rg
 & 
mesge
 = std::
	`rg
()) \

334 : 
	$BaCss
(
th
, 
funi
, 
le
, 
as
, 
mesge
) { \

335 
BaCss
::
m_assName
 = #Class; \

336 
	}
} \

337 };

	)

339 
	#UNHANDLED_EXCEPTION_HANDLER_BEGIN
 
y


	)

341 
	#UNHANDLED_EXCEPTION_HANDLER_END
 \

342 
	`tch
 (cڡ 
VceDPL
::
Exi
 &
exi
) \

344 
d
::
orgam
 
msg
; \

345 
msg
 << 
VceDPL
::
Exi
::
	`KnownExiToSg
(
exi
); \

346 
VceDPL
::
	`LogUnhddExi
(
msg
.
	`r
(), \

347 
__FILE__
, \

348 
__LINE__
, \

349 
__FUNCTION__
); \

350 
	`abt
(); \

352 
	`tch
 (
d
::
exi
& 
e
) \

354 
d
::
orgam
 
msg
; \

355 
msg
 << 
e
.
	`wh
(); \

356 
msg
 << "\n"; \

357 
msg
 << 
VceDPL
::
Exi
::
	`UnknownExiToSg
(); \

358 
VceDPL
::
	`LogUnhddExi
(
msg
.
	`r
(), \

359 
__FILE__
, \

360 
__LINE__
, \

361 
__FUNCTION__
); \

362 
	`abt
(); \

364 
	`tch
 (...) \

366 
d
::
orgam
 
msg
; \

367 
msg
 << 
VceDPL
::
Exi
::
	`UnknownExiToSg
(); \

368 
VceDPL
::
	`LogUnhddExi
(
msg
.
	`r
(), \

369 
__FILE__
, \

370 
__LINE__
, \

371 
__FUNCTION__
); \

372 
	`abt
(); \

373 }

	)

375 
mea
 
	gVceDPL
 {

376 
mea
 
	gCommExi
 {

384 
DECLARE_EXCEPTION_TYPE
(
Exi
, 
IlE
)

	@vcore/src/dpl/core/include/dpl/file_input.h

22 #ide
DPL_FILE_INPUT_H


23 
	#DPL_FILE_INPUT_H


	)

25 
	~<d/ncyab.h
>

26 
	~<d/exi.h
>

27 
	~<d/ab_waab_put.h
>

29 
mea
 
	gVceDPL
 {

30 
ass
 
	gFeIut
 :

31 
ive
 
Ncyab
,

32 
public
 
	gAbWaabIut


34 
	gpublic
:

35 as
	cExi


37 
public
:

38 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

39 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
OnFaed
)

40 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
CloFaed
)

43 
	geed
:

44 
m_fd
;

46 
	gpublic
:

47 
FeIut
();

48 
FeIut
(cڡ 
d
::
rg
 &
feName
);

49 
	gvtu
 ~
FeIut
();

51 
On
(cڡ 
d
::
rg
 &
feName
);

52 
Clo
();

55 
vtu
 
ByQueueAutoP
 
Rd
(
size_t
 
size
);

58 
vtu
 
WaabHd
 
WaabRdHd
() const;

	@vcore/src/dpl/core/include/dpl/foreach.h

24 #ide
DPL_FOREACH_H


25 
	#DPL_FOREACH_H


	)

27 
	~<d/ross.h
>

29 
mea
 
	gVceDPL
 {

30 
mea
 
	gPrive
 {

34 
	gme
 <
tyme
 
	gT
>

35 
	gT
& 
VueRen
(
T
& 
t
)

37 (
	gt
);

40 
	gme
 <
tyme
 
	gT
>

41 cڡ 
	gT
& 
VueRen
(cڡ 
T
& 
t
)

43 (
	gt
);

48 
	#DPL_FOREACH_IMPL
(
mpܬyName
, 

, 
cڏ
) \

49 
	`__tyof__
 (
VceDPL
::
Prive
::
	`VueRen
((
cڏ
))) & \

50 
mpܬyName
 = (
cڏ
); \

51 
	`__tyof__
 (
mpܬyName
.
	`beg
())

 = \

52 
mpܬyName
.
	`beg
(); \

53 (

!
mpܬyName
.
	`d
(); ++)

	)

55 
	#FOREACH
(

, 
cڏ
) \

56 
	`DPL_FOREACH_IMPL
( \

57 
	`DPL_MACRO_CONCAT
(
fܗchCڏRen
, 
__COUNTER__
), \

58 

, \

59 
cڏ
)

	)

	@vcore/src/dpl/core/include/dpl/free_deleter.h

22 #ide
FREE_DELETER_H


23 
	#FREE_DELETER_H


	)

25 
	~<cdlib
>

26 
mea
 
	gVceDPL


28 
	s_d


30 
ݔ
()(*
	gp
{ 
	gd
::

(
p
); }

	@vcore/src/dpl/core/include/dpl/lexical_cast.h

22 #ide
DPL_LEXICAL_CAST_H


23 
	#DPL_LEXICAL_CAST_H


	)

25 
	~<sam
>

27 
mea
 
	gVceDPL
 {

28 
	gme
<
tyme
 
	gTgTy
,ym
	gSourTy
>

29 
TgTy
 
xil_
(cڡ 
SourTy
 &
da
)

31 
TgTy
 
	gsu
;

33 
	gd
::
orgam
 
out
;

34 
	gout
 << 
	gda
;

36 
	gd
::
irgam
 

(
out
.
r
());

37 
	g
 >> 
	gsu
;

39  
	gsu
;

	@vcore/src/dpl/core/include/dpl/noncopyable.h

22 #ide
DPL_NONCOPYABLE_H


23 
	#DPL_NONCOPYABLE_H


	)

25 
mea
 
	gVceDPL
 {

26 as
	cNcyab


28 
	give
:

29 
Ncyab
(const Noncopyable &);

30 cڡ 
	gNcyab
 &
	gݔ
=(cڡ 
Ncyab
 &);

32 
	gpublic
:

33 
Ncyab
();

34 
	gvtu
 ~
Ncyab
();

	@vcore/src/dpl/core/include/dpl/optional.h

22 #ide
DPL_OPTIONAL_H


23 
	#DPL_OPTIONAL_H


	)

25 
	~<d/exi.h
>

26 
	~<d/avaaby.h
>

28 
mea
 
	gVceDPL
 {

29 
	gme
 <
tyme
 
	gTy
>

30 as
	cOiڮ


32 as
	cExi


34 
	gpublic
:

35 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

36 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
NuRen
)

39 
	gpublic
:

40 
Oiڮ
() :

41 
m_nu
(
ue
),

42 
m_vue
()

45 
Oiڮ
(cڡ 
Ty
& 
t
) :

46 
m_nu
(
l
),

47 
m_vue
(
t
)

50 
bo
 
IsNu
() const

52  
	gm_nu
;

55 
	gTy
& 
	gݔ
*()

57 i(
	gm_nu
) {

58 
Throw
(
tyme
 
Exi
::
NuRen
);

60  
	gm_vue
;

63 cڡ 
	gTy
& 
	gݔ
*() const

65 i(
	gm_nu
) {

66 
Throw
(
tyme
 
Exi
::
NuRen
);

68  
	gm_vue
;

71 cڡ 
Ty
* 
	gݔ
->() const

73 i(
	gm_nu
) {

74 
Throw
(
tyme
 
Exi
::
NuRen
);

76  &
	gm_vue
;

79 
Ty
* 
	gݔ
->()

81 i(
	gm_nu
) {

82 
Throw
(
tyme
 
Exi
::
NuRen
);

84  &
	gm_vue
;

87 
bo
 
	gݔ
!() const

89  
	gm_nu
;

92 
	gOiڮ
<
	gTy
>& 
	gݔ
=(cڡ 
Ty
& 
h
)

94 
m_nu
 = 
l
;

95 
	gm_vue
 = 
h
;

96  *
	gthis
;

99 
bo
 
	gݔ
==(cڡ 
Oiڮ
<
Ty
>& 
aSecd
) const

101  
LogilOt
<
ue
>(*
this
, 
aSecd
,

102 
d
::
equ_to
<
Ty
>(), std::equ_to<
bo
>());

105 
bo
 
	gݔ
==(cڡ 
Ty
& 
aSecd
) const

107  
Oiڮ
<
Ty
>(
aSecd
=*
this
;

110 
bo
 
	gݔ
!=(cڡ 
Oiڮ
<
Ty
>& 
aSecd
) const

112  !(*
this
 =
aSecd
);

115 
bo
 
	gݔ
<(cڡ 
	gOiڮ
<
	gTy
>& 
	gaSecd
) const

117  
	gLogilOt
<
	gl
>(*
	gthis
, 
	gaSecd
,

118 
	gd
::
ss
<
Ty
>(), std::ss<
bo
>());

121 
bo
 
	gݔ
>(cڡ 
	gOiڮ
<
	gTy
>& 
	gaSecd
) const

123  
	gLogilOt
<
	gl
>(*
	gthis
, 
	gaSecd
,

124 
	gd
::
g
<
Ty
>(), std::g<
bo
>());

127 
bo
 
	gݔ
<=(cڡ 
Oiڮ
<
Ty
>& 
aSecd
) const

129  *
this
 =
aSecd
 || *this <Second;

132 
bo
 
	gݔ
>=(cڡ 
Oiڮ
<
Ty
>& 
aSecd
) const

134  *
this
 =
aSecd
 || *this >Second;

137 
	gOiڮ
<
	gTy
> 
	gNu
;

139 
	give
:

140 
bo
 
m_nu
;

141 
Ty
 
	gm_vue
;

143 
	gme
 <
bo
 
	gEquy
, 
tyme
 
	gComt
,ym
	gNuComt
>

144 
bo
 
LogilOt
(cڡ 
Oiڮ
<
Ty
>& 
aF
,

145 cڡ 
Oiڮ
<
Ty
>& 
aSecd
,

146 
Comt
 
aComt
,

147 
NuComt
 
aNuComt
)

149 i(
	gaF
.
	gm_nu
 =
aSecd
.
m_nu
) {

150 i(
aF
.
m_nu
) {

151  
Equy
;

153  
aComt
(
aF
.
m_vue
, 
aSecd
.m_value);

156  
aNuComt
(
aF
.
m_nu
, 
aSecd
.m_null);

159 } 
DPL_DEPRECATED_WITH_MESSAGE
("Use boost::optional instead");

161 
	gme
<
tyme
 
	gTy
>

162 
	gOiڮ
<
	gTy
> Oiڮ<Ty>::
Nu
 = 
Oiڮ
<
Ty
>();

165 
	gme
<
tyme
 
	gTy
>

166 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
aSm
,

167 cڡ 
	gVceDPL
::
Oiڮ
<
Ty
>& 
aOiڮ
)

169 i(
aOiڮ
.
IsNu
()) {

170  
aSm
 << "null optional";

172  
	gaSm
 << *
	gaOiڮ
;

	@vcore/src/dpl/core/include/dpl/optional_typedefs.h

16 #ide
DPL_OPTIONAL_TYPEDEFS_H


17 
	#DPL_OPTIONAL_TYPEDEFS_H


	)

19 
	~<rg
>

20 
	~<d/rg.h
>

21 
	~<boo/tiڮ.h
>

23 
mea
 
	gVceDPL
 {

24 
	gboo
::
	ttiڮ
<
	tSg
> 
	tOiڮSg
;

25 
	gboo
::
	ttiڮ
<> 
	tOiڮI
;

26 
	gboo
::
	ttiڮ
<> 
	tOiڮUI
;

27 
	gboo
::
	ttiڮ
<
	tbo
> 
	tOiڮBo
;

28 
	gboo
::
	ttiڮ
<> 
	tOiڮFlt
;

29 
	gboo
::
	ttiڮ
<
	td
::
	trg
> 
	tOiڮStdSg
;

	@vcore/src/dpl/core/include/dpl/preprocessor.h

23 #ide
DPL_PREPROCESSOR_H


24 
	#DPL_PREPROCESSOR_H


	)

26 
	#DPL_MACRO_CONCAT_IMPL
(
x
, 
y
x##
	)
y

27 
	#DPL_MACRO_CONCAT
(
x
, 
y

	`DPL_MACRO_CONCAT_IMPL
(x, y)

	)

29 #ifde
__COUNTER__


30 
	#DPL_ANONYMOUS_VARIABLE
(
me

	`DPL_MACRO_CONCAT
ame, 
__COUNTER__
)

	)

32 
	#DPL_ANONYMOUS_VARIABLE
(
me

	`DPL_MACRO_CONCAT
ame, 
__LINE__
)

	)

	@vcore/src/dpl/core/include/dpl/scoped_array.h

24 #ide
DPL_SCOPED_ARRAY_H


25 
	#DPL_SCOPED_ARRAY_H


	)

27 
	~<cddef
>

29 
	~<d/as.h
>

30 
	~<d/sced_sour.h
>

31 
	~<d/avaaby.h
>

33 
mea
 
	gVceDPL
 {

34 
	gme
<
tyme
 
	gCss
>

35 
	sScedAayPicy


37 
Css
* 
	tTy
;

38 
Ty
 
NuVue
()

40  
	gNULL
;

42 
Deroy
(
Ty
 
r
)

44 
	gde
[] 
	gr
;

48 
	gme
<
tyme
 
	gCss
>

49 
ass
 
	gScedAay
 : 
public
 
ScedResour
<
ScedAayPicy
<
Css
> >

51 
ScedAayPicy
<
	tCss
> 
	tPicy
;

52 
	gScedResour
<
	tPicy
> 
	tBaTy
;

54 
	gpublic
:

55 
exic
 
ScedAay
(
Css
 *
r
 = 
Picy
::
NuVue
(): 
BaTy
(ptr) { }

57 
Css
 &
ݔ
 [](
d
::
rdiff_t
 
k
) const

59 
As
(
this
->
m_vue
 !
Picy
::
NuVue
() &&

61 
As
(
k
 >= 0 && "Negativerray index");

63  
	gthis
->
	gm_vue
[
k
];

65 } 
DPL_DEPRECATED_WITH_MESSAGE
("use standard C++11 feature: std::unique_ptr<Type[]>");

	@vcore/src/dpl/core/include/dpl/scoped_fclose.h

22 #ide
DPL_SCOPED_FCLOSE_H


23 
	#DPL_SCOPED_FCLOSE_H


	)

25 
	~<unid.h
>

26 
	~<no
>

27 
	~<cdio
>

28 
	~<rg
>

29 
	~<d/log/vce_log.h
>

30 
	~<d/sced_sour.h
>

31 
	~<d/o_rg.h
>

33 
mea
 
	gVceDPL
 {

34 
	sScedFCloPicy


36 
FILE
* 
	tTy
;

37 
Ty
 
NuVue
()

39  
	gNULL
;

41 
Deroy
(
Ty
 
fe
)

43 i(
	gfe
 !
NULL
) {

45 i(
TEMP_FAILURE_RETRY
(
fush
(
fe
)) != 0) {

46 
d
::
rg
 
rSg
 = 
GEnoSg
();

47 
VceLogD
("Failedo fflush scoped fcloserror: %s",

48 
rSg
.
c_r
());

52 i(
fo
(
fe
) != 0) {

53 
d
::
rg
 
rSg
 = 
GEnoSg
();

54 
VceLogD
("Faed sced fo: %s", 
rSg
.
c_r
());

60 
ass
 
	gScedFClo
 : 
public
 
ScedResour
<
ScedFCloPicy
>

62 
ScedFCloPicy
 
	tPicy
;

63 
	gScedResour
<
	tPicy
> 
	tBaTy
;

65 
	gpublic
:

66 
exic
 
ScedFClo
(
FILE
* 
gFeSm
 = 
Picy
::
NuVue
()) :

67 
BaTy
(
gFeSm
)

	@vcore/src/dpl/core/include/dpl/scoped_free.h

23 #ide
DPL_SCOPED_FREE_H


24 
	#DPL_SCOPED_FREE_H


	)

26 
	~<mloc.h
>

27 
	~<cddef
>

29 
	~<d/sced_sour.h
>

31 
mea
 
	gVceDPL
 {

32 
	gme
<
tyme
 
	gCss
>

33 
	sScedFePicy


35 
Css
* 
	tTy
;

36 
Ty
 
NuVue
()

38  
	gNULL
;

40 
Deroy
(
Ty
 
r
)

42 

(
r
);

46 
	gme
<
tyme
 
	gMemy
>

47 
ass
 
	gScedFe
 : 
public
 
ScedResour
<
ScedFePicy
<
Memy
> >

49 
ScedFePicy
<
	tMemy
> 
	tPicy
;

50 
	gScedResour
<
	tPicy
> 
	tBaTy
;

52 
	gpublic
:

53 
exic
 
ScedFe
(
Memy
 *
r
 = 
Picy
::
NuVue
(): 
BaTy
(ptr) { }

	@vcore/src/dpl/core/include/dpl/scoped_resource.h

22 #ide
DPL_SCOPED_RESOURCE_H


23 
	#DPL_SCOPED_RESOURCE_H


	)

25 
	~<d/ncyab.h
>

27 
mea
 
	gVceDPL
 {

28 
	gme
<
tyme
 
	gCssPicy
>

29 as
	cScedResour
 :

30 
ive
 
Ncyab


32 
public
:

33 
tyme
 
	tCssPicy
::
	tTy
 
	tVueTy
;

34 
	gScedResour
<
	tCssPicy
> 
	tThisTy
;

36 
	geed
:

37 
VueTy
 
m_vue
;

39 
	gpublic
:

40 
exic
 
ScedResour
(
VueTy
 
vue
: 
m_vue
(value) { }

42 ~
ScedResour
()

44 
CssPicy
::
Deroy
(
m_vue
);

47 
VueTy
 
G
() const

49  
	gm_vue
;

52 
Ret
(
VueTy
 
vue
 = 
CssPicy
::
NuVue
())

54 
CssPicy
::
Deroy
(
m_vue
);

55 
	gm_vue
 = 
vue
;

58 
VueTy
 
R
()

60 
VueTy
 
	gvue
 = 
m_vue
;

61 
	gm_vue
 = 
CssPicy
::
NuVue
();

62  
	gvue
;

64 
VueTy
 
	tThisTy
::*
	tUnknownBoTy
;

66 
ݔ
 
UnknownBoTy
() const

68  
	gm_vue
 =
CssPicy
::
NuVue
() ?

70 &
ThisTy
::
m_vue
;

73 
bo
 
	gݔ
 !() const

75  
	gm_vue
 =
CssPicy
::
NuVue
();

	@vcore/src/dpl/core/include/dpl/singleton.h

22 #ide
DPL_SINGLETON_H


23 
	#DPL_SINGLETON_H


	)

25 
	~<boo/tiڮ.h
>

26 
	~<d/thad.h
>

27 
	~<d/as.h
>

29 
mea
 
	gVceDPL
 {

30 
	gme
<
tyme
 
	gCss
>

31 as
	cSgt
 :

32 
ive
 
Css


41 
ive
:

42 
Sgt
()

45 
boo
::
	ttiڮ
<
	tThad
 *> 
	tOiڮThadP
;

47 
	gSgt
 &
IlIn
();

49 
	gpublic
:

50 
vtu
 ~
Sgt
()

53 
Css
 &
In
();

	@vcore/src/dpl/core/include/dpl/singleton_impl.h

22 #ide
DPL_SINGLETON_IMPL_H


23 
	#DPL_SINGLETON_IMPL_H


	)

33 
mea
 
	gVceDPL
 {

34 
	gme
<
tyme
 
	gCss
>

35 
	gSgt
<
	gCss
>& Sgt<Css>::
IlIn
()

37 
Sgt
<
Css
> 

;

38  
	g
;

41 
	gme
<
tyme
 
	gCss
>

42 
	gCss
 &
	gSgt
<Css>::
In
()

44 
Sgt
<
Css
>& 

 = Sgt<Css>::
IlIn
();

45  
	g
;

49 
	#IMPLEMENT_SINGLETON
(
Ty
) \

50 
me
 
VceDPL
::
Sgt
<
Ty
>&VceDPL::Sgt<Ty>::
	`IlIn
(); \

51 
me
 
Ty
 & 
VceDPL
::
Sgt
<Ty>::
	`In
(); \

52 

	)

	@vcore/src/dpl/core/include/dpl/string.h

21 #ide
DPL_STRING


22 
	#DPL_STRING


	)

24 
	~<d/exi.h
>

25 
	~<d/ch_as.h
>

26 
	~<rg
>

27 
	~<oam
>

28 
	~<numic
>

30 
mea
 
	gVceDPL
 {

32 
	gd
::
	tbasic_rg
<
	twch_t
, 
	tChTs
> 
	tSg
;

35 as
	cSgExi


37 
	gpublic
:

38 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

41 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
IcvInEUTF8ToUTF32
)

44 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
IcvInEUTF32ToUTF8
)

47 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
IcvCvtEUTF8ToUTF32
)

50 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
IcvCvtEUTF32ToUTF8
)

53 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
InvidASCIICha
)

56 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
ICUInvidChaFound
)

60 
Sg
 
FromASCIISg
(cڡ 
d
::
rg
& 
aSg
);

63 
Sg
 
FromUTF32Sg
(cڡ 
d
::
wrg
& 
aSg
);

67 
Sg
 
FromUTF8Sg
(cڡ 
d
::
rg
& 
aSg
);

70 
	gd
::
rg
 
ToUTF8Sg
(cڡ 
Sg
& 
aSg
);

73 
SgCom
(cڡ 
Sg
 &

,

74 cڡ 
Sg
 &
right
,

75 
bo
 
Innsive
 = 
l
);

82 
	gme
<
tyme
 
	gSgTy
,ym
	gDims
,ym
	gInIt
>

83 
	$Tokize
(cڡ 
SgTy
& 
r
,

84 cڡ 
Dims
& 
dims
,

85 
InIt
 

,

86 
bo
 
igneEmy
 = 
l
)

88 
tyme
 
SgTy
::
size_ty
 
xtSrchS
 = 0;

89 
tyme
 
SgTy
::
size_ty
 
pos
;

90 
tyme
 
SgTy
::
size_ty
 
ngth
;

92 
ue
) {

93 
pos
 = 
r
.
	`fd_f_of
(
dims
, 
xtSrchS
);

94 
ngth
 =

95 ((
pos
 =
SgTy
::
os
? 
r
.
	`ngth
(:os- 
xtSrchS
;

97 i(!
igneEmy
 || 
ngth
 > 0) {

98 *

 = 
r
.
	`subr
(
xtSrchS
, 
ngth
);

99 

++;

102 i(
pos
 =
SgTy
::
os
) {

106 
xtSrchS
 = 
pos
 + 1;

108 
	}
}

110 
mea
 
	gUts
 {

112 
	gme
<
tyme
 
	gT
> 
ass
 
	gCtFunc
 : 
public
 
d
::
by_funi
<
T
, T, T>

114 
	gpublic
:

115 
exic
 
CtFunc
(cڡ 
T
 & 
v
: 
m_dim
(val) {}

116 
T
 
ݔ
()(cڡ T & 
g1
, cڡ 
	gT
 & 
	gg2
) const

118  
	gg1
 + 
	gm_dim
 + 
	gg2
;

120 
	give
:

121 
T
 
m_dim
;

126 
	gme
<
tyme
 
	gFwdIt
>

127 
tyme
 
	gFwdIt
::
vue_ty
 
	$Jo
(
FwdIt
 
beg
, FwdIt 
d
, 
tyme
 FwdIt::
vue_ty
 
dim
)

129 
tyme
 
	tFwdIt
::
	tvue_ty
 
	tvue
;

130 if(
beg
 =
d
 
	`vue
();

131 
Uts
::
CtFunc
<
vue
> 
	`func
(
dim
);

132 
FwdIt
 

 = 
beg
;

133  
d
::
	`accumuϋ
(++
beg
, 
d
, *

, 
func
);

134 
	}
}

136 
	gme
<
ass
 
	gSgTy
> 
	$TrimLe
(
SgTy
 & 
obj
, 
tyme
 SgTy::
cڡ_por
 
ts
)

138 
obj
.
	`a
(0, obj.
	`fd_f_n_of
(
ts
));

139 
	}
}

141 
	gme
<
ass
 
	gSgTy
> 
	$TrimRight
(
SgTy
 & 
obj
, 
tyme
 SgTy::
cڡ_por
 
ts
)

143 
obj
.
	`a
(obj.
	`fd_ϡ_n_of
(
ts
)+1);

144 
	}
}

146 
	gme
<
ass
 
	gSgTy
> 
	$Trim
(
SgTy
 & 
obj
, 
tyme
 SgTy::
cڡ_por
 
ts
)

148 
	`TrimLe
(
obj
, 
ts
);

149 
	`TrimRight
(
obj
, 
ts
);

150 
	}
}

155 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
aSm
, cڡ 
	gVceDPL
::
Sg
& 
aSg
);

	@vcore/src/dpl/core/include/dpl/thread.h

22 #ide
DPL_THREAD_H


23 
	#DPL_THREAD_H


	)

25 
	~<d/waab_hd_wch_sut.h
>

26 
	~<d/ncyab.h
>

27 
	~<d/exi.h
>

28 
	~<d/as.h
>

29 
	~<boo/tiڮ.h
>

30 
	~<dt.h
>

31 
	~<cdlib
>

32 
	~<had.h
>

33 
	~<thad
>

34 
	~<ve
>

35 
	~<li
>

36 
	~<mux
>

38 
mea
 
	gVceDPL
 {

39 
ass
 
	gThad
 :

40 
ive
 
Ncyab
,

41 
public
 
	gWaabHdWchSut


43 
	gpublic
:

44 as
	cExi


46 
public
:

47 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

48 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
CeFaed
)

49 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
DeroyFaed
)

50 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
RunFaed
)

51 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
QuFaed
)

52 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
UnmagedThad
)

55 (*
	gEvtDeProc
)(*
	tevt
, *
	turPam
);

56 (*
	gEvtDichProc
)(*
	tevt
, *
	turPam
);

58 
	geed
:

65 
vtu
 
ThadEry
();

70 
Exec
();

72 
	give
:

73 
	sIlEvt


75 *
evt
;

76 *
	gurPam
;

77 
EvtDichProc
 
	gevtDichProc
;

78 
EvtDeProc
 
	gevtDeProc
;

80 
IlEvt
(*
evtArg
,

81 *
urPamArg
,

82 
EvtDichProc
 
evtDichProcArg
,

83 
EvtDeProc
 
evtDeProcArg
) :

84 
evt
(
evtArg
),

85 
urPam
(
urPamArg
),

86 
evtDichProc
(
evtDichProcArg
),

87 
evtDeProc
(
evtDeProcArg
)

91 
	gIlTimedEvt
 :

92 
IlEvt


94 
dueTimeMicds
;

95 
	ggiTimeMicds
;

97 
IlTimedEvt
(*
evtArg
,

98 *
urPamArg
,

99 
dueTimeMicdsArg
,

100 
giTimeMicdsArg
,

101 
EvtDichProc
 
evtDichProcArg
,

102 
EvtDeProc
 
evtDeProcArg
) :

103 
IlEvt
(
evtArg
,

104 
urPamArg
,

105 
evtDichProcArg
,

106 
evtDeProcArg
),

107 
dueTimeMicds
(
dueTimeMicdsArg
),

108 
giTimeMicds
(
giTimeMicdsArg
)

111 
bo
 
	gݔ
<(cڡ 
	gIlTimedEvt
 &
	gh
)

113  
	ggiTimeMicds
 + 
	gdueTimeMicds
 >

114 
	gh
.
	ggiTimeMicds
 + oth.
	gdueTimeMicds
;

119 
	gd
::
	tli
<
	tIlEvt
> 
	tIlEvtLi
;

122 
	gd
::
	tve
<
	tIlTimedEvt
> 
	tIlTimedEvtVe
;

125 
	gd
::
thad
 
m_thad
;

126 vީ
bo
 
	gm_abd
;

127 vީ
bo
 
	gm_rug
;

128 
	gd
::
mux
 
m_eMux
;

129 
WaabEvt
 
	gm_quEvt
;

132 
	gd
::
mux
 
m_evtMux
;

133 
IlEvtLi
 
	gm_evtLi
;

134 
WaabEvt
 
	gm_evtInvok
;

137 
	gd
::
mux
 
m_timedEvtMux
;

138 
IlTimedEvtVe
 
	gm_timedEvtVe
;

139 
WaabEvt
 
	gm_timedEvtInvok
;

142 
vtu
 
Thad
 *
GInvokThad
();

143 
vtu
 
HdDeInvok
();

144 
bo
 
	gm_deInvoke
;

147 
GCutTimeMicds
() const;

148 
ProssEvts
();

149 
ProssTimedEvts
();

151 *
SticThadEry
(*
m
);

153 
	gpublic
:

154 
exic
 
Thad
();

155 
	gvtu
 ~
Thad
();

160 
Run
();

166 
Qu
();

172 
bo
 
IsMaThad
();

178 
Thad
 *
GCutThad
();

183 
PushEvt
(*
evt
,

184 
EvtDichProc
 
evtDichProc
,

185 
EvtDeProc
 
evtDeProc
,

186 *
urPam
);

191 
PushTimedEvt
(*
evt
,

192 
dueTimeSecds
,

193 
EvtDichProc
 
evtDichProc
,

194 
EvtDeProc
 
evtDeProc
,

195 *
urPam
);

200 
S˕
(
ut64_t
 
cds
);

205 
MiS˕
(
ut64_t
 
micds
);

210 
MioS˕
(
ut64_t
 
miocds
);

215 
NoS˕
(
ut64_t
 
nocds
);

218 
bo
 
g_TLSfMaCed
;

226 
	gme
<
tyme
 
	gTy
>

227 as
	cThadLolVb
 :

228 
public
 
Ncyab


230 
public
:

231 
Ty
 
	tVueTy
;

233 as
	cExi


235 
	gpublic
:

236 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

237 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
NuRen
)

238 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
KeyCeFaed
)

241 
	give
:

242 
had_key_t
 
m_key
;

244 
	sMagedVue


246 
VueTy
 
	gvue
;

247 
	gboo
::
tiڮ
<
had_key_t
> 
gudKey
;

250 
MaThadExC˪
()

260 
IlDeroy
(*
ecific
)

263 
MagedVue
 *
	g
 = 
ic_
<MagedVu*>(
ecific
);

264 i(!
	g
->
	ggudKey
) {

265 
de
 
	g
;

267 
	gsu
 = 
had_tecific
(*(

->
gudKey
), instance);

269 
As
(
su
 == 0 &&

274 
	gTy
 &
Ren
(
bo
 
lowInt
 = 
l
)

276 
MagedVue
 *

 =

277 
ic_
<
MagedVue
 *>(
had_gecific
(
m_key
));

279 i(!
	g
) {

281 i(!
	glowInt
) {

282 
Throw
(
tyme
 
Exi
::
NuRen
);

287 i(!
	gg_TLSfMaCed
) {

288 i(
	gThad
::
IsMaThad
()) {

289 
g_TLSfMaCed
 = 
ue
;

290 
ex
(&
MaThadExC˪
);

295 
	g
 = 
w
 
MagedVue
();

297 
	gsu
 = 
had_tecific
(
m_key
, 

);

299 
As
(
su
 == 0 &&

303  
	g
->
	gvue
;

306 
	gpublic
:

307 
ThadLolVb
()

309 
su
 = 
had_key_
(&
m_key
, &
IlDeroy
);

310 i(
	gsu
 != 0) {

311 
ThrowMsg
(
tyme
 
Exi
::
KeyCeFaed
,

312 "Faedخlohadovb: " << 
su
);

316 ~
ThadLolVb
()

318 
had_key_de
(
m_key
);

321 
	gTy
 &
	gݔ
=(cڡ 
Ty
 &
h
)

323 
Ty
 &
n
 = 
Ren
(
ue
);

324 
	gn
 = 
h
;

325  
	gn
;

328 
bo
 
IsNu
() const

330  
had_gecific
(
m_key
=
NULL
;

333 
	gTy
& 
	gݔ
*()

335  
Ren
();

338 cڡ 
	gTy
& 
	gݔ
*() const

340  
Ren
();

343 cڡ 
Ty
* 
	gݔ
->() const

345  &
Ren
();

348 
Ty
* 
	gݔ
->()

350  &
Ren
();

353 
bo
 
	gݔ
!() const

355  
IsNu
();

358 
Ret
()

360 
MagedVue
 *
	gecific
 =

361 
ic_
<
MagedVue
 *>(
had_gecific
(
m_key
));

363 i(!
	gecific
) {

369 
	gecific
->
	ggudKey
 = 
boo
::
tiڮ
<
had_key_t
>();

371 
IlDeroy
(
ecific
);

373 
	gsu
 = 
had_tecific
(
m_key
, 
NULL
);

375 
As
(
su
 == 0 &&

382 
GudVue
(
bo
 
gud
)

384 
MagedVue
 *
	g
 =

385 
ic_
<
MagedVue
 *>(
had_gecific
(
m_key
));

387 
As
(

 && "Failedo gethe value");

389 
	g
->
	ggudKey
 = 
gud
 ? 
m_key
 : 
boo
::
tiڮ
<
had_key_t
>();

	@vcore/src/dpl/core/include/dpl/type_list.h

22 #ide
DPL_TYPE_LIST_H


23 
	#DPL_TYPE_LIST_H


	)

25 
	~<cddef
>

27 
mea
 
	gVceDPL
 {

28 as
	cTyLiGud


30 
	gpublic
:

31 
me
<
size_t
 
Index
>

32 
	sEmt


34 
ERROR_TyLiEmtIndexIsOutOfBounds
;

35 
ERROR_TyLiEmtIndexIsOutOfBounds
 
	tTy
;

38 cڡ 
size_t
 
	gSize
 = 0;

41 
	gme
<
tyme
 
	gHdTy
,ym
	gTaTy
>

42 as
	cTyLi


44 
	give
:

45 as
	cDummyCss


48 
	gme
<
tyme
 
	gLi
, 
size_t
 
	gEnum
>

49 
	gTyCou
 : 
public
 
TyCou
<
tyme
 
Li
::
Ta
, 
	gEnum
 + 1>

52 
	gme
<
size_t
 
	gEnum
>

53 
	gTyCou
<
	gTyLiGud
, 
	gEnum
>

55 cڡ 
size_t
 
	gSize
 = 
Enum
;

58 
	gpublic
:

59 
TaTy
 
	tTa
;

60 
HdTy
 
	tHd
;

61 
	gTyLi
<
	tHdTy
, 
	tTaTy
> 
	tThisTy
;

63 
	gme
<
size_t
 
	gIndex
, 
tyme
 
	gDummyTy
 = 
DummyCss
>

64 
	sEmt


66 
tyme
 
	tTaTy
::
	tme
 
	tEmt
<
	tIndex
 - 1>::
	tTy
 Type;

69 
	gme
<
tyme
 
	gDummyTy
>

70 
	gEmt
<0, 
	gDummyTy
>

72 
HdTy
 
	tTy
;

75 
	gme
<
tyme
 
	gTy
,ym
	gDummyTy
 = 
DummyCss
>

76 
	sCڏs


78 
tyme
 
	tTaTy
::
	tme
 
	tCڏs
<
	tTy
>::
	tYes
 Yes;

81 
	gme
<
tyme
 
	gDummyTy
>

82 
	gCڏs
<
	gHdTy
, 
	gDummyTy
>

84 
	tYes
;

87 cڡ 
size_t
 
	gSize
 = 
TyCou
<
ThisTy
, 0>::
Size
;

90 
	gme
<
tyme
 
	gT1
 = 
TyLiGud
,ym
	gT2
 = TypeListGuard,

91 
tyme
 
	gT3
 = 
TyLiGud
,ym
	gT4
 = TypeListGuard,

92 
tyme
 
	gT5
 = 
TyLiGud
,ym
	gT6
 = TypeListGuard,

93 
tyme
 
	gT7
 = 
TyLiGud
,ym
	gT8
 = TypeListGuard,

94 
tyme
 
	gT9
 = 
TyLiGud
,ym
	gT10
 = TypeListGuard,

95 
tyme
 
	gT11
 = 
TyLiGud
,ym
	gT12
 = TypeListGuard,

96 
tyme
 
	gT13
 = 
TyLiGud
,ym
	gT14
 = TypeListGuard,

97 
tyme
 
	gT15
 = 
TyLiGud
,ym
	gT16
 = TypeListGuard,

98 
tyme
 
	gT17
 = 
TyLiGud
,ym
	gT18
 = TypeListGuard,

99 
tyme
 
	gT19
 = 
TyLiGud
,ym
	gT20
 = TypeListGuard,

100 
tyme
 
	gT21
 = 
TyLiGud
,ym
	gT22
 = TypeListGuard,

101 
tyme
 
	gT23
 = 
TyLiGud
,ym
	gT24
 = TypeListGuard,

102 
tyme
 
	gT25
 = 
TyLiGud
,ym
	gT26
 = TypeListGuard,

103 
tyme
 
	gT27
 = 
TyLiGud
,ym
	gT28
 = TypeListGuard,

104 
tyme
 
	gT29
 = 
TyLiGud
,ym
	gT30
 = TypeListGuard,

105 
tyme
 
	gT31
 = 
TyLiGud
,ym
	gT32
 = TypeListGuard,

106 
tyme
 
	gT33
 = 
TyLiGud
,ym
	gT34
 = TypeListGuard,

107 
tyme
 
	gT35
 = 
TyLiGud
,ym
	gT36
 = TypeListGuard,

108 
tyme
 
	gT37
 = 
TyLiGud
,ym
	gT38
 = TypeListGuard,

109 
tyme
 
	gT39
 = 
TyLiGud
,ym
	gT40
 = TypeListGuard,

110 
tyme
 
	gT41
 = 
TyLiGud
,ym
	gT42
 = TypeListGuard,

111 
tyme
 
	gT43
 = 
TyLiGud
,ym
	gT44
 = TypeListGuard,

112 
tyme
 
	gT45
 = 
TyLiGud
,ym
	gT46
 = TypeListGuard,

113 
tyme
 
	gT47
 = 
TyLiGud
,ym
	gT48
 = TypeListGuard,

114 
tyme
 
	gT49
 = 
TyLiGud
,ym
	gT50
 = TypeListGuard,

115 
tyme
 
	gT51
 = 
TyLiGud
,ym
	gT52
 = TypeListGuard,

116 
tyme
 
	gT53
 = 
TyLiGud
,ym
	gT54
 = TypeListGuard,

117 
tyme
 
	gT55
 = 
TyLiGud
,ym
	gT56
 = TypeListGuard,

118 
tyme
 
	gT57
 = 
TyLiGud
,ym
	gT58
 = TypeListGuard,

119 
tyme
 
	gT59
 = 
TyLiGud
,ym
	gT60
 = TypeListGuard,

120 
tyme
 
	gT61
 = 
TyLiGud
,ym
	gT62
 = TypeListGuard,

121 
tyme
 
	gT63
 = 
TyLiGud
,ym
	gT64
 = TypeListGuard>

122 
	sTyLiDe


124 
TyLi
<
	tT1
,

125 
	ttyme
 
	tTyLiDe
<

126 
	tT2
, 
	tT3
, 
	tT4
, 
	tT5
, 
	tT6
, 
	tT7
, 
	tT8
,

127 
	tT9
, 
	tT10
, 
	tT11
, 
	tT12
, 
	tT13
, 
	tT14
, 
	tT15
,

128 
	tT16
, 
	tT17
, 
	tT18
, 
	tT19
, 
	tT20
, 
	tT21
, 
	tT22
,

129 
	tT23
, 
	tT24
, 
	tT25
, 
	tT26
, 
	tT27
, 
	tT28
, 
	tT29
,

130 
	tT30
, 
	tT31
, 
	tT32
, 
	tT33
, 
	tT34
, 
	tT35
, 
	tT36
,

131 
	tT37
, 
	tT38
, 
	tT39
, 
	tT40
, 
	tT41
, 
	tT42
, 
	tT43
,

132 
	tT44
, 
	tT45
, 
	tT46
, 
	tT47
, 
	tT48
, 
	tT49
, 
	tT50
,

133 
	tT51
, 
	tT52
, 
	tT53
, 
	tT54
, 
	tT55
, 
	tT56
, 
	tT57
,

134 
	tT58
, 
	tT59
, 
	tT60
, 
	tT61
, 
	tT62
, 
	tT63
, 
	tT64
>::
	tTy
> Type;

137 
	gme
<>

138 
	gTyLiDe
<
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

139 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

140 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

141 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

142 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

143 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

144 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

145 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

146 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

147 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

148 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

149 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

150 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

151 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

152 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard,

153 
	gTyLiGud
, TypeListGuard, TypeListGuard, TypeListGuard>

155 
TyLiGud
 
	tTy
;

	@vcore/src/dpl/core/include/dpl/waitable_event.h

22 #ide
DPL_WAITABLE_EVENT_H


23 
	#DPL_WAITABLE_EVENT_H


	)

25 
	~<d/waab_hd.h
>

26 
	~<d/ncyab.h
>

27 
	~<d/exi.h
>

28 
	~<ve
>

30 
mea
 
	gVceDPL
 {

31 as
	cWaabEvt
 :

32 
ive
 
Ncyab


34 
public
:

35 as
	cExi


37 
public
:

38 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

39 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
CeFaed
)

40 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
DeroyFaed
)

41 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
SiglFaed
)

42 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
RetFaed
)

45 
	give
:

46 
m_pe
[2];

48 
	gpublic
:

49 
WaabEvt
();

50 
	gvtu
 ~
WaabEvt
();

52 
WaabHd
 
GHd
() const;

54 
Sigl
() const;

55 
Ret
() const;

	@vcore/src/dpl/core/include/dpl/waitable_handle.h

22 #ide
DPL_WAITABLE_HANDLE_H


23 
	#DPL_WAITABLE_HANDLE_H


	)

25 
	~<d/ncyab.h
>

26 
	~<d/exi.h
>

27 
	~<ve
>

29 
mea
 
	gVceDPL
 {

33 
	tWaabHd
;

38 
	gd
::
	tve
<
	tWaabHd
> 
	tWaabHdLi
;

43 as
	cWaMode


45 
	gpublic
:

46 
	eTy


48 
Rd
,

49 
	gWre


56 
	gd
::
	tve
<
	td
::
	t
<
	tWaabHd
,

57 
	tWaMode
::
	tTy
> > 
	tWaabHdLiEx
;

62 
	gd
::
	tve
<
	tsize_t
> 
	tWaabHdIndexLi
;

67 
	$DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
WaFaed
)

76 
WaabHdIndexLi
 
	`WaFSgHd
(

77 
WaabHd
 
hd
,

78 
micds
 =

88 
WaabHdIndexLi
 
	`WaFSgHd
(

89 
WaabHd
 
hd
,

90 
WaMode
::
Ty
 
mode
,

91 
micds
 =

100 
WaabHdIndexLi
 
	`WaFMuɝHds
(

101 cڡ 
WaabHdLi
 &
hdLi
,

102 
micds
 = 0xFFFFFFFF);

110 
WaabHdIndexLi
 
	`WaFMuɝHds
(

111 cڡ 
WaabHdLiEx
 &
hdLiEx
,

112 
micds
 = 0xFFFFFFFF);

113 
	}
}

	@vcore/src/dpl/core/include/dpl/waitable_handle_watch_support.h

23 #ide
DPL_WAITABLE_HANDLE_WATCH_SUPPORT_H


24 
	#DPL_WAITABLE_HANDLE_WATCH_SUPPORT_H


	)

26 
	~<d/waab_evt.h
>

27 
	~<d/waab_hd.h
>

28 
	~<d/exi.h
>

29 
	~<li
>

30 
	~<m
>

31 
	~<mux
>

33 
mea
 
	gVceDPL
 {

34 
ass
 
	gThad
;

36 as
	cWaabHdWchSut


38 
	gpublic
:

39 as
	cWaabHdLi


41 
public
:

42 
vtu
 ~
WaabHdLi
() {}

44 
vtu
 
OnWaabHdEvt
(
WaabHd
 
waabHd
,

45 
WaMode
::
Ty
 
mode
) = 0;

48 
	geed
:

52 
WaabHd
 
WaabInvokHd
() const;

55 
WaabHdLiEx
 
WaabWchHds
() const;

59 
HdWch
(
WaabHd
 
waabHd
, 
WaMode
::
Ty
 
mode
);

62 
InvokFished
();

65 
vtu
 
Thad
 *
GInvokThad
() = 0;

68 
vtu
 
HdDeInvok
() = 0;

70 
	give
:

72 
	sWaabHdWch


74 
WaabHdLi
 *
li
;

75 
	gWaMode
::
Ty
 
mode
;

77 
WaabHdWch
(
WaabHdLi
 *
l
, 
WaMode
::
Ty
 
m
) :

78 
li
(
l
),

79 
mode
(
m
)

83 
	gd
::
	tli
<
	tWaabHdWch
> 
	tWaabHdLiLi
;

85 
	sWaabHdWchs


87 
WaabHdLiLi
 
	glis
;

88 
size_t
 
	gadLisCou
;

89 
size_t
 
	gwreLisCou
;

91 
WaabHdWchs
() :

92 
adLisCou
(0),

93 
wreLisCou
(0)

97 
	gd
::
	tm
<
	tWaabHd
,

98 
	tWaabHdWchs
> 
	tWaabHdWchsM
;

101 
mub
 
	gd
::
cursive_mux
 
m_wchsMux
;

102 
WaabHdWchsM
 
	gm_wchsM
;

103 
WaabEvt
 
	gm_wchsInvok
;

104 
WaabEvt
 
	gm_wchsInvokComm
;

107 
CommInvok
();

109 
	gpublic
:

113 
exic
 
WaabHdWchSut
();

118 
	gvtu
 ~
WaabHdWchSut
();

129 
AddWaabHdWch
(
WaabHdLi
 *
li
,

130 
WaabHd
 
waabHd
,

131 
WaMode
::
Ty
 
mode
);

142 
RemoveWaabHdWch
(
WaabHdLi
 *
li
,

143 
WaabHd
 
waabHd
,

144 
WaMode
::
Ty
 
mode
);

	@vcore/src/dpl/core/include/dpl/workaround.h

22 #ide
DPL_WORKAROUND_H


23 
	#DPL_WORKAROUND_H


	)

29 
	#DPL_ENABLE_WAITABLE_HANDLE_BADF_CHECK


	)

35 
	#DPL_ENABLE_GLIB_LOOP_INTEGRATION_WORKAROUND


	)

41 
	#DPL_ENABLE_HTONS_NTOHS_I386_WORKAROUND


	)

	@vcore/src/dpl/core/src/assert.cpp

22 
	~<cdlib
>

23 
	~<sam
>

24 
	~<ddef.h
>

25 
	~<d/as.h
>

26 
	~<d/cs.h
>

27 
	~<d/exi.h
>

28 
	~<d/log/vce_log.h
>

30 
mea
 
	gVceDPL
 {

31 
AsProc
(cڡ *
cdi
,

32 cڡ *
fe
,

33 
le
,

34 cڡ *
funi
)

37 
	#INTERNAL_LOG
(
mesge
) \

39 
d
::
orgam
 
fmLog
; \

40 
fmLog
 << 
mesge
; \

41 
	`VceLogD
("%s", 
fmLog
.
	`r
().
	`c_r
()); \

42 } 0)

	)

45 
	gTry
 {

46 
INTERNAL_LOG
("########################################################################");

47 
INTERNAL_LOG
("### DPLssertion failed! ###");

48 
INTERNAL_LOG
("########################################################################");

49 
INTERNAL_LOG
("### Cdi: " << 
cdi
);

50 
INTERNAL_LOG
("### Fe: " << 
fe
);

51 
INTERNAL_LOG
("### Le: " << 
le
);

52 
INTERNAL_LOG
("### Funi: " << 
funi
);

53 
INTERNAL_LOG
("########################################################################");

54 } 
tch
 (
Exi
) {

59 
abt
();

	@vcore/src/dpl/core/src/binary_queue.cpp

22 
	~<ddef.h
>

23 
	~<d/by_queue.h
>

24 
	~<d/as.h
>

25 
	~<d/sced_.h
>

26 
	~<gܙhm
>

27 
	~<mloc.h
>

28 
	~<crg
>

29 
	~<w
>

31 
mea
 
	gVceDPL
 {

32 
	gByQueue
::
ByQueue
() :

33 
m_size
(0)

36 
ByQueue
::ByQueue(cڡ ByQueu&
h
) :

37 
m_size
(0)

39 
AdCyFrom
(
h
);

42 
	gByQueue
::~
ByQueue
()

45 
Cˬ
();

48 
	gByQueue
 &ByQueue::
ݔ
=(cڡ 
ByQueue
 &
h
)

50 i(
this
 !&
h
) {

51 
Cˬ
();

52 
AdCyFrom
(
h
);

55  *
	gthis
;

58 
	gByQueue
::
AdCyFrom
(cڡ 
ByQueue
 &
h
)

61 *
bufrCy
 = 
mloc
(
h
.
m_size
);

63 i(
	gbufrCy
 =
NULL
) {

64 
throw
 
d
::
bad_loc
();

67 
	gy
 {

68 
	gh
.
Fω
(
bufrCy
, 
h
.
m_size
);

69 
AdUnmaged
(
bufrCy
, 
h
.
m_size
, &
BufrDFe
, 
NULL
);

70 } 
tch
 (cڡ 
d
::
bad_loc
 &) {

72 

(
bufrCy
);

73 
	gthrow
;

77 
	gByQueue
::
AdMoveFrom
(
ByQueue
 &
h
)

80 
d
::
cy
(
h
.
m_bucks
.
beg
(),

81 
h
.
m_bucks
.
d
(), 
d
::
back_
(m_buckets));

82 
	gm_size
 +
h
.
m_size
;

85 
	gh
.
	gm_bucks
.
r
();

86 
	gh
.
	gm_size
 = 0;

89 
	gByQueue
::
AdCyTo
(
ByQueue
 &
h
) const

91 
h
.
AdCyFrom
(*
this
);

94 
	gByQueue
::
AdMoveTo
(
ByQueue
 &
h
)

96 
h
.
AdMoveFrom
(*
this
);

99 
	gByQueue
::
Cˬ
()

101 
d
::
f_ch
(
m_bucks
.
beg
(), m_bucks.
d
(), &
DeBuck
);

102 
	gm_bucks
.
r
();

103 
	gm_size
 = 0;

106 
	gByQueue
::
AdCy
(cڡ * 
bufr
, 
size_t
 
bufrSize
)

109 *
	gbufrCy
 = 
mloc
(
bufrSize
);

112 i(
	gbufrCy
 =
NULL
) {

113 
throw
 
d
::
bad_loc
();

117 
memy
(
bufrCy
, 
bufr
, 
bufrSize
);

119 
	gy
 {

121 
AdUnmaged
(
bufrCy
, 
bufrSize
, &
BufrDFe
, 
NULL
);

122 } 
tch
 (cڡ 
d
::
bad_loc
 &) {

124 

(
bufrCy
);

125 
	gthrow
;

129 
	gByQueue
::
AdUnmaged
(cڡ * 
bufr
,

130 
size_t
 
bufrSize
,

131 
BufrD
 
d
,

132 * 
urPam
)

135 i(
	gbufrSize
 == 0) {

136 
d
(
bufr
, 
bufrSize
, 
urPam
);

141 
	gm_bucks
.
push_back
(
w
 
Buck
(
bufr
, 
bufrSize
, 
d
, 
urPam
));

144 
	gm_size
 +
bufrSize
;

147 
size_t
 
	gByQueue
::
Size
() const

149  
m_size
;

152 
bo
 
	gByQueue
::
Emy
() const

154  
m_size
 == 0;

157 
	gByQueue
::
Csume
(
size_t
 
size
)

160 i(
size
 > 
m_size
) {

161 
Throw
(
Exi
::
OutOfDa
);

164 
size_t
 
	gbysLe
 = 
size
;

167 
	gbysLe
 > 0) {

169 
size_t
 
	gcou
 = 
d
::
m
(
bysLe
, 
m_bucks
.
t
()->

);

171 
	gm_bucks
.
t
()->
	gr
 =

172 
ic_
<cڡ *>(
m_bucks
.
t
()->
r
+ 
cou
;

173 
	gm_bucks
.
t
()->
	g
 -
cou
;

174 
	gbysLe
 -
cou
;

175 
	gm_size
 -
cou
;

177 i(
	gm_bucks
.
t
()->
	g
 == 0) {

178 
DeBuck
(
m_bucks
.
t
());

179 
	gm_bucks
.
p_t
();

184 
	gByQueue
::
Fω
(*
bufr
, 
size_t
 
bufrSize
) const

187 i(
	gbufrSize
 == 0) {

191 i(
	gbufrSize
 > 
	gm_size
) {

192 
Throw
(
Exi
::
OutOfDa
);

195 
size_t
 
	gbysLe
 = 
bufrSize
;

196 *
	gr
 = 
bufr
;

197 
	gBuckLi
::
cڡ_
 
buckIt
 = 
m_bucks
.
beg
();

198 
As
(
m_bucks
.
d
(!
buckIt
);

201 
	gbysLe
 > 0) {

203 
size_t
 
	gcou
 = 
d
::
m
(
bysLe
, (*
buckIt
)->

);

206 
memy
(
r
, (*
buckIt
)->r, 
cou
);

209 
	gbysLe
 -
cou
;

210 
	gr
 = 
ic_
<*>(
r
+ 
cou
;

213 ++
	gbuckIt
;

217 
	gByQueue
::
FωCsume
(*
bufr
, 
size_t
 
bufrSize
)

220 
Fω
(
bufr
, 
bufrSize
);

221 
Csume
(
bufrSize
);

224 
	gByQueue
::
DeBuck
(
ByQueue
::
Buck
 *
buck
)

226 
de
 
buck
;

229 
	gByQueue
::
BufrDFe
(cڡ * 
da
,

230 
size_t
 
daSize
,

231 * 
urPam
)

233 ()
	gdaSize
;

234 ()
	gurPam
;

237 

(
cڡ_
<*>(
da
));

240 
	gByQueue
::
Buck
::Buck(cڡ * 
da
,

241 
size_t
 
daSize
,

242 
BufrD
 
daD
,

243 * 
urPam
) :

244 
bufr
(
da
),

245 
r
(
da
),

246 
size
(
daSize
),

247 

(
daSize
),

248 
d
(
daD
),

249 
m
(
urPam
)

251 
As
(
da
 !
NULL
);

252 
As
(
d
 !
NULL
);

255 
	gByQueue
::
Buck
::~Bucket()

258 
d
(
bufr
, 
size
, 
m
);

261 
	gByQueue
::
BuckVis
::~BucketVisitor()

264 
ByQueue
::
BuckVisCl
::BuckVisCl(
BuckVis
 *
vis
) :

265 
m_vis
(
vis
)

268 
ByQueue
::
BuckVisCl
::~BucketVisitorCall()

271 
ByQueue
::
BuckVisCl
::
ݔ
()(
Buck
 *
buck
) const

273 
m_vis
->
OnVisBuck
(
buck
->
r
, buck->

);

276 
	gByQueue
::
VisBucks
(
BuckVis
 *
vis
) const

278 
As
(
vis
 !
NULL
);

281 
	gd
::
f_ch
(
m_bucks
.
beg
(), m_bucks.
d
(), 
BuckVisCl
(
vis
));

284 
ByQueueAutoP
 
	gByQueue
::
Rd
(
size_t
 
size
)

287 
size_t
 
avaab
 = 
d
::
m
(
size
, 
m_size
);

289 
	gScedFe
<> 
bufrCy
(
mloc
(
avaab
));

291 i(!
	gbufrCy
) {

292 
throw
 
	gd
::
bad_loc
();

295 
ByQueueAutoP
 
su
(
w
 
ByQueue
());

297 
Fω
(
bufrCy
.
G
(), 
avaab
);

298 
	gsu
->
AdUnmaged
(

299 
bufrCy
.
G
(), 
avaab
, &
BufrDFe
, 
NULL
);

300 
	gbufrCy
.
R
();

301 
Csume
(
avaab
);

303  
	gsu
;

306 
size_t
 
	gByQueue
::
Wre
(cڡ 
ByQueue
 &
bufr
, size_
bufrSize
)

309 
AdCyFrom
(
bufr
);

310  
	gbufrSize
;

	@vcore/src/dpl/core/src/char_traits.cpp

25 
	~<ddef.h
>

26 
	~<d/ch_as.h
>

	@vcore/src/dpl/core/src/colors.cpp

23 
	~<ddef.h
>

24 
	~<d/cs.h
>

26 
mea
 
	gVceDPL
 {

27 
mea
 
	gCs
 {

28 
mea
 
	gText
 {

29 cڡ * 
	gBOLD_GREEN_BEGIN
 = "\033[1;32m";

30 cڡ * 
	gBOLD_GREEN_END
 = "\033[m";

31 cڡ * 
	gRED_BEGIN
 = "\033[0;31m";

32 cڡ * 
	gRED_END
 = "\033[m";

33 cڡ * 
	gPURPLE_BEGIN
 = "\033[0;35m";

34 cڡ * 
	gPURPLE_END
 = "\033[m";

35 cڡ * 
	gGREEN_BEGIN
 = "\033[0;32m";

36 cڡ * 
	gGREEN_END
 = "\033[m";

37 cڡ * 
	gCYAN_BEGIN
 = "\033[0;36m";

38 cڡ * 
	gCYAN_END
 = "\033[m";

39 cڡ * 
	gBOLD_RED_BEGIN
 = "\033[1;31m";

40 cڡ * 
	gBOLD_RED_END
 = "\033[m";

41 cڡ * 
	gBOLD_YELLOW_BEGIN
 = "\033[1;33m";

42 cڡ * 
	gBOLD_YELLOW_END
 = "\033[m";

43 cڡ * 
	gBOLD_GOLD_BEGIN
 = "\033[0;33m";

44 cڡ * 
	gBOLD_GOLD_END
 = "\033[m";

45 cڡ * 
	gBOLD_WHITE_BEGIN
 = "\033[1;37m";

46 cڡ * 
	gBOLD_WHITE_END
 = "\033[m";

49 
mea
 
	gHtml
 {

50 cڡ * 
	gBOLD_GREEN_BEGIN
 = "<font color=\"green\"><b>";

51 cڡ * 
	gBOLD_GREEN_END
 = "</b></font>";

52 cڡ * 
	gPURPLE_BEGIN
 = "<font color=\"purple\"><b>";

53 cڡ * 
	gPURPLE_END
 = "</b></font>";

54 cڡ * 
	gRED_BEGIN
 = "<font color=\"red\"><b>";

55 cڡ * 
	gRED_END
 = "</b></font>";

56 cڡ * 
	gGREEN_BEGIN
 = "<font color=\"green\">";

57 cڡ * 
	gGREEN_END
 = "</font>";

58 cڡ * 
	gCYAN_BEGIN
 = "<font color=\"cyan\">";

59 cڡ * 
	gCYAN_END
 = "</font>";

60 cڡ * 
	gBOLD_RED_BEGIN
 = "<font color=\"red\"><b>";

61 cڡ * 
	gBOLD_RED_END
 = "</b></font>";

62 cڡ * 
	gBOLD_YELLOW_BEGIN
 = "<font color=\"yellow\"><b>";

63 cڡ * 
	gBOLD_YELLOW_END
 = "</b></font>";

64 cڡ * 
	gBOLD_GOLD_BEGIN
 = "<font color=\"gold\"><b>";

65 cڡ * 
	gBOLD_GOLD_END
 = "</b></font>";

66 cڡ * 
	gBOLD_WHITE_BEGIN
 = "<font color=\"white\"><b>";

67 cڡ * 
	gBOLD_WHITE_END
 = "</b></font>";

	@vcore/src/dpl/core/src/errno_string.cpp

22 
	~<ddef.h
>

23 
	~<d/o_rg.h
>

24 
	~<d/as.h
>

25 
	~<d/exi.h
>

26 
	~<d/as.h
>

27 
	~<d/sced_.h
>

28 
	~<rg
>

29 
	~<cddef
>

30 
	~<crg
>

31 
	~<mloc.h
>

32 
	~<no
>

33 
	~<dex
>

35 
mea
 
	gVceDPL
 {

36 
	gmea


38 cڡ 
size_t
 
	gDEFAULT_ERRNO_STRING_SIZE
 = 32;

41 
	gd
::
rg
 
GEnoSg
(
r
)

43 
size_t
 
size
 = 
DEFAULT_ERRNO_STRING_SIZE
;

44 *
	gbufr
 = 
NULL
;

48 *
	gwBufr
 = 
ic_
<*>(::
loc
(
bufr
, 
size
 + 1));

50 i(!
	gwBufr
) {

52 ::

(
bufr
);

53 
throw
 
	gd
::
bad_loc
();

57 
	gbufr
 = 
wBufr
;

58 ::
memt
(
bufr
, 0, 
size
 + 1);

61 #i(
_POSIX_C_SOURCE
 >200112L || 
_XOPEN_SOURCE
 >600&& !
_GNU_SOURCE


63 
	gsu
 = ::
_r
(
r
, 
bufr
, 
size
);

65 i(
	gsu
 == 0) {

66 
ScedFe
<> 
scedBufrFe
(
bufr
);

67  
	gd
::
rg
(
bufr
);

70 
	go
 = 0;

73 *
	gsu
 = ::
_r
(
r
, 
bufr
, 
size
);

75 i(
	gsu
 !
NULL
) {

76 
ScedFe
<> 
scedBufrFe
(
bufr
);

77  
	gd
::
rg
(
su
);

82 
	go
) {

83 
	gEINVAL
:

85 ::

(
bufr
);

86 
ThrowMsg
(
InvidEnoVue
, "Invidnvue: " << 
r
);

88 
	gERANGE
:

90 
size
 <<= 1;

94 
AsMsg
(0, "Invalidrrno valuefter callo strerror_r!");

	@vcore/src/dpl/core/src/exception.cpp

22 
	~<ddef.h
>

23 
	~<d/exi.h
>

24 
	~<d/log/vce_log.h
>

25 
	~<cdio
>

27 
mea
 
	gVceDPL
 {

28 
Exi
* 
	gExi
::
m_ϡExi
 = 
NULL
;

29 
	gExi
::
m_exiCou
 = 0;

30 (*
	gExi
::
m_rmeHdr
)(
NULL
;

32 
LogUnhddExi
(cڡ 
d
::
rg
 &
r
)

35 
VceLogD
("%s", 
r
.
c_r
());

38 
LogUnhddExi
(cڡ 
d
::
rg
 &
r
,

39 cڡ *
fame
,

40 
le
,

41 cڡ *
funi
)

44 
VceLogE
("Exception occured on file[%s]ine[%d] function[%s] msg[%s]",

45 
fame
, 
le
, 
funi
, 
r
.
c_r
());

	@vcore/src/dpl/core/src/file_input.cpp

22 
	~<ddef.h
>

23 
	~<d/fe_put.h
>

24 
	~<d/by_queue.h
>

25 
	~<d/log/log.h
>

26 
	~<unid.h
>

27 
	~<sys/.h
>

28 
	~<f.h
>

29 
	~<o.h
>

31 
mea
 
	gVceDPL
 {

32 
	gmea


34 cڡ 
size_t
 
	gDEFAULT_READ_BUFFER_SIZE
 = 4096;

37 
	gFeIut
::
FeIut
() :

38 
m_fd
(-1)

41 
FeIut
::FeIut(cڡ 
d
::
rg
& 
feName
) :

42 
m_fd
(-1)

44 
On
(
feName
);

47 
	gFeIut
::~
FeIut
()

49 
Clo
();

52 
	gFeIut
::
On
(cڡ 
d
::
rg
& 
feName
)

55 
fd
 = 
TEMP_FAILURE_RETRY
(
ݒ
(
feName
.
c_r
(), 
O_RDONLY
 | 
O_NONBLOCK
));

58 i(
	gfd
 == -1) {

59 
ThrowMsg
(
Exi
::
OnFaed
, 
feName
);

63 
Clo
();

66 
	gm_fd
 = 
fd
;

68 
LogPedtic
("Od fe: " << 
feName
);

71 
	gFeIut
::
Clo
()

73 i(
m_fd
 == -1) {

77 i(
TEMP_FAILURE_RETRY
(
o
(
m_fd
)) == -1) {

78 
Throw
(
Exi
::
CloFaed
);

81 
	gm_fd
 = -1;

83 
LogPedtic
("Closed file");

86 
ByQueueAutoP
 
	gFeIut
::
Rd
(
size_t
 
size
)

88 
size_t
 
bysToRd
 = 
size
 >

89 
DEFAULT_READ_BUFFER_SIZE
 ? DEFAULT_READ_BUFFER_SIZE : 
size
;

93 *
	gbufr
 = 
mloc
(
bysToRd
);

95 i(
	gbufr
 =
NULL
) {

96 
throw
 
d
::
bad_loc
();

99 
LogPedtic
("Trygػad " << 
bysToRd
 << " bytes");

101 
ssize_t
 
	gsu
 = 
TEMP_FAILURE_RETRY
(
ad
(
m_fd
, 
bufr
, 
bysToRd
));

103 
LogPedtic
("Rd " << 
su
 << " bytes from file");

105 i(
	gsu
 > 0) {

107 
ByQueueAutoP
 
byQueue
(
w
 
ByQueue
());

110 
	gbyQueue
->
AdUnmaged
(
bufr
,

111 
su
,

112 &
ByQueue
::
BufrDFe
,

113 
NULL
);

116  
	gbyQueue
;

117 } i(
	gsu
 == 0) {

119 

(
bufr
);

122  
ByQueueAutoP
(
w
 
ByQueue
());

125 
	gϡEno
 = 
o
;

128 

(
bufr
);

131 ()
	gϡEno
;

134 
Throw
(
AbIut
::
Exi
::
RdFaed
);

138 
WaabHd
 
	gFeIut
::
WaabRdHd
() const

140  
ic_
<
WaabHd
>(
m_fd
);

	@vcore/src/dpl/core/src/noncopyable.cpp

22 
	~<ddef.h
>

23 
	~<d/ncyab.h
>

25 
mea
 
	gVceDPL
 {

26 
	gNcyab
::
Ncyab
()

29 
Ncyab
::~Noncopyable()

	@vcore/src/dpl/core/src/singleton.cpp

22 
	~<ddef.h
>

23 
	~<d/sgt.h
>

	@vcore/src/dpl/core/src/string.cpp

22 
	~<ddef.h
>

23 
	~<memy
>

24 
	~<d/rg.h
>

25 
	~<d/ch_as.h
>

26 
	~<d/o_rg.h
>

27 
	~<d/exi.h
>

28 
	~<d/log/vce_log.h
>

29 
	~<rg
>

30 
	~<ve
>

31 
	~<gܙhm
>

32 
	~<crg
>

33 
	~<o.h
>

34 
	~<icv.h
>

35 
	~<unicode/urg.h
>

38 
mea
 
	gVceDPL
 {

39 
	gmea


41 as
	cASCIIVid


43 cڡ 
	gd
::
rg
& 
m_TeedSg
;

45 
	gpublic
:

46 
ASCIIVid
(cڡ 
d
::
rg
& 
aTeedSg
);

48 
ݔ
()(
	gaCha
) const;

51 
	gASCIIVid
::
ASCIIVid
(cڡ 
d
::
rg
& 
aTeedSg
) :

52 
m_TeedSg
(
aTeedSg
)

55 
ASCIIVid
::
ݔ
()(
aCha
) const

58 i(
aCha
 <= 0) {

59 
ThrowMsg
(

60 
SgExi
::
InvidASCIICha
,

61 "vid cha cod" << 
ic_
<>(
aCha
)

63 
m_TeedSg


68 cڡ 
icv_t
 
	ggc_IcvOrE
 = 
t_
<iconv_t>(-1);

69 cڡ 
size_t
 
	ggc_IcvCvtE
 = 
ic_
<size_t>(-1);

72 
Sg
 
	$FromUTF8Sg
(cڡ 
d
::
rg
& 
aIn
)

74 i(
aIn
.
	`emy
()) {

75  
	`Sg
();

78 
size_t
 
bys
 = 
aIn
.
	`size
();

87 
size_t
 
outbys
 = (
wch_t
* (
bys
 + 2);

88 
d
::
ve
<
wch_t
> 
	`ouut
(
bys
 + 2, 0);

90 
size_t
 
outbye
 = 
outbys
;

91 * 
buf
 = 
cڡ_
<*>(
aIn
.
	`c_r
());

95 * 
outbuf
 = 
t_
<*>(&
ouut
[0]);

97 
icv_t
 
icvHd
 = 
	`icv_ݒ
("UTF-32", "UTF-8");

99 i(
gc_IcvOrE
 =
icvHd
) {

100 
r
 = 
o
;

102 
	`ThrowMsg
(
SgExi
::
IcvInEUTF8ToUTF32
,

104 "r: " << 
	`GEnoSg
(
r
));

107 
size_t
 
icvR
 = 
	`icv
(
icvHd
,

108 &
buf
,

109 &
bys
,

110 &
outbuf
,

111 &
outbye
);

113 
	`icv_o
(
icvHd
);

115 i(
gc_IcvCvtE
 =
icvR
) {

116 
	`ThrowMsg
(
SgExi
::
IcvCvtEUTF8ToUTF32
,

118 << 
	`GEnoSg
());

122  &
ouut
[1];

123 
	}
}

125 
	gd
::
rg
 
	$ToUTF8Sg
(cڡ 
VceDPL
::
Sg
& 
aIn
)

127 i(
aIn
.
	`emy
()) {

128  
d
::
	`rg
();

131 
size_t
 
bys
 = 
aIn
.
	`size
(* (
wch_t
);

132 
size_t
 
outbys
 = 
bys
 + ();

136 * 
buf
 = 
t_
<*>(
cڡ_
<
wch_t
*>(
aIn
.
	`c_r
()));

137 
d
::
ve
<> 
	`ouut
(
bys
, 0);

138 * 
outbuf
 = &
ouut
[0];

140 
size_t
 
outbye
 = 
outbys
;

142 
icv_t
 
icvHd
 = 
	`icv_ݒ
("UTF-8", "UTF-32");

144 i(
gc_IcvOrE
 =
icvHd
) {

145 
	`ThrowMsg
(
SgExi
::
IcvInEUTF32ToUTF8
,

147 << "r: " << 
	`GEnoSg
());

150 
size_t
 
icvR
 = 
	`icv
(
icvHd
,

151 &
buf
,

152 &
bys
,

153 &
outbuf
,

154 &
outbye
);

156 
	`icv_o
(
icvHd
);

158 i(
gc_IcvCvtE
 =
icvR
) {

159 
	`ThrowMsg
(
SgExi
::
IcvCvtEUTF32ToUTF8
,

161 << "r: " << 
	`GEnoSg
());

164  &
ouut
[0];

165 
	}
}

167 
Sg
 
	$FromASCIISg
(cڡ 
d
::
rg
& 
aSg
)

169 
Sg
 
ouut
;

171 
d
::
	`f_ch
(
aSg
.
	`beg
(),Sg.
	`d
(), 
	`ASCIIVid
(aString));

172 
d
::
	`cy
(
aSg
.
	`beg
(),Sg.
	`d
(), std::
back_
<
Sg
>(
ouut
));

174  
ouut
;

175 
	}
}

177 
Sg
 
	$FromUTF32Sg
(cڡ 
d
::
wrg
& 
aSg
)

179  
	`Sg
(&
aSg
[0]);

180 
	}
}

182 
UCh
 *
	$CvtToICU
(cڡ 
Sg
 &
putSg
)

184 
d
::
unique_r
<
UCh
[]> 
ouutSg
;

185 
t32_t
 
size
 = 0;

186 
t32_t
 
cvdSize
 = 0;

187 
UECode
 
r
 = 
U_ZERO_ERROR
;

190 ::
	`u_rFromWCS
(
NULL
,

192 &
size
,

193 
putSg
.
	`c_r
(),

195 &
r
);

197 i(
r
 =
U_ZERO_ERROR
 ||

198 
r
 =
U_BUFFER_OVERFLOW_ERROR
)

201 
	`VceLogD
("ICU: Ouubufsize: %i", 
size
);

203 
	`ThrowMsg
(
SgExi
::
ICUInvidChaFound
,

205 << 
r
);

209 
ouutSg
.
	`t
(
w
 
UCh
[
size
 + 1]);

210 ::
	`memt
(
ouutSg
.
	`g
(), 0, (
UCh
* (
size
 + 1));

212 
r
 = 
U_ZERO_ERROR
;

215 ::
	`u_rFromWCS
(
ouutSg
.
	`g
(),

216 
size
 + 1,

217 &
cvdSize
,

218 
putSg
.
	`c_r
(),

220 &
r
);

222 i(!
	`U_SUCCESS
(
r
)) {

223 
	`ThrowMsg
(
SgExi
::
ICUInvidChaFound
,

224 "ICU: Faedcvrg. E: " << 
r
);

228  
ouutSg
.
	`a
();

229 
	}
}

231 
	$SgCom
(cڡ 
Sg
 &

,

232 cڡ 
Sg
 &
right
,

233 
bo
 
Innsive
)

236 
d
::
unique_r
<
UCh
[]> 
	`ICU
(
	`CvtToICU
(

));

237 
d
::
unique_r
<
UCh
[]> 
	`rightICU
(
	`CvtToICU
(
right
));

239 i(
Innsive
) {

240  
ic_
<>(
	`u_rcmp
(
ICU
.
	`g
(), 
rightICU
.get(), 0));

242  
ic_
<>(
	`u_rcmp
(
ICU
.
	`g
(), 
rightICU
.get()));

244 
	}
}

247 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
aSm
, cڡ 
	gVceDPL
::
Sg
& 
aSg
)

249  
aSm
 << 
VceDPL
::
ToUTF8Sg
(
aSg
);

	@vcore/src/dpl/core/src/thread.cpp

22 
	~<ddef.h
>

23 
	~<d/thad.h
>

24 
	~<d/log/vce_log.h
>

25 
	~<sys/time.h
>

26 
	~<gܙhm
>

27 
	~<d/as.h
>

28 
	~<o.h
>

29 
	~<time.h
>

30 
	~<rg.h
>

32 
	gmea


34 cڡ 
size_t
 
	gNANOSECONDS_PER_SECOND
 =

35 
ic_
<
ut64_t
>(1000 * 1000 * 1000);

37 cڡ 
size_t
 
	gNANOSECONDS_PER_MILISECOND
 =

38 
ic_
<
ut64_t
>(1000 * 1000);

40 cڡ 
size_t
 
	gNANOSECONDS_PER_MICROSECOND
 =

41 
ic_
<
ut64_t
>(1000);

43 cڡ 
	gd
::
thad
::
id
 
g_maThad
 = 
d
::
this_thad
::
g_id
();

45 as
	cThadScific


47 
	gpublic
:

48 
had_key_t
 
thadScific
;

50 
ThadScific
() :

51 
thadScific
(0)

53 
thadScific
 = 0;

54 
had_key_
(&
thadScific
, 
NULL
);

57 
	gvtu
 ~
ThadScific
()

59 
had_key_de
(
thadScific
);

63 
ThadScific
 
	gg_thadScific
;

66 
mea
 
	gVceDPL
 {

67 
bo
 
	gg_TLSfMaCed
 = 
l
;

69 
	gThad
::
Thad
() :

70 
m_thad
(),

71 
m_abd
(
l
),

72 
m_rug
(
l
),

73 
m_deInvoke
(
l
)

76 
	gThad
::~
Thad
()

82 
Qu
();

86 
	gIlEvtLi
::

 it = 
m_evtLi
.
beg
();

87 
	g
 !
m_evtLi
.
d
();

88 ++
	g
)

90 
	g
->
evtDeProc
(

->
evt
, it->
urPam
);

93 
	gm_evtLi
.
r
();

96 
bo
 
	gThad
::
IsMaThad
()

98  (
d
::
this_thad
::
g_id
(=
g_maThad
);

101 
Thad
 *
	gThad
::
GCutThad
()

103 i(
d
::
this_thad
::
g_id
(=
g_maThad
) {

104  
NULL
;

107 *
	gthadScific
 = 
had_gecific
(
g_thadScific
.
thadScific
);

110 i(
	gthadScific
 =
NULL
) {

111 
Throw
(
Exi
::
UnmagedThad
);

114  
	gic_
<
	gThad
 *>(
	gthadScific
);

117 *
	gThad
::
SticThadEry
(*
m
)

119 
VceLogD
("Entered statichreadntry");

122 
Thad
 *
	gThis
 = 
ic_
<Thad *>(
m
);

123 
As
(
This
 !
NULL
);

126 
	gsu
 = 
had_tecific
(
g_thadScific
.
thadScific
, 
This
);

128 i(
	gsu
)

129 
VceLogE
("Failedo sethreadSpecific.");

133 
	gUNHANDLED_EXCEPTION_HANDLER_BEGIN


135 
	gThis
->
ThadEry
();

137 
	gUNHANDLED_EXCEPTION_HANDLER_END


142 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(
This
->
m_eMux
);

144 
	gThis
->
	gm_rug
 = 
l
;

147 i(
	gThis
->
	gm_abd
) {

148 
VceLogD
("Thread wasbandoned");

149 
	gThis
->
	gm_thad
.
dach
();

151 
VceLogD
("Thread is joinable");

155  
	gNULL
;

158 
	gThad
::
ThadEry
()

160 
VceLogD
("Entered defaulthreadntry");

161  
Exec
();

164 
	gThad
::
ProssEvts
()

166 
VceLogD
("Processingvents");

169 
IlEvtLi
 
	gޒEvts
;

173 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(
m_evtMux
);

174 
	gm_evtLi
.
sw
(
ޒEvts
);

175 
	gm_evtInvok
.
Ret
();

179 
VceLogD
("Stޒ %u ievts", 
ޒEvts
.
size
());

181 
	gIlEvtLi
::

 it = 
ޒEvts
.
beg
();

182 
	g
 !
ޒEvts
.
d
();

183 ++
	g
)

186 
	g
->
evtDichProc
(

->
evt
, it->
urPam
);

189 
	g
->
evtDeProc
(

->
evt
, it->
urPam
);

193 
	gThad
::
ProssTimedEvts
()

197 
d
::
lock_gud
<d::
mux
> 
lock
(
m_timedEvtMux
);

200 
	gcutTimeMicds
 = 
GCutTimeMicds
();

203 
VceLogD
("Prossgimedvts. Timnow: %lu ms", 
cutTimeMicds
);

207 !
	gm_timedEvtVe
.
emy
() &&

208 
	gcutTimeMicds
 >=

209 
m_timedEvtVe
.
beg
()->
giTimeMicds
 +

210 
m_timedEvtVe
.
beg
()->
dueTimeMicds
)

213 
VceLogD
("Transformingimedvent into immediatevent. Absolute dueime: %lu ms",

214 (
m_timedEvtVe
.
beg
()->
giTimeMicds
 +

215 
m_timedEvtVe
.
beg
()->
dueTimeMicds
));

218 
PushEvt
(
m_timedEvtVe
.
beg
()->
evt
,

219 
m_timedEvtVe
.
beg
()->
evtDichProc
,

220 
m_timedEvtVe
.
beg
()->
evtDeProc
,

221 
m_timedEvtVe
.
beg
()->
urPam
);

224 
	gd
::
p_hp
(
m_timedEvtVe
.
beg
(), m_timedEvtVe.
d
());

225 
	gm_timedEvtVe
.
p_back
();

230 
	gThad
::
GCutTimeMicds
() const

232 
timev
 
tv
;

233 
gtimeofday
(&
tv
, 
NULL
);

234  
	gic_
<>(
	gtv
.
	gtv_c
) * 1000 +

235 
	gic_
<>(
	gtv
.
	gtv_uc
) / 1000;

238 
	gThad
::
Exec
()

240 
VceLogD
("Executinghreadventrocessing");

242 cڡ 
	gd
::
size_t
 
MIN_HANDLE_LIST_SIZE
 = 4;

245 
WaabHdLiEx
 
	ghdLi
;

248 
	ghdLi
.
push_back
(
d
::
make_
(
m_quEvt
.
GHd
(), 
WaMode
::
Rd
));

251 
	ghdLi
.
push_back
(
d
::
make_
(
m_evtInvok
.
GHd
(),

252 
WaMode
::
Rd
));

255 
	ghdLi
.
push_back
(
d
::
make_
(
m_timedEvtInvok
.
GHd
(),

256 
WaMode
::
Rd
));

259 
	ghdLi
.
push_back
(
d
::
make_
(
WaabHdWchSut
::

260 
WaabInvokHd
(),

261 
WaMode
::
Rd
));

268 
WaabHdLiEx
 
	gwaabHdWchHds
 =

269 
WaabHdWchSut
::
WaabWchHds
();

270 
	gd
::
cy
(

271 
waabHdWchHds
.
beg
(),

272 
waabHdWchHds
.
d
(), 
d
::
back_
(
hdLi
));

276 
bo
 
	gqu
 = 
l
;

278 !
	gqu
) {

280 
	gmimumWaTime
;

284 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(
m_timedEvtMux
);

286 i(!
	gm_timedEvtVe
.
emy
()) {

287 
	gcutTimeMicds
 =

288 
GCutTimeMicds
();

289 
	gdeiTimeMicds
 =

290 
m_timedEvtVe
.
beg
()->
giTimeMicds
 +

291 
m_timedEvtVe
.
beg
()->
dueTimeMicds
;

294 i(
	gcutTimeMicds
 > 
	gdeiTimeMicds
) {

295 
	gmimumWaTime
 = 0;

297 
	gmimumWaTime
 = 
deiTimeMicds
 -

298 
cutTimeMicds
;

301 
	gmimumWaTime
 = 0xFFFFFFFF;

306 
VceLogD
("Thado mimum waime: %lu ms", 
mimumWaTime
);

309 
WaabHdIndexLi
 
	gwaabHdIndexLi
 =

310 
WaFMuɝHds
(
hdLi
, 
mimumWaTime
);

312 i(
	gwaabHdIndexLi
.
emy
()) {

314 
VceLogD
("Timedventistlapsed invoker");

315 
ProssTimedEvts
();

320 
	gWaabHdIndexLi
::
cڡ_


321 
waabHdIndexIt
 = 
waabHdIndexLi
.
beg
();

322 
	gwaabHdIndexIt
 !
waabHdIndexLi
.
d
();

323 ++
	gwaabHdIndexIt
)

325 
size_t
 
	gdex
 = *
waabHdIndexIt
;

327 
VceLogD
("Evlo݁rigged wh index: %u", 
dex
);

329 
	gdex
) {

332 
qu
 = 
ue
;

337 
ProssEvts
();

340 i(
	gm_deInvoke
) {

341 
	gm_deInvoke
 = 
l
;

343 
VceLogD
("Handling direct invoker");

346 
	ghdLi
.
size
(> 
	gMIN_HANDLE_LIST_SIZE
) {

347 
	ghdLi
.
p_back
();

352 
WaabHdLiEx
 
	gwaabHdWchHds
 =

353 
WaabHdWchSut
::
WaabWchHds
();

354 
	gd
::
cy
(

355 
waabHdWchHds
.
beg
(),

356 
waabHdWchHds
.
d
(),

357 
d
::
back_
(
hdLi
));

366 
VceLogD
("Timedventist changed invoker");

367 
ProssTimedEvts
();

370 
	gm_timedEvtInvok
.
Ret
();

377 
VceLogD
("Waitable handle watch invokervent occurred");

380 
	ghdLi
.
size
(> 
	gMIN_HANDLE_LIST_SIZE
) {

381 
	ghdLi
.
p_back
();

386 
WaabHdLiEx
 
	gwaabHdWchHds
 =

387 
WaabHdWchSut
::
WaabWchHds
();

388 
	gd
::
cy
(

389 
waabHdWchHds
.
beg
(),

390 
waabHdWchHds
.
d
(),

391 
d
::
back_
(
hdLi
));

395 
	gWaabHdWchSut
::
InvokFished
();

397 
VceLogD
("Waitable handle watch invokervent handled");

404 
VceLogD
("Waitable handle watchvent occurred");

408 
	gd
::

<
WaabHd
,

409 
	gWaMode
::
Ty
> 
hd
 = 
hdLi
[
dex
];

410 
	gWaabHdWchSut
::
HdWch
(
hd
.
f
,

411 
hd
.
cd
);

414 i(
	gm_deInvoke
) {

415 
	gm_deInvoke
 = 
l
;

417 
VceLogD
("Handling direct invoker");

420 
	ghdLi
.
size
(> 
	gMIN_HANDLE_LIST_SIZE
) {

421 
	ghdLi
.
p_back
();

426 
WaabHdLiEx
 
	gwaabHdWchHds
 =

427 
WaabHdWchSut
::

428 
WaabWchHds
();

429 
	gd
::
cy
(
waabHdWchHds
.
beg
(),

430 
waabHdWchHds
.
d
(),

431 
d
::
back_
(
hdLi
));

435 
VceLogD
("Waitable handle watchvent handled");

443 
VceLogD
("Leavinghreadventrocessing");

447 
	gThad
::
Run
()

449 
VceLogD
("Runninghread");

453 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(
m_eMux
);

455 i(
	gm_rug
) {

459 
	gy
{

460 
	gm_thad
 = 
d
::
thad
(
SticThadEry
,
this
);

461 }
tch
(
d
::
syem_r
 
e
){

462 
Throw
(
Exi
::
RunFaed
);

466 
	gm_abd
 = 
ue
;

469 
	gm_rug
 = 
ue
;

472 
VceLogD
("Threadun");

475 
	gThad
::
Qu
()

479 
d
::
lock_gud
<d::
mux
> 
lock
(
m_eMux
);

482 i(!
	gm_rug
) {

486 
VceLogD
("Quittinghread...");

489 
	gm_abd
 = 
l
;

492 
	gm_quEvt
.
Sigl
();

495 
	gy
{

496 
	gm_thad
.
jo
();

497 }
tch
(
d
::
syem_r
 
e
){

498 
Throw
(
Exi
::
QuFaed
);

501 
VceLogD
("Thread quit");

504 
	gThad
::
PushEvt
(*
evt
,

505 
EvtDichProc
 
evtDichProc
,

506 
EvtDeProc
 
evtDeProc
,

507 *
urPam
)

510 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(
m_evtMux
);

513 
	gm_evtLi
.
push_back
(
IlEvt
(
evt
, 
urPam
, 
evtDichProc
,

514 
evtDeProc
));

517 
	gm_evtInvok
.
Sigl
();

519 
VceLogD
("Eventushednd invoker signaled");

522 
	gThad
::
PushTimedEvt
(*
evt
,

523 
dueTimeSecds
,

524 
EvtDichProc
 
evtDichProc
,

525 
EvtDeProc
 
evtDeProc
,

526 *
urPam
)

529 
As
(
dueTimeSecds
 >= 0.0);

532 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(
m_timedEvtMux
);

535 
	gcutTimeMicds
 = 
GCutTimeMicds
();

538 
	gdueTimeMicds
 =

539 
ic_
<>(1000.0 * 
dueTimeSecds
);

542 
	gm_timedEvtVe
.
push_back
(
IlTimedEvt
(
evt
, 
urPam
,

543 
dueTimeMicds
,

544 
cutTimeMicds
,

545 
evtDichProc
,

546 
evtDeProc
));

549 
	gd
::
make_hp
(
m_timedEvtVe
.
beg
(), m_timedEvtVe.
d
());

552 
	gm_timedEvtInvok
.
Sigl
();

554 
VceLogD
("Timedventushednd invoker signaled: "

556 
dueTimeMicds
, 
cutTimeMicds
 + dueTimeMiliseconds);

559 
Thad
 *
	gThad
::
GInvokThad
()

561  
this
;

564 
	gThad
::
HdDeInvok
()

568 
m_deInvoke
 = 
ue
;

571 
	gThad
::
S˕
(
ut64_t
 
cds
)

573 
NoS˕
(
cds
 * 
NANOSECONDS_PER_SECOND
);

576 
	gThad
::
MiS˕
(
ut64_t
 
micds
)

578 
NoS˕
(
micds
 * 
NANOSECONDS_PER_MILISECOND
);

581 
	gThad
::
MioS˕
(
ut64_t
 
miocds
)

583 
NoS˕
(
miocds
 * 
NANOSECONDS_PER_MICROSECOND
);

586 
	gThad
::
NoS˕
(
ut64_t
 
nocds
)

588 
timeec
 
queedTime
 = {

589 
ic_
<
time_t
>(

590 
nocds
 / 
NANOSECONDS_PER_SECOND
),

592 
ic_
<>(

593 
nocds
 % 
NANOSECONDS_PER_SECOND
)

596 
timeec
 
	gmagTime
;

599 i(
nop
(&
queedTime
, &
magTime
) == 0) {

603 
	gr
 = 
o
;

604 
As
(
r
 =
EINTR
);

606 
	gqueedTime
 = 
magTime
;

	@vcore/src/dpl/core/src/type_list.cpp

22 
	~<ddef.h
>

23 
	~<d/ty_li.h
>

	@vcore/src/dpl/core/src/waitable_event.cpp

22 
	~<ddef.h
>

23 
	~<d/waab_evt.h
>

24 
	~<sys/.h
>

25 
	~<unid.h
>

26 
	~<f.h
>

27 
	~<o.h
>

28 
	~<o.h
>

30 
mea
 
	gVceDPL
 {

31 
	gWaabEvt
::
WaabEvt
()

33 i(
pe
(
m_pe
) == -1) {

34 
Throw
(
Exi
::
CeFaed
);

37 i(
f
(
m_pe
[0], 
F_SETFL
, 
O_NONBLOCK
 |

38 
f
(
m_pe
[0], 
F_GETFL
)) == -1)

40 
Throw
(
Exi
::
CeFaed
);

44 
	gWaabEvt
::~
WaabEvt
()

46 i(
TEMP_FAILURE_RETRY
(
o
(
m_pe
[0])) == -1) {

47 
Throw
(
Exi
::
DeroyFaed
);

50 i(
TEMP_FAILURE_RETRY
(
o
(
m_pe
[1])) == -1) {

51 
Throw
(
Exi
::
DeroyFaed
);

55 
WaabHd
 
	gWaabEvt
::
GHd
() const

57  
m_pe
[0];

60 
	gWaabEvt
::
Sigl
() const

62 
da
 = 0;

64 i(
TEMP_FAILURE_RETRY
(
wre
(
m_pe
[1], &
da
, 1)) != 1) {

65 
Throw
(
Exi
::
SiglFaed
);

69 
	gWaabEvt
::
Ret
() const

71 
da
;

73 i(
TEMP_FAILURE_RETRY
(
ad
(
m_pe
[0], &
da
, 1)) != 1) {

74 
Throw
(
Exi
::
RetFaed
);

	@vcore/src/dpl/core/src/waitable_handle.cpp

22 
	~<ddef.h
>

23 
	~<d/waab_evt.h
>

24 
	~<d/wkound.h
>

25 
	~<sys/.h
>

26 
	~<unid.h
>

27 
	~<f.h
>

28 
	~<o.h
>

29 
	~<d/as.h
>

31 
mea
 
	gVceDPL
 {

32 
	gmea


34 
CheckWaabHd
(
WaabHd
 
hd
)

36 #ifde
DPL_ENABLE_WAITABLE_HANDLE_BADF_CHECK


38 
	gsu
 = 
f
(
hd
, 
F_GETFL
);

40 i(
	gsu
 =-1 && 
o
 =
EBADF
) {

41 
AsMsg
(0, "CheckWaitableHandle: Invalid WaitableHandle! (EBADF)");

44 
AsMsg
(
su
 != -1, "CheckWaitableHandle: Invalid WaitableHandle!");

49 
WaabHdIndexLi
 
WaFSgHd
(
WaabHd
 
hd
,

50 
micds
)

52 
WaabHdLi
 
	gwaHds
;

53 
	gwaHds
.
push_back
(
hd
);

54  
WaFMuɝHds
(
waHds
, 
micds
);

57 
WaabHdIndexLi
 
WaFSgHd
(
WaabHd
 
hd
,

58 
WaMode
::
Ty
 
mode
,

59 
micds
)

61 
WaabHdLiEx
 
	gwaHds
;

62 
	gwaHds
.
push_back
(
d
::
make_
(
hd
, 
mode
));

63  
WaFMuɝHds
(
waHds
, 
micds
);

66 
WaabHdIndexLi
 
WaFMuɝHds
(

67 cڡ 
WaabHdLi
 &
waabHdLi
,

68 
micds
)

70 
WaabHdLiEx
 
	ghdLi
;

72 
	gWaabHdLi
::
cڡ_
 

 = 
waabHdLi
.
beg
();

73 
	g
 !
waabHdLi
.
d
();

74 ++
	g
)

77 
	ghdLi
.
push_back
(
d
::
make_
(*

, 
WaMode
::
Rd
));

81  
WaFMuɝHds
(
hdLi
, 
micds
);

84 
WaabHdIndexLi
 
WaFMuɝHds
(

85 cڡ 
WaabHdLiEx
 &
waabHdLiEx
,

86 
micds
)

88 
fd_t
 
	gadFds
, 
	gwreFds
, 
	grFds
;

91 
	gmaxFd
 = -1;

93 
FD_ZERO
(&
adFds
);

94 
FD_ZERO
(&
wreFds
);

95 
FD_ZERO
(&
rFds
);

98 
	gWaabHdLiEx
::
cڡ_
 

 =

99 
waabHdLiEx
.
beg
();

100 
	g
 !
waabHdLiEx
.
d
();

101 ++
	g
)

103 i(
	g
->
	gf
 > 
	gmaxFd
) {

104 
	gmaxFd
 = 

->
f
;

107 
CheckWaabHd
(

->
f
);

110 
FD_SET
(

->
f
, &
rFds
);

112 i(
	g
->
	gcd
 =
WaMode
::
Rd
) {

113 
FD_SET
(

->
f
, &
adFds
);

114 } i(
	g
->
	gcd
 =
WaMode
::
Wre
) {

115 
FD_SET
(

->
f
, &
wreFds
);

120 
timev
 
	gtimeout
;

121 
timev
 *
	gefiveTimeout
 = 
NULL
;

122 i(
	gmicds
 != 0xFFFFFFFF) {

123 
timeout
.
tv_c
 = 
micds
 / 1000;

124 
	gtimeout
.
	gtv_uc
 = (
micds
 % 1000) * 1000;

125 
	gefiveTimeout
 = &
timeout
;

128 i(
TEMP_FAILURE_RETRY
(

(
maxFd
 + 1, &
adFds
, &
wreFds
, &
rFds
,

129 
efiveTimeout
)) == -1)

131 
Throw
(
WaFaed
);

135 
WaabHdIndexLi
 
	gdexes
;

136 
size_t
 
	gdex
 = 0;

138 
	gWaabHdLiEx
::
cڡ_
 

 =

139 
waabHdLiEx
.
beg
();

140 
	g
 !
waabHdLiEx
.
d
();

141 ++
	g
)

144 i(
FD_ISSET
(

->
f
, &
rFds
)) {

145 
	gdexes
.
push_back
(
dex
);

146 } i(
	g
->
	gcd
 =
WaMode
::
Rd
) {

147 i(
FD_ISSET
(

->
f
, &
adFds
)) {

148 
dexes
.
push_back
(
dex
);

150 } i(
	g
->
	gcd
 =
WaMode
::
Wre
) {

151 i(
FD_ISSET
(

->
f
, &
wreFds
)) {

152 
dexes
.
push_back
(
dex
);

155 ++
	gdex
;

159  
	gdexes
;

	@vcore/src/dpl/core/src/waitable_handle_watch_support.cpp

23 
	~<ddef.h
>

24 
	~<d/waab_hd_wch_sut.h
>

25 
	~<d/thad.h
>

26 
	~<d/log/vce_log.h
>

27 
	~<gܙhm
>

28 
	~<d/as.h
>

30 
mea
 
	gVceDPL
 {

31 
	gWaabHdWchSut
::
WaabHdWchSut
()

34 
WaabHdWchSut
::~WaitableHandleWatchSupport()

37 i(!
m_wchsM
.
emy
()) {

38 
VceLogW
("### Leaked watchers map dump ###");

40 
	gWaabHdWchsM
::
cڡ_
 

 =

41 
m_wchsM
.
beg
();

42 
	g
 !
m_wchsM
.
d
();

43 ++
	g
)

45 
VceLogW
("### Waab hd: %i", 

->
f
);

47 
VceLogW
("### Rdis: %u", 

->
cd
.
adLisCou
);

48 
VceLogW
("### Wrlis: %u", 

->
cd
.
wreLisCou
);

50 
	gWaabHdLiLi
::
cڡ_
 
lisIt
 =

51 

->
cd
.
lis
.
beg
();

52 
	glisIt
 !

->
cd
.
lis
.
d
();

53 ++
	glisIt
)

55 
VceLogW
("### Mode: %i. Listener: %p",

56 
lisIt
->
mode
,isIt->
li
);

62 
WaabHd
 
	gWaabHdWchSut
::
WaabInvokHd
() const

64  
m_wchsInvok
.
GHd
();

67 
WaabHdLiEx
 
	gWaabHdWchSut
::
WaabWchHds
() const

71 
d
::
lock_gud
<d::
cursive_mux
> 
lock
(
m_wchsMux
);

73 
WaabHdLiEx
 
	ghdLi
;

75 
	gWaabHdWchsM
::
cڡ_
 

 =

76 
m_wchsM
.
beg
();

77 
	g
 !
m_wchsM
.
d
();

78 ++
	g
)

83 i(
	g
->
	gcd
.
	gadLisCou
 > 0) {

84 
	ghdLi
.
push_back
(
d
::
make_
(

->
f
,

85 
WaMode
::
Rd
));

88 i(
	g
->
	gcd
.
	gwreLisCou
 > 0) {

89 
	ghdLi
.
push_back
(
d
::
make_
(

->
f
,

90 
WaMode
::
Wre
));

94  
	ghdLi
;

98 
	gWaabHdWchSut
::
InvokFished
()

100 
VceLogD
("Invoker finished called");

103 
	gm_wchsInvok
.
Ret
();

106 
	gm_wchsInvokComm
.
Sigl
();

109 
	gWaabHdWchSut
::
HdWch
(
WaabHd
 
waabHd
,

110 
WaMode
::
Ty
 
mode
)

119 
VceLogD
("Waitablevent occurred");

123 
	gd
::
lock_gud
<
d
::
cursive_mux
> 
lock
(
m_wchsMux
);

130 
WaabHdWchsM
 
	gackedWchs
 = 
m_wchsM
;

132 
	gWaabHdWchsM
::
cڡ_
 
ackedWchsIt


133 
ackedWchs
.
beg
();

134 
	gackedWchsIt
 !
ackedWchs
.
d
();

135 ++
	gackedWchsIt
)

139 i(
	gm_wchsM
.
fd
(
ackedWchsIt
->
f
) ==

140 
m_wchsM
.
d
())

142 
VceLogD
("Watcher disappeared during watcher handler");

147 i(
	gwaabHd
 !
ackedWchsIt
->
f
) {

152 
WaabHdLiLi
 
	gackedLis
 =

153 
ackedWchsIt
->
cd
.
lis
;

155 
VceLogD
("Calling waitableventisteners (%u)...",

156 
ackedLis
.
size
());

166 
	gWaabHdLiLi
::
cڡ_


167 
ackedLisIt
 = 
ackedLis
.
beg
();

168 
	gackedLisIt
 !
ackedLis
.
d
();

169 ++
	gackedLisIt
)

174 i(
	gm_wchsM
.
fd
(
ackedWchsIt
->
f
) ==

175 
m_wchsM
.
d
())

177 
VceLogD
("Watcher disappeared during watcher handler");

183 
bo
 
	gliStlExis
 = 
l
;

185 
	gWaabHdLiLi
::
cڡ_


186 
chLiIt
 =

187 
ackedWchsIt
->
cd
.
lis
.
beg
();

188 
	gchLiIt
 !=

189 
ackedWchsIt
->
cd
.
lis
.
d
();

190 ++
	gchLiIt
)

192 i(
	gchLiIt
->
	gli
 ==

193 
ackedLisIt
->
li
 &&

194 
chLiIt
->
mode
 ==

195 
ackedLisIt
->
mode
)

197 
liStlExis
 = 
ue
;

202 i(!
	gliStlExis
) {

203 
VceLogD
("Watcheristener disappeared during watcher handler");

208 i(
	gmode
 !
ackedLisIt
->
mode
) {

213 
VceLogD
("Beforerackeristener call...");

214 
	gackedLisIt
->
	gli
->
OnWaabHdEvt
(

215 
ackedWchsIt
->
f
,

216 
ackedLisIt
->
mode
);

217 
VceLogD
("Afterrackeristener call...");

223 
VceLogD
("Waitableventisteners called");

231 
	gWaabHdWchSut
::
AddWaabHdWch
(

232 
WaabHdLi
* 
li
,

233 
WaabHd
 
waabHd
,

234 
WaMode
::
Ty
 
mode
)

237 
d
::
lock_gud
<d::
cursive_mux
> 
lock
(
m_wchsMux
);

240 
	gWaabHdWchsM
::

 
mIt
 = 
m_wchsM
.
fd
(

241 
waabHd
);

243 i(
	gmIt
 !
m_wchsM
.
d
()) {

246 
WaabHdLiLi
::

 
lisIt
 =

247 
mIt
->
cd
.
lis
.
beg
();

248 
	glisIt
 !
mIt
->
cd
.
lis
.
d
();

249 ++
	glisIt
)

252 
As
(

253 
lisIt
->
li
 !=istener ||

254 
lisIt
->
mode
 != mode);

258 
VceLogD
("Addg waab hd wch: %i", 
waabHd
);

261 i(
	gmIt
 !
m_wchsM
.
d
()) {

262 
mIt
->
cd
.
lis
.
push_back
(
WaabHdWch
(
li
,

263 
mode
));

265 
	gm_wchsM
[
waabHd
].
	glis
.
push_back
(
WaabHdWch
(

266 
li
, 
mode
));

270 
	gmode
) {

271 
	gWaMode
::
Rd
:

272 
m_wchsM
[
waabHd
].
adLisCou
++;

275 
	gWaMode
::
Wre
:

276 
m_wchsM
[
waabHd
].
wreLisCou
++;

280 
As
(0);

284 
CommInvok
();

286 
VceLogD
("Waitablevent watchddednd invoker signaled");

289 
	gWaabHdWchSut
::
RemoveWaabHdWch
(

290 
WaabHdLi
 *
li
,

291 
WaabHd
 
waabHd
,

292 
WaMode
::
Ty
 
mode
)

295 
d
::
lock_gud
<d::
cursive_mux
> 
lock
(
m_wchsMux
);

298 
	gWaabHdWchsM
::

 
mIt
 = 
m_wchsM
.
fd
(

299 
waabHd
);

301 
As
(
mIt
 !
m_wchsM
.
d
());

304 
	gWaabHdLiLi
::

 
liIt
 =

305 
mIt
->
cd
.
lis
.
d
();

307 
	gWaabHdLiLi
::

 
lisIt
 =

308 
mIt
->
cd
.
lis
.
beg
();

309 
	glisIt
 !
mIt
->
cd
.
lis
.
d
();

310 ++
	glisIt
)

313 i(
	glisIt
->
	gli
 =
li
 &&

314 
lisIt
->
mode
 == mode)

316 
liIt
 = 
lisIt
;

322 
As
(
liIt
 !
mIt
->
cd
.
lis
.
d
());

324 
VceLogD
("Removg waab hd wch: %i", 
waabHd
);

327 
	gmIt
->
	gcd
.
	glis
.
a
(
liIt
);

330 
	gmode
) {

331 
	gWaMode
::
Rd
:

332 
mIt
->
cd
.
adLisCou
--;

335 
	gWaMode
::
Wre
:

336 
mIt
->
cd
.
wreLisCou
--;

340 
As
(0);

344 i(
	gmIt
->
	gcd
.
	glis
.
emy
()) {

345 
	gm_wchsM
.
a
(
mIt
);

349 
CommInvok
();

351 
VceLogD
("Waitablevent watchemovednd invoker signaled");

354 
	gWaabHdWchSut
::
CommInvok
()

357 i(
Thad
::
GCutThad
(=
GInvokThad
()) {

358 
VceLogD
("Calling direct invoker");

361 
HdDeInvok
();

363 
VceLogD
("Calling indirect invoker");

366 
	gm_wchsInvok
.
Sigl
();

368 
WaabHdLi
 
	gwaHds
;

369 
	gwaHds
.
push_back
(
m_wchsInvokComm
.
GHd
());

370 
WaFMuɝHds
(
waHds
);

372 
	gm_wchsInvokComm
.
Ret
();

	@vcore/src/dpl/db/include/dpl/db/naive_synchronization_object.h

23 #ide
DPL_NAIVE_SYNCHRONIZATION_OBJECT_H


24 
	#DPL_NAIVE_SYNCHRONIZATION_OBJECT_H


	)

26 
	~<d/db/sql_ci.h
>

28 
mea
 
	gVceDPL
 {

29 
mea
 
	gDB
 {

34 as
	cNaiveSynchriziObje
 :

35 
public
 
SqlCi
::
SynchriziObje


37 
public
:

39 
vtu
 
Synchrize
();

40 
vtu
 
NifyA
();

	@vcore/src/dpl/db/include/dpl/db/orm.h

23 
	~<cdlib
>

24 
	~<cdio
>

25 
	~<rg
>

26 
	~<tyfo
>

27 
	~<uty
>

28 
	~<t
>

29 
	~<li
>

30 
	~<memy
>

31 
	~<boo/tiڮ.h
>

33 
	~<d/db/sql_ci.h
>

34 
	~<d/db/m_r.h
>

35 
	~<d/rg.h
>

36 
	~<d/ty_li.h
>

37 
	~<d/as.h
>

38 
	~<d/fܗch.h
>

40 #ide
DPL_ORM_H


41 
	#DPL_ORM_H


	)

43 
mea
 
	gVceDPL
 {

44 
mea
 
	gDB
 {

45 
mea
 
	gORM
 {

48 
	#DPL_CHECK_TYPE_INSTANTIABILITY
(
ty
) \

50 
ty
 
_igned_
; \

51 ()
_igned_
; \

52 }

	)

54 
	#DECLARE_COLUMN_TYPE_LIST
(
VceDPL
::
	tTyLiDe
<

	)

55 
	tSELECTED_COLUMN
(
	tb_me
, 
	tcumn_me
b_me::cumn_me,

	)

56 
	tDECLARE_COLUMN_TYPE_LIST_END
(
	tme

	tVceDPL
::
	tTyLiGud
>::
	tTy
ame;

	)

58 
size_t
 
	tCumnIndex
;

59 
size_t
 
	tArgumtIndex
;

60 
	gboo
::
	ttiڮ
<
	tVceDPL
::
	tSg
> 
	tOiڮSg
;

61 
	gboo
::
	ttiڮ
<> 
	tOiڮIeg
;

62 
	gVceDPL
::
	tDB
::
	tSqlCi
::
	tDaCommd
 DataCommand;

64 
mea
 
	gRiTys
 {

65 cڡ 
Equ
[];

66 cڡ 
LessTh
[];

67 cڡ 
And
[];

68 cڡ 
Or
[];

69 cڡ 
Is
[];

70 cڡ 
In
[];

74 
mea
 
	gDaCommdUts
 {

76 
BdArgumt
(
DaCommd
 *
commd
, 
ArgumtIndex
 
dex
, 
gumt
);

77 
BdArgumt
(
DaCommd
 *
commd
, 
ArgumtIndex
 
dex
, cڡ 
OiڮIeg
& 
gumt
);

78 
BdArgumt
(
DaCommd
 *
commd
, 
ArgumtIndex
 
dex
, cڡ 
VceDPL
::
Sg
& 
gumt
);

79 
BdArgumt
(
DaCommd
 *
commd
, 
ArgumtIndex
 
dex
, cڡ 
OiڮSg
& 
gumt
);

81 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gExessi
 {

82 
	gpublic
:

83 
vtu
 ~
Exessi
() {}

84 
vtu
 
d
::
rg
 
GSg
() const = 0;

85 
vtu
 
ArgumtIndex
 
BdTo
(
DaCommd
 *
commd
, ArgumtIndex 
dex
) = 0;

88 
	gd
::
	tshed_r
<
	tExessi
> 
	tExessiP
;

90 
mea
 
	gOrdgUts
 {

92 
	gme
<
tyme
 
	gCompoundTy
> 
le
 
	gd
::
rg
 
OrdByIl
()

94 
d
::
rg
 
d
 = 
OrdByIl
<
tyme
 
CompoundTy
::
Ta
>();

95 if(!
	gd
.
emy
() 
	gCompoundTy
::
Hd
::
GSg
(+ ", " + 
d
;

96  
	gCompoundTy
::
Hd
::
GSg
();

99 
	gme
<> 
le
 
	gd
::
rg
 
OrdByIl
<
TyLiGud
>()

101  
d
::
rg
();

106 
	gme
<
tyme
 
	gCumnTy
>

107 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gOrdgExessi
 {

108 
	geed
:

109 
d
::
rg
 
GSchemaAndName
()

111 
d
::
rg
 
emt
;

112 
	gemt
 +
CumnTy
::
GTabName
();

113 
	gemt
 += ".";

114 
	gemt
 +
CumnTy
::
GCumnName
();

115 
	gemt
 += " ";

116  
	gemt
;

118 
	gpublic
:

119 
vtu
 ~
OrdgExessi
() {}

122 
	gme
<cڡ * 
	gOt
, 
tyme
 
	gLeExessi
,ym
	gRightExessi
>

123 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gByExessi
 : 
public
 
Exessi
 {

124 
eed
:

125 
LeExessi
 
m_Exessi
;

126 
RightExessi
 
	gm_rightExessi
;

127 
bo
 
	gm_ourPthesis
;

128 
	gpublic
:

129 
ByExessi
(cڡ 
LeExessi
& 
Exessi
, cڡ 
RightExessi
& 
rightExessi
, 
bo
 
ourPthesis
 = 
ue
) :

130 
m_Exessi
(
Exessi
),

131 
m_rightExessi
(
rightExessi
),

132 
m_ourPthesis
(
ourPthesis
)

135 
vtu
 
	gd
::
rg
 
GSg
() const

137  (
m_ourPthesis
 ? "( " : " " ) +

138 
m_Exessi
.
GSg
(+ " " + 
Ot
 + " " + 
m_rightExessi
.GetString() +

139 (
m_ourPthesis
 ? " )" : " " ) ;

142 
vtu
 
ArgumtIndex
 
BdTo
(
DaCommd
 *
commd
, ArgumtIndex 
dex
)

144 
	gdex
 = 
m_Exessi
.
BdTo
(
commd
, 
dex
);

145  
	gm_rightExessi
.
BdTo
(
commd
, 
dex
);

148 
	gme
<
tyme
 
	gTabDefi
>

149 
	sVidFTab
 {

150 
	gd
::
	t
<
	ttyme
 
	tLeExessi
 ::
	tme
 
	tVidFTab
<
	tTabDefi
>::
	tYes
 ,

151 
	ttyme
 
	tRightExessi
::
	tme
 
	tVidFTab
<
	tTabDefi
>::
	tYes
 >

152 
	tYes
;

156 
	gme
<
tyme
 
	gLeExessi
,ym
	gRightExessi
>

157 
	gByExessi
<
	gRiTys
::
And
, 
	gLeExessi
, 
	gRightExessi
>

158 
And
(cڡ 
LeExessi
& 
Exessi
, cڡ 
RightExessi
& 
rightExessi
)

160  
	gByExessi
<
	gRiTys
::
And
, 
	gLeExessi
, 
	gRightExessi
>

161 (
	gExessi
, 
	grightExessi
);

164 
	gme
<
tyme
 
	gLeExessi
,ym
	gRightExessi
>

165 
	gByExessi
<
	gRiTys
::
Or
, 
	gLeExessi
, 
	gRightExessi
>

166 
Or
(cڡ 
LeExessi
& 
Exessi
, cڡ 
RightExessi
& 
rightExessi
)

168  
	gByExessi
<
	gRiTys
::
Or
, 
	gLeExessi
, 
	gRightExessi
>

169 (
	gExessi
, 
	grightExessi
);

172 
	gme
<
tyme
 
	gArgumtTy
>

173 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gExessiWhArgumt
 : 
public
 
Exessi
 {

174 
eed
:

175 
ArgumtTy
 
gumt
;

177 
	gpublic
:

178 
exic
 
ExessiWhArgumt
(cڡ 
ArgumtTy
& 
_gumt
: 
gumt
(_argument) {}

180 
vtu
 
ArgumtIndex
 
BdTo
(
DaCommd
 *
commd
, ArgumtIndex 
dex
)

182 
	gDaCommdUts
::
BdArgumt
(
commd
, 
dex
, 
gumt
);

183  
	gdex
 + 1;

187 
	gme
<
tyme
 
	gCumnDa
, cڡ * 
	gRi
>

188 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gCom
 : 
public
 
ExessiWhArgumt
<
tyme
 
CumnDa
::
CumnTy
> {

189 
public
:

190 
exic
 
Com
(
tyme
 
CumnDa
::
CumnTy
 
cumn
) :

191 
ExessiWhArgumt
<
tyme
 
CumnDa
::
CumnTy
>(
cumn
)

194 
vtu
 
d
::
rg
 
GSg
() const

196 
d
::
rg
 
emt
;

197 
	gemt
 +
CumnDa
::
GTabName
();

198 
	gemt
 += ".";

199 
	gemt
 +
CumnDa
::
GCumnName
();

200 
	gemt
 += " ";

201 
	gemt
 +
Ri
;

202 
	gemt
 += " ?";

203  
	gemt
;

206 
	gme
<
tyme
 
	gTabDefi
>

207 
	sVidFTab
 {

208 
tyme
 
	tTabDefi
::
	tCumnLi
::
	tme
 
	tCڏs
<
	tCumnDa
> 
	tYes
;

211 
	#ORM_DEFINE_COMPARE_EXPRESSION
(
me
, 
tiTy
) \

212 
me
<
tyme
 
CumnDa
> \

213 
ass
 
	`__ibu__
 ((
	`visiby
("hidd"))
me
 : 
public
 
Com
<
CumnDa
, 
RiTys
::
tiTy
> { \

214 
public
: \

215 
	`me
(
tyme
 
CumnDa
::
CumnTy
 
cumn
) : \

216 
Com
<
CumnDa
, 
RiTys
::
tiTy
>(
cumn
) \

218 };

	)

220 
ORM_DEFINE_COMPARE_EXPRESSION
(
Equs
, 
Equ
)

221 
ORM_DEFINE_COMPARE_EXPRESSION
(
Is
, Is)

223 
	#ORM_DEFINE_ORDERING_EXPRESSION
(
me
, 
vue
) \

224 
me
<
tyme
 
CumnTy
> \

225 
ass
 
	`__ibu__
 ((
	`visiby
("hidd"))
me
 \

226 : 
OrdgExessi
<
CumnTy
> { \

227 
public
: \

228 
d
::
rg
 
	`GSg
() \

230 
d
::
rg
 
emt
 = 
OrdgExessi
<
CumnTy
>::
	`GSchemaAndName
(); \

231 
emt
 +
vue
; \

232  
emt
; \

234 };

	)

236 
ORM_DEFINE_ORDERING_EXPRESSION
(
OrdgAsndg
, "ASC")

237 
ORM_DEFINE_ORDERING_EXPRESSION
(
OrdgDesndg
, "DESC")

239 
	gme
<
tyme
 
	gCumnDa1
,ym
	gCumnDa2
>

240 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gComByCumn
 {

241 
	give
:

242 
d
::
rg
 
m_ti
;

243 
	gpublic
:

244 
ComByCumn
(cڡ * 
Ri
) :

245 
m_ti
(
Ri
)

248 
vtu
 ~
ComByCumn
() {}

250 
vtu
 
d
::
rg
 
GSg
() const

252 
d
::
rg
 
emt
;

253 
	gemt
 +
CumnDa1
::
GTabName
();

254 
	gemt
 += ".";

255 
	gemt
 +
CumnDa1
::
GCumnName
();

256 
	gemt
 += " ";

257 
	gemt
 +
m_ti
;

258 
	gemt
 += " ";

259 
	gemt
 +
CumnDa2
::
GTabName
();

260 
	gemt
 += ".";

261 
	gemt
 +
CumnDa2
::
GCumnName
();

263  
	gemt
;

267 
	gme
<
tyme
 
	gCumnDa1
,ym
	gCumnDa2
>

268 
	gComByCumn
<
	gCumnDa1
, 
	gCumnDa2
>

269 
Equ
()

271  
	gComByCumn
<
	gCumnDa1
, 
	gCumnDa2
>(
	gRiTys
::
Equ
);

274 
	gme
<
tyme
 
	gCumnDa
, cڡ * 
	gRi
>

275 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gNumousArgumts
 : 
public
 
Exessi
 {

276 
eed
:

277 
d
::
t
<
tyme
 
CumnDa
::
CumnTy
> 
m_gumtLi
;

278 
	gpublic
:

279 
NumousArgumts
(cڡ 
d
::
t
<
tyme
 
CumnDa
::
CumnTy
>& 
gumtLi
: 
m_gumtLi
(argumentList) {}

281 
vtu
 
d
::
rg
 
GSg
() const

283 
d
::
rg
 
emt
;

284 
	gemt
 +
CumnDa
::
GCumnName
();

285 
	gemt
 += " ";

286 
	gemt
 +
Ri
;

287 
	gemt
 += " ( ";

289 
	ggumtCou
 = 
m_gumtLi
.
size
();

290 
	ggumtCou
)

292 
	gemt
 += "?";

293 
	ggumtCou
--;

294 i(
	ggumtCou
)

296 
	gemt
 += ", ";

300 
	gemt
 += " )";

302  
	gemt
;

305 
vtu
 
ArgumtIndex
 
BdTo
(
DaCommd
 *
commd
, ArgumtIndex 
dex
)

307 
ArgumtIndex
 
	ggumtIndex
 = 
dex
;

308 
FOREACH
(
gumtIt
, 
m_gumtLi
)

310 
	gDaCommdUts
::
BdArgumt
(
commd
, 
gumtIndex
, *
gumtIt
);

311 
	ggumtIndex
++;

313  
	ggumtIndex
 + 1;

316 
	gme
<
tyme
 
	gTabDefi
>

317 
	sVidFTab
 {

318 
tyme
 
	tTabDefi
::
	tCumnLi
::
	tme
 
	tCڏs
<
	tCumnDa
> 
	tYes
;

322 
	#ORM_DEFINE_COMPARE_EXPRESSION_NUMEROUS_ARGUMENTS
(
me
, 
tiTy
) \

323 
me
<
tyme
 
CumnDa
> \

324 
ass
 
	`__ibu__
 ((
	`visiby
("hidd"))
me
 : 
public
 
NumousArgumts
<
CumnDa
, 
RiTys
::
tiTy
> { \

325 
public
: \

326 
	`me
(
d
::
t
<
tyme
 
CumnDa
::
CumnTy
> 
cumn
) : \

327 
NumousArgumts
<
CumnDa
, 
RiTys
::
tiTy
>(
cumn
) \

329 };

	)

331 
ORM_DEFINE_COMPARE_EXPRESSION_NUMEROUS_ARGUMENTS
(
In
, In)

333 
	gme
<
tyme
 
	gCumnTy
>

334 
CumnTy
 
GCumnFromCommd
(
CumnIndex
 
cumnIndex
, 
DaCommd
 *
commd
);

336 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gCuomCumnBa
 {

337 
	gpublic
:

338 
CuomCumnBa
() {}

339 
vtu
 ~
CuomCumnBa
() {}

342 
	gme
<
tyme
 
	gCumnTy
>

343 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gCuomCumn
 : 
public
 
CuomCumnBa
 {

344 
ive
:

345 
CumnTy
 
m_cumnDa
;

347 
	gpublic
:

348 
CuomCumn
() {}

349 
CuomCumn
(
CumnTy
 
da
)

351 
m_cumnDa
 = 
da
;

354 
SCumnDa
(
CumnTy
 
da
)

356 
	gm_cumnDa
 = 
da
;

359 
CumnTy
 
GCumnDa
() const

361  
	gm_cumnDa
;

365 
	gme
<
tyme
 
	gCumnLi
>

366 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gCuomRowUt
 {

367 
	gpublic
:

368 
MakeCumnLi
(
d
::
ve
<
CuomCumnBa
*>& 
cumnLi
)

370 
CuomCumn
<
	ttyme
 
	tCumnLi
::
	tHd
::
	tCumnTy
> 
	tTy
;

371 
Ty
* 
	gpCumn
 = 
w
 Type();

372 
	gcumnLi
.
push_back
(
pCumn
);

373 
	gCuomRowUt
<
tyme
 
	gCumnLi
::
Ta
>::
MakeCumnLi
(
cumnLi
);

376 
CyCumnLi
(cڡ 
d
::
ve
<
CuomCumnBa
*>& 
cLi
, std::ve<CuomCumnBa*>& 
dLi
)

378 
CyCumnLi
(
cLi
, 
dLi
, 0);

381 
CumnIndex
 
GCumnIndex
(cڡ 
d
::
rg
& 
cumnName
)

383  
GCumnIndex
(
cumnName
, 0);

386 
	give
:

387 
CyCumnLi
(cڡ 
d
::
ve
<
CuomCumnBa
*>& 
cLi
, std::ve<CuomCumnBa*>& 
dLi
, 
CumnIndex
 
dex
)

389 
	gCuomCumn
<
	ttyme
 
	tCumnLi
::
	tHd
::
	tCumnTy
> 
	tTy
;

390 
Ty
* 
	gpCumn
 = 
w
 Ty(((Ty*)(
cLi
.

(
dex
)))->
GCumnDa
());

391 
	gdLi
.
push_back
(
pCumn
);

392 
	gCuomRowUt
<
tyme
 
	gCumnLi
::
Ta
>::
CyCumnLi
(
cLi
, 
dLi
, 
dex
 + 1);

395 
CumnIndex
 
GCumnIndex
(cڡ 
d
::
rg
& 
cumnName
, CumnIndex 
dex
)

397 i(
	gCumnLi
::
Hd
::
GCumnName
(=
cumnName
)

398  
dex
;

400  
	gCuomRowUt
<
tyme
 
	gCumnLi
::
Ta
>::
GCumnIndex
(
cumnName
, 
dex
 + 1);

403 
	gme
<
tyme
 
	gOth
>

404 
nd
 
ass
 
	gCuomRowUt
;

407 
	gme
<>

408 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gCuomRowUt
<
	gVceDPL
::
TyLiGud
> {

409 
public
:

410 
MakeCumnLi
(
d
::
ve
<
CuomCumnBa
*>&) {}

411 
ive
:

412 
CyCumnLi
(cڡ 
d
::
ve
<
CuomCumnBa
*>&, std::ve<CuomCumnBa*>&, 
CumnIndex
) {}

413 
CumnIndex
 
GCumnIndex
(cڡ 
d
::
rg
&, ColumnIndex) {  -1; }

415 
	gme
<
tyme
 
	gOth
>

416 
nd
 
ass
 
	gCuomRowUt
;

419 
	gme
<
tyme
 
	gCumnLi
>

420 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gCuomRow
 {

421 
	give
:

422 
d
::
ve
<
CuomCumnBa
*> 
m_cumns
;

424 
	gpublic
:

425 
CuomRow
()

427 
CuomRowUt
<
CumnLi
>::
MakeCumnLi
(
m_cumns
);

430 
CuomRow
(cڡ CuomRow& 
r
)

432 
	gCuomRowUt
<
	gCumnLi
>::
CyCumnLi
(
r
.
m_cumns
, m_columns);

435 
	gvtu
 ~
CuomRow
()

437 !
	gm_cumns
.
emy
())

439 
CuomCumnBa
* 
	gpCuomCumn
 = 
m_cumns
.
back
();

440 
	gm_cumns
.
p_back
();

441 i(
	gpCuomCumn
)

442 
de
 
	gpCuomCumn
;

446 
	gme
<
tyme
 
	gCumnTy
>

447 
SCumnDa
(
CumnIndex
 
cumnIndex
, 
CumnTy
 
da
)

449 
	gCuomCumn
<
	tCumnTy
> 
	tTy
;

450 
As
(
cumnIndex
 < 
m_cumns
.
size
());

451 
Ty
* 
	gpCumn
 = 
dymic_
<Ty*>(
m_cumns
.

(
cumnIndex
));

452 
As
(
pCumn
);

453 
	gpCumn
->
SCumnDa
(
da
);

456 
	gme
<
tyme
 
	gCumnDa
>

457 
tyme
 
	gCumnDa
::
CumnTy
 
GCumnDa
()

459 
CuomCumn
<
	ttyme
 
	tCumnDa
::
	tCumnTy
> 
	tTy
;

460 
CumnIndex
 
	gdex
 = 
CuomRowUt
<
CumnLi
>::
GCumnIndex
(
CumnDa
::
GCumnName
());

461 
As
(
dex
 < 
m_cumns
.
size
());

462 
Ty
* 
	gpCumn
 = 
dymic_
<Ty*>(
m_cumns
.

(
dex
));

463 
As
(
pCumn
);

464  
	gpCumn
->
GCumnDa
();

468 
	gme
<
tyme
 
	gCuomRow
,ym
	gCumnTy
>

469 
SCumnDa
(
CuomRow
& 
row
, 
CumnTy
 
cumnDa
, 
CumnIndex
 
cumnIndex
)

471 
	grow
.
	gSCumnDa
<
	gCumnTy
>(
	gcumnIndex
, 
	gcumnDa
);

474 
	gme
<
tyme
 
	gCumnLi
,ym
	gCuomRow
>

475 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gFlCuomRowUt
 {

476 
	gpublic
:

477 
FlCuomRow
(
CuomRow
& 
row
, 
DaCommd
* 
commd
)

479 
FlCuomRow
(
row
, 0, 
commd
);

482 
	give
:

483 
FlCuomRow
(
CuomRow
& 
row
, 
CumnIndex
 
cumnIndex
, 
DaCommd
* 
commd
)

485 
tyme
 
	gCumnLi
::
Hd
::
CumnTy
 
cumnDa
;

486 
	gcumnDa
 = 
GCumnFromCommd
<
tyme
 
CumnLi
::
Hd
::
CumnTy
>(
cumnIndex
, 
	gcommd
);

487 
	gSCumnDa
<
	gCuomRow
, 
tyme
 
	gCumnLi
::
Hd
::
CumnTy
>(
row
, 
	gcumnDa
, 
	gcumnIndex
);

488 
	gFlCuomRowUt
<
tyme
 
	gCumnLi
::
Ta
, 
	gCuomRow
>::
FlCuomRow
(
row
, 
cumnIndex
 + 1, 
commd
);

491 
	gme
<
tyme
 
	gOth
,ym
	gOthRow
>

492 
nd
 
ass
 
	gFlCuomRowUt
;

495 
	gme
<
tyme
 
	gCuomRow
>

496 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gFlCuomRowUt
<
	gVceDPL
::
TyLiGud
, 
	gCuomRow
> {

497 
	give
:

498 
FlCuomRow
(
CuomRow
&, 
CumnIndex
, 
DaCommd
 *)

501 
	gme
<
tyme
 
	gOth
,ym
	gOthRow
>

502 
nd
 
ass
 
	gFlCuomRowUt
;

505 
	gme
<
tyme
 
	gCumnLi
,ym
	gRow
>

506 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gFlRowUt
 {

507 
	gpublic
:

508 
FlRow
(
Row
& 
row
, 
DaCommd
 *
commd
)

510 
FlRow
(
row
, 0, 
commd
);

513 
	give
:

514 
FlRow
(
Row
& 
row
, 
CumnIndex
 
cumnIndex
, 
DaCommd
 *
commd
)

516 
tyme
 
	gCumnLi
::
Hd
::
CumnTy
 
rowFld
;

517 
	growFld
 = 
GCumnFromCommd
<
tyme
 
CumnLi
::
Hd
::
CumnTy
>(
cumnIndex
, 
	gcommd
);

518 
	gCumnLi
::
Hd
::
SRowFld
(
row
, 
rowFld
);

519 
	gFlRowUt
<
tyme
 
	gCumnLi
::
Ta
, 
	gRow
>::
FlRow
(
row
, 
cumnIndex
 + 1, 
commd
);

522 
	gme
<
tyme
 
	gOth
,ym
	gOthRow
>

523 
nd
 
ass
 
	gFlRowUt
;

526 
	gme
<
tyme
 
	gRow
>

527 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gFlRowUt
<
	gVceDPL
::
TyLiGud
, 
	gRow
> {

528 
	give
:

529 
FlRow
(
Row
&, 
CumnIndex
, 
DaCommd
 *)

532 
	gme
<
tyme
 
	gOth
,ym
	gOthRow
>

533 
nd
 
ass
 
	gFlRowUt
;

536 
	gme
<
tyme
 
	gCumnLi
>

537 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gJoUt
 {

538 
	gpublic
:

539 
d
::
rg
 
GCumnNames
()

541 
d
::
rg
 
su
;

542 
	gsu
 = 
CumnLi
::
Hd
::
GTabName
();

543 
	gsu
 += ".";

544 
	gsu
 +
CumnLi
::
Hd
::
GCumnName
();

545 i(
	gCumnLi
::
Ta
::
Size
 > 0)

546 
su
 += ", ";

548  
	gsu
 +
JoUt
<
tyme
 
CumnLi
::
Ta
>::
GCumnNames
();

551 
	gd
::
rg
 
GJoTabName
(cڡ 
d
::rg& 
bName
)

553 
d
::
rg
 
joTabName
 = 
CumnLi
::
Hd
::
GTabName
();

554 i(
	gbName
.
fd
(
joTabName
=
d
::
rg
::
os
)

555  
joTabName
;

557  
	gJoUt
<
tyme
 
	gCumnLi
::
Ta
>::
GJoTabName
(
bName
);

561 
	gme
<>

562 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gJoUt
<
	gVceDPL
::
TyLiGud
> {

563 
public
:

564 
d
::
rg
 
GCumnNames
() {  ""; }

565 
	gd
::
rg
 
GJoTabName
(
d
::string) {  ""; }

568 as
	cExi
 {

569 
	gpublic
:

570 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

571 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
SeReuWhDifQuySigtu
)

572 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
RowFldNInlized
)

573 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
EmyUpdeSmt
)

576 
	gme
<
tyme
 
	gTabDefi
>

577 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gQuy


579 
	geed
:

580 
exic
 
Quy
(
IOrmI
* 
r
) :

581 
m_r
(
r
),

582 
m_commd
(
NULL
)

586 
	gvtu
 ~
Quy
()

588 i(
	gm_commd
 =
NULL
)

591 
	gTabDefi
::
FeTabDaCommd
(
m_commd
, 
m_r
);

594 
IOrmI
* 
	gm_r
;

595 
DaCommd
 *
	gm_commd
;

596 
	gd
::
rg
 
m_commdSg
;

597 
ArgumtIndex
 
	gm_bdArgumtIndex
;

600 
	gme
<
tyme
 
	gTabDefi
>

601 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gQuyWhWheCu
 : 
public
 
Quy
<
TabDefi
>

603 
eed
:

604 
ExessiP
 
m_wheExessi
;

606 
P
()

608 i!!
	gm_wheExessi
 )

610 
	gthis
->
	gm_commdSg
 += " WHERE ";

611 
	gthis
->
	gm_commdSg
 +
m_wheExessi
->
GSg
();

615 
Bd
()

617 i!!
	gm_wheExessi
 )

619 
	gthis
->
	gm_bdArgumtIndex
 = 
m_wheExessi
->
BdTo
(

620 
this
->
m_commd
,his->
m_bdArgumtIndex
);

624 
	gpublic
:

625 
exic
 
QuyWhWheCu
(
IOrmI
* 
r
) :

626 
Quy
<
TabDefi
>(
r
)

630 
me
<
tyme
 
Exessi
>

631 
Whe
(cڡ 
Exessi
& 
exessi
)

633 
DPL_CHECK_TYPE_INSTANTIABILITY
(
tyme
 
Exessi
::
me
 
VidFTab
<
TabDefi
>::
Yes
);

634 i!!
	gm_wheExessi
 && ( 
tyid
(
Exessi
!tyid(*
m_wheExessi
) ) )

636 
d
::
orgam
 
r
;

637 
	gr
 << "Current ORM implementation doesn'tllowoeuse Select"

640 
	gr
 << "Query: ";

641 
	gr
 << 
	gthis
->
	gm_commdSg
;

642 
ThrowMsg
(
Exi
::
SeReuWhDifQuySigtu
,

643 
r
.str());

646 
	gm_wheExessi
.
t
(
w
 
Exessi
(
exessi
));

651 
	gme
<
tyme
 
	gTabDefi
>

652 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gDe
 : 
public
 
QuyWhWheCu
<
TabDefi
>

654 
eed
:

655 
P
()

657 i!
this
->
m_commd
)

659 
this
->
m_commdSg
 = "DELETE FROM ";

660 
	gthis
->
	gm_commdSg
 +
TabDefi
::
GName
();

662 
	gQuyWhWheCu
<
	gTabDefi
>::
P
();

664 
	gthis
->
	gm_commd
 = 
TabDefi
::
AocTabDaCommd
(

665 
this
->
m_commdSg
.
c_r
(),

666 
Quy
<
TabDefi
>::
m_r
);

667 
VceLogD
("Pd SQL commd %s", 
this
->
m_commdSg
.
c_r
());

671 
Bd
()

673 
	gthis
->
	gm_bdArgumtIndex
 = 1;

674 
	gQuyWhWheCu
<
	gTabDefi
>::
Bd
();

677 
	gpublic
:

678 
exic
 
De
(
IOrmI
 *
r
 = 
NULL
) :

679 
QuyWhWheCu
<
TabDefi
>(
r
)

683 
Execu
()

685 
P
();

686 
Bd
();

687 
	gthis
->
	gm_commd
->
Sp
();

688 
	gthis
->
	gm_commd
->
Ret
();

692 
	gmea
 {

693 as
	cBdVis
 {

694 
	give
:

695 
DaCommd
 *
m_commd
;

696 
	gpublic
:

697 
ArgumtIndex
 
m_bdArgumtIndex
;

699 
BdVis
(
DaCommd
 *
commd
) :

700 
m_commd
(
commd
),

701 
m_bdArgumtIndex
(1)

704 
	gme
<
tyme
 
	gCumnTy
>

705 
Vis
(cڡ *, cڡ 
CumnTy
& 
vue
, 
bo
 
isS
)

707 i
	gisS
 )

709 
	gDaCommdUts
::
BdArgumt
(
m_commd
, 
m_bdArgumtIndex
, 
vue
);

710 
	gm_bdArgumtIndex
++;

715 
	gme
<
tyme
 
	gTabDefi
>

716 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gIn
 : 
public
 
Quy
<
TabDefi
>

718 
public
:

719 
tyme
 
	tTabDefi
::
	tRow
 Row;

720 
	gVceDPL
::
	tDB
::
	tSqlCi
::
	tRowID
 RowID;

722 
	geed
:

723 
boo
::
tiڮ
<
d
::
rg
> 
m_Cu
;

724 
Row
 
	gm_row
;

726 as
	cPVis
 {

727 
	gpublic
:

728 
d
::
rg
 
m_cumnNames
;

729 
	gd
::
rg
 
m_vues
;

731 
	gme
<
tyme
 
	gCumnTy
>

732 
Vis
(cڡ * 
me
, cڡ 
CumnTy
&, 
bo
 
isS
)

734 i
	gisS
 )

736 i!
	gm_cumnNames
.
emy
() )

738 
	gm_cumnNames
 += ", ";

739 
	gm_vues
 += ", ";

741 
	gm_cumnNames
 +
me
;

742 
	gm_vues
 += "?";

747 
P
()

749 i!
	gthis
->
	gm_commd
 )

751 
	gthis
->
	gm_commdSg
 = "INSERT ";

752 i!!
	gm_Cu
 )

754 
	gthis
->
	gm_commdSg
 +" OR " + *
m_Cu
 + " ";

756 
	gthis
->
	gm_commdSg
 += "INTO ";

757 
	gthis
->
	gm_commdSg
 +
TabDefi
::
GName
();

759 
PVis
 
	gvis
;

760 
	gm_row
.
VisCumns
(
vis
);

762 
	gthis
->
	gm_commdSg
 +" ( " + 
vis
.
m_cumnNames
 + " ) ";

763 
	gthis
->
	gm_commdSg
 +"VALUES ( " + 
vis
.
m_vues
 + " )";

765 
VceLogD
("Pd SQL commd %s", 
this
->
m_commdSg
.
c_r
());

766 
	gthis
->
	gm_commd
 = 
TabDefi
::
AocTabDaCommd
(

767 
this
->
m_commdSg
.
c_r
(),

768 
Quy
<
TabDefi
>::
m_r
);

772 
Bd
()

774 
BdVis
 
vis
(
this
->
m_commd
);

775 
	gm_row
.
VisCumns
(
vis
);

778 
	gpublic
:

779 
exic
 
In
(

780 
IOrmI
* 
r
 = 
NULL
,

781 cڡ 
boo
::
tiڮ
<
d
::
rg
>& 
Cu
 = boost::optional<std::string>()) :

782 
Quy
<
TabDefi
>(
r
),

783 
m_Cu
(
Cu
)

787 
Vues
(cڡ 
Row
& 
row
)

789 i
	gthis
->
	gm_commd
 )

791 i!
	grow
.
IsSigtuMchg
(
m_row
) )

793 
ThrowMsg
(
Exi
::
SeReuWhDifQuySigtu
,

798 
	gm_row
 = 
row
;

801 
RowID
 
Execu
()

803 
P
();

804 
Bd
();

805 
	gthis
->
	gm_commd
->
Sp
();

807 
RowID
 
	gsu
 = 
TabDefi
::
GLaInRowID
(

808 
Quy
<
TabDefi
>::
m_r
);

810 
	gthis
->
	gm_commd
->
Ret
();

811  
	gsu
;

815 
	gme
<
tyme
 
	gTabDefi
>

816 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gSe
 : 
public
 
QuyWhWheCu
<
TabDefi
>

818 
public
:

819 
tyme
 
	tTabDefi
::
	tCumnLi
 ColumnList;

820 
tyme
 
	tTabDefi
::
	tRow
 Row;

822 
	gd
::
	tli
<
	tRow
> 
	tRowLi
;

823 
	geed
:

824 
boo
::
tiڮ
<
d
::
rg
> 
m_dBy
;

825 
	gd
::
rg
 
m_JoCu
;

826 
bo
 
	gm_diResus
;

828 
P
(cڡ * 
CumnName
)

830 i!
	gthis
->
	gm_commd
 )

832 
	gthis
->
	gm_commdSg
 = "SELECT ";

833 i(
	gm_diResus
)

834 
	gthis
->
	gm_commdSg
 += "DISTINCT ";

835 
	gthis
->
	gm_commdSg
 +
CumnName
;

836 
	gthis
->
	gm_commdSg
 += " FROM ";

837 
	gthis
->
	gm_commdSg
 +
TabDefi
::
GName
();

839 
	gthis
->
	gm_commdSg
 +
m_JoCu
;

841 
	gQuyWhWheCu
<
	gTabDefi
>::
P
();

843 i!!
	gm_dBy
 )

845 
	gthis
->
	gm_commdSg
 +" ORDER BY " + *
m_dBy
;

848 
	gthis
->
	gm_commd
 = 
TabDefi
::
AocTabDaCommd
(

849 
this
->
m_commdSg
.
c_r
(),

850 
Quy
<
TabDefi
>::
m_r
);

852 
VceLogD
("Pd SQL commd %s", 
this
->
m_commdSg
.
c_r
());

856 
Bd
()

858 
	gthis
->
	gm_bdArgumtIndex
 = 1;

859 
	gQuyWhWheCu
<
	gTabDefi
>::
Bd
();

862 
	gme
<
tyme
 
	gCumnTy
>

863 
CumnTy
 
GCumn
(
CumnIndex
 
cumnIndex
)

865  
	gGCumnFromCommd
<
	gCumnTy
>(
	gcumnIndex
, 
	gthis
->
	gm_commd
);

868 
Row
 
GRow
()

870 
Row
 
	grow
;

871 
	gFlRowUt
<
	gCumnLi
, 
	gRow
>::
FlRow
(
row
, 
this
->
m_commd
);

872  
	grow
;

875 
	gme
<
tyme
 
	gCumnLi
,ym
	gCuomRow
>

876 
CuomRow
 
GCuomRow
()

878 
CuomRow
 
	grow
;

879 
	gFlCuomRowUt
<
	gCumnLi
, 
	gCuomRow
>::
FlCuomRow
(
row
, 
this
->
m_commd
);

880  
	grow
;

883 
	gpublic
:

885 
exic
 
Se
(
IOrmI
 *
r
 = 
NULL
) :

886 
QuyWhWheCu
<
TabDefi
>(
r
),

887 
m_diResus
(
l
)

891 
Di
()

893 
	gm_diResus
 = 
ue
;

896 
	gme
<
tyme
 
	gCompoundTy
>

897 
OrdBy
(cڡ 
CompoundTy
&)

899 
	gm_dBy
 = 
OrdgUts
::
OrdByIl
<
tyme
 
CompoundTy
::
Ty
>();

902 
OrdBy
(cڡ 
d
::
rg
 & 
dBy
)

904 
m_dBy
 = 
dBy
;

907 
OrdBy
(cڡ * 
dBy
)

909 
	gm_dBy
 = 
d
::
rg
(
dBy
);

912 
	gme
<
tyme
 
	gCumnLi
,ym
	gExessi
>

913 
Jo
(cڡ 
Exessi
& 
exessi
) {

914 
	gd
::
rg
 
udTabNames
 = 
TabDefi
::
GName
();

915 i(!
	gm_JoCu
.
emy
())

916 
	gudTabNames
 +
m_JoCu
;

918 
	gthis
->
	gm_JoCu
 += " JOIN ";

919 
	gthis
->
	gm_JoCu
 +
JoUt
<
CumnLi
>::
GJoTabName
(
udTabNames
);

920 
	gthis
->
	gm_JoCu
 += " ON ";

921 
	gthis
->
	gm_JoCu
 +
exessi
.
GSg
();

924 
	gme
<
tyme
 
	gCumnDa
>

925 
tyme
 
	gCumnDa
::
CumnTy
 
GSgVue
()

927 
P
(
CumnDa
::
GCumnName
());

928 
Bd
();

929 
	gthis
->
	gm_commd
->
Sp
();

931 
tyme
 
	gCumnDa
::
CumnTy
 
su
 =

932 
GCumn
<
tyme
 
CumnDa
::
CumnTy
>(0);

934 
	gthis
->
	gm_commd
->
Ret
();

935  
	gsu
;

939 
	gme
<
tyme
 
	gCumnDa
>

940 
	gd
::
li
<
tyme
 
CumnDa
::
CumnTy
> 
GVueLi
()

942 
P
(
CumnDa
::
GCumnName
());

943 
Bd
();

945 
	gd
::
li
<
tyme
 
CumnDa
::
CumnTy
> 
suLi
;

947 
	gthis
->
	gm_commd
->
Sp
())

948 
	gsuLi
.
push_back
(
GCumn
<
tyme
 
CumnDa
::
CumnTy
>(0));

950 
	gthis
->
	gm_commd
->
Ret
();

951  
	gsuLi
;

954 
Row
 
GSgRow
()

956 
P
("*");

957 
Bd
();

958 
	gthis
->
	gm_commd
->
Sp
();

960 
Row
 
	gsu
 = 
GRow
();

962 
	gthis
->
	gm_commd
->
Ret
();

963  
	gsu
;

967 
RowLi
 
GRowLi
()

969 
P
("*");

970 
Bd
();

972 
RowLi
 
	gsuLi
;

974 
	gthis
->
	gm_commd
->
Sp
())

975 
	gsuLi
.
push_back
(
GRow
());

977 
	gthis
->
	gm_commd
->
Ret
();

978  
	gsuLi
;

981 
	gme
<
tyme
 
	gCumnLi
,ym
	gCuomRow
>

982 
CuomRow
 
GCuomSgRow
()

984 
P
(
JoUt
<
CumnLi
>::
GCumnNames
().
c_r
());

985 
Bd
();

986 
	gthis
->
	gm_commd
->
Sp
();

988 
CuomRow
 
	gsu
 = 
GCuomRow
<
CumnLi
, 
	gCuomRow
>();

990 
	gthis
->
	gm_commd
->
Ret
();

991  
	gsu
;

994 
	gme
<
tyme
 
	gCumnLi
,ym
	gCuomRow
>

995 
	gd
::
li
<
CuomRow
> 
GCuomRowLi
()

997 
P
(
JoUt
<
CumnLi
>::
GCumnNames
().
c_r
());

998 
Bd
();

1000 
	gd
::
li
<
CuomRow
> 
suLi
;

1002 
	gthis
->
	gm_commd
->
Sp
())

1003 
	gsuLi
.
push_back
(
GCuomRow
<
CumnLi
, 
CuomRow
>());

1005 
	gthis
->
	gm_commd
->
Ret
();

1006  
	gsuLi
;

1010 
	gme
<
tyme
 
	gTabDefi
>

1011 
ass
 
__ibu__
 ((
visiby
("hidd"))
	gUpde
 : 
public
 
QuyWhWheCu
<
TabDefi
> {

1012 
public
:

1013 
tyme
 
	tTabDefi
::
	tRow
 Row;

1015 
	geed
:

1016 
boo
::
tiڮ
<
d
::
rg
> 
m_Cu
;

1017 
Row
 
	gm_row
;

1019 as
	cPVis
 {

1020 
	gpublic
:

1021 
d
::
rg
 
m_tExessis
;

1023 
	gme
<
tyme
 
	gCumnTy
>

1024 
Vis
(cڡ * 
me
, cڡ 
CumnTy
&, 
bo
 
isS
)

1026 i
	gisS
 )

1028 i!
	gm_tExessis
.
emy
() )

1030 
	gm_tExessis
 += ", ";

1032 
	gm_tExessis
 +
me
;

1033 
	gm_tExessis
 += " = ";

1034 
	gm_tExessis
 += "?";

1039 
P
()

1041 i!
	gthis
->
	gm_commd
 )

1043 
	gthis
->
	gm_commdSg
 = "UPDATE ";

1044 i!!
	gm_Cu
 )

1046 
	gthis
->
	gm_commdSg
 +" OR " + *
m_Cu
 + " ";

1048 
	gthis
->
	gm_commdSg
 +
TabDefi
::
GName
();

1049 
	gthis
->
	gm_commdSg
 += " SET ";

1052 
PVis
 
	gvis
;

1053 
	gm_row
.
VisCumns
(
vis
);

1055 if(
	gvis
.
	gm_tExessis
.
emy
())

1057 
ThrowMsg
(
Exi
::
EmyUpdeSmt
, "No SETxpressions in update statement");

1060 
	gthis
->
	gm_commdSg
 +
vis
.
m_tExessis
;

1063 
	gQuyWhWheCu
<
	gTabDefi
>::
P
();

1065 
	gthis
->
	gm_commd
 = 
TabDefi
::
AocTabDaCommd
(

1066 
this
->
m_commdSg
.
c_r
(),

1067 
Quy
<
TabDefi
>::
m_r
);

1068 
VceLogD
("Pd SQL commd %s", 
this
->
m_commdSg
.
c_r
());

1072 
Bd
()

1074 
BdVis
 
vis
(
this
->
m_commd
);

1075 
	gm_row
.
VisCumns
(
vis
);

1077 
	gthis
->
	gm_bdArgumtIndex
 = 
vis
.
m_bdArgumtIndex
;

1078 
	gQuyWhWheCu
<
	gTabDefi
>::
Bd
();

1082 
	gpublic
:

1083 
exic
 
Upde
(
IOrmI
 *
r
 = 
NULL
,

1084 cڡ 
boo
::
tiڮ
<
d
::
rg
>& 
Cu
 = boost::optional<std::string>()) :

1085 
QuyWhWheCu
<
TabDefi
>(
r
),

1086 
m_Cu
(
Cu
)

1090 
Vues
(cڡ 
Row
& 
row
)

1092 i
	gthis
->
	gm_commd
 )

1094 i!
	grow
.
IsSigtuMchg
(
m_row
) )

1096 
ThrowMsg
(
Exi
::
SeReuWhDifQuySigtu
,

1101 
	gm_row
 = 
row
;

1104 
Execu
()

1106 
P
();

1107 
Bd
();

1108 
	gthis
->
	gm_commd
->
Sp
();

1109 
	gthis
->
	gm_commd
->
Ret
();

	@vcore/src/dpl/db/include/dpl/db/orm_generator.h

23 #ide
ORM_GENERATOR_DATABASE_NAME


24 #r 
You
 
ed
 
to
 
defe
 
daba
 
me
 

 
ORM_GENERATOR_DATABASE_NAME
 def
befe
 
you
 
ude
 
m_g
.
h
 
fe


27 
	~<d/db/m_r.h
>

29 
	#ORM_GENERATOR_DATABASE_NAME_LOCAL
 <
ORM_GENERATOR_DATABASE_NAME
>

	)

31 #ifde
DPL_ORM_GENERATOR_H


32 #wng 
m_g
.
h
 
is
 
uded
 
muɝly
 
times
. 
Make
 
su
 

 
has
 
dif
 
ORM_GENERATOR_DATABASE_NAME
 
t
.

35 
	#DPL_ORM_GENERATOR_H


	)

38 
	~<boo/tiڮ.h
>

39 
	~<d/rg.h
>

40 
	~<d/ty_li.h
>

41 
	~<d/db/sql_ci.h
>

42 
	~<d/db/m.h
>

43 
	~<d/as.h
>

44 
	~<rg
>

62 
mea
 
	gVceDPL
 {

63 
mea
 
	gDB
 {

64 
mea
 
	gORM
 {

68 
	#STRINGIFY
(
s

	`_r
(s)

	)

69 
	#_r
(
s
#s

	)

70 
	#DECLARE_COLUMN
(
FIELD
, 
TYPE
) \

71 
	sFIELD
 { \

72 
TYPE
 
	tCumnTy
; \

73 cڡ * 
	`GTabName
({  
	`GName
(); } \

74 cڡ * 
	`GCumnName
({  
	`STRINGIFY
(
FIELD
); } \

75 
	`SRowFld
(
Row
& 
row
, cڡ 
TYPE
& 
_vue
{ow.
S_
##
	`FIELD
(_value);} \

76 };

	)

78 
	#INT
 

	)

79 
	#TINYINT
 

	)

80 
	#INTEGER
 

81 
	#BIGINT
 

82 
	#VARCHAR
(
x

VceDPL
::
Sg


	)

83 
	#TEXT
 
VceDPL
::
Sg


	)

85 
	#SQL
(...)

	)

86 
	#TABLE_CONSTRAINTS
(...)

	)

87 
	#OPTIONAL
(
ty

boo
::
tiڮ
<y >

	)

88 
	#DATABASE_START
(
db_me
) \

89 
mea
 
db_me
 \

91 
ass
 
ScedTni
 \

93 
bo
 
m_commed
; \

94 
IOrmI
 *
m_r
; \

96 
public
: \

97 
	`ScedTni
(
IOrmI
 *
r
) : \

98 
	`m_commed
(
l
), \

99 
	`m_r
(
r
) \

101 
	`As
(
r
 !
NULL
); \

102 
m_r
->
	`TniBeg
(); \

105 ~
	`ScedTni
() \

107 i(!
m_commed
) \

108 
m_r
->
	`TniRlback
(); \

111 
	`Comm
() \

113 
m_r
->
	`TniComm
(); \

114 
m_commed
 = 
ue
; \

116 };

	)

118 
	#DATABASE_END
(}

	)

122 
	#CREATE_TABLE
(
me
) \

123 
mea
 
me
 { \

124 
ass
 
RowBa
; \

125 
le
 
d
::
oam
& 
ݔ
<<(d::oam& 
or
, cڡ 
RowBa
& 
row
); \

126 }

	)

127 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...)

	)

128 
	#COLUMN
(
me
, 
ty
, ...)

	)

129 
	#CREATE_TABLE_END
()

	)

131 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


133 #unde
CREATE_TABLE


134 #unde
COLUMN_NOT_NULL


135 #unde
COLUMN


136 #unde
CREATE_TABLE_END


138 #unde
DATABASE_START


139 
	#DATABASE_START
(
db_me

mea
 db_m{

	)

143 
	#CREATE_TABLE
(
me

mea
am{ cs
	cRowBa
 { \

144 
public
: 
nd
 
d
::
oam
& 
ݔ
<<(d::oam&, cڡ 
RowBa
&);

	)

145 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...) \

146 
eed
: 
ty
 
me
; 
bo
 
m_
##me##
_t
; \

147 
public
: 
S_
##
	`me
(cڡ 
ty
& 
_vue
) { \

148 
m_
##
me
##
_t
 = 
ue
; \

149 
this
->
me
 = 
_vue
; \

151 
public
: 
ty
 
G_
##
	`me
() const { \

152 i!
m_
##
me
##
_t
 ) { \

153 
	`ThrowMsg
(
Exi
::
RowFldNInlized
, \

156  
me
; \

157 }

	)

159 
	#COLUMN
(
me
, 
ty
, ...) \

160 
eed
: 
	`OPTIONAL
(
ty

me
; 
bo
 
m_
##me##
_t
; \

161 
public
: 
S_
##
	`me
(cڡ 
	`OPTIONAL
(
ty
)& 
_vue
) { \

162 
m_
##
me
##
_t
 = 
ue
; \

163 
this
->
me
 = 
_vue
; \

165 
public
: 
	`OPTIONAL
(
ty

G_
##
	`me
() const { \

166 i!
m_
##
me
##
_t
 ) { \

167 
	`ThrowMsg
(
Exi
::
RowFldNInlized
, \

170  
me
; \

171 }

	)

172 
	#CREATE_TABLE_END
(}; }

	)

174 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


176 #unde
CREATE_TABLE


177 #unde
COLUMN_NOT_NULL


178 #unde
COLUMN


179 #unde
CREATE_TABLE_END


183 
	#CREATE_TABLE
(
me

d
::
oam
&ame::
ݔ
<<(d::oam& 
or
, cڡ 
RowBa
& 
row
{ 
usg
 ::ݔ<< ; o<< 
	`STRINGIFY
ame<< " (";

	)

184 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...
or
 << " '" << 
row
.m<< "'" ;

	)

185 
	#COLUMN
(
me
, 
ty
, ...
or
 << " '" << 
row
.m<< "'" ;

	)

186 
	#CREATE_TABLE_END
(
or
 << " )" ;  or; }

	)

188 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


190 #unde
CREATE_TABLE


191 #unde
COLUMN_NOT_NULL


192 #unde
COLUMN


193 #unde
CREATE_TABLE_END


197 
	#CREATE_TABLE
(
me

mea
am{ cs
	cRowBa2
 : 
public
 
RowBa
 { \

198 
public
: 
bo
 
ݔ
==(cڡ 
RowBa2
& 
row
cڡ {  
ue


	)

199 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...&& (
this
->m=
row
.me)

	)

200 
	#COLUMN
(
me
, 
ty
, ...&& (
this
->m=
row
.me)

	)

201 
	#CREATE_TABLE_END
(; } }; }

	)

203 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


205 #unde
CREATE_TABLE


206 #unde
COLUMN_NOT_NULL


207 #unde
COLUMN


208 #unde
CREATE_TABLE_END


212 
	#CREATE_TABLE
(
me

mea
am{ cs
	cRowBa3
 : 
public
 
RowBa2
 { \

213 
public
: 
bo
 
ݔ
<(cڡ 
RowBa3
& 
row
cڡ {

	)

214 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...i(
this
->m< 
row
.me{  
ue
; } ihis->m>ow.me{  
l
; }

	)

215 
	#COLUMN
(
me
, 
ty
, ...i(
this
->m< 
row
.me{  
ue
; } ihis->m>ow.me{  
l
; }

	)

216 
	#CREATE_TABLE_END
( 
l
; } }; }

	)

218 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


220 #unde
CREATE_TABLE


221 #unde
COLUMN_NOT_NULL


222 #unde
COLUMN


223 #unde
CREATE_TABLE_END


227 
	#CREATE_TABLE
(
me

mea
am{ cs
	cRowBa4
 : 
public
 
RowBa3
 { \

228 
public
: 
bo
 
	`IsSigtuMchg
(cڡ 
RowBa4
& 
row
cڡ {  
ue


	)

229 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...&& (
this
->
m_
##me##
_t
 =
row
.m_##me##_t)

	)

230 
	#COLUMN
(
me
, 
ty
, ...&& (
this
->
m_
##me##
_t
 =
row
.m_##me##_t)

	)

231 
	#CREATE_TABLE_END
(; } }; }

	)

233 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


235 #unde
CREATE_TABLE


236 #unde
COLUMN_NOT_NULL


237 #unde
COLUMN


238 #unde
CREATE_TABLE_END


242 
	#CREATE_TABLE
(
me

mea
am{ cs
	cRowBa5
 : 
public
 
RowBa4
 { \

243 
public
: 
	`RowBa5
({

	)

244 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...
m_
##me##
_t
 = 
l
;

	)

245 
	#COLUMN
(
me
, 
ty
, ...
m_
##me##
_t
 = 
l
;

	)

246 
	#CREATE_TABLE_END
(} }; }

	)

248 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


250 #unde
CREATE_TABLE


251 #unde
COLUMN_NOT_NULL


252 #unde
COLUMN


253 #unde
CREATE_TABLE_END


257 
	#CREATE_TABLE
(
me

mea
am{ cs
	cRow
 : 
public
 
RowBa5
 { \

258 
public
: 
me
<
tyme
 
Vis
> \

259 
	`VisCumns
(
Vis
& 
vis
cڡ {

	)

260 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...
vis
.
	`Vis
(
	`STRINGIFY
ame), 
this
->me,his->
m_
##me##
_t
);

	)

261 
	#COLUMN
(
me
, 
ty
, ...
vis
.
	`Vis
(
	`STRINGIFY
ame), 
this
->me,his->
m_
##me##
_t
);

	)

262 
	#CREATE_TABLE_END
(} }; }

	)

264 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


266 #unde
CREATE_TABLE


267 #unde
COLUMN_NOT_NULL


268 #unde
COLUMN


269 #unde
CREATE_TABLE_END


273 
	#CREATE_TABLE
(
me

mea
ame { \

274 cڡ * 
	`GName
({  
	`STRINGIFY
(
me
); }

	)

275 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...
	`DECLARE_COLUMN
ame,y)

	)

276 
	#COLUMN
(
me
, 
ty
, ...
	`DECLARE_COLUMN
ame, 
	`OPTIONAL
y))

	)

277 
	#CREATE_TABLE_END
(}

	)

279 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


281 #unde
CREATE_TABLE


282 #unde
COLUMN_NOT_NULL


283 #unde
COLUMN


284 #unde
CREATE_TABLE_END


288 
	#CREATE_TABLE
(
me

mea
am{ 
VceDPL
::
	tTyLiDe
<

	)

289 
	tCOLUMN_NOT_NULL
(
	tme
, 
	tty
, ...me,

	)

290 
	tCOLUMN
(
	tme
, 
	tty
, ...me,

	)

291 
	tCREATE_TABLE_END
(
	tVceDPL
::
	tTyLiGud
>::
	tTy
 
	tCumnLi
; }

	)

293 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


295 #unde
CREATE_TABLE


296 #unde
COLUMN_NOT_NULL


297 #unde
COLUMN


298 #unde
CREATE_TABLE_END


302 
	#CREATE_TABLE
(
b_me
) \

303 
mea
 
b_me
 { \

304 
	sTabDefi
 { \

305 
b_me
::
	tCumnLi
 ColumnList; \

306 
b_me
::
	tRow
 Row; \

307 cڡ * 
	`GName
({  
	`STRINGIFY
(
b_me
); } \

308 
VceDPL
::
DB
::
SqlCi
::
DaCommd
 *
	`AocTabDaCommd
( \

309 cڡ 
d
::
rg
 &
emt
, \

310 
IOrmI
 *
r
) \

312 
	`As
(
r
 !
NULL
); \

313  
r
->
	`AocDaCommd
(
emt
); \

315 
	`FeTabDaCommd
( \

316 
VceDPL
::
DB
::
SqlCi
::
DaCommd
 *
commd
, \

317 
IOrmI
 *
r
) \

319 
	`As
(
r
 !
NULL
); \

320 
r
->
	`FeDaCommd
(
commd
); \

322 
VceDPL
::
DB
::
SqlCi
::
RowID
 
	`GLaInRowID
( \

323 
IOrmI
 *
r
) \

325 
	`As
(
r
 !
NULL
); \

326  
r
->
	`GLaInRowID
(); \

329 }

	)

331 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...)

	)

332 
	#COLUMN
(
me
, 
ty
, ...)

	)

333 
	#CREATE_TABLE_END
()

	)

335 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


337 #unde
CREATE_TABLE


338 #unde
COLUMN_NOT_NULL


339 #unde
COLUMN


340 #unde
CREATE_TABLE_END


344 
	#CREATE_TABLE
(
me
) \

345 
mea
 
me
 { \

346 
Se
<
	tTabDefi
> 
	tSe
; \

347 
In
<
	tTabDefi
> 
	tIn
; \

348 
De
<
	tTabDefi
> 
	tDe
; \

349 
Upde
<
	tTabDefi
> 
	tUpde
; \

350 }

	)

351 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...)

	)

352 
	#COLUMN
(
me
, 
ty
, ...)

	)

353 
	#CREATE_TABLE_END
()

	)

355 #ud
ORM_GENERATOR_DATABASE_NAME_LOCAL


357 #unde
CREATE_TABLE


358 #unde
COLUMN_NOT_NULL


359 #unde
COLUMN


360 #unde
CREATE_TABLE_END


364 #unde
INT


365 #unde
TINYINT


366 #unde
INTEGER


367 #unde
BIGINT


368 #unde
VARCHAR


369 #unde
TEXT


371 #unde
SQL


372 #unde
TABLE_CONSTRAINTS


373 #unde
OPTIONAL


374 #unde
DATABASE_START


375 #unde
DATABASE_END


381 #unde
ORM_GENERATOR_DATABASE_NAME


382 #unde
ORM_GENERATOR_DATABASE_NAME_LOCAL


	@vcore/src/dpl/db/include/dpl/db/orm_interface.h

22 
	~<rg
>

23 
	~<d/db/sql_ci.h
>

25 #ide
DPL_ORM_INTERFACE_H


26 
	#DPL_ORM_INTERFACE_H


	)

28 
mea
 
	gVceDPL
 {

29 
mea
 
	gDB
 {

30 
mea
 
	gORM
 {

31 as
	cIOrmI


33 
	gpublic
:

34 
vtu
 ~
IOrmI
() {}

35 
vtu
 
VceDPL
::
DB
::
SqlCi
::
DaCommd
 *
AocDaCommd
(

36 cڡ 
d
::
rg
 &
emt
) = 0;

37 
vtu
 
FeDaCommd
(
VceDPL
::
DB
::
SqlCi
::
DaCommd
 *
commd
)

39 
vtu
 
TniBeg
() = 0;

40 
vtu
 
TniComm
() = 0;

41 
vtu
 
TniRlback
() = 0;

42 
vtu
 
	gVceDPL
::
DB
::
SqlCi
::
RowID
 
GLaInRowID
() = 0;

	@vcore/src/dpl/db/include/dpl/db/orm_macros.h

26 
	#CREATE_TABLE
(
me

CREATE
 
TABLE
 
	`me
(

	)

27 
	#COLUMN
(
me
, 
ty
, ...mty 
__VA_ARGS__
,

	)

28 
	#COLUMN_NOT_NULL
(
me
, 
ty
, ...mty 
__VA_ARGS__
 
n
 
nu
,

	)

29 
	#SQL
(...
__VA_ARGS__


	)

30 
	#TABLE_CONSTRAINTS
(...
__VA_ARGS__
,

	)

31 
	#CREATE_TABLE_END
(
	`CHECK
(1);

	)

32 
	#DATABASE_START
(
db_me
)

	)

33 
	#DATABASE_END
()

	)

	@vcore/src/dpl/db/include/dpl/db/sql_connection.h

22 #ide
DPL_SQL_CONNECTION_H


23 
	#DPL_SQL_CONNECTION_H


	)

25 
	~<d/ncyab.h
>

26 
	~<d/exi.h
>

27 
	~<d/avaaby.h
>

28 
	~<memy
>

29 
	~<boo/tiڮ.h
>

30 
	~<d/rg.h
>

31 
	~<d/log/vce_log.h
>

32 
	~<sqle3.h
>

33 
	~<rg
>

34 
	~<d/as.h
>

35 
	~<memy
>

36 
	~<dt.h
>

38 
mea
 
	gVceDPL
 {

39 
mea
 
	gDB
 {

43 as
	cSqlCi


45 
	gpublic
:

49 as
	cExi


51 
public
:

52 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

53 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
SyaxE
)

54 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
CiBrok
)

55 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
IlE
)

56 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
InvidCumn
)

59 
	tCumnIndex
;

60 
	tArgumtIndex
;

65 as
	cDaCommd
 :

66 
ive
 
Ncyab


68 
ive
:

69 
SqlCi
 *
m_maCi
;

70 
sqle3_mt
 *
	gm_mt
;

72 
CheckBdResu
(
su
);

73 
CheckCumnIndex
(
SqlCi
::
CumnIndex
 
cumn
);

75 
DaCommd
(
SqlCi
 *
ci
, cڡ *
bufr
);

77 
nd
 
ass
 
	gSqlCi
;

79 
	gpublic
:

80 
vtu
 ~
DaCommd
();

87 
BdNu
(
ArgumtIndex
 
posi
);

95 
BdIeg
(
ArgumtIndex
 
posi
, 
vue
);

103 
BdI8
(
ArgumtIndex
 
posi
, 
t8_t
 
vue
);

111 
BdI16
(
ArgumtIndex
 
posi
, 
t16_t
 
vue
);

119 
BdI32
(
ArgumtIndex
 
posi
, 
t32_t
 
vue
);

127 
BdI64
(
ArgumtIndex
 
posi
, 
t64_t
 
vue
);

135 
BdFlt
(
ArgumtIndex
 
posi
, 
vue
);

143 
BdDoub
(
ArgumtIndex
 
posi
, 
vue
);

151 
BdSg
(
ArgumtIndex
 
posi
, cڡ *
vue
);

159 
BdSg
(
ArgumtIndex
 
posi
, cڡ 
Sg
& 
vue
);

168 
BdIeg
(
ArgumtIndex
 
posi
, cڡ 
boo
::
tiڮ
<> &
vue
);

177 
BdI8
(
ArgumtIndex
 
posi
, cڡ 
boo
::
tiڮ
<
t8_t
> &
vue
);

186 
BdI16
(
ArgumtIndex
 
posi
, cڡ 
boo
::
tiڮ
<
t16_t
> &
vue
);

195 
BdI32
(
ArgumtIndex
 
posi
, cڡ 
boo
::
tiڮ
<
t32_t
> &
vue
);

204 
BdI64
(
ArgumtIndex
 
posi
, cڡ 
boo
::
tiڮ
<
t64_t
> &
vue
);

213 
BdFlt
(
ArgumtIndex
 
posi
, cڡ 
boo
::
tiڮ
<> &
vue
);

222 
BdDoub
(
ArgumtIndex
 
posi
, cڡ 
boo
::
tiڮ
<> &
vue
);

231 
BdSg
(
ArgumtIndex
 
posi
, cڡ 
boo
::
tiڮ
<
Sg
> &
vue
);

239 
bo
 
Sp
();

245 
Ret
();

252 
bo
 
IsCumnNu
(
CumnIndex
 
cumn
);

259 
GCumnIeg
(
CumnIndex
 
cumn
);

266 
t8_t
 
GCumnI8
(
CumnIndex
 
cumn
);

273 
t16_t
 
GCumnI16
(
CumnIndex
 
cumn
);

279 
t32_t
 
GCumnI32
(
CumnIndex
 
cumn
);

286 
t64_t
 
GCumnI64
(
CumnIndex
 
cumn
);

293 
GCumnFlt
(
CumnIndex
 
cumn
);

300 
GCumnDoub
(
CumnIndex
 
cumn
);

307 
	gd
::
rg
 
GCumnSg
(
CumnIndex
 
cumn
);

314 
	gboo
::
tiڮ
<> 
GCumnOiڮIeg
(
CumnIndex
 
cumn
);

321 
	gboo
::
tiڮ
<
t8_t
> 
GCumnOiڮI8
(
CumnIndex
 
cumn
);

328 
	gboo
::
tiڮ
<
t16_t
> 
GCumnOiڮI16
(
CumnIndex
 
cumn
);

335 
	gboo
::
tiڮ
<
t32_t
> 
GCumnOiڮI32
(
CumnIndex
 
cumn
);

342 
	gboo
::
tiڮ
<
t64_t
> 
GCumnOiڮI64
(
CumnIndex
 
cumn
);

349 
	gboo
::
tiڮ
<> 
GCumnOiڮFlt
(
CumnIndex
 
cumn
);

356 
	gboo
::
tiڮ
<> 
GCumnOiڮDoub
(
CumnIndex
 
cumn
);

363 
	gboo
::
tiڮ
<
Sg
> 
GCumnOiڮSg
(
CumnIndex
 
cumn
);

367 
	gd
::
	tauto_r
<
	tDaCommd
> 
	tDaCommdAutoP
;

370 as
	cFg


372 
	gpublic
:

373 
	eTy


375 
Ne
 = 1 << 0,

376 
	gULu
 = 1 << 1

379 
	eOi


381 
	gRO
 = 
SQLITE_OPEN_NOMUTEX
 | 
SQLITE_OPEN_READONLY
,

386 
	gRW
 = 
SQLITE_OPEN_NOMUTEX
 | 
SQLITE_OPEN_READWRITE
 |

387 
SQLITE_OPEN_CREATE
,

388 
	gCRW
 = 
RW
 | 
SQLITE_OPEN_CREATE


393 
sqle3_t64
 
	tRowID
;

399 as
	cSynchriziObje


401 
	gpublic
:

402 
vtu
 ~
SynchriziObje
() {}

407 
vtu
 
Synchrize
() = 0;

412 
vtu
 
NifyA
() = 0;

415 
	geed
:

416 
sqle3
 *
m_ci
;

419 
bo
 
	gm_usgLu
;

422 
	gm_daCommdsCou
;

425 
	gd
::
unique_r
<
SynchriziObje
> 
m_synchriziObje
;

427 
vtu
 
C
(cڡ 
d
::
rg
 &
addss
,

428 
Fg
::
Ty
 = Fg::
Ne
, Fg::
Oi
 = Fg::
RO
);

429 
vtu
 
Disc
();

431 
TuOnFeignKeys
();

433 
SynchriziObje
 *
AocDeuSynchriziObje
();

435 
	gpublic
:

448 
exic
 
SqlCi
(cڡ 
d
::
rg
 &
addss
 = std::string(),

449 
Fg
::
Ty
 
ags
 = Fg::
Ne
,

450 
Fg
::
Oi
 
tis
 = Fg::
RO
,

451 
SynchriziObje
 *
synchriziObje
 =

452 
AocDeuSynchriziObje
());

457 
	gvtu
 ~
SqlCi
();

465 
ExecCommd
(cڡ *
fm
, ...
DPL_DEPRECATED_WITH_MESSAGE
(

473 
BegTni
();

479 
RlbackTni
();

485 
CommTni
();

493 
DaCommdAutoP
 
PDaCommd
(cڡ *
fm
, ...);

501 
bo
 
CheckTabExi
(cڡ *
bName
);

508 
RowID
 
GLaInRowID
() const;

510 
	give
:

511 
db_ut_ݒ_wh_tis
(cڡ *
pszFePh
, 
sqle3
 **
DB
,

512 
ags
, cڡ *
zVfs
);

513 
db_ut_o
(
sqle3
 *
pDB
);

	@vcore/src/dpl/db/include/dpl/db/thread_database_support.h

23 #ide
DPL_THREAD_DATABASE_SUPPORT_H


24 
	#DPL_THREAD_DATABASE_SUPPORT_H


	)

26 
	~<rg
>

27 
	~<d/db/sql_ci.h
>

28 
	~<d/db/m_r.h
>

29 
	~<d/thad.h
>

30 
	~<d/as.h
>

31 
	~<dt.h
>

33 
mea
 
	gVceDPL
 {

34 
mea
 
	gDB
 {

42 as
	cThadDabaSut
 :

43 
public
 
VceDPL
::
DB
::
ORM
::
IOrmI


45 
ive
:

46 
VceDPL
::
	tDB
::
	tSqlCi
 *
	tSqlCiP
;

47 
	gVceDPL
::
	tThadLolVb
<
	tSqlCiP
> 
	tTLVSqlCiP
;

48 
	gVceDPL
::
	tThadLolVb
<
	tsize_t
> 
	tTLVSizeT
;

49 
	gVceDPL
::
	tThadLolVb
<
	tbo
> 
	tTLVBo
;

51 
TLVSqlCiP
 
	gm_ci
;

52 
TLVBo
 
	gm_lg
;

53 
TLVSizeT
 
	gm_fCou
;

54 
TLVSizeT
 
	gm_iDth
;

55 
TLVSizeT
 
	gm_chCou
;

56 
TLVBo
 
	gm_iCl
;

57 
	gd
::
rg
 
m_addss
;

58 
	gVceDPL
::
DB
::
SqlCi
::
Fg
::
Ty
 
m_ags
;

60 
	gTLVSqlCiP
 &
Ci
()

62  
	gm_ci
;

65 
	gTLVBo
 &
Lg
()

67  
	gm_lg
;

70 
	gTLVSizeT
 &
RefCou
()

72  
	gm_fCou
;

75 
	gTLVSizeT
 &
TniDth
()

77  
	gm_iDth
;

80 
	gTLVSizeT
 &
AachCou
()

82  
	gm_chCou
;

85 
	gTLVBo
 &
TniCl
()

87  
	gm_iCl
;

90 
CheckedCiDe
()

92 
As
(!
Ci
().
IsNu
());

93 
As
(*
Lg
(=
ue
);

95 i(*
RefCou
(> 0 || *
AachCou
() > 0) {

100 
VceLogD
("Deroyghad daba ci: %s", 
m_addss
.
c_r
());

102 
de
 *
Ci
();

105 
Ci
().
GudVue
(
l
);

106 
Lg
().
GudVue
(
l
);

107 
RefCou
().
GudVue
(
l
);

108 
TniCl
().
GudVue
(
l
);

109 
TniDth
().
GudVue
(
l
);

110 
AachCou
().
GudVue
(
l
);

112 
Ci
().
Ret
();

113 
Lg
().
Ret
();

114 
RefCou
().
Ret
();

115 
TniCl
().
Ret
();

116 
TniDth
().
Ret
();

117 
AachCou
().
Ret
();

120 
TniUef
()

122 
VceLogD
("Unrefransaction");

124 i(--(*
TniDth
()) == 0) {

125 
VceLogD
("Transaction is finalized");

127 i(*
TniCl
()) {

128 
VceLogD
("Transaction will beolled back");

129 (*
Ci
())->
RlbackTni
();

131 
VceLogD
("Transaction will be commited");

132 (*
Ci
())->
CommTni
();

137 
	gpublic
:

138 
ThadDabaSut
(cڡ 
d
::
rg
 &
addss
,

139 
VceDPL
::
DB
::
SqlCi
::
Fg
::
Ty
 
ags
) :

140 
m_addss
(
addss
),

141 
m_ags
(
ags
)

144 
	gvtu
 ~
ThadDabaSut
()

147 
AachToThad
(

148 
VceDPL
::
DB
::
SqlCi
::
Fg
::
Oi
 
tis
 =

149 
VceDPL
::
DB
::
SqlCi
::
Fg
::
RO
)

151 
Lg
(
l
;

153 i(!
Ci
().
IsNu
()) {

155 ++*
AachCou
();

160 
VceLogD
("Aachghad daba ci: %s", 
m_addss
.
c_r
());

162 
Ci
(
w
 
VceDPL
::
DB
::
SqlCi
(

163 
m_addss
.
c_r
(), 
m_ags
, 
tis
);

165 
RefCou
() = 0;

167 
AachCou
() = 1;

170 
TniDth
() = 0;

171 
TniCl
(
l
;

174 
Ci
().
GudVue
(
ue
);

175 
Lg
().
GudVue
(
ue
);

176 
RefCou
().
GudVue
(
ue
);

177 
TniDth
().
GudVue
(
ue
);

178 
AachCou
().
GudVue
(
ue
);

179 
TniCl
().
GudVue
(
ue
);

182 
DachFromThad
()

185 
As
(!
Ci
().
IsNu
());

188 --*
AachCou
();

190 i(*
AachCou
() > 0) {

195 
As
(*
Lg
(=
l
);

197 
VceLogD
("Dachghad daba ci: %s", 
m_addss
.
c_r
());

200 *
Lg
(
ue
;

203 
CheckedCiDe
();

206 
bo
 
IsAached
()

208  !
AachCou
().
IsNu
() && *AttachCount() > 0;

211 
	gVceDPL
::
DB
::
SqlCi
::
DaCommd
 *
AocDaCommd
(

212 cڡ 
d
::
rg
 &
emt
)

215 
As
(!
Ci
().
IsNu
());

218 
As
(*
Lg
(=
l
);

221 ++*
RefCou
();

224  (*
Ci
())->
PDaCommd
(
emt
.
c_r
()).
a
();

227 
FeDaCommd
(
VceDPL
::
DB
::
SqlCi
::
DaCommd
 *
commd
)

230 
As
(!
Ci
().
IsNu
());

233 
de
 
	gcommd
;

236 --*
RefCou
();

239 i(*
Lg
(=
ue
) {

240 
CheckedCiDe
();

244 
TniBeg
()

247 
As
(!
Ci
().
IsNu
());

249 
VceLogD
("Beginransaction");

252 i(++(*
TniDth
()) == 1) {

253 
VceLogD
("Transaction is initialized");

255 
TniCl
(
l
;

256 (*
Ci
())->
BegTni
();

260 
TniComm
()

263 
As
(!
Ci
().
IsNu
());

265 
VceLogD
("Commitransaction");

268 
TniUef
();

271 
TniRlback
()

274 
As
(!
Ci
().
IsNu
());

277 
TniCl
(
ue
;

278 
TniUef
();

281 
	gVceDPL
::
DB
::
SqlCi
::
RowID
 
GLaInRowID
()

284 
As
(!
Ci
().
IsNu
());

286  (*
Ci
())->
GLaInRowID
();

289 
bo
 
CheckTabExi
(cڡ *
me
)

292 
As
(!
Ci
().
IsNu
());

294  (*
Ci
())->
CheckTabExi
(
me
);

	@vcore/src/dpl/db/src/naive_synchronization_object.cpp

23 
	~<ddef.h
>

24 
	~<d/db/ive_synchrizi_obje.h
>

25 
	~<d/thad.h
>

27 
	gmea
 {

28 
	ged
 = 
time
(
NULL
);

31 
mea
 
	gVceDPL
 {

32 
mea
 
	gDB
 {

33 
	gNaiveSynchriziObje
::
Synchrize
()

36 
Thad
::
MiS˕
(10 + 
nd_r
(&
ed
) % 20);

39 
	gNaiveSynchriziObje
::
NifyA
()

	@vcore/src/dpl/db/src/orm.cpp

23 
	~<ddef.h
>

24 
	~<d/db/m.h
>

26 
mea
 
	gVceDPL
 {

27 
mea
 
	gDB
 {

28 
mea
 
	gORM
 {

29 
mea
 
	gRiTys
 {

30 cڡ 
	gEqu
[] = "=";

31 cڡ 
	gLessTh
[] = "<";

32 cڡ 
	gAnd
[] = "AND";

33 cڡ 
	gOr
[] = "OR";

34 cڡ 
	gIs
[] = "IS";

35 cڡ 
	gIn
[] = "IN";

38 
	gme
<>

39 
	gGCumnFromCommd
<>(
CumnIndex
 
	gcumnIndex
,

40 
DaCommd
 *
	gcommd
)

42  
	gcommd
->
GCumnIeg
(
cumnIndex
);

45 
	gme
<>

46 
	gVceDPL
::
Sg
 
GCumnFromCommd
<
VceDPL
::Sg>(
CumnIndex
 
cumnIndex
,

47 
DaCommd
 *
	gcommd
)

49  
	gVceDPL
::
FromUTF8Sg
(
commd
->
GCumnSg
(
cumnIndex
));

52 
	gme
<>

53 
OiڮIeg
 
	gGCumnFromCommd
<
	gOiڮIeg
>(
CumnIndex
 
	gcumnIndex
,

54 
DaCommd
 *
	gcommd
)

56  
	gcommd
->
GCumnOiڮIeg
(
cumnIndex
);

59 
	gme
<>

60 
OiڮSg
 
	gGCumnFromCommd
<
	gOiڮSg
>(
CumnIndex
 
	gcumnIndex
,

61 
DaCommd
 *
	gcommd
)

63  
	gcommd
->
GCumnOiڮSg
(
cumnIndex
);

66 
	gme
<>

67 
	gGCumnFromCommd
<>(
CumnIndex
 
	gcumnIndex
,

68 
DaCommd
 *
	gcommd
)

70  
	gcommd
->
GCumnDoub
(
cumnIndex
);

73 
	gDaCommdUts
::
BdArgumt
(
DaCommd
 *
commd
,

74 
ArgumtIndex
 
dex
,

75 
gumt
)

77 
	gcommd
->
BdIeg
(
dex
, 
gumt
);

80 
	gDaCommdUts
::
BdArgumt
(
DaCommd
 *
commd
,

81 
ArgumtIndex
 
dex
,

82 cڡ 
OiڮIeg
& 
gumt
)

84 
	gcommd
->
BdIeg
(
dex
, 
gumt
);

87 
	gDaCommdUts
::
BdArgumt
(
DaCommd
 *
commd
,

88 
ArgumtIndex
 
dex
,

89 cڡ 
VceDPL
::
Sg
& 
gumt
)

91 
commd
->
BdSg
(
dex
, 
gumt
);

94 
	gDaCommdUts
::
BdArgumt
(
DaCommd
 *
commd
,

95 
ArgumtIndex
 
dex
,

96 cڡ 
OiڮSg
& 
gumt
)

98 
	gcommd
->
BdSg
(
dex
, 
gumt
);

	@vcore/src/dpl/db/src/sql_connection.cpp

22 
	~<ddef.h
>

23 
	~<d/db/sql_ci.h
>

24 
	~<d/db/ive_synchrizi_obje.h
>

25 
	~<d/_d.h
>

26 
	~<memy
>

27 
	~<d/ncyab.h
>

28 
	~<d/as.h
>

29 
	~<unid.h
>

30 
	~<cdio
>

31 
	~<cdg
>

33 
mea
 
	gVceDPL
 {

34 
mea
 
	gDB
 {

35 
	gmea


37 as
	cScedNifyA
 :

38 
public
 
Ncyab


40 
ive
:

41 
SqlCi
::
SynchriziObje
 *
m_synchriziObje
;

43 
	gpublic
:

44 
exic
 
ScedNifyA
(

45 
SqlCi
::
SynchriziObje
 *
synchriziObje
) :

46 
m_synchriziObje
(
synchriziObje
)

49 ~
ScedNifyA
()

51 i(!
m_synchriziObje
) {

55 
VceLogD
("Notifyingfter successful synchronize");

56 
	gm_synchriziObje
->
NifyA
();

61 
	gSqlCi
::
DaCommd
::DaCommd(
SqlCi
 *
ci
,

62 cڡ *
bufr
) :

63 
m_maCi
(
ci
),

64 
m_mt
(
NULL
)

66 
As
(
ci
 !
NULL
);

69 
ScedNifyA
 
nifyA
(
ci
->
m_synchriziObje
.
g
());

72 
	gt
 = 
sqle3_e_v2
(
ci
->
m_ci
,

73 
bufr
, 

(buffer),

74 &
m_mt
, 
NULL
);

76 i(
	gt
 =
SQLITE_OK
) {

77 
VceLogD
("Data commandrepared successfuly");

79 } i(
	gt
 =
SQLITE_BUSY
) {

80 
VceLogD
("Collision occurred whilereparing SQL command");

83 i(
	gci
->
	gm_synchriziObje
) {

84 
VceLogD
("Performing synchronization");

85 
	gci
->
	gm_synchriziObje
->
Synchrize
();

93 cڡ *
	gr
 = 
sqle3_rmsg
(
m_maCi
->
m_ci
);

95 
VceLogD
("SQLrepare data command failed");

96 
VceLogD
(" Smt: %s", 
bufr
);

97 
VceLogD
(" E: %s", 
r
);

99 
ThrowMsg
(
Exi
::
SyaxE
, 
r
);

102 
VceLogD
("Pd dcommd: %s", 
bufr
);

105 ++
	gm_maCi
->
	gm_daCommdsCou
;

108 
	gSqlCi
::
DaCommd
::~DataCommand()

110 
VceLogD
("SQL data command finalizing");

112 i(
sqle3_fize
(
m_mt
!
SQLITE_OK
) {

113 
VceLogD
("Failedo finalize data command");

117 --
	gm_maCi
->
	gm_daCommdsCou
;

120 
	gSqlCi
::
DaCommd
::
CheckBdResu
(
su
)

122 i(
su
 !
SQLITE_OK
) {

123 cڡ *
r
 = 
sqle3_rmsg
(

124 
m_maCi
->
m_ci
);

126 
VceLogD
("Failedo bind SQL statementarameter");

127 
VceLogD
(" E: %s", 
r
);

129 
ThrowMsg
(
Exi
::
SyaxE
, 
r
);

133 
	gSqlCi
::
DaCommd
::
BdNu
(

134 
SqlCi
::
ArgumtIndex
 
posi
)

136 
CheckBdResu
(
sqle3_bd_nu
(
m_mt
, 
posi
));

137 
VceLogD
("SQL dcommd bdu: [%i]", 
posi
);

140 
	gSqlCi
::
DaCommd
::
BdIeg
(

141 
SqlCi
::
ArgumtIndex
 
posi
,

142 
vue
)

144 
CheckBdResu
(
sqle3_bd_t
(
m_mt
, 
posi
, 
vue
));

145 
VceLogD
("SQL dcommd bd ieg: [%i] -> %i", 
posi
, 
vue
);

148 
	gSqlCi
::
DaCommd
::
BdI8
(

149 
SqlCi
::
ArgumtIndex
 
posi
,

150 
t8_t
 
vue
)

152 
CheckBdResu
(
sqle3_bd_t
(
m_mt
, 
posi
,

153 
ic_
<>(
vue
)));

154 
VceLogD
("SQL dcommd bd i8: [%i] -> %i", 
posi
, 
vue
);

157 
	gSqlCi
::
DaCommd
::
BdI16
(

158 
SqlCi
::
ArgumtIndex
 
posi
,

159 
t16_t
 
vue
)

161 
CheckBdResu
(
sqle3_bd_t
(
m_mt
, 
posi
,

162 
ic_
<>(
vue
)));

163 
VceLogD
("SQL dcommd bd i16: [%i] -> %i", 
posi
, 
vue
);

166 
	gSqlCi
::
DaCommd
::
BdI32
(

167 
SqlCi
::
ArgumtIndex
 
posi
,

168 
t32_t
 
vue
)

170 
CheckBdResu
(
sqle3_bd_t
(
m_mt
, 
posi
,

171 
ic_
<>(
vue
)));

172 
VceLogD
("SQL dcommd bd i32: [%i] -> %i", 
posi
, 
vue
);

175 
	gSqlCi
::
DaCommd
::
BdI64
(

176 
SqlCi
::
ArgumtIndex
 
posi
,

177 
t64_t
 
vue
)

179 
CheckBdResu
(
sqle3_bd_t64
(
m_mt
, 
posi
,

180 
ic_
<
sqle3_t64
>(
vue
)));

181 
VceLogD
("SQL dcommd bd i64: [%i] -> %i", 
posi
, 
vue
);

184 
	gSqlCi
::
DaCommd
::
BdFlt
(

185 
SqlCi
::
ArgumtIndex
 
posi
,

186 
vue
)

188 
CheckBdResu
(
sqle3_bd_doub
(
m_mt
, 
posi
,

189 
ic_
<>(
vue
)));

190 
VceLogD
("SQL dcommd bd flt: [%i] -> %f", 
posi
, 
vue
);

193 
	gSqlCi
::
DaCommd
::
BdDoub
(

194 
SqlCi
::
ArgumtIndex
 
posi
,

195 
vue
)

197 
CheckBdResu
(
sqle3_bd_doub
(
m_mt
, 
posi
, 
vue
));

198 
VceLogD
("SQL dcommd bd doub: [%i] -> %f", 
posi
, 
vue
);

201 
	gSqlCi
::
DaCommd
::
BdSg
(

202 
SqlCi
::
ArgumtIndex
 
posi
,

203 cڡ *
vue
)

205 i(!
	gvue
) {

206 
BdNu
(
posi
);

211 
CheckBdResu
(
sqle3_bd_xt
(
m_mt
, 
posi
,

212 
vue
, 

(value),

213 
SQLITE_TRANSIENT
));

215 
VceLogD
("SQL dcommd bd sg: [%i] -> %s", 
posi
, 
vue
);

218 
	gSqlCi
::
DaCommd
::
BdSg
(

219 
SqlCi
::
ArgumtIndex
 
posi
,

220 cڡ 
Sg
 &
vue
)

222 
BdSg
(
posi
, 
ToUTF8Sg
(
vue
).
c_r
());

225 
	gSqlCi
::
DaCommd
::
BdIeg
(

226 
SqlCi
::
ArgumtIndex
 
posi
,

227 cڡ 
boo
::
tiڮ
<> &
vue
)

229 i(!
vue
) {

230 
BdNu
(
posi
);

232 
BdIeg
(
posi
, *
vue
);

236 
	gSqlCi
::
DaCommd
::
BdI8
(

237 
SqlCi
::
ArgumtIndex
 
posi
,

238 cڡ 
boo
::
tiڮ
<
t8_t
> &
vue
)

240 i(!
vue
) {

241 
BdNu
(
posi
);

243 
BdI8
(
posi
, *
vue
);

247 
	gSqlCi
::
DaCommd
::
BdI16
(

248 
SqlCi
::
ArgumtIndex
 
posi
,

249 cڡ 
boo
::
tiڮ
<
t16_t
> &
vue
)

251 i(!
vue
) {

252 
BdNu
(
posi
);

254 
BdI16
(
posi
, *
vue
);

258 
	gSqlCi
::
DaCommd
::
BdI32
(

259 
SqlCi
::
ArgumtIndex
 
posi
,

260 cڡ 
boo
::
tiڮ
<
t32_t
> &
vue
)

262 i(!
vue
) {

263 
BdNu
(
posi
);

265 
BdI32
(
posi
, *
vue
);

269 
	gSqlCi
::
DaCommd
::
BdI64
(

270 
SqlCi
::
ArgumtIndex
 
posi
,

271 cڡ 
boo
::
tiڮ
<
t64_t
> &
vue
)

273 i(!
vue
) {

274 
BdNu
(
posi
);

276 
BdI64
(
posi
, *
vue
);

280 
	gSqlCi
::
DaCommd
::
BdFlt
(

281 
SqlCi
::
ArgumtIndex
 
posi
,

282 cڡ 
boo
::
tiڮ
<> &
vue
)

284 i(!
vue
) {

285 
BdNu
(
posi
);

287 
BdFlt
(
posi
, *
vue
);

291 
	gSqlCi
::
DaCommd
::
BdDoub
(

292 
SqlCi
::
ArgumtIndex
 
posi
,

293 cڡ 
boo
::
tiڮ
<> &
vue
)

295 i(!
vue
) {

296 
BdNu
(
posi
);

298 
BdDoub
(
posi
, *
vue
);

302 
	gSqlCi
::
DaCommd
::
BdSg
(

303 
SqlCi
::
ArgumtIndex
 
posi
,

304 cڡ 
boo
::
tiڮ
<
Sg
> &
vue
)

306 i(!!
vue
) {

307 
BdSg
(
posi
, 
ToUTF8Sg
(*
vue
).
c_r
());

309 
BdNu
(
posi
);

313 
bo
 
	gSqlCi
::
DaCommd
::
Sp
()

316 
ScedNifyA
 
nifyA
(

317 
m_maCi
->
m_synchriziObje
.
g
());

320 
	gt
 = 
sqle3_
(
m_mt
);

322 i(
	gt
 =
SQLITE_ROW
) {

323 
VceLogD
("SQL data command step ROW");

324  
	gue
;

325 } i(
	gt
 =
SQLITE_DONE
) {

326 
VceLogD
("SQL data command step DONE");

327  
	gl
;

328 } i(
	gt
 =
SQLITE_BUSY
) {

329 
VceLogD
("Collision occurred whilexecuting SQL command");

332 i(
	gm_maCi
->
	gm_synchriziObje
) {

333 
VceLogD
("Performing synchronization");

335 
	gm_maCi
->

336 
	gm_synchriziObje
->
Synchrize
();

345 cڡ *
	gr
 = 
sqle3_rmsg
(
m_maCi
->
m_ci
);

347 
VceLogD
("SQL step data command failed");

348 
VceLogD
(" E: %s", 
r
);

350 
ThrowMsg
(
Exi
::
IlE
, 
r
);

354 
	gSqlCi
::
DaCommd
::
Ret
()

364 
sqle3_t
(
m_mt
);

366 
VceLogD
("SQL data commandeset");

369 
	gSqlCi
::
DaCommd
::
CheckCumnIndex
(

370 
SqlCi
::
CumnIndex
 
cumn
)

372 i(
cumn
 < 0 || cum>
sqle3_cumn_cou
(
m_mt
)) {

373 
ThrowMsg
(
Exi
::
InvidCumn
, "Column index is out of bounds");

377 
bo
 
	gSqlCi
::
DaCommd
::
IsCumnNu
(

378 
SqlCi
::
CumnIndex
 
cumn
)

380 
VceLogD
("SQL dcommd g cumty: [%i]", 
cumn
);

381 
CheckCumnIndex
(
cumn
);

382  
sqle3_cumn_ty
(
m_mt
, 
cumn
=
SQLITE_NULL
;

385 
	gSqlCi
::
DaCommd
::
GCumnIeg
(

386 
SqlCi
::
CumnIndex
 
cumn
)

388 
VceLogD
("SQL dcommd g cumg: [%i]", 
cumn
);

389 
CheckCumnIndex
(
cumn
);

390 
	gvue
 = 
sqle3_cumn_t
(
m_mt
, 
cumn
);

391 
VceLogD
(" Vue: %i", 
vue
);

392  
	gvue
;

395 
t8_t
 
	gSqlCi
::
DaCommd
::
GCumnI8
(

396 
SqlCi
::
CumnIndex
 
cumn
)

398 
VceLogD
("SQL dcommd g cumt8: [%i]", 
cumn
);

399 
CheckCumnIndex
(
cumn
);

400 
t8_t
 
	gvue
 = 
ic_
<t8_t>(
sqle3_cumn_t
(
m_mt
, 
cumn
));

401 
VceLogD
(" Vue: %i", 
vue
);

402  
	gvue
;

405 
t16_t
 
	gSqlCi
::
DaCommd
::
GCumnI16
(

406 
SqlCi
::
CumnIndex
 
cumn
)

408 
VceLogD
("SQL dcommd g cumt16: [%i]", 
cumn
);

409 
CheckCumnIndex
(
cumn
);

410 
t16_t
 
	gvue
 = 
ic_
<t16_t>(
sqle3_cumn_t
(
m_mt
, 
cumn
));

411 
VceLogD
(" Vue: %i", 
vue
);

412  
	gvue
;

415 
t32_t
 
	gSqlCi
::
DaCommd
::
GCumnI32
(

416 
SqlCi
::
CumnIndex
 
cumn
)

418 
VceLogD
("SQL dcommd g cumt32: [%i]", 
cumn
);

419 
CheckCumnIndex
(
cumn
);

420 
t32_t
 
	gvue
 = 
ic_
<t32_t>(
sqle3_cumn_t
(
m_mt
, 
cumn
));

421 
VceLogD
(" Vue: %i", 
vue
);

422  
	gvue
;

425 
t64_t
 
	gSqlCi
::
DaCommd
::
GCumnI64
(

426 
SqlCi
::
CumnIndex
 
cumn
)

428 
VceLogD
("SQL dcommd g cumt64: [%i]", 
cumn
);

429 
CheckCumnIndex
(
cumn
);

430 
t64_t
 
	gvue
 = 
ic_
<t64_t>(
sqle3_cumn_t64
(
m_mt
, 
cumn
));

431 
VceLogD
(" Vue: %i", 
vue
);

432  
	gvue
;

435 
	gSqlCi
::
DaCommd
::
GCumnFlt
(

436 
SqlCi
::
CumnIndex
 
cumn
)

438 
VceLogD
("SQL dcommd g cumt: [%i]", 
cumn
);

439 
CheckCumnIndex
(
cumn
);

440 
	gvue
 = 
ic_
<>(
sqle3_cumn_doub
(
m_mt
, 
cumn
));

441 
VceLogD
(" Vue: %f", 
vue
);

442  
	gvue
;

445 
	gSqlCi
::
DaCommd
::
GCumnDoub
(

446 
SqlCi
::
CumnIndex
 
cumn
)

448 
VceLogD
("SQL dcommd g cumdoub: [%i]", 
cumn
);

449 
CheckCumnIndex
(
cumn
);

450 
	gvue
 = 
sqle3_cumn_doub
(
m_mt
, 
cumn
);

451 
VceLogD
(" Vue: %f", 
vue
);

452  
	gvue
;

455 
	gd
::
rg
 
SqlCi
::
DaCommd
::
GCumnSg
(

456 
SqlCi
::
CumnIndex
 
cumn
)

458 
VceLogD
("SQL dcommd g cumrg: [%i]", 
cumn
);

459 
CheckCumnIndex
(
cumn
);

461 cڡ *
	gvue
 = 
t_
<const *>(

462 
sqle3_cumn_xt
(
m_mt
, 
cumn
));

464 
VceLogD
(" Vue: %s", 
vue
);

466 i(
	gvue
 =
NULL
) {

467  
d
::
rg
();

470  
	gd
::
rg
(
vue
);

473 
	gboo
::
tiڮ
<> 
SqlCi
::
DaCommd
::
GCumnOiڮIeg
(

474 
SqlCi
::
CumnIndex
 
cumn
)

476 
VceLogD
("SQL dcommd g cumtiڮ ieg: [%i]", 
cumn
);

477 
CheckCumnIndex
(
cumn
);

478 i(
sqle3_cumn_ty
(
m_mt
, 
cumn
=
SQLITE_NULL
) {

479  
boo
::
tiڮ
<>();

481 
	gvue
 = 
sqle3_cumn_t
(
m_mt
, 
cumn
);

482 
VceLogD
(" Vue: %i", 
vue
);

483  
	gboo
::
tiڮ
<>(
vue
);

486 
	gboo
::
tiڮ
<
t8_t
> 
SqlCi
::
DaCommd
::
GCumnOiڮI8
(

487 
SqlCi
::
CumnIndex
 
cumn
)

489 
VceLogD
("SQL dcommd g cumtiڮ i8: [%i]", 
cumn
);

490 
CheckCumnIndex
(
cumn
);

491 i(
sqle3_cumn_ty
(
m_mt
, 
cumn
=
SQLITE_NULL
) {

492  
boo
::
tiڮ
<
t8_t
>();

494 
t8_t
 
	gvue
 = 
ic_
<t8_t>(
sqle3_cumn_t
(
m_mt
, 
cumn
));

495 
VceLogD
(" Vue: %i", 
vue
);

496  
	gboo
::
tiڮ
<
t8_t
>(
vue
);

499 
	gboo
::
tiڮ
<
t16_t
> 
SqlCi
::
DaCommd
::
GCumnOiڮI16
(

500 
SqlCi
::
CumnIndex
 
cumn
)

502 
VceLogD
("SQL dcommd g cumtiڮ i16: [%i]", 
cumn
);

503 
CheckCumnIndex
(
cumn
);

504 i(
sqle3_cumn_ty
(
m_mt
, 
cumn
=
SQLITE_NULL
) {

505  
boo
::
tiڮ
<
t16_t
>();

507 
t16_t
 
	gvue
 = 
ic_
<t16_t>(
sqle3_cumn_t
(
m_mt
, 
cumn
));

508 
VceLogD
(" Vue: %i", 
vue
);

509  
	gboo
::
tiڮ
<
t16_t
>(
vue
);

512 
	gboo
::
tiڮ
<
t32_t
> 
SqlCi
::
DaCommd
::
GCumnOiڮI32
(

513 
SqlCi
::
CumnIndex
 
cumn
)

515 
VceLogD
("SQL dcommd g cumtiڮ i32: [%i]", 
cumn
);

516 
CheckCumnIndex
(
cumn
);

517 i(
sqle3_cumn_ty
(
m_mt
, 
cumn
=
SQLITE_NULL
) {

518  
boo
::
tiڮ
<
t32_t
>();

520 
t32_t
 
	gvue
 = 
ic_
<t32_t>(
sqle3_cumn_t
(
m_mt
, 
cumn
));

521 
VceLogD
(" Vue: %i", 
vue
);

522  
	gboo
::
tiڮ
<
t32_t
>(
vue
);

525 
	gboo
::
tiڮ
<
t64_t
> 
SqlCi
::
DaCommd
::
GCumnOiڮI64
(

526 
SqlCi
::
CumnIndex
 
cumn
)

528 
VceLogD
("SQL dcommd g cumtiڮ i64: [%i]", 
cumn
);

529 
CheckCumnIndex
(
cumn
);

530 i(
sqle3_cumn_ty
(
m_mt
, 
cumn
=
SQLITE_NULL
) {

531  
boo
::
tiڮ
<
t64_t
>();

533 
t64_t
 
	gvue
 = 
ic_
<t64_t>(
sqle3_cumn_t64
(
m_mt
, 
cumn
));

534 
VceLogD
(" Vue: %i", 
vue
);

535  
	gboo
::
tiڮ
<
t64_t
>(
vue
);

538 
	gboo
::
tiڮ
<> 
SqlCi
::
DaCommd
::
GCumnOiڮFlt
(

539 
SqlCi
::
CumnIndex
 
cumn
)

541 
VceLogD
("SQL dcommd g cumtiڮ flt: [%i]", 
cumn
);

542 
CheckCumnIndex
(
cumn
);

543 i(
sqle3_cumn_ty
(
m_mt
, 
cumn
=
SQLITE_NULL
) {

544  
boo
::
tiڮ
<>();

546 
	gvue
 = 
ic_
<>(
sqle3_cumn_doub
(
m_mt
, 
cumn
));

547 
VceLogD
(" Vue: %f", 
vue
);

548  
	gboo
::
tiڮ
<>(
vue
);

551 
	gboo
::
tiڮ
<> 
SqlCi
::
DaCommd
::
GCumnOiڮDoub
(

552 
SqlCi
::
CumnIndex
 
cumn
)

554 
VceLogD
("SQL dcommd g cumtiڮ doub: [%i]", 
cumn
);

555 
CheckCumnIndex
(
cumn
);

556 i(
sqle3_cumn_ty
(
m_mt
, 
cumn
=
SQLITE_NULL
) {

557  
boo
::
tiڮ
<>();

559 
	gvue
 = 
sqle3_cumn_doub
(
m_mt
, 
cumn
);

560 
VceLogD
(" Vue: %f", 
vue
);

561  
	gboo
::
tiڮ
<>(
vue
);

564 
	gboo
::
tiڮ
<
Sg
> 
SqlCi
::
DaCommd
::
GCumnOiڮSg
(

565 
SqlCi
::
CumnIndex
 
cumn
)

567 
VceLogD
("SQL dcommd g cumtiڮ sg: [%i]", 
cumn
);

568 
CheckCumnIndex
(
cumn
);

569 i(
sqle3_cumn_ty
(
m_mt
, 
cumn
=
SQLITE_NULL
) {

570  
boo
::
tiڮ
<
Sg
>();

572 cڡ *
	gvue
 = 
t_
<const *>(

573 
sqle3_cumn_xt
(
m_mt
, 
cumn
));

574 
VceLogD
(" Vue: %s", 
vue
);

575 
Sg
 
	gs
 = 
FromUTF8Sg
(
vue
);

576  
	gboo
::
tiڮ
<
Sg
>(
s
);

579 
	gSqlCi
::
C
(cڡ 
d
::
rg
 &
addss
,

580 
Fg
::
Ty
 
ty
,

581 
Fg
::
Oi
 
ag
)

583 i(
m_ci
 !
NULL
) {

584 
VceLogD
("Already connected.");

587 
VceLogD
("CgDB: %s...", 
addss
.
c_r
());

590 
	gsu
;

591 i(
	gty
 & 
	gFg
::
ULu
) {

592 
su
 = 
db_ut_ݒ_wh_tis
(

593 
addss
.
c_r
(),

594 &
m_ci
,

595 
ag
,

596 
NULL
);

598 
	gm_usgLu
 = 
ue
;

599 
VceLogD
("Lucene indexnabled");

601 
	gsu
 = 
sqle3_ݒ_v2
(

602 
addss
.
c_r
(),

603 &
m_ci
,

604 
ag
,

605 
NULL
);

607 
	gm_usgLu
 = 
l
;

608 
VceLogD
("Lucene index disabled");

611 i(
	gsu
 =
SQLITE_OK
) {

612 
VceLogD
("Connectedo DB");

614 
VceLogD
("Failedo connecto DB!");

615 
ThrowMsg
(
Exi
::
CiBrok
, 
addss
);

619 
TuOnFeignKeys
();

622 
	gSqlCi
::
Disc
()

624 i(
m_ci
 =
NULL
) {

625 
VceLogD
("Already disconnected.");

629 
VceLogD
("Disconnecting from DB...");

632 
AsMsg
(
m_daCommdsCou
 == 0,

636 
	gsu
;

638 i(
	gm_usgLu
) {

639 
	gsu
 = 
db_ut_o
(
m_ci
);

641 
	gsu
 = 
sqle3_o
(
m_ci
);

644 i(
	gsu
 !
SQLITE_OK
) {

645 cڡ *
r
 = 
sqle3_rmsg
(
m_ci
);

646 
VceLogD
("SQL close failed");

647 
VceLogD
(" E: %s", 
r
);

648 
Throw
(
Exi
::
IlE
);

651 
	gm_ci
 = 
NULL
;

653 
VceLogD
("Disconnected from DB");

656 
bo
 
	gSqlCi
::
CheckTabExi
(cڡ *
bName
)

658 i(
m_ci
 =
NULL
) {

659 
VceLogD
("Cannotxecute command. Not connectedo DB!");

660  
	gl
;

663 
DaCommdAutoP
 
	gcommd
 =

664 
PDaCommd
("selectbl_name from sqlite_master whereame=?;");

666 
	gcommd
->
BdSg
(1, 
bName
);

668 i(!
	gcommd
->
Sp
()) {

669 
VceLogD
("No matchingecords inable");

670  
	gl
;

673  
	gcommd
->
GCumnSg
(0=
bName
;

676 
	gSqlCi
::
SqlCi
(cڡ 
d
::
rg
 &
addss
,

677 
Fg
::
Ty
 
ag
,

678 
Fg
::
Oi
 
ti
,

679 
SynchriziObje
 *
synchriziObje
) :

680 
m_ci
(
NULL
),

681 
m_usgLu
(
l
),

682 
m_daCommdsCou
(0),

683 
m_synchriziObje
(
synchriziObje
)

685 
VceLogD
("Ong daba ciځo: %s", 
addss
.
c_r
());

688 
	gSqlCi
::
C
(
addss
, 
ag
, 
ti
);

690 i(!
	gm_synchriziObje
) {

691 
VceLogD
("No synchronization object defined");

695 
	gSqlCi
::~
SqlCi
()

697 
VceLogD
("Closing database connection");

700 
	gTry


702 
	gSqlCi
::
Disc
();

704 
Cch
(
Exi
::
Ba
)

706 
VceLogD
("Failedo disconnect from database");

710 
	gSqlCi
::
ExecCommd
(cڡ *
fm
, ...)

712 i(
	gm_ci
 =
NULL
) {

713 
VceLogD
("Cannotxecute command. Not connectedo DB!");

717 i(
	gfm
 =
NULL
) {

718 
VceLogD
("Null query!");

719 
ThrowMsg
(
Exi
::
SyaxE
, "Null statement");

722 *
	gwBufr
;

724 
va_li
 
	ggs
;

725 
va_t
(
gs
, 
fm
);

727 i(
vartf
(&
wBufr
, 
fm
, 
gs
) == -1) {

728 
wBufr
 = 
NULL
;

731 
va_d
(
gs
);

733 
	gd
::
unique_r
<[],
	g_d
> 
bufr
(
wBufr
);

735 i(!
	gbufr
) {

736 
VceLogD
("Failedollocate statement string");

740 
VceLogD
("Executg SQL commd: %s", 
bufr
.
g
());

743 
ScedNifyA
 
nifyA
(
m_synchriziObje
.
g
());

746 *
	grBufr
;

748 
	gt
 = 
sqle3_exec
(
m_ci
,

749 
bufr
.
g
(),

750 
NULL
,

751 
NULL
,

752 &
rBufr
);

754 
	gd
::
rg
 
rMsg
;

757 i(
	grBufr
 !
NULL
) {

758 
rMsg
 = 
rBufr
;

759 
sqle3_
(
rBufr
);

762 i(
	gt
 =
SQLITE_OK
) {

766 i(
	gt
 =
SQLITE_BUSY
) {

767 
VceLogD
("Collision occurred whilexecuting SQL command");

770 i(
	gm_synchriziObje
) {

771 
VceLogD
("Performing synchronization");

772 
	gm_synchriziObje
->
Synchrize
();

780 
VceLogD
("Faedexecu SQL commd. E: %s", 
rMsg
.
c_r
());

781 
ThrowMsg
(
Exi
::
SyaxE
, 
rMsg
);

785 
	gSqlCi
::
DaCommdAutoP
 
SqlCi
::
PDaCommd
(

786 cڡ *
fm
,

789 i(
	gm_ci
 =
NULL
) {

790 
VceLogD
("Cannotxecute data command. Not connectedo DB!");

791  
DaCommdAutoP
();

794 *
	gwBufr
;

796 
va_li
 
	ggs
;

797 
va_t
(
gs
, 
fm
);

799 i(
vartf
(&
wBufr
, 
fm
, 
gs
) == -1) {

800 
wBufr
 = 
NULL
;

803 
va_d
(
gs
);

805 
	gd
::
unique_r
<[],
	g_d
> 
bufr
(
wBufr
);

807 i(!
	gbufr
) {

808 
VceLogD
("Failedollocate statement string");

809  
DaCommdAutoP
();

812 
VceLogD
("Executg SQL dcommd: %s", 
bufr
.
g
());

814  
DaCommdAutoP
(
w
 
DaCommd
(
this
, 
bufr
.
g
()));

817 
	gSqlCi
::
RowID
 
SqlCi
::
GLaInRowID
() const

819  
ic_
<
RowID
>(
sqle3_ϡ__rowid
(
m_ci
));

822 
	gSqlCi
::
TuOnFeignKeys
()

824 
ExecCommd
("PRAGMA foreign_keys = ON;");

827 
	gSqlCi
::
BegTni
()

829 
ExecCommd
("BEGIN;");

832 
	gSqlCi
::
RlbackTni
()

834 
ExecCommd
("ROLLBACK;");

837 
	gSqlCi
::
CommTni
()

839 
ExecCommd
("COMMIT;");

842 
	gSqlCi
::
SynchriziObje
 *

843 
SqlCi
::
AocDeuSynchriziObje
()

845  
w
 
NaiveSynchriziObje
();

848 
	gSqlCi
::
db_ut_ݒ_wh_tis
(cڡ *
pszFePh
, 
sqle3
 **
DB
,

849 
ags
, cڡ *
zVfs
)

851 
	gmode
;

853 if((
	gpszFePh
 =
NULL
|| (
DB
 == NULL)) {

854 
VceLogW
("sqlite3 handleullrror");

855  
	gSQLITE_ERROR
;

858 
	gmode
 = 
R_OK
;

860 if((
geuid
(!0&& (
acss
(
pszFePh
, 
mode
))) {

861 if(
	go
 =
EACCES
) {

862 
VceLogD
("fileccessermissionrror");

863  
	gSQLITE_PERM
;

868 
	grc
 = 
sqle3_ݒ_v2
(
pszFePh
, 
DB
, 
ags
, 
zVfs
);

869 i(
	gSQLITE_OK
 !
rc
) {

870 
VceLogE
("sqle3_ݒ_v2(%d)",
rc
);

871  
	grc
;

876  
	grc
;

880 
	gSqlCi
::
db_ut_o
(
sqle3
 *
pDB
)

882 *
pszEMsg
 = 
NULL
;

885 
	grc
 = 
sqle3_o
(
pDB
);

886 i(
	gSQLITE_OK
 !
rc
) {

887 
VceLogW
("Fachgjou mode: %s\n", 
pszEMsg
);

888 
sqle3_
(
pszEMsg
);

889  
	grc
;

892  
	gSQLITE_OK
;

	@vcore/src/dpl/db/src/thread_database_support.cpp

22 
	~<ddef.h
>

23 
	~<d/db/thad_daba_sut.h
>

	@vcore/src/dpl/log/include/dpl/log/abstract_log_provider.h

22 #ide
DPL_ABSTRACT_LOG_PROVIDER_H


23 
	#DPL_ABSTRACT_LOG_PROVIDER_H


	)

25 
mea
 
	gVceDPL
 {

26 
mea
 
	gLog
 {

27 as
	cAbLogProvid


29 
	gpublic
:

30 
vtu
 ~
AbLogProvid
() {}

32 
vtu
 
Debug
(cڡ *
mesge
,

33 cڡ *
feName
,

34 
le
,

35 cڡ *
funi
) = 0;

36 
vtu
 
Info
(cڡ *
mesge
,

37 cڡ *
feName
,

38 
le
,

39 cڡ *
funi
) = 0;

40 
vtu
 
Wng
(cڡ *
mesge
,

41 cڡ *
feName
,

42 
le
,

43 cڡ *
funi
) = 0;

44 
vtu
 
E
(cڡ *
mesge
,

45 cڡ *
feName
,

46 
le
,

47 cڡ *
funi
) = 0;

48 
vtu
 
Pedtic
(cڡ *
mesge
,

49 cڡ *
feName
,

50 
le
,

51 cڡ *
funi
) = 0;

53 
	geed
:

54 cڡ *
LoSourFeName
(cڡ *
fame
);

	@vcore/src/dpl/log/include/dpl/log/dlog_log_provider.h

22 #ide
DPL_DLOG_LOG_PROVIDER_H


23 
	#DPL_DLOG_LOG_PROVIDER_H


	)

25 
	~<d/log/ab_log_ovid.h
>

26 
	~<d/sced_.h
>

27 
	~<rg
>

29 
mea
 
	gVceDPL
 {

30 
mea
 
	gLog
 {

31 as
	cDLOGLogProvid
 :

32 
public
 
AbLogProvid


34 
ive
:

35 
VceDPL
::
ScedFe
<> 
m_g
;

37 
	gd
::
rg
 
FmMesge
(cڡ *
mesge
,

38 cڡ *
fame
,

39 
le
,

40 cڡ *
funi
);

42 
	gpublic
:

43 
DLOGLogProvid
();

44 
	gvtu
 ~
DLOGLogProvid
();

46 
vtu
 
Debug
(cڡ *
mesge
,

47 cڡ *
feName
,

48 
le
,

49 cڡ *
funi
);

50 
vtu
 
Info
(cڡ *
mesge
,

51 cڡ *
feName
,

52 
le
,

53 cڡ *
funi
);

54 
vtu
 
Wng
(cڡ *
mesge
,

55 cڡ *
feName
,

56 
le
,

57 cڡ *
funi
);

58 
vtu
 
E
(cڡ *
mesge
,

59 cڡ *
feName
,

60 
le
,

61 cڡ *
funi
);

62 
vtu
 
Pedtic
(cڡ *
mesge
,

63 cڡ *
feName
,

64 
le
,

65 cڡ *
funi
);

68 
STag
(cڡ *
g
);

	@vcore/src/dpl/log/include/dpl/log/log.h

22 #ide
DPL_LOG_H


23 
	#DPL_LOG_H


	)

25 
	~<d/sgt.h
>

26 
	~<d/ncyab.h
>

27 
	~<d/log/ab_log_ovid.h
>

28 
	~<d/log/dlog_log_ovid.h
>

29 
	~<d/log/d_y_log_ovid.h
>

30 
	~<sam
>

31 
	~<li
>

33 
mea
 
	gVceDPL
 {

34 
mea
 
	gLog
 {

41 as
	cLogSyem
 :

42 
ive
 
Ncyab


44 
ive
:

45 
d
::
	tli
<
	tAbLogProvid
 *> 
	tAbLogProvidPLi
;

46 
AbLogProvidPLi
 
	gm_ovids
;

48 
DLOGLogProvid
 *
	gm_dlogProvid
;

49 
OldStyLogProvid
 *
	gm_dStyProvid
;

51 
bo
 
	gm_isLogggEbd
;

53 
	gpublic
:

54 
bo
 
IsLogggEbd
() const;

55 
LogSyem
();

56 
	gvtu
 ~
LogSyem
();

61 
Debug
(cڡ *
mesge
,

62 cڡ *
fame
,

63 
le
,

64 cڡ *
funi
);

69 
Info
(cڡ *
mesge
,

70 cڡ *
fame
,

71 
le
,

72 cڡ *
funi
);

77 
Wng
(cڡ *
mesge
,

78 cڡ *
fame
,

79 
le
,

80 cڡ *
funi
);

85 
E
(cڡ *
mesge
,

86 cڡ *
fame
,

87 
le
,

88 cڡ *
funi
);

93 
Pedtic
(cڡ *
mesge
,

94 cڡ *
fame
,

95 
le
,

96 cڡ *
funi
);

101 
STag
(cڡ *
g
);

108 
AddProvid
(
AbLogProvid
 *
ovid
);

113 
RemoveProvid
(
AbLogProvid
 *
ovid
);

119 as
	cNuSm


121 
	gpublic
:

122 
NuSm
() {}

124 
me
 <
tyme
 
T
>

125 
NuSm
& 
ݔ
<<(cڡ 
T
&)

127  *
this
;

134 
	gSgt
<
	tLogSyem
> 
	tLogSyemSgt
;

143 #ifde
DPL_LOGS_ENABLED


144 
	#DPL_MACRO_FOR_LOGGING
(
mesge
, 
funi
) \

147 i(
VceDPL
::
Log
::
LogSyemSgt
::
	`In
().
	`IsLogggEbd
()) \

149 
d
::
orgam
 
fmLog
; \

150 
fmLog
 << 
mesge
; \

151 
VceDPL
::
Log
::
LogSyemSgt
::
	`In
().
	`funi
( \

152 
fmLog
.
	`r
().
	`c_r
(), \

153 
__FILE__
, 
__LINE__
, 
__FUNCTION__
); \

155 } 0)

	)

158 
	#DPL_MACRO_FOR_LOGGING
(
mesge
, 
funi
) \

160 
VceDPL
::
Log
::
NuSm
 
ns
; \

161 
ns
 << 
mesge
; \

162 } 0)

	)

165 
	#LogDebug
(
mesge

	`DPL_MACRO_FOR_LOGGING
(mesge, 
Debug
)

	)

166 
	#LogInfo
(
mesge

	`DPL_MACRO_FOR_LOGGING
(mesge, 
Info
)

	)

167 
	#LogWng
(
mesge

	`DPL_MACRO_FOR_LOGGING
(mesge, 
Wng
)

	)

168 
	#LogE
(
mesge

	`DPL_MACRO_FOR_LOGGING
(mesge, 
E
)

	)

169 
	#LogPedtic
(
mesge

	`DPL_MACRO_FOR_LOGGING
(mesge, 
Pedtic
)

	)

	@vcore/src/dpl/log/include/dpl/log/old_style_log_provider.h

22 #ide
DPL_OLD_STYLE_LOG_PROVIDER_H


23 
	#DPL_OLD_STYLE_LOG_PROVIDER_H


	)

25 
	~<d/log/ab_log_ovid.h
>

26 
	~<rg
>

28 
mea
 
	gVceDPL
 {

29 
mea
 
	gLog
 {

30 as
	cOldStyLogProvid
 :

31 
public
 
AbLogProvid


33 
ive
:

34 
bo
 
m_showDebug
;

35 
bo
 
	gm_showInfo
;

36 
bo
 
	gm_showWng
;

37 
bo
 
	gm_showE
;

38 
bo
 
	gm_showPedtic
;

39 
bo
 
	gm_tStdE
;

41 
	gd
::
rg
 
FmMesge
(cڡ *
mesge
,

42 cڡ *
fame
,

43 
le
,

44 cڡ *
funi
);

46 
	gpublic
:

47 
OldStyLogProvid
(
bo
 
showDebug
,

48 
bo
 
showInfo
,

49 
bo
 
showWng
,

50 
bo
 
showE
,

51 
bo
 
showPedtic
);

52 
OldStyLogProvid
(
bo
 
showDebug
,

53 
bo
 
showInfo
,

54 
bo
 
showWng
,

55 
bo
 
showE
,

56 
bo
 
showPedtic
,

57 
bo
 
tStdE
);

58 
	gvtu
 ~
OldStyLogProvid
() {}

60 
vtu
 
Debug
(cڡ *
mesge
,

61 cڡ *
feName
,

62 
le
,

63 cڡ *
funi
);

64 
vtu
 
Info
(cڡ *
mesge
,

65 cڡ *
feName
,

66 
le
,

67 cڡ *
funi
);

68 
vtu
 
Wng
(cڡ *
mesge
,

69 cڡ *
feName
,

70 
le
,

71 cڡ *
funi
);

72 
vtu
 
E
(cڡ *
mesge
,

73 cڡ *
feName
,

74 
le
,

75 cڡ *
funi
);

76 
vtu
 
Pedtic
(cڡ *
mesge
,

77 cڡ *
feName
,

78 
le
,

79 cڡ *
funi
);

	@vcore/src/dpl/log/include/dpl/log/vcore_log.h

17 #ide
VCORE_LOG_H


18 
	#VCORE_LOG_H


	)

20 #ifde
LOG_TAG


21 #unde
LOG_TAG


23 
	#LOG_TAG
 "CERT_SVC_VCORE"

	)

25 
	~<dlog.h
>

27 
	#COLOR_ERROR
 "\033[38;5;160;1m"

28 
	#COLOR_WARNING
 "\033[38;5;202;1m"

29 
	#COLOR_INFO
 "\033[38;5;243;1m"

30 
	#COLOR_DEBUG
 "\033[38;5;243;0m"

31 
	#COLOR_END
 "\033[0m"

	)

33 
	#INTERNAL_SECURE_LOG
 
__exnsi__
 
SECURE_SLOG


	)

34 
	#VCORE_LOG
(
iܙy
, 
c
, 
fm
, ...) \

36 
	`INTERNAL_SECURE_LOG
(
iܙy
, 
LOG_TAG
, 
c
 
fm
 "%s", 
__VA_ARGS__
); \

37 } 0)

	)

43 
	#VceLogD
(...
	`VCORE_LOG
(
LOG_DEBUG
, 
COLOR_DEBUG
, 
__VA_ARGS__
, 
COLOR_END
)

	)

44 
	#VceLogI
(...
	`VCORE_LOG
(
LOG_INFO
, 
COLOR_INFO
, 
__VA_ARGS__
, 
COLOR_END
)

	)

45 
	#VceLogW
(...
	`VCORE_LOG
(
LOG_WARN
, 
COLOR_WARNING
, 
__VA_ARGS__
, 
COLOR_END
)

	)

46 
	#VceLogE
(...
	`VCORE_LOG
(
LOG_ERROR
, 
COLOR_ERROR
, 
__VA_ARGS__
, 
COLOR_END
)

	)

	@vcore/src/dpl/log/include/dpl/log/wrt_log.h

17 #ide
VCORE_WRT_LOG_H


18 
	#VCORE_WRT_LOG_H


	)

20 #ifde
LOG_TAG


21 #unde
LOG_TAG


23 
	#LOG_TAG
 "CERT_SVC_VCORE"

	)

25 
	~<dlog.h
>

27 
	#COLOR_ERROR
 "\033[38;5;160;1m"

28 
	#COLOR_WARNING
 "\033[38;5;202;1m"

29 
	#COLOR_INFO
 "\033[38;5;243;1m"

30 
	#COLOR_DEBUG
 "\033[38;5;243;0m"

31 
	#COLOR_END
 "\033[0m"

	)

33 
	#INTERNAL_SECURE_LOG
 
__exnsi__
 
SECURE_SLOG


	)

34 
	#WRT_LOG
(
iܙy
, 
c
, 
fm
, ...) \

36 
	`INTERNAL_SECURE_LOG
(
iܙy
, 
LOG_TAG
, 
c
 
fm
 "%s", 
__VA_ARGS__
); \

37 } 0)

	)

43 
	#WLogD
(...
	`WRT_LOG
(
LOG_DEBUG
, 
COLOR_DEBUG
, 
__VA_ARGS__
, 
COLOR_END
)

	)

44 
	#WLogI
(...
	`WRT_LOG
(
LOG_INFO
, 
COLOR_INFO
, 
__VA_ARGS__
, 
COLOR_END
)

	)

45 
	#WLogW
(...
	`WRT_LOG
(
LOG_WARN
, 
COLOR_WARNING
, 
__VA_ARGS__
, 
COLOR_END
)

	)

46 
	#WLogE
(...
	`WRT_LOG
(
LOG_ERROR
, 
COLOR_ERROR
, 
__VA_ARGS__
, 
COLOR_END
)

	)

	@vcore/src/dpl/log/src/abstract_log_provider.cpp

22 
	~<ddef.h
>

23 
	~<d/log/ab_log_ovid.h
>

24 
	~<crg
>

26 
mea
 
	gVceDPL
 {

27 
mea
 
	gLog
 {

28 cڡ *
	gAbLogProvid
::
LoSourFeName
(cڡ *
fame
)

30 cڡ *
r
 = 
chr
(
fame
, '/');

31  
	gr
 !
NULL
 ? 
r
 + 1 : 
fame
;

	@vcore/src/dpl/log/src/dlog_log_provider.cpp

22 
	~<ddef.h
>

23 
	~<d/log/dlog_log_ovid.h
>

24 
	~<crg
>

25 
	~<sam
>

26 
	~<dlog.h
>

28 #ifde
SECURE_LOG


29 
	#INTERNAL_DLP_LOG_
 
SECURE_LOG


	)

31 
	#INTERNAL_DLP_LOG_
 
LOG


	)

39 
	#INTERNAL_DLP_LOG
 
__exnsi__
 
INTERNAL_DLP_LOG_


	)

41 
mea
 
	gVceDPL
 {

42 
mea
 
	gLog
 {

43 
	gd
::
rg
 
DLOGLogProvid
::
FmMesge
(cڡ *
mesge
,

44 cڡ *
fame
,

45 
le
,

46 cڡ *
funi
)

48 
	gd
::
orgam
 
v
;

50 
	gv
 << 
	gd
::
rg
("[") <<

51 
LoSourFeName
(
fame
<< 
d
::
rg
(":"<< 
le
 <<

52 
d
::
rg
("] "<< 
funi
 << std::rg("(): "<< 
mesge
;

54  
	gv
.
r
();

57 
	gDLOGLogProvid
::
DLOGLogProvid
()

60 
DLOGLogProvid
::~DLOGLogProvider()

63 
DLOGLogProvid
::
STag
(cڡ *
g
)

65 
m_g
.
Ret
(
rdup
(
g
));

68 
	gDLOGLogProvid
::
Debug
(cڡ *
mesge
,

69 cڡ *
fame
,

70 
le
,

71 cڡ *
funi
)

73 
INTERNAL_DLP_LOG
(
LOG_DEBUG
, 
m_g
.
G
(), "%s",

74 
FmMesge
(
mesge
, 
fame
, 
le
, 
funi
).
c_r
());

77 
	gDLOGLogProvid
::
Info
(cڡ *
mesge
,

78 cڡ *
fame
,

79 
le
,

80 cڡ *
funi
)

82 
INTERNAL_DLP_LOG
(
LOG_INFO
, 
m_g
.
G
(), "%s",

83 
FmMesge
(
mesge
, 
fame
, 
le
, 
funi
).
c_r
());

86 
	gDLOGLogProvid
::
Wng
(cڡ *
mesge
,

87 cڡ *
fame
,

88 
le
,

89 cڡ *
funi
)

91 
INTERNAL_DLP_LOG
(
LOG_WARN
, 
m_g
.
G
(), "%s",

92 
FmMesge
(
mesge
, 
fame
, 
le
, 
funi
).
c_r
());

95 
	gDLOGLogProvid
::
E
(cڡ *
mesge
,

96 cڡ *
fame
,

97 
le
,

98 cڡ *
funi
)

100 
INTERNAL_DLP_LOG
(
LOG_ERROR
, 
m_g
.
G
(), "%s",

101 
FmMesge
(
mesge
, 
fame
, 
le
, 
funi
).
c_r
());

104 
	gDLOGLogProvid
::
Pedtic
(cڡ *
mesge
,

105 cڡ *
fame
,

106 
le
,

107 cڡ *
funi
)

109 
INTERNAL_DLP_LOG
(
LOG_DEBUG
, "DPL", "%s",

110 
FmMesge
(
mesge
, 
fame
, 
le
, 
funi
).
c_r
());

115 #unde
INTERNAL_DLP_LOG


116 #unde
INTERNAL_DLP_LOG_


	@vcore/src/dpl/log/src/log.cpp

22 
	~<ddef.h
>

23 
	~<d/log/log.h
>

24 
	~<d/sgt_im.h
>

26 
	$IMPLEMENT_SINGLETON
(
VceDPL
::
Log
::
LogSyem
)

28 
mea
 
VceDPL
 {

29 
mea
 
Log
 {

30 
mea


32 cڡ *
OLD_STYLE_LOGS_ENV_NAME
 = "DPL_USE_OLD_STYLE_LOGS";

33 cڡ *
OLD_STYLE_PEDANTIC_LOGS_ENV_NAME
 =

35 cڡ *
OLD_STYLE_LOGS_MASK_ENV_NAME
 = "DPL_USE_OLD_STYLE_LOGS_MASK";

36 cڡ *
DPL_LOG_OFF
 = "DPL_LOG_OFF";

39 
bo
 
LogSyem
::
	`IsLogggEbd
() const

41  
m_isLogggEbd
;

44 
LogSyem
::
	`LogSyem
() :

45 
	`m_dlogProvid
(
NULL
),

46 
	`m_dStyProvid
(
NULL
),

47 
	`m_isLogggEbd
(!
	`gv
(
DPL_LOG_OFF
))

49 
bo
 
dStyLogs
 = 
l
;

50 
bo
 
dStyDebugLogs
 = 
ue
;

51 
bo
 
dStyInfoLogs
 = 
ue
;

52 
bo
 
dStyWngLogs
 = 
ue
;

53 
bo
 
dStyELogs
 = 
ue
;

54 
bo
 
dStyPedticLogs
 = 
l
;

57 cڡ *
vue
 = 
	`gv
(
OLD_STYLE_LOGS_ENV_NAME
);

59 i(
vue
 !
NULL
 && !
	`rcmp
(value, "1")) {

60 
dStyLogs
 = 
ue
;

63 
vue
 = 
	`gv
(
OLD_STYLE_PEDANTIC_LOGS_ENV_NAME
);

65 i(
vue
 !
NULL
 && !
	`rcmp
(value, "1")) {

66 
dStyPedticLogs
 = 
ue
;

69 
vue
 = 
	`gv
(
OLD_STYLE_LOGS_MASK_ENV_NAME
);

71 i(
vue
 !
NULL
) {

72 
size_t
 
n
 = 
	`
(
vue
);

74 i(
n
 >= 1) {

75 i(
vue
[0] == '0') {

76 
dStyDebugLogs
 = 
l
;

77 } i(
vue
[0] == '1') {

78 
dStyDebugLogs
 = 
ue
;

82 i(
n
 >= 2) {

83 i(
vue
[1] == '0') {

84 
dStyInfoLogs
 = 
l
;

85 } i(
vue
[1] == '1') {

86 
dStyInfoLogs
 = 
ue
;

90 i(
n
 >= 3) {

91 i(
vue
[2] == '0') {

92 
dStyWngLogs
 = 
l
;

93 } i(
vue
[2] == '1') {

94 
dStyWngLogs
 = 
ue
;

98 i(
n
 >= 4) {

99 i(
vue
[3] == '0') {

100 
dStyELogs
 = 
l
;

101 } i(
vue
[3] == '1') {

102 
dStyELogs
 = 
ue
;

108 i(
dStyLogs
) {

110 
m_dStyProvid
 = 
w
 
	`OldStyLogProvid
(
dStyDebugLogs
,

111 
dStyInfoLogs
,

112 
dStyWngLogs
,

113 
dStyELogs
,

114 
dStyPedticLogs
);

115 
	`AddProvid
(
m_dStyProvid
);

118 
m_dlogProvid
 = 
w
 
	`DLOGLogProvid
();

119 
	`AddProvid
(
m_dlogProvid
);

123 
LogSyem
::~
	`LogSyem
()

126 
AbLogProvidPLi
::

 it = 
m_ovids
.
	`beg
();

127 

 !
m_ovids
.
	`d
();

128 ++

)

130 
de
 *

;

133 
m_ovids
.
	`r
();

136 
m_dlogProvid
 = 
NULL
;

137 
m_dStyProvid
 = 
NULL
;

140 
LogSyem
::
	`STag
(cڡ * 
g
)

142 i(
m_dlogProvid
 !
NULL
) {

143 
m_dlogProvid
->
	`STag
(
g
);

147 
LogSyem
::
	`AddProvid
(
AbLogProvid
 *
ovid
)

149 
m_ovids
.
	`push_back
(
ovid
);

152 
LogSyem
::
	`RemoveProvid
(
AbLogProvid
 *
ovid
)

154 
m_ovids
.
	`move
(
ovid
);

157 
LogSyem
::
	`Debug
(cڡ *
mesge
,

158 cڡ *
fame
,

159 
le
,

160 cڡ *
funi
)

162 
AbLogProvidPLi
::

 it = 
m_ovids
.
	`beg
();

163 

 !
m_ovids
.
	`d
();

164 ++

)

166 (*

)->
	`Debug
(
mesge
, 
fame
, 
le
, 
funi
);

170 
LogSyem
::
	`Info
(cڡ *
mesge
,

171 cڡ *
fame
,

172 
le
,

173 cڡ *
funi
)

175 
AbLogProvidPLi
::

 it = 
m_ovids
.
	`beg
();

176 

 !
m_ovids
.
	`d
();

177 ++

)

179 (*

)->
	`Info
(
mesge
, 
fame
, 
le
, 
funi
);

183 
LogSyem
::
	`Wng
(cڡ *
mesge
,

184 cڡ *
fame
,

185 
le
,

186 cڡ *
funi
)

188 
AbLogProvidPLi
::

 it = 
m_ovids
.
	`beg
();

189 

 !
m_ovids
.
	`d
();

190 ++

)

192 (*

)->
	`Wng
(
mesge
, 
fame
, 
le
, 
funi
);

196 
LogSyem
::
	`E
(cڡ *
mesge
,

197 cڡ *
fame
,

198 
le
,

199 cڡ *
funi
)

201 
AbLogProvidPLi
::

 it = 
m_ovids
.
	`beg
();

202 

 !
m_ovids
.
	`d
();

203 ++

)

205 (*

)->
	`E
(
mesge
, 
fame
, 
le
, 
funi
);

209 
LogSyem
::
	`Pedtic
(cڡ *
mesge
,

210 cڡ *
fame
,

211 
le
,

212 cڡ *
funi
)

214 
AbLogProvidPLi
::

 it = 
m_ovids
.
	`beg
();

215 

 !
m_ovids
.
	`d
();

216 ++

)

218 (*

)->
	`Pedtic
(
mesge
, 
fame
, 
le
, 
funi
);

222 
	}
}

	@vcore/src/dpl/log/src/old_style_log_provider.cpp

22 
	~<ddef.h
>

23 
	~<d/log/d_y_log_ovid.h
>

24 
	~<d/cs.h
>

25 
	~<cdio
>

26 
	~<crg
>

27 
	~<sam
>

28 
	~<sys/time.h
>

29 
	~<unid.h
>

31 
mea
 
	gVceDPL
 {

32 
mea
 
	gLog
 {

33 
	gmea


35 
usg
 
mea
 
	gVceDPL
::
Cs
::
Text
;

36 cڡ *
	gDEBUG_BEGIN
 = 
GREEN_BEGIN
;

37 cڡ *
	gDEBUG_END
 = 
GREEN_END
;

38 cڡ *
	gINFO_BEGIN
 = 
CYAN_BEGIN
;

39 cڡ *
	gINFO_END
 = 
CYAN_END
;

40 cڡ *
	gERROR_BEGIN
 = 
RED_BEGIN
;

41 cڡ *
	gERROR_END
 = 
RED_END
;

42 cڡ *
	gWARNING_BEGIN
 = 
BOLD_GOLD_BEGIN
;

43 cڡ *
	gWARNING_END
 = 
BOLD_GOLD_END
;

44 cڡ *
	gPEDANTIC_BEGIN
 = 
PURPLE_BEGIN
;

45 cڡ *
	gPEDANTIC_END
 = 
PURPLE_END
;

47 
	gd
::
rg
 
GFmdTime
()

49 
timev
 
tv
;

50 
tm
 
	glolNowTime
;

52 
gtimeofday
(&
tv
, 
NULL
);

53 
loime_r
(&
tv
.
tv_c
, &
lolNowTime
);

55 
	gfm
[64];

56 
tf
(
fm
,

57 (
fm
),

59 
lolNowTime
.
tm_hour
,

60 
lolNowTime
.
tm_m
,

61 
lolNowTime
.
tm_c
,

62 
ic_
<>(
tv
.
tv_uc
 / 1000));

63  
	gfm
;

67 
	gd
::
rg
 
OldStyLogProvid
::
FmMesge
(cڡ *
mesge
,

68 cڡ *
fame
,

69 
le
,

70 cڡ *
funi
)

72 
	gd
::
orgam
 
v
;

74 
	gv
 << 
	gd
::
rg
("["<< 
GFmdTime
(<< 
d
::string("] [") <<

75 
ic_
<>(
had_lf
()) << "/" <<

76 
ic_
<>(
gpid
()<< 
d
::
rg
("] [") <<

77 
LoSourFeName
(
fame
<< 
d
::
rg
(":"<< 
le
 <<

78 
d
::
rg
("] "<< 
funi
 << std::rg("(): "<< 
mesge
;

80  
	gv
.
r
();

83 
	gOldStyLogProvid
::
OldStyLogProvid
(
bo
 
showDebug
,

84 
bo
 
showInfo
,

85 
bo
 
showWng
,

86 
bo
 
showE
,

87 
bo
 
showPedtic
) :

88 
m_showDebug
(
showDebug
),

89 
m_showInfo
(
showInfo
),

90 
m_showWng
(
showWng
),

91 
m_showE
(
showE
),

92 
m_showPedtic
(
showPedtic
),

93 
m_tStdE
(
l
)

96 
	gOldStyLogProvid
::
OldStyLogProvid
(
bo
 
showDebug
,

97 
bo
 
showInfo
,

98 
bo
 
showWng
,

99 
bo
 
showE
,

100 
bo
 
showPedtic
,

101 
bo
 
tStdE
) :

102 
m_showDebug
(
showDebug
),

103 
m_showInfo
(
showInfo
),

104 
m_showWng
(
showWng
),

105 
m_showE
(
showE
),

106 
m_showPedtic
(
showPedtic
),

107 
m_tStdE
(
tStdE
)

110 
	gOldStyLogProvid
::
Debug
(cڡ *
mesge
,

111 cڡ *
fame
,

112 
le
,

113 cڡ *
funi
)

115 i(
	gm_showDebug
) {

116 i(
	gm_tStdE
) {

117 
rtf
(
dr
, "%s%s%s\n", 
DEBUG_BEGIN
,

118 
FmMesge
(
mesge
, 
fame
, 
le
,

119 
funi
).
c_r
(), 
DEBUG_END
);

121 
rtf
(
dout
, "%s%s%s\n", 
DEBUG_BEGIN
,

122 
FmMesge
(
mesge
, 
fame
, 
le
,

123 
funi
).
c_r
(), 
DEBUG_END
);

128 
	gOldStyLogProvid
::
Info
(cڡ *
mesge
,

129 cڡ *
fame
,

130 
le
,

131 cڡ *
funi
)

133 i(
	gm_showInfo
) {

134 i(
	gm_tStdE
) {

135 
rtf
(
dr
, "%s%s%s\n", 
INFO_BEGIN
,

136 
FmMesge
(
mesge
, 
fame
, 
le
,

137 
funi
).
c_r
(), 
INFO_END
);

139 
rtf
(
dout
, "%s%s%s\n", 
INFO_BEGIN
,

140 
FmMesge
(
mesge
, 
fame
, 
le
,

141 
funi
).
c_r
(), 
INFO_END
);

146 
	gOldStyLogProvid
::
Wng
(cڡ *
mesge
,

147 cڡ *
fame
,

148 
le
,

149 cڡ *
funi
)

151 i(
	gm_showWng
) {

152 i(
	gm_tStdE
) {

153 
rtf
(
dr
, "%s%s%s\n", 
WARNING_BEGIN
,

154 
FmMesge
(
mesge
, 
fame
, 
le
,

155 
funi
).
c_r
(), 
WARNING_END
);

157 
rtf
(
dout
, "%s%s%s\n", 
WARNING_BEGIN
,

158 
FmMesge
(
mesge
, 
fame
, 
le
,

159 
funi
).
c_r
(), 
WARNING_END
);

164 
	gOldStyLogProvid
::
E
(cڡ *
mesge
,

165 cڡ *
fame
,

166 
le
,

167 cڡ *
funi
)

169 i(
	gm_showE
) {

170 i(
	gm_tStdE
) {

171 
rtf
(
dr
, "%s%s%s\n", 
ERROR_BEGIN
,

172 
FmMesge
(
mesge
, 
fame
, 
le
,

173 
funi
).
c_r
(), 
ERROR_END
);

175 
rtf
(
dout
, "%s%s%s\n", 
ERROR_BEGIN
,

176 
FmMesge
(
mesge
, 
fame
, 
le
,

177 
funi
).
c_r
(), 
ERROR_END
);

182 
	gOldStyLogProvid
::
Pedtic
(cڡ *
mesge
,

183 cڡ *
fame
,

184 
le
,

185 cڡ *
funi
)

187 i(
	gm_showPedtic
) {

188 i(
	gm_tStdE
) {

189 
rtf
(
dr
, "%s%s%s\n", 
PEDANTIC_BEGIN
,

190 
FmMesge
(
mesge
, 
fame
, 
le
,

191 
funi
).
c_r
(), 
PEDANTIC_END
);

193 
rtf
(
dout
, "%s%s%s\n", 
PEDANTIC_BEGIN
,

194 
FmMesge
(
mesge
, 
fame
, 
le
,

195 
funi
).
c_r
(), 
PEDANTIC_END
);

	@vcore/src/dpl/test/include/dpl/test/abstract_input_parser.h

22 #ide
ABSTRACT_INPUT_PARSER_H


23 
	#ABSTRACT_INPUT_PARSER_H


	)

25 
	~<d/exi.h
>

27 
	~<memy
>

29 
mea
 
	gVceDPL
 {

35 
	gme
<
ass
 
	gResu
, cs
	gTok
> cs
	cAbIutPr


37 
	gpublic
:

38 as
	cExi


40 
public
:

41 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

42 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
PrE
)

45 
Resu
 
	tResuTy
;

46 
Tok
 
	tTokTy
;

48 
	gvtu
 ~
AbIutPr
() {}

50 
vtu
 
CsumeTok
(
d
::
unique_r
<
Tok
> && 
tok
) = 0;

51 
vtu
 
bo
 
IsSVid
() = 0;

52 
vtu
 
Resu
 
GResu
() const = 0;

	@vcore/src/dpl/test/include/dpl/test/abstract_input_reader.h

32 #ide
ABSTRACT_INPUT_READER_H


33 
	#ABSTRACT_INPUT_READER_H


	)

35 
	~<memy
>

37 
	~<d//ab_put_tokiz.h
>

38 
	~<d//ab_put_rr.h
>

39 
	~<d/ab_put.h
>

41 
mea
 
	gVceDPL
 {

52 
	gme
<
ass
 
	gResuT
, cs
	gTokT
> cs
	cAbIutRd


54 
	gpublic
:

55 
ResuT
 
	tTokTy
;

56 
TokT
 
	tResuTy
;

57 
	gAbIutPr
<
	tResuT
, 
	tTokT
> 
	tPrBa
;

58 
	gAbIutTokiz
<
	tTokT
> 
	tTokizBa
;

60 as
	cExi


62 
	gpublic
:

63 
tyme
 
	tTokizBa
::
	tExi
::
	tTokizE
 TokenizerError;

64 
tyme
 
	tPrBa
::
	tExi
::
	tPrE
 ParserError;

67 
AbIutRd
(
d
::
shed_r
<
AbIut
> 

,

68 
d
::
unique_r
<
PrBa
> && 
rr
,

69 
d
::
unique_r
<
TokizBa
> && 
tokiz
)

70 : 
m_rr
(
d
::
move
(
rr
)), 
m_tokiz
(d::move(
tokiz
))

72 
m_tokiz
->
Ret
(

);

75 
	gvtu
 ~
AbIutRd
() {}

77 
ResuT
 
RdIut
()

79 
tyme
 
	tExi
::
	tTokizE
 TokenizerError;

80 
tyme
 
	tExi
::
	tPrE
 ParserError;

82 
	gue
)

84 
	gd
::
unique_r
<
TokT
> 
tok
 = 
m_tokiz
->
GNextTok
();

85 if(!
	gtok
)

87 if(!
	gm_tokiz
->
IsSVid
())

89 
ThrowMsg
(
TokizE
, "Tokenizerrror");

91 if(!
	gm_rr
->
IsSVid
())

93 
ThrowMsg
(
PrE
, "Parserrror");

96  
	gm_rr
->
GResu
();

98 
	gm_rr
->
CsumeTok
(
d
::
move
(
tok
));

102 
	geed
:

103 
d
::
unique_r
<
PrBa
> 
m_rr
;

104 
	gd
::
unique_r
<
TokizBa
> 
m_tokiz
;

	@vcore/src/dpl/test/include/dpl/test/abstract_input_tokenizer.h

22 #ide
ABSTRACT_INPUT_TOKENIZER_H


23 
	#ABSTRACT_INPUT_TOKENIZER_H


	)

25 
	~<memy
>

26 
	~<rg
>

28 
	~<d/ab_put.h
>

29 
	~<d/exi.h
>

31 
mea
 
	gVceDPL
 {

40 
	gme
<
ass
 
	gTok
> cs
	cAbIutTokiz


42 
	gpublic
:

43 as
	cExi


45 
public
:

46 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

47 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
TokizE
)

50 
Tok
 
	tTokTy
;

52 
AbIutTokiz
() {}

53 
	gvtu
 ~
AbIutTokiz
() {}

59 
vtu
 
Ret
(
d
::
shed_r
<
AbIut
> 
w
)

61 
m_put
 = 
w
;

76 
vtu
 
	gd
::
unique_r
<
Tok
> 
GNextTok
() = 0;

77 
vtu
 
bo
 
IsSVid
() = 0;

79 
	geed
:

80 
d
::
shed_r
<
AbIut
> 
m_put
;

	@vcore/src/dpl/test/include/dpl/test/process_pipe.h

22 #ide
PROCESS_PIPE_H


23 
	#PROCESS_PIPE_H


	)

25 
	~<d/fe_put.h
>

26 
	~<d/exi.h
>

28 
	~<cdio
>

30 
mea
 
	gVceDPL
 {

32 as
	cProssPe
 : 
public
 
FeIut


34 
public
:

35 as
	cExi


37 
public
:

38 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

39 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
DoubOn
)

42 as
	cPeEPicy


44 
	gNONE
,

45 
	gOFF
,

46 
	gPIPE


49 
exic
 
ProssPe
(
PeEPicy
 
r
 = PeEPicy::
NONE
);

50 
	gvtu
 ~
ProssPe
();

52 
On
(cڡ 
d
::
rg
 &
commd
);

53 
Clo
();

55 
	give
:

56 
FILE
 * 
m_fe
;

57 
PeEPicy
 
	gm_rPicy
;

	@vcore/src/dpl/test/include/dpl/test/test_results_collector.h

23 #ide
DPL_TEST_RESULTS_COLLECTOR_H


24 
	#DPL_TEST_RESULTS_COLLECTOR_H


	)

26 
	~<d/ncyab.h
>

27 
	~<d/avaaby.h
>

28 
	~<ve
>

29 
	~<li
>

30 
	~<m
>

31 
	~<rg
>

32 
	~<memy
>

34 
mea
 
	gVceDPL
 {

35 
mea
 
	gTe
 {

36 
ass
 
	gTeResusCBa
;

37 
	gd
::
	tshed_r
<
	tTeResusCBa
>

38 
	tTeResusCBaP
;

40 as
	cTeResusCBa
 :

41 
ive
 
VceDPL
::
Ncyab


43 
public
:

44 
TeResusCBa
* (*
	tCCڡruFunc
)();

45 
	gd
::
	tli
<
	td
::
	trg
> 
	tTeCaIdLi
;

46 
	sFaStus


48 
	eTy


50 
	gNONE
,

51 
	gFAILED
,

52 
	gIGNORED
,

53 
	gINTERNAL


57 
	gvtu
 ~
TeResusCBa
() {}

59 
vtu
 
bo
 
Cfigu
()

61  
	gue
;

63 
vtu
 
S
(
cou
{ 
DPL_UNUSED_PARAM
(count); }

64 
vtu
 
Fish
() { }

65 
vtu
 
CCutTeGroupName
(cڡ 
d
::
rg
& )

68 
vtu
 
CTesCasLi
(cڡ 
TeCaIdLi
& ) {}

69 
vtu
 
CResu
(cڡ 
d
::
rg
& 
id
,

70 cڡ 
d
::
rg
& 
desti
,

71 cڡ 
FaStus
::
Ty
 
us
 = FaStus::
NONE
,

72 cڡ 
d
::
rg
& 
as
 = "") = 0;

73 
vtu
 
	gd
::
rg
 
CScificHp
() const

77 
vtu
 
bo
 
PCScificArg
 (cڡ 
d
::
rg
& )

79  
l
;

82 
TeResusCBa
* 
Ce
(cڡ 
d
::
rg
& 
me
);

83 
RegiCCڡru
(

84 cڡ 
d
::
rg
& 
me
,

85 
CCڡruFunc


86 
cڡru
);

87 
	gd
::
ve
<
d
::
rg
> 
GCsNames
();

89 
	give
:

90 
d
::
	tm
<
	td
::
	trg
, 
	tCCڡruFunc
> 
	tCڡrusM
;

91 
CڡrusM
 
	gm_cڡrusM
;

	@vcore/src/dpl/test/include/dpl/test/test_runner.h

23 #ide
DPL_TEST_RUNNER_H


24 
	#DPL_TEST_RUNNER_H


	)

26 
	~<d/sgt.h
>

27 
	~<d/avaaby.h
>

28 
	~<d//_sus_c.h
>

30 
	~<omic
>

31 
	~<sam
>

32 
	~<rg
>

33 
	~<ve
>

34 
	~<li
>

35 
	~<t
>

36 
	~<m
>

38 
mea
 
	gVceDPL
 {

39 
mea
 
	gTe
 {

40 as
	cTeRu


42 
	gd
::
	tm
<
	td
::
	trg
, 
	tTeResusCBaP
>

43 
	tTeResusCs
;

44 
TeResusCs
 
	gm_cs
;

46 
	gd
::
rg
 
m_tTeId
;

47 
bo
 
	gm_runIgned
;

49 
	gpublic
:

50 
TeRu
()

51 : 
m_runIgned
(
l
)

52 , 
m_lowChdLogs
(
l
)

53 , 
m_rme
(
l
)

54 , 
m_tٮAsis
(0)

57 (*
	gTeCa
)();

59 
	give
:

60 
	sTeCaSu


62 
d
::
rg
 
me
;

63 
TeCa
 
	goc
;

65 
bo
 
	gݔ
 <(cڡ 
	gTeCaSu
 &
	gh
) const

67  
	gme
 < 
	gh
.name;

70 
bo
 
	gݔ
 ==(cڡ 
TeCaSu
 &
h
) const

72  
me
 =
h
.name;

75 
TeCaSu
(cڡ 
d
::
rg
 &
n
, 
TeCa
 
p
) :

76 
me
(
n
),

77 
oc
(
p
)

81 
	gd
::
	tli
<
	tTeCaSu
> 
	tTeCaSuLi
;

82 
	gd
::
	tm
<
	td
::
	trg
, 
	tTeCaSuLi
> 
	tTeCaGroupM
;

83 
TeCaGroupM
 
	gm_Groups
;

85 
	gd
::
	tt
<
	td
::
	trg
> 
	tSeedTeNameS
;

86 
SeedTeNameS
 
	gm_edTeNamesS
;

87 
	gd
::
	tt
<
	td
::
	trg
> 
	tSeedTeGroupS
;

88 
SeedTeGroupS
 
	gm_edTeGroupS
;

89 
	gd
::
rg
 
m_cutGroup
;

94 
bo
 
	gm_lowChdLogs
;

95 
bo
 
	gm_rme
;

97 
	gd
::
omic
<> 
m_tٮAsis
;

99 
Br
();

100 
InvidArgs
(cڡ 
d
::
rg
& 
mesge
 = "Invalidrguments!");

101 
Uge
();

103 
bo
 
frGroupsByXmls
(cڡ 
d
::
ve
<d::
rg
> & 
fes
);

104 
bo
 
frByXML
(
d
::
m
<d::
rg
, bo> & 
sM
);

105 
nmizeXMLTag
(
d
::
rg
& 
r
, cڡ std::rg& 

);

107 
	eStus
 { 
	gFAILED
, 
	gIGNORED
, 
	gPASS
 };

109 
Stus
 
RunTeCa
(cڡ 
TeCaSu
& 
Ca
);

111 
RunTes
();

113 
CResu
(cڡ 
d
::
rg
& 
id
,

114 cڡ 
d
::
rg
& 
desti
,

115 cڡ 
TeResusCBa
::
FaStus
::
Ty
 
us


116 
TeResusCBa
::
FaStus
::
NONE
,

117 cڡ 
d
::
rg
& 
as
 = std::string());

119 
	gpublic
:

120 as
	cTeFaed


122 
ive
:

123 
d
::
rg
 
m_mesge
;

125 
	gpublic
:

126 
TeFaed
()

135 
TeFaed
(cڡ * 
aTe
,

136 cڡ * 
aFe
,

137 
aLe
,

138 cڡ 
d
::
rg
 &
aMesge
);

140 
TeFaed
(cڡ 
d
::
rg
 &
mesge
);

142 
	gd
::
rg
 
GMesge
() const

144  
m_mesge
;

148 as
	cIgned


150 
	give
:

151 
d
::
rg
 
m_mesge
;

153 
	gpublic
:

154 
Igned
()

157 
Igned
(cڡ 
d
::
rg
 &
mesge
) :

158 
m_mesge
(
mesge
)

161 
d
::
rg
 
GMesge
() const

163  
m_mesge
;

167 
MkAsi
();

169 
RegiTe
(cڡ *
Name
, 
TeCa
 
oc
);

170 
InGroup
(cڡ * 
me
);

172 
ExecTeRu
(
gc
, *
gv
[]);

173 
	gd
::
	tve
<
	td
::
	trg
> 
	tArgsLi
;

174 
ExecTeRu
(cڡ 
ArgsLi
& 
gs
);

175 
bo
 
gRunIgned
() const;

177 
Tme
();

178 
bo
 
GAowChdLogs
();

181 
	gVceDPL
::
	tSgt
<
	tTeRu
> 
	tTeRuSgt
;

185 
	#RUNNER_TEST_GROUP_INIT
(
GroupName
) \

186 
Stic
##
GroupName
##
	`In
() \

188 
VceDPL
::
Te
::
TeRuSgt
::
	`In
().
	`InGroup
(#GroupName); \

191 cڡ 
DPL_UNUSED
 
Stic
##
GroupName
##
InV
 = \

192 
Stic
##
GroupName
##
	`In
();

	)

194 
	#RUNNER_TEST
(
Proc
) \

195 
	`Proc
(); \

196 
Stic
##
Proc
##
	`In
() \

198 
VceDPL
::
Te
::
TeRuSgt
::
	`In
().
	`RegiTe
(#Proc, &
Proc
);\

201 cڡ 
DPL_UNUSED
 
Stic
##
Proc
##
InV
 = Stic##Proc##
	`In
(); \

202 
	`Proc
()

	)

204 
	#RUNNER_ASSERT_MSG
(

, 
mesge
) \

207 
VceDPL
::
Te
::
TeRuSgt
::
	`In
().
	`MkAsi
(); \

209 i(!(

)) \

211 
d
::
orgam
 
asMsg
; \

212 
asMsg
 << 
mesge
; \

213 
throw
 
VceDPL
::
Te
::
TeRu
::
	`TeFaed
(#test, \

214 
__FILE__
, \

215 
__LINE__
, \

216 
asMsg
.
	`r
()); \

218 } 0)

	)

220 
	#RUNNER_ASSERT
(


	`RUNNER_ASSERT_MSG
e, "")

	)

222 
	#RUNNER_FAIL
 
	`RUNNER_ASSERT
(
l
)

	)

224 
	#RUNNER_IGNORED_MSG
(
mesge
) \

226 
d
::
orgam
 
asMsg
; \

227 
asMsg
 << 
mesge
; \

228 
throw
 
VceDPL
::
Te
::
TeRu
::
	`Igned

asMsg
.
	`r
() ); \

229 } 0)

	)

	@vcore/src/dpl/test/include/dpl/test/test_runner_child.h

22 #ide
DPL_TEST_RUNNER_CHILD_H


23 
	#DPL_TEST_RUNNER_CHILD_H


	)

25 
	~<d//_ru.h
>

27 
mea
 
	gVceDPL
 {

28 
mea
 
	gTe
 {

30 as
	cPeW
 : 
VceDPL
::
Ncyab


32 
public
:

33 
	eUge
 {

34 
READONLY
,

35 
	gWRITEONLY


38 
	eStus
 {

39 
	gSUCCESS
,

40 
	gTIMEOUT
,

41 
	gERROR


44 
PeW
();

46 
bo
 
isRdy
();

48 
tUge
(
Uge
 
uge
);

50 
	gvtu
 ~
PeW
();

52 
Stus
 
nd
(
code
, 
d
::
rg
 &
mesge
);

54 
Stus
 
ive
(&
code
, 
d
::
rg
 &
da
, 
time_t
 
ddle
);

56 
oA
();

58 
	geed
:

60 
d
::
rg
 
toBySg
(
da
);

62 
oHp
(
desc
);

64 
Stus
 
wreHp
(cڡ *
bufr
, 
size
);

66 
Stus
 
adHp
(*
buf
, 
size
, 
time_t
 
ddle
);

68 cڡ 
	gPIPE_CLOSED
 = -1;

70 
	gm_pefd
[2];

73 
RunChdProc
(
TeRu
::
TeCa
 
ocChd
);

77 
	#RUNNER_CHILD_TEST
(
Proc
) \

78 
	`Proc
(); \

79 
Proc
##
	`Chd
(); \

80 
Stic
##
Proc
##
	`In
() \

82 
VceDPL
::
Te
::
TeRuSgt
::
	`In
().
	`RegiTe
(#Proc, &
Proc
); \

85 cڡ 
DPL_UNUSED
 
Stic
##
Proc
##
InV
 = Stic##Proc##
	`In
(); \

86 
	`Proc
(){ \

87 
VceDPL
::
Te
::
	`RunChdProc
(&
Proc
##
Chd
); \

89 
Proc
##
	`Chd
()

	)

	@vcore/src/dpl/test/include/dpl/test/test_runner_multiprocess.h

22 #ide
DPL_TEST_RUNNER_MULTIPROCESS_H


23 
	#DPL_TEST_RUNNER_MULTIPROCESS_H


	)

25 
	~<d//_ru_chd.h
>

27 
mea
 
	gVceDPL
 {

28 
mea
 
	gTe
 {

30 as
	cSimePeW
 :

31 
public
 
PeW


33 
public
:

34 
SimePeW
();

36 
	gvtu
 ~
SimePeW
();

38 
Stus
 
nd
(
d
::
rg
 &
mesge
);

39 
Stus
 
ive
(
d
::
rg
 &
da
, 
bo
 &
emy
, 
time_t
 
ddle
);

42 
RunMuiProc
(
TeRu
::
TeCa
 
ocMui
);

46 
	#RUNNER_MULTIPROCESS_TEST
(
Proc
) \

47 
	`Proc
(); \

48 
Proc
##
	`Mui
(); \

49 
Stic
##
Proc
##
	`In
() \

51 
VceDPL
::
Te
::
TeRuSgt
::
	`In
().
	`RegiTe
(#Proc, &
Proc
); \

54 cڡ 
DPL_UNUSED
 
Stic
##
Proc
##
InV
 = Stic##Proc##
	`In
(); \

55 
	`Proc
(){ \

56 
VceDPL
::
Te
::
	`RunMuiProc
(&
Proc
##
Mui
); \

58 
Proc
##
	`Mui
()

	)

	@vcore/src/dpl/test/include/dpl/test/value_separated_parser.h

22 #ide
VALUE_SEPARATED_PARSER_H


23 
	#VALUE_SEPARATED_PARSER_H


	)

25 
	~<rg
>

26 
	~<ve
>

27 
	~<memy
>

29 
	~<d//vue_d_toks.h
>

30 
	~<d//ab_put_rr.h
>

32 
mea
 
	gVceDPL
 {

34 
	gd
::
	tve
<
	td
::
	trg
> 
	tVSLe
;

35 
	gd
::
	tve
<
	tVSLe
> 
	tVSResu
;

36 
	gd
::
	tshed_r
<
	tVSResu
> 
	tVSResuP
;

50 
	gme
<
ass
 
	gPrPicy
>

51 
ass
 
	gVSPr
 : 
public
 
AbIutPr
<
VSResuP
, 
	gVSTok
>

53 
	gpublic
:

54 
VSPr
(: 
m_swchLe
(
ue
), 
m_su
(
w
 
VSResu
()) {}

56 
CsumeTok
(
d
::
unique_r
<
VSTok
> && 
tok
)

58 if(
m_swchLe
)

60 
m_su
->
push_back
(
VSLe
());

61 
	gm_swchLe
 = 
l
;

63 if(
	gtok
->
isNewLe
())

65 if(
	gPrPicy
::
SkLe
(*
m_su
->
rbeg
()))

67 
m_su
->
p_back
();

69 
	gm_swchLe
 = 
ue
;

73 
	gm_su
->
rbeg
()->
push_back
(
tok
->

());

77 
bo
 
IsSVid
()

79  
	gPrPicy
::
Vide
(
m_su
);

82 
VSResuP
 
GResu
() const

84  
	gm_su
;

87 
	give
:

88 
bo
 
m_swchLe
;

89 
VSResuP
 
	gm_su
;

	@vcore/src/dpl/test/include/dpl/test/value_separated_policies.h

22 #ide
VALUE_SEPARATED_POLICIES_H


23 
	#VALUE_SEPARATED_POLICIES_H


	)

25 
	~<rg
>

26 
	~<ve
>

27 
	~<memy
>

29 
mea
 
	gVceDPL
 {

31 
	sCSVTokizPicy


33 
	gd
::
rg
 
GSs
();

34 
bo
 
SkEmy
();

35 
PVue
(
d
::
rg
 &);

36 
bo
 
TryAgaAtEnd
();

39 
	sCSVPrPicy


41 
bo
 
SkLe
(cڡ 
d
::
ve
<d::
rg
> & );

42 
bo
 
Vide
(
d
::
shed_r
<d::
ve
<d::ve<d::
rg
> > > & 
su
);

	@vcore/src/dpl/test/include/dpl/test/value_separated_reader.h

29 #ide
VALUE_SEPARATED_READER_H


30 
	#VALUE_SEPARATED_READER_H


	)

32 
	~<d//ab_put_ad.h
>

33 
	~<d//vue_d_tokiz.h
>

34 
	~<d//vue_d_rr.h
>

35 
	~<d//vue_d_toks.h
>

36 
	~<d//vue_d_pics.h
>

38 
mea
 
	gVceDPL
 {

48 
	gme
<
ass
 
	gPrPicy
, cs
	gTokizPicy
>

49 
ass
 
	gVSRd
 : 
public
 
AbIutRd
<
VSResuP
, 
	gVSTok
>

51 
	gpublic
:

52 
VSRd
(
d
::
shed_r
<
AbIut
> 
w
)

53 : 
AbIutRd
<
VSResuP
, 
	gVSTok
>(
	gw
,

54 
	gd
::
unique_r
<
PrBa
>(
w
 
VSPr
<
PrPicy
>()),

55 
	gd
::
unique_r
<
TokizBa
>(
w
 
VSTokiz
<
TokizPicy
>()))

59 
	gVSRd
<
	tCSVPrPicy
, 
	tCSVTokizPicy
> 
	tCSVRd
;

	@vcore/src/dpl/test/include/dpl/test/value_separated_tokenizer.h

22 #ide
VALUE_SEPARATED_TOKENIZER_H


23 
	#VALUE_SEPARATED_TOKENIZER_H


	)

25 
	~<d//ab_put_tokiz.h
>

26 
	~<d//vue_d_toks.h
>

27 
	~<d/by_queue.h
>

30 
mea
 
	gVceDPL
 {

44 
	gme
<
ass
 
	gTokizPicy
>

45 
ass
 
	gVSTokiz
 : 
public
 
AbIutTokiz
<
VSTok
>

47 
public
:

48 
VSTokiz
() {}

50 
Ret
(
d
::
shed_r
<
AbIut
> 

)

52 
AbIutTokiz
<
VSTok
>::
Ret
(

);

53 
	gm_queue
.
Cˬ
();

54 
	gm_fished
 = 
l
;

55 
	gm_wle
 = 
l
;

58 
	gd
::
unique_r
<
VSTok
> 
GNextTok
()

60 
d
::
unique_r
<
VSTok
> 
tok
;

61 
	gd
::
rg
 
da
;

62 
	gby
;

63 
	gyNumb
 = 0;

65 
	gue
)

68 if(
	gm_wle
)

70 
	gtok
.
t
(
w
 
VSTok
());

71 
	gm_wle
 = 
l
;

72  
	gtok
;

76 if(
	gm_queue
.
Emy
())

78 if(
	gm_fished
)

80  
	gtok
;

84 aut
	gb
 = 
m_put
->
Rd
(4096);

85 if(
	gb
.
g
() == 0)

87 
ThrowMsg
(
Exi
::
TokizE
, "Inputead failed");

89 if(
	gb
->
Emy
())

91 if(
	gTokizPicy
::
TryAgaAtEnd
(
yNumb
))

93 ++
yNumb
;

96 
	gm_fished
 = 
ue
;

97  
	gtok
;

99 
	gm_queue
.
AdMoveFrom
(*
b
);

104 
	gm_queue
.
FωCsume
(&
by
, 1);

105 if(
	gby
 == '\n')

107 
m_wle
 = 
ue
;

108 if(!
	gda
.
emy
(|| !
	gTokizPicy
::
SkEmy
())

110 
ProduSg
(
tok
, 
da
);

111  
	gtok
;

114 if(
	gTokizPicy
::
GSs
().
fd
(
by
!
d
::
rg
::
os
)

116 if(!
da
.
emy
(|| !
TokizPicy
::
SkEmy
())

118 
ProduSg
(
tok
, 
da
);

119  
	gtok
;

124 
	gda
 +
by
;

129 
bo
 
IsSVid
()

131 if(!
	gm_queue
.
Emy
(&& 
	gm_fished
 
	gl
;

132  
	gue
;

135 
	geed
:

136 
ProduSg
(
d
::
unique_r
<
VSTok
> & 
tok
, std::
rg
 & 
da
)

138 
TokizPicy
::
PVue
(
da
);

139 
	gtok
.
t
(
w
 
VSTok
(
da
));

142 
ByQueue
 
	gm_queue
;

143 
bo
 
	gm_fished
;

144 
bo
 
	gm_wle
;

	@vcore/src/dpl/test/include/dpl/test/value_separated_tokens.h

22 #ide
VALUE_SEPARATED_TOKENS_H


23 
	#VALUE_SEPARATED_TOKENS_H


	)

25 
	~<rg
>

27 
mea
 
	gVceDPL
 {

29 as
	cVSTok


31 
	gpublic
:

32 
VSTok
(cڡ 
d
::
rg
 & 
c
);

33 
VSTok
();

34 cڡ 
	gd
::
rg
 & 

() const;

36 
bo
 
isNewLe
();

37 
	give
:

38 
bo
 
m_wle
;

39 
	gd
::
rg
 
m_
;

	@vcore/src/dpl/test/src/process_pipe.cpp

23 
	~<d//oss_pe.h
>

24 
	~<d/log/vce_log.h
>

26 
mea
 
	gVceDPL
 {

28 
	gProssPe
::
ProssPe
(
PeEPicy
 
r
: 
m_fe
(
NULL
), 
m_rPicy
(err)

32 
	gProssPe
::~
ProssPe
()

36 
ProssPe
::
On
(cڡ 
d
::
rg
 & 
commd
)

38 if(
m_fe
 !
NULL
)

40 
ThrowMsg
(
Exi
::
DoubOn
, "Tryingo openipe secondime. Close it first");

43 
	gd
::
rg
 
dERedei
;

44 
	gm_rPicy
)

46 
	gPeEPicy
::
NONE
: ;

47 
	gPeEPicy
::
OFF
: 
dERedei
 = " 2>/dev/null"; ;

48 
	gPeEPicy
::
PIPE
: 
dERedei
 = " 2>&1"; ;

52 
	gd
::
rg
 
fcommd
 = 
commd
 + 
dERedei
;

53 
FILE
 * 
	gfe
 = 
pݒ
(
fcommd
.
c_r
(), "r");

56 i(
	gfe
 =
NULL
) {

57 
ThrowMsg
(
FeIut
::
Exi
::
OnFaed
, 
fcommd
);

61 
	gm_fe
 = 
fe
;

62 
	gm_fd
 = 
fo
(
m_fe
);

64 
VceLogD
("Ode: %s", 
fcommd
.
c_r
());

67 
	gProssPe
::
Clo
()

69 i(
m_fd
 == -1) {

73 i(
po
(
m_fe
) == -1) {

74 
Throw
(
FeIut
::
Exi
::
CloFaed
);

77 
	gm_fd
 = -1;

78 
	gm_fe
 = 
NULL
;

80 
VceLogD
("Closedipe");

	@vcore/src/dpl/test/src/test_results_collector.cpp

22 
	~<cddef
>

23 
	~<d//_sus_c.h
>

24 
	~<d/cs.h
>

25 
	~<d/as.h
>

26 
	~<d/fܗch.h
>

27 
	~<d/sced_fo.h
>

28 
	~<d/exi.h
>

29 
	~<d/o_rg.h
>

30 
	~<d/xil_.h
>

31 
	~<d/avaaby.h
>

33 
	~<rg
>

34 
	~<rg.h
>

35 
	~<cdio
>

36 
	~<fam
>

37 
	~<sam
>

38 
	~<cdlib
>

40 
	#GREEN_RESULT_OK
 "[%s%s%s]\n", 
BOLD_GREEN_BEGIN
, " OK ", \

41 
BOLD_GREEN_END


	)

43 
mea
 
	gVceDPL
 {

44 
mea
 
	gTe
 {

45 
	gmea
 {

46 cڡ *
	gDEFAULT_HTML_FILE_NAME
 = "index.html";

47 cڡ *
	gDEFAULT_TAP_FILE_NAME
 = "results.tap";

48 cڡ *
	gDEFAULT_XML_FILE_NAME
 = "results.xml";

50 
bo
 
PCFeArg
(cڡ 
d
::
rg
 &
g
, std::rg &
fame
)

52 cڡ 
d
::
rg
 
gme
 = "--file=";

53 i(
	gg
.
fd
(
gme
) == 0 ) {

54 
fame
 = 
g
.
subr
(
gme
.
size
());

55  
	gue
;

57  
	gl
;

60 as
	cStiic


62 
	gpublic
:

63 
Stiic
() :

64 
m_ed
(0),

65 
m_igned
(0),

66 
m_sd
(0),

67 
m_cou
(0)

70 
AddTe
(
TeResusCBa
::
FaStus
::
Ty
 
ty
)

72 ++
m_cou
;

73 
	gty
) {

74 
	gTeResusCBa
::
FaStus
::
INTERNAL
:

75 
TeResusCBa
::
FaStus
::
FAILED
: ++
m_ed
;

77 
	gTeResusCBa
::
FaStus
::
IGNORED
: ++
m_igned
;

79 
	gTeResusCBa
::
FaStus
::
NONE
: ++
m_sd
;

82 
As
(
l
 && "Bad FailStatus");

86 
	gd
::
size_t
 
GTٮ
() const

88  
m_cou
;

90 
	gd
::
size_t
 
GPasd
() const

92  
m_sd
;

94 
	gd
::
size_t
 
GSucd
() const

96  
m_sd
;

98 
	gd
::
size_t
 
GFaed
() const

100  
m_ed
;

102 
	gd
::
size_t
 
GIgned
() const

104  
m_igned
;

106 
GPasdOrIgnedPnd
() const

108 
	gssIgnedP
 =

109 100.0* (
ic_
<>(
m_sd
)

110 + 
ic_
<>(
m_igned
))

111 / 
ic_
<>(
m_cou
);

112  
	gssIgnedP
;

115 
	give
:

116 
d
::
size_t
 
m_ed
;

117 
	gd
::
size_t
 
m_igned
;

118 
	gd
::
size_t
 
m_sd
;

119 
	gd
::
size_t
 
m_cou
;

122 as
	cCseC
 :

123 
public
 
TeResusCBa


125 
public
:

126 
TeResusCBa
* 
Cڡru
();

128 
	give
:

129 
CseC
() {}

131 
vtu
 
CCutTeGroupName
(cڡ 
d
::
rg
& 
me
)

133 
tf
("Sg grou%s\n", 
me
.
c_r
());

134 
	gm_cutGroup
 = 
me
;

137 
vtu
 
Fish
()

139 
usg
 
mea
 
	gVceDPL
::
Cs
::
Text
;

142 
FOREACH
(
group
, 
m_groupsSts
) {

143 
PrtSts
(
group
->
f
, group->
cd
);

145 
PrtSts
("A΁etogh", 
m_s
);

148 
vtu
 
CResu
(cڡ 
d
::
rg
& 
id
,

149 cڡ 
d
::
rg
& ,

150 cڡ 
FaStus
::
Ty
 
us
 = FaStus::
NONE
,

151 cڡ 
d
::
rg
& 
as
 = "")

153 
usg
 
mea
 
VceDPL
::
Cs
::
Text
;

154 
	gd
::
rg
 
tmp
 = "'" + 
id
 + "' ...";

156 
tf
("Ruge ca %-60s", 
tmp
.
c_r
());

157 
	gus
) {

158 
	gTeResusCBa
::
FaStus
::
NONE
:

159 
tf
(
GREEN_RESULT_OK
);

161 
	gTeResusCBa
::
FaStus
::
FAILED
:

162 
PrtfEMesge
(" FAILED ", 
as
, 
ue
);

164 
	gTeResusCBa
::
FaStus
::
IGNORED
:

165 
PrtfIgnedMesge
("Igned ", 
as
, 
ue
);

167 
	gTeResusCBa
::
FaStus
::
INTERNAL
:

168 
PrtfEMesge
("INTERNAL", 
as
, 
ue
);

171 
As
(
l
 && "Bad status");

173 
	gm_s
.
AddTe
(
us
);

174 
	gm_groupsSts
[
m_cutGroup
].
AddTe
(
us
);

177 
PrtfEMesge
(cڡ * 
ty
,

178 cڡ 
d
::
rg
& 
mesge
,

179 
bo
 
vbosy
)

181 
usg
 
mea
 
	gVceDPL
::
Cs
::
Text
;

182 i(
	gvbosy
) {

183 
tf
("[%s%s%s] %s%s%s\n",

184 
BOLD_RED_BEGIN
,

185 
ty
,

186 
BOLD_RED_END
,

187 
BOLD_YELLOW_BEGIN
,

188 
mesge
.
c_r
(),

189 
BOLD_YELLOW_END
);

191 
tf
("[%s%s%s]\n",

192 
BOLD_RED_BEGIN
,

193 
ty
,

194 
BOLD_RED_END
);

198 
PrtfIgnedMesge
(cڡ * 
ty
,

199 cڡ 
d
::
rg
& 
mesge
,

200 
bo
 
vbosy
)

202 
usg
 
mea
 
	gVceDPL
::
Cs
::
Text
;

203 i(
	gvbosy
) {

204 
tf
("[%s%s%s] %s%s%s\n",

205 
CYAN_BEGIN
,

206 
ty
,

207 
CYAN_END
,

208 
BOLD_GOLD_BEGIN
,

209 
mesge
.
c_r
(),

210 
BOLD_GOLD_END
);

212 
tf
("[%s%s%s]\n",

213 
CYAN_BEGIN
,

214 
ty
,

215 
CYAN_END
);

219 
PrtSts
(cڡ 
d
::
rg
& 
t
, cڡ 
Stiic
& 
s
)

221 
usg
 
mea
 
	gVceDPL
::
Cs
::
Text
;

222 
tf
("\n%sResuɠ[%s]: %s\n", 
BOLD_GREEN_BEGIN
,

223 
t
.
c_r
(), 
BOLD_GREEN_END
);

224 
tf
("%s%s%3d%s\n",

225 
CYAN_BEGIN
,

227 
s
.
GTٮ
(),

228 
CYAN_END
);

229 
tf
(" %s%s%3d%s\n",

230 
CYAN_BEGIN
,

232 
s
.
GPasd
(),

233 
CYAN_END
);

234 
tf
(" %s%s%3d%s\n",

235 
CYAN_BEGIN
,

237 
s
.
GFaed
(),

238 
CYAN_END
);

239 
tf
(" %s%s%3d%s\n",

240 
CYAN_BEGIN
,

242 
s
.
GIgned
(),

243 
CYAN_END
);

246 
Stiic
 
	gm_s
;

247 
	gd
::
m
<
d
::
rg
, 
	gStiic
> 
	gm_groupsSts
;

248 
	gd
::
rg
 
m_cutGroup
;

251 
TeResusCBa
* 
	gCseC
::
Cڡru
()

253  
w
 
CseC
();

256 as
	cHtmlC
 :

257 
public
 
TeResusCBa


259 
public
:

260 
TeResusCBa
* 
Cڡru
();

262 
	give
:

263 
HtmlC
(: 
m_fame
(
DEFAULT_HTML_FILE_NAME
) {}

265 
vtu
 
CCutTeGroupName
(cڡ 
d
::
rg
& 
me
)

267 
rtf
(
m_
.
G
(), "<b>Sg grou%s", 
me
.
c_r
());

268 
	gm_cutGroup
 = 
me
;

271 
vtu
 
bo
 
Cfigu
()

273 
	gm_
.
Ret
(
fݒ
(
m_fame
.
c_r
(), "w"));

274 i(!
	gm_
)

275  
	gl
;

277  
	gue
;

279 
vtu
 
	gd
::
rg
 
CScificHp
() const

285 
vtu
 
S
(
cou
)

287 
DPL_UNUSED_PARAM
(
cou
);

288 
AsMsg
(!!
m_
, "File handle mustot beull");

289 
rtf
(
m_
.
G
(),

294 
rtf
(
m_
.
G
(),

297 
rtf
(
m_
.
G
(), "<body style=\"background-color: black;\">\n");

298 
rtf
(
m_
.
G
(), "<pre>\n");

299 
rtf
(
m_
.
G
(), "<font color=\"white\">\n");

302 
vtu
 
Fish
()

304 
usg
 
mea
 
	gVceDPL
::
Cs
::
Html
;

306 
FOREACH
(
group
, 
m_groupsSts
) {

307 
PrtSts
(
group
->
f
, group->
cd
);

309 
PrtSts
("A΁etogh", 
m_s
);

310 
rtf
(
m_
.
G
(), "</font>\n");

311 
rtf
(
m_
.
G
(), "</pre>\n");

312 
rtf
(
m_
.
G
(), "</body>\n");

313 
rtf
(
m_
.
G
(), "</html>\n");

316 
vtu
 
bo
 
PCScificArg
(cڡ 
d
::
rg
& 
g
)

318  
PCFeArg
(
g
, 
m_fame
);

321 
vtu
 
CResu
(cڡ 
d
::
rg
& 
id
,

322 cڡ 
d
::
rg
& ,

323 cڡ 
FaStus
::
Ty
 
us
 = FaStus::
NONE
,

324 cڡ 
d
::
rg
& 
as
 = "")

326 
usg
 
mea
 
VceDPL
::
Cs
::
Html
;

327 
	gd
::
rg
 
tmp
 = "'" + 
id
 + "' ...";

329 
rtf
(
m_
.
G
(), "Ruge ca %-100s", 
tmp
.
c_r
());

330 
	gus
) {

331 
	gTeResusCBa
::
FaStus
::
NONE
:

332 
rtf
(
m_
.
G
(), 
GREEN_RESULT_OK
);

334 
	gTeResusCBa
::
FaStus
::
FAILED
:

335 
PrtfEMesge
(" FAILED ", 
as
, 
ue
);

337 
	gTeResusCBa
::
FaStus
::
IGNORED
:

338 
PrtfIgnedMesge
("Igned ", 
as
, 
ue
);

340 
	gTeResusCBa
::
FaStus
::
INTERNAL
:

341 
PrtfEMesge
("INTERNAL", 
as
, 
ue
);

344 
As
(
l
 && "Bad status");

346 
	gm_groupsSts
[
m_cutGroup
].
AddTe
(
us
);

347 
	gm_s
.
AddTe
(
us
);

350 
PrtfEMesge
(cڡ * 
ty
,

351 cڡ 
d
::
rg
& 
mesge
,

352 
bo
 
vbosy
)

354 
usg
 
mea
 
	gVceDPL
::
Cs
::
Html
;

355 i(
	gvbosy
) {

356 
rtf
(
m_
.
G
(),

358 
BOLD_RED_BEGIN
,

359 
ty
,

360 
BOLD_RED_END
,

361 
BOLD_YELLOW_BEGIN
,

362 
mesge
.
c_r
(),

363 
BOLD_YELLOW_END
);

365 
rtf
(
m_
.
G
(),

367 
BOLD_RED_BEGIN
,

368 
ty
,

369 
BOLD_RED_END
);

373 
PrtfIgnedMesge
(cڡ * 
ty
,

374 cڡ 
d
::
rg
& 
mesge
,

375 
bo
 
vbosy
)

377 
usg
 
mea
 
	gVceDPL
::
Cs
::
Html
;

379 i(
	gvbosy
) {

380 
rtf
(
m_
.
G
(),

382 
CYAN_BEGIN
,

383 
ty
,

384 
CYAN_END
,

385 
BOLD_GOLD_BEGIN
,

386 
mesge
.
c_r
(),

387 
BOLD_GOLD_END
);

389 
rtf
(
m_
.
G
(),

391 
CYAN_BEGIN
,

392 
ty
,

393 
CYAN_END
);

397 
PrtSts
(cڡ 
d
::
rg
& 
me
, cڡ 
Stiic
& 
s
)

399 
usg
 
mea
 
	gVceDPL
::
Cs
::
Html
;

400 
rtf
(

401 
m_
.
G
(), "\n%sResuɠ[%s]:%s\n", 
BOLD_GREEN_BEGIN
,

402 
me
.
c_r
(), 
BOLD_GREEN_END
);

403 
rtf
(

404 
m_
.
G
(), "%s%s%3d%s\n", 
CYAN_BEGIN
,

405 "Tٮes: ", 
s
.
GTٮ
(), 
CYAN_END
);

406 
rtf
(

407 
m_
.
G
(), " %s%s%3d%s\n", 
CYAN_BEGIN
,

408 "Suceded: ", 
s
.
GPasd
(), 
CYAN_END
);

409 
rtf
(

410 
m_
.
G
(), " %s%s%3d%s\n", 
CYAN_BEGIN
,

411 "Faed: ", 
s
.
GFaed
(), 
CYAN_END
);

412 
rtf
(

413 
m_
.
G
(), " %s%s%3d%s\n", 
CYAN_BEGIN
,

414 "Igned: ", 
s
.
GIgned
(), 
CYAN_END
);

417 
	gd
::
rg
 
m_fame
;

418 
ScedFClo
 
	gm_
;

419 
Stiic
 
	gm_s
;

420 
	gd
::
rg
 
m_cutGroup
;

421 
	gd
::
m
<
d
::
rg
, 
	gStiic
> 
	gm_groupsSts
;

424 
TeResusCBa
* 
	gHtmlC
::
Cڡru
()

426  
w
 
HtmlC
();

429 as
	cXmlC
 :

430 
public
 
TeResusCBa


432 
public
:

433 
TeResusCBa
* 
Cڡru
();

435 
	give
:

436 
XmlC
(: 
m_fame
(
DEFAULT_XML_FILE_NAME
) {}

438 
vtu
 
CCutTeGroupName
(cڡ 
d
::
rg
& 
me
)

440 
d
::
size_t
 
pos
 = 
GCutGroupPosi
();

441 i(
	gd
::
rg
::
os
 !
pos
) {

442 
GroupFish
(
pos
);

443 
FlushOuut
();

444 
	gm_s
 = 
Stiic
();

447 
	gpos
 = 
m_ouutBufr
.
fd
("</testsuites>");

448 i(
	gd
::
rg
::
os
 =
pos
) {

449 
ThrowMsg
(
VceDPL
::
Exi
, "Couldot findest suites closingag");

451 
GroupS
(
pos
, 
me
);

454 
GroupS
(cڡ 
d
::
size_t
 
pos
, cڡ std::
rg
& 
me
)

456 
d
::
rgam
 
groupHd
;

457 
	ggroupHd
 << "\n\t<testsuite";

458 
	ggroupHd
 << "ame=\"" << 
EsSclChas
(
me
) << "\"";

459 
	ggroupHd
 << 
	gR
"(ests="1")";

460 
	ggroupHd
 << 
	gR
"( failures="1")";

461 
	ggroupHd
 << 
	gR
"( skipped="0")";

462 
	ggroupHd
 << ">";

464 
	ggroupHd
 << "\n\t\t<testcaseame=\"unknown\" status=\"FAILED\">";

465 
	ggroupHd
 <<

467 
	ggroupHd
 << "\n\t\t</testcase>";

469 
	ggroupHd
 << "\n\t</testsuite>";

471 
	gm_ouutBufr
.

(
pos
 - 1, 
groupHd
.
r
());

474 
vtu
 
bo
 
Cfigu
()

476 
	gm_
.
Ret
(
fݒ
(
m_fame
.
c_r
(), "w"));

477 i(!
	gm_
)

478  
	gl
;

480  
	gue
;

483 
vtu
 
	gd
::
rg
 
CScificHp
() const

489 
vtu
 
S
(
cou
)

491 
AsMsg
(!!
m_
, "File handle mustot beull");

492 
	gm_ouutBufr
.
nd
("<?xml version=\"1.0\"ncoding=\"UTF-8\" ?>\n");

493 
	gm_ouutBufr
.
nd
("<testsuites ");

494 if(
	gcou
 >= 0)

496 
m_ouutBufr
.
nd
("total=\"");

497 
	gm_ouutBufr
.
nd
(
VceDPL
::
xil_
<
d
::
rg
>(
cou
));

498 
	gm_ouutBufr
.
nd
("\"");

500 
	gm_ouutBufr
.
nd
(" >\n</testsuites>");

501 
FlushOuut
();

504 
vtu
 
Fish
()

506 
	gd
::
size_t
 
pos
 = 
GCutGroupPosi
();

507 i(
	gd
::
rg
::
os
 !
pos
) {

508 
GroupFish
(
pos
);

509 
FlushOuut
();

513 
vtu
 
bo
 
PCScificArg
(cڡ 
d
::
rg
& 
g
)

515  
PCFeArg
(
g
, 
m_fame
);

518 
vtu
 
CResu
(cڡ 
d
::
rg
& 
id
,

519 cڡ 
d
::
rg
& ,

520 cڡ 
FaStus
::
Ty
 
us
 = FaStus::
NONE
,

521 cڡ 
d
::
rg
& 
as
 = "")

523 
m_suBufr
.
a
();

524 
	gm_suBufr
.
nd
("\t\t<testcaseame=\"");

525 
	gm_suBufr
.
nd
(
EsSclChas
(
id
));

526 
	gm_suBufr
.
nd
("\"");

527 
	gus
) {

528 
	gTeResusCBa
::
FaStus
::
NONE
:

529 
m_suBufr
.
nd
(" status=\"OK\"/>\n");

531 
	gTeResusCBa
::
FaStus
::
FAILED
:

532 
m_suBufr
.
nd
(" status=\"FAILED\">\n");

533 
PrtfEMesge
("FAILED", 
EsSclChas
(
as
), 
ue
);

534 
	gm_suBufr
.
nd
("\t\t</testcase>\n");

536 
	gTeResusCBa
::
FaStus
::
IGNORED
:

537 
m_suBufr
.
nd
(" status=\"Ignored\">\n");

538 
PrtfIgnedMesge
("Igned", 
EsSclChas
(

539 
as
), 
ue
);

540 
	gm_suBufr
.
nd
("\t\t</testcase>\n");

542 
	gTeResusCBa
::
FaStus
::
INTERNAL
:

543 
m_suBufr
.
nd
(" status=\"FAILED\">\n");

544 
PrtfEMesge
("INTERNAL", 
EsSclChas
(

545 
as
), 
ue
);

546 
	gm_suBufr
.
nd
("\t\t</testcase>");

549 
As
(
l
 && "Bad status");

551 
	gd
::
size_t
 
group_pos
 = 
GCutGroupPosi
();

552 i(
	gd
::
rg
::
os
 =
group_pos
) {

553 
ThrowMsg
(
VceDPL
::
Exi
, "No current group set");

556 
	gd
::
size_t
 
ϡ__pos
 = 
m_ouutBufr
.
fd
(

558 
group_pos
);

559 i(
	gd
::
rg
::
os
 =
ϡ__pos
) {

560 
ThrowMsg
(
VceDPL
::
Exi
, "Couldot find SegFaultest case");

562 
	gm_ouutBufr
.

(
ϡ__pos
 - 2, 
m_suBufr
);

564 
	gm_s
.
AddTe
(
us
);

566 
UpdeGroupHd
(
group_pos
,

567 
m_s
.
GTٮ
() + 1,

568 
m_s
.
GFaed
() + 1,

569 
m_s
.
GIgned
());

570 
FlushOuut
();

573 
	gd
::
size_t
 
GCutGroupPosi
() const

575  
m_ouutBufr
.
rfd
("<testsuite ");

578 
UpdeGroupHd
(cڡ 
d
::
size_t
 
groupPosi
,

579 cڡ 
s
,

580 cڡ 
us
,

581 cڡ 
skd
)

583 
UpdeEmtAribu
(
groupPosi
, "s", 
UIToSg
(
s
));

584 
UpdeEmtAribu
(
groupPosi
, "us", 
UIToSg
(
us
));

585 
UpdeEmtAribu
(
groupPosi
, "skd", 
UIToSg
(
skd
));

588 
UpdeEmtAribu
(cڡ 
d
::
size_t
 
emtPosi
,

589 cڡ 
d
::
rg
& 
me
,

590 cڡ 
d
::
rg
& 
vue
)

592 
d
::
rg
 
n
 = 
me
 + "=\"";

594 
	gd
::
size_t
 
t
 = 
m_ouutBufr
.
fd
(
n
, 
emtPosi
);

595 i(
	gd
::
rg
::
os
 =
t
) {

596 
ThrowMsg
(
VceDPL
::
Exi
,

597 "Could fdribu " << 
me
 << " beginning");

600 
	gd
::
size_t
 
d
 = 
m_ouutBufr
.
fd
("\"", 
t
 + 
n
.
ngth
());

601 i(
	gd
::
rg
::
os
 =
d
) {

602 
ThrowMsg
(
VceDPL
::
Exi
,

603 "Could fdribu " << 
me
 << "nd");

606 
	gm_ouutBufr
.
a
(
t
 + 
n
.
ngth
(),

607 
d
 - 
t
 - 
n
.
ngth
(),

608 
vue
);

611 
	gd
::
rg
 
UIToSg
(cڡ 
vue
)

613 
d
::
rgam
 
su
;

614 
	gsu
 << 
	gvue
;

615  
	gsu
.
r
();

618 
GroupFish
(cڡ 
d
::
size_t
 
groupPosi
)

620 
d
::
size_t
 
gFauS
 =

621 
m_ouutBufr
.
fd
("<ame=\"unknown\"", 
groupPosi
);

622 i(
	gd
::
rg
::
os
 =
gFauS
) {

623 
ThrowMsg
(
VceDPL
::
Exi
,

626 
	ggFauS
 -= 2;

628 
	gd
::
rg
 
oTag
 = "</testcase>";

629 
	gd
::
size_t
 
gFauEnd
 = 
m_ouutBufr
.
fd
(
oTag
, 
gFauS
);

630 i(
	gd
::
rg
::
os
 =
gFauEnd
) {

631 
ThrowMsg
(
VceDPL
::
Exi
,

634 
	ggFauEnd
 +
oTag
.
ngth
() + 1;

636 
	gm_ouutBufr
.
a
(
gFauS
, 
gFauEnd
 - segFaultStart);

638 
UpdeGroupHd
(
groupPosi
,

639 
m_s
.
GTٮ
(),

640 
m_s
.
GFaed
(),

641 
m_s
.
GIgned
());

644 
FlushOuut
()

646 
	gfd
 = 
fo
(
m_
.
G
());

647 i(-1 =
fd
) {

648 
r
 = 
o
;

649 
ThrowMsg
(
VceDPL
::
Exi
, VceDPL::
GEnoSg
(
r
));

652 i(-1 =
TEMP_FAILURE_RETRY
(
run
(
fd
, 0L))) {

653 
	gr
 = 
o
;

654 
ThrowMsg
(
VceDPL
::
Exi
, VceDPL::
GEnoSg
(
r
));

657 i(-1 =
TEMP_FAILURE_RETRY
(
fek
(
m_
.
G
(), 0L, 
SEEK_SET
))) {

658 
	gr
 = 
o
;

659 
ThrowMsg
(
VceDPL
::
Exi
, VceDPL::
GEnoSg
(
r
));

662 i(
	gm_ouutBufr
.
size
() !=

663 
fwre
(
m_ouutBufr
.
c_r
(), 1, m_ouutBufr.
size
(),

664 
m_
.
G
()))

666 
	gr
 = 
o
;

667 
ThrowMsg
(
VceDPL
::
Exi
, VceDPL::
GEnoSg
(
r
));

670 i(-1 =
TEMP_FAILURE_RETRY
(
fush
(
m_
.
G
()))) {

671 
r
 = 
o
;

672 
ThrowMsg
(
VceDPL
::
Exi
, VceDPL::
GEnoSg
(
r
));

676 
PrtfEMesge
(cڡ * 
ty
,

677 cڡ 
d
::
rg
& 
mesge
,

678 
bo
 
vbosy
)

680 i(
	gvbosy
) {

681 
	gm_suBufr
.
nd
("\t\t\t<failureype=\"");

682 
	gm_suBufr
.
nd
(
EsSclChas
(
ty
));

683 
	gm_suBufr
.
nd
("\" message=\"");

684 
	gm_suBufr
.
nd
(
EsSclChas
(
mesge
));

685 
	gm_suBufr
.
nd
("\"/>\n");

687 
	gm_suBufr
.
nd
("\t\t\t<failureype=\"");

688 
	gm_suBufr
.
nd
(
EsSclChas
(
ty
));

689 
	gm_suBufr
.
nd
("\"/>\n");

693 
PrtfIgnedMesge
(cڡ * 
ty
,

694 cڡ 
d
::
rg
& 
mesge
,

695 
bo
 
vbosy
)

697 i(
	gvbosy
) {

698 
	gm_suBufr
.
nd
("\t\t\t<skippedype=\"");

699 
	gm_suBufr
.
nd
(
EsSclChas
(
ty
));

700 
	gm_suBufr
.
nd
("\" message=\"");

701 
	gm_suBufr
.
nd
(
EsSclChas
(
mesge
));

702 
	gm_suBufr
.
nd
("\"/>\n");

704 
	gm_suBufr
.
nd
("\t\t\t<skippedype=\"");

705 
	gm_suBufr
.
nd
(
EsSclChas
(
ty
));

706 
	gm_suBufr
.
nd
("\"/>\n");

710 
	gd
::
rg
 
EsSclChas
(
d
::rg 
s
)

712 
i
 = 0; 
	gi
 < 
	gs
.
size
();) {

713 
	gs
[
i
]) {

715 
s
.
a
(
i
, 1);

716 
	gs
.

(
i
, "&quot;");

717 
	gi
 += 6;

721 
s
.
a
(
i
, 1);

722 
	gs
.

(
i
, "&amp;");

723 
	gi
 += 5;

727 
s
.
a
(
i
, 1);

728 
	gs
.

(
i
, "&lt;");

729 
	gi
 += 4;

733 
s
.
a
(
i
, 1);

734 
	gs
.

(
i
, "&gt;");

735 
	gi
 += 4;

739 
s
.
a
(
i
, 1);

740 
	gs
.

(
i
, "&#39;");

741 
	gi
 += 5;

744 ++
i
;

748  
	gs
;

751 
	gd
::
rg
 
m_fame
;

752 
ScedFClo
 
	gm_
;

753 
Stiic
 
	gm_s
;

754 
	gd
::
rg
 
m_ouutBufr
;

755 
	gd
::
rg
 
m_suBufr
;

758 
TeResusCBa
* 
	gXmlC
::
Cڡru
()

760  
w
 
XmlC
();

763 as
	cCSVC
 :

764 
public
 
TeResusCBa


766 
public
:

767 
TeResusCBa
* 
Cڡru
();

769 
	give
:

770 
CSVC
() {}

772 
vtu
 
S
(
cou
)

774 
DPL_UNUSED_PARAM
(
cou
);

775 
tf
("GROUP;ID;RESULT;REASON\n");

778 
vtu
 
CCutTeGroupName
(cڡ 
d
::
rg
& 
me
)

780 
m_cutGroup
 = 
me
;

783 
vtu
 
CResu
(cڡ 
d
::
rg
& 
id
,

784 cڡ 
d
::
rg
& ,

785 cڡ 
FaStus
::
Ty
 
us
 = FaStus::
NONE
,

786 cڡ 
d
::
rg
& 
as
 = "")

788 
d
::
rg
 
usMsg
 = "";

789 
	gus
) {

790 
	gTeResusCBa
::
FaStus
::
NONE
: 
usMsg
 = "OK";

792 
	gTeResusCBa
::
FaStus
::
FAILED
: 
usMsg
 = "FAILED";

794 
	gTeResusCBa
::
FaStus
::
IGNORED
: 
usMsg
 =

797 
	gTeResusCBa
::
FaStus
::
INTERNAL
: 
usMsg
 =

801 
As
(
l
 && "Bad status");

803 
tf
("%s;%s;%s;%s\n",

804 
m_cutGroup
.
c_r
(),

805 
id
.
c_r
(),

806 
usMsg
.
c_r
(),

807 
as
.
c_r
());

810 
	gd
::
rg
 
m_cutGroup
;

813 
TeResusCBa
* 
	gCSVC
::
Cڡru
()

815  
w
 
CSVC
();

819 as
	cTAPC
 :

820 
public
 
TeResusCBa


822 
public
:

823 
TeResusCBa
* 
Cڡru
();

825 
	give
:

826 
TAPC
(: 
m_fame
(
DEFAULT_TAP_FILE_NAME
) {}

828 
vtu
 
bo
 
Cfigu
()

830 
m_ouut
.
ݒ
(
m_fame
.
c_r
(), 
d
::
ios_ba
::
unc
);

831 i(
	gm_ouut
.

())

832  
	gl
;

834  
	gue
;

836 
vtu
 
	gd
::
rg
 
CScificHp
() const

838 
d
::
rg
 
tV
 = "--file=<filename> -ame of file for output\n"

840 
	gtV
 +
DEFAULT_TAP_FILE_NAME
;

841 
	gtV
 += "\n";

842  
	gtV
;

845 
vtu
 
S
(
cou
)

847 
DPL_UNUSED_PARAM
(
cou
);

848 
AsMsg
(
m_ouut
.
good
(), "Output file must be opened.");

849 
	gm_ouut
 << "TAP vsi 13" << 
	gd
::
dl
;

850 
	gm_Index
 = 0;

853 
vtu
 
Fish
()

855 
	gm_ouut
 << "1.." << 
	gm_Index
 << 
	gd
::
dl
;

856 
	gm_ouut
 << 
	gm_cedDa
.
rdbuf
();

857 
	gm_ouut
.
o
();

860 
vtu
 
bo
 
PCScificArg
(cڡ 
d
::
rg
& 
g
)

862  
PCFeArg
(
g
, 
m_fame
);

865 
vtu
 
CResu
(cڡ 
d
::
rg
& 
id
,

866 cڡ 
d
::
rg
& 
desti
,

867 cڡ 
FaStus
::
Ty
 
us
 = FaStus::
NONE
,

868 cڡ 
d
::
rg
& 
as
 = "")

870 
m_Index
++;

871 
	gus
) {

872 
	gTeResusCBa
::
FaStus
::
NONE
:

873 
LogBasicTAP
(
ue
, 
id
, 
desti
);

874 
dTAPLe
();

876 
	gTeResusCBa
::
FaStus
::
FAILED
:

877 
LogBasicTAP
(
l
, 
id
, 
desti
);

878 
dTAPLe
();

880 
	gTeResusCBa
::
FaStus
::
IGNORED
:

881 
LogBasicTAP
(
ue
, 
id
, 
desti
);

882 
	gm_cedDa
 << " # sk " << 
	gas
;

883 
dTAPLe
();

885 
	gTeResusCBa
::
FaStus
::
INTERNAL
:

886 
LogBasicTAP
(
ue
, 
id
, 
desti
);

887 
dTAPLe
();

888 
	gm_cedDa
 << " ---" << 
	gd
::
dl
;

889 
	gm_cedDa
 << " mesge: " << 
	gas
 << 
	gd
::
dl
;

890 
	gm_cedDa
 << " sevy: Il" << 
	gd
::
dl
;

891 
	gm_cedDa
 << " ..." << 
	gd
::
dl
;

894 
As
(
l
 && "Bad status");

898 
LogBasicTAP
(
bo
 
isOK
, cڡ 
d
::
rg
& 
id
,

899 cڡ 
d
::
rg
& 
desti
)

901 i(!
isOK
) {

902 
m_cedDa
 << "not ";

904 
	gm_cedDa
 << "ok " << 
	gm_Index
 << " [" <<

905 
	gid
 << "] " << 
	gdesti
;

908 
dTAPLe
()

910 
	gm_cedDa
 << 
	gd
::
dl
;

913 
	gd
::
rg
 
m_fame
;

914 
	gd
::
rgam
 
m_cedDa
;

915 
	gd
::
ofam
 
m_ouut
;

916 
	gm_Index
;

919 
TeResusCBa
* 
	gTAPC
::
Cڡru
()

921  
w
 
TAPC
();

924 
	gTeResusCBa
::
RegiCCڡru
(

925 cڡ 
d
::
rg
& 
me
,

926 
TeResusCBa
::
CCڡruFunc
 
func
)

928 
As
(
m_cڡrusM
.
fd
(
me
=m_cڡrusM.
d
());

929 
	gm_cڡrusM
[
me
] = 
func
;

932 
TeResusCBa
* 
	gTeResusCBa
::
Ce
(

933 cڡ 
d
::
rg
& 
me
)

935 
CڡrusM
::

 
found
 = 
m_cڡrusM
.
fd
(
me
);

936 i(
	gfound
 !
m_cڡrusM
.
d
()) {

937  
found
->
cd
();

939  
	gNULL
;

943 
	gd
::
ve
<
d
::
rg
> 
TeResusCBa
::
GCsNames
()

945 
d
::
ve
<d::
rg
> 
li
;

946 
FOREACH
(

, 
m_cڡrusM
)

948 
	gli
.
push_back
(

->
f
);

950  
	gli
;

953 
	gTeResusCBa
::
CڡrusM
 
TeResusCBa
::

954 
m_cڡrusM
;

956 
	gmea
 {

957 
RegiCCڡrus
();

958 cڡ 
	gRegiHrVb
 = 
RegiCCڡrus
();

959 
RegiCCڡrus
()

961 ()
	gRegiHrVb
;

963 
	gTeResusCBa
::
RegiCCڡru
(

965 &
CseC
::
Cڡru
);

966 
	gTeResusCBa
::
RegiCCڡru
(

968 &
HtmlC
::
Cڡru
);

969 
	gTeResusCBa
::
RegiCCڡru
(

971 &
CSVC
::
Cڡru
);

972 
	gTeResusCBa
::
RegiCCڡru
(

974 &
TAPC
::
Cڡru
);

975 
	gTeResusCBa
::
RegiCCڡru
(

977 &
XmlC
::
Cڡru
);

984 #unde
GREEN_RESULT_OK


	@vcore/src/dpl/test/src/test_runner.cpp

23 
	~<ddef.h
>

24 
	~<d//_ru.h
>

25 
	~<d//_sus_c.h
>

26 
	~<d/exi.h
>

27 
	~<d/_d.h
>

28 
	~<memy
>

29 
	~<d/fܗch.h
>

30 
	~<d/cs.h
>

31 
	~<pep.h
>

32 
	~<gܙhm
>

33 
	~<cdio
>

34 
	~<memy.h
>

35 
	~<libg.h
>

36 
	~<crg
>

37 
	~<cdlib
>

39 
	~<libxml/xth.h
>

40 
	~<libxml/xthIls.h
>

41 
	~<libxml/rr.h
>

42 
	~<libxml/.h
>

44 
	~<d/sgt_im.h
>

45 
	$IMPLEMENT_SINGLETON
(
VceDPL
::
Te
::
TeRu
)

47 
mea
 {

49 
d
::
rg
 
	`gXMLNode
(
xmlNodeP
 
node
)

51 
d
::
rg
 
t
;

52 
xmlCh
 * 
vue
 = 
	`xmlNodeGCڋ
(
node
);

53 i(
vue
 !
NULL
) {

54 
t
 = 
d
::
	`rg
(
t_
<*>(
vue
));

55 
	`xmlFe
(
vue
);

57  
t
;

60 
	}
}

63 
mea
 
	gVceDPL
 {

64 
mea
 
	gTe
 {

65 
	gmea


67 
	gd
::
rg
 
BaName
(
d
::rg 
aPh
)

69 
d
::
unique_r
<[],
	g_d
> 
th
(
rdup
(
aPh
.
c_r
()));

70 i(
	gNULL
 =
th
.
g
()) {

71 
throw
 
d
::
bad_loc
();

73 * 
	gbaName
 = 
bame
(
th
.
g
());

74 
	gd
::
rg
 
tVue
 = 
baName
;

75  
	gtVue
;

85 
	gTeRu
::
TeFaed
::TeFaed(cڡ * 
aTe
,

86 cڡ * 
aFe
,

87 
aLe
,

88 cڡ 
d
::
rg
 &
aMesge
)

90 
d
::
orgam
 
asMsg
;

91 
	gasMsg
 << "[" << 
BaName
(
aFe
<< ":" << 
	gaLe


93 << 
	gaTe
 << "" << 
	gaMesge
;

94 
	gm_mesge
 = 
asMsg
.
r
();

97 
	gTeRu
::
TeFaed
::TeFaed(cڡ 
d
::
rg
 &
mesge
)

99 
m_mesge
 = 
mesge
;

102 
	gTeRu
::
RegiTe
(cڡ *
Name
, 
TeCa
 
oc
)

104 
	gm_Groups
[
m_cutGroup
].
push_back
(
TeCaSu
(
Name
, 
oc
));

107 
	gTeRu
::
InGroup
(cڡ * 
me
)

109 
m_cutGroup
 = 
me
;

112 
	gTeRu
::
nmizeXMLTag
(
d
::
rg
& 
r
, cڡ std::rg& 

)

115 
d
::
rg
::
size_ty
 
pos
 = 
r
.
fd
(

);

116 if(
	gpos
 != 0)

118 
r
 = 

 + "_" + str;

123 
	gd
::
a
(
r
.
beg
(), s.
d
(), '-', '_');

126 
bo
 
	gTeRu
::
frGroupsByXmls
(cڡ 
d
::
ve
<d::
rg
> & 
fes
)

128 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
XMLE
)

130 cڡ 
	gd
::
rg
 
idPh
 = "/test_definition/suite/set/testcase/@id";

132 
bo
 
	gsucss
 = 
ue
;

133 
	gd
::
m
<
d
::
rg
, 
	gbo
> 
	gsM
;

135 
	gd
::
rg
 
sue
;

136 if(!
	gm_Groups
.
emy
())

138 
	gTeCaGroupM
::
cڡ_
 
c
 = 
m_Groups
.
beg
(); 
	gc
 !m_Groups.
d
(); ++cit)

140 if(!
	gc
->
	gcd
.
emy
())

142 
	gTeCaSuLi
::
cڡ_
 
cj
 = 
c
->
cd
.
beg
(); 
	gcj
 !c->cd.
d
(); ++cj)

144 
	gd
::
rg
 
me
 = 
cj
->name;

145 
	gd
::
rg
::
size_ty
 

 = 
me
.
fd
('_');

146 if(
	g
 !
d
::
rg
::
os
)

148 
me
 =ame.
subr
(0, 

);

149 
	gsue
 = 
me
;

153 if(!
	gsue
.
emy
()) ;

158 
xmlInPr
();

159 
LIBXML_TEST_VERSION


160 
xmlXPhIn
();

162 
	gTry


164 
FOREACH
(
fe
, 
fes
)

166 
xmlDocP
 
	gdoc
;

167 
xmlXPhCڋxtP
 
	gxthCtx
;

169 
	gdoc
 = 
xmlRdFe
(
fe
->
c_r
(), 
NULL
, 0);

170 i(
	gdoc
 =
NULL
) {

171 
ThrowMsg
(
XMLE
, "File Problem");

174 
	gxthCtx
 = 
xmlXPhNewCڋxt
(
doc
);

175 i(
	gxthCtx
 =
NULL
) {

176 
ThrowMsg
(
XMLE
,

179 
	gxthCtx
->
	gnode
 = 
xmlDocGRoEmt
(
doc
);

182 
	gd
::
rg
 
su
;

183 
xmlXPhObjeP
 
	gxthObje
;

185 
	gxthObje
 = 
xmlXPhEvExessi
(
BAD_CAST
 
idPh
.
c_r
(), 
xthCtx
);

186 i(
	gxthObje
 =
NULL
)

188 
ThrowMsg
(
XMLE
, "XPhvui fau: " << 
idPh
);

190 
xmlNodeSP
 
	gnodes
 = 
xthObje
->
nodetv
;

191 
	gsize
 = (
nodes
?odes->
nodeNr
 : 0;

192 
	gi
 = 0; i < 
	gsize
; ++i)

194 i(
	gnodes
->
	gnodeTab
[
i
]->
	gty
 =
XML_ATTRIBUTE_NODE
) {

195 
xmlNodeP
 
curNode
 = 
nodes
->
nodeTab
[
i
];

196 
	gsu
 = 
gXMLNode
(
curNode
);

197 
nmizeXMLTag
(
su
, 
sue
);

198 
	gsM
.

(
make_
(
su
, 
l
));

202 
xmlXPhFeObje
(
xthObje
);

203 
xmlXPhFeCڋxt
(
xthCtx
);

204 
xmlFeDoc
(
doc
);

207 
Cch
(
XMLE
)

209 
	gsucss
 = 
l
;

211 
xmlC˪upPr
();

213 if(!
frByXML
(
sM
))

215 
	gsucss
 = 
l
;

218  
	gsucss
;

221 
bo
 
	gTeRu
::
frByXML
(
d
::
m
<d::
rg
, bo> & 
sM
)

223 
FOREACH
(
group
, 
m_Groups
) {

224 
TeCaSuLi
 
	gwLi
;

225 
FOREACH
(

, 
group
->
cd
)

227 i(
	gsM
.
fd
(

->
me
!
sM
.
d
()) {

228 
sM
[

->
me
] = 
ue
;

229 
	gwLi
.
push_back
(*

);

232 
	ggroup
->
	gcd
 = 
wLi
;

234 
FOREACH
(
cs
, 
sM
)

236 if(
	gcs
->
	gcd
 =
l
)

238  
l
;

241  
	gue
;

244 
	gTeRu
::
Stus
 
TeRu
::
RunTeCa
(cڡ 
TeCaSu
& 
Ca
)

246 
y
 {

247 
Ca
.
oc
();

248 } 
tch
 (cڡ 
TeFaed
 &
e
) {

250 
CResu
(
Ca
.
me
,

252 
TeResusCBa
::
FaStus
::
FAILED
,

253 
e
.
GMesge
());

254  
	gFAILED
;

255 } 
tch
 (cڡ 
Igned
 &
e
) {

256 i(
	gm_runIgned
) {

258 
CResu
(
Ca
.
me
,

260 
TeResusCBa
::
FaStus
::
IGNORED
,

261 
e
.
GMesge
());

264  
	gIGNORED
;

265 } 
tch
 (cڡ 
VceDPL
::
Exi
 &
e
) {

267 
CResu
(
Ca
.
me
,

269 
TeResusCBa
::
FaStus
::
INTERNAL
,

270 "DPLxi:" + 
e
.
GMesge
(+ "\n" +.
DumpToSg
());

272  
	gFAILED
;

273 } 
tch
 (cڡ 
d
::
exi
 &) {

275 
CResu
(
Ca
.
me
,

277 
TeResusCBa
::
FaStus
::
INTERNAL
,

280  
	gFAILED
;

281 } 
tch
 (...) {

283 
CResu
(
Ca
.
me
,

285 
TeResusCBa
::
FaStus
::
INTERNAL
,

288  
	gFAILED
;

291 
CResu
(
Ca
.
me
,

293 
TeResusCBa
::
FaStus
::
NONE
);

296  
	gPASS
;

299 
	gTeRu
::
RunTes
()

301 
usg
 
mea
 
VceDPL
::
Cs
::
Text
;

303 
Br
();

305 
	gcou
 = 0;

306 
FOREACH
(
group
, 
m_Groups
) {

307 
	gcou
 +
group
->
cd
.
size
();

310 
	gd
::
f_ch
(
m_cs
.
beg
(),

311 
m_cs
.
d
(),

312 [
cou
] (cڡ 
TeResusCs
::
vue_ty
 & 
c
)

314 
c
.
cd
->
S
(
cou
);

317 
rtf
(
dr
, "%sFound %des...%s\n", 
GREEN_BEGIN
, 
cou
, 
GREEN_END
);

318 
rtf
(
dr
, "%s%s%s\n", 
GREEN_BEGIN
, "Ruges...", 
GREEN_END
);

319 
FOREACH
(
group
, 
m_Groups
) {

320 
TeCaSuLi
 
	gli
 = 
group
->
cd
;

321 i(!
	gli
.
emy
()) {

322 
	gd
::
f_ch
(

323 
m_cs
.
beg
(),

324 
m_cs
.
d
(),

325 [&
group
](cڡ 
TeResusCs
::
vue_ty
 & 
c
)

327 
c
.
cd
->

328 
CCutTeGroupName
(
group
->
f
);

330 
	gli
.
st
();

332 
	gTeCaSuLi
::
cڡ_
 

 = 
li
.
beg
();

333 
	g
 !
li
.
d
();

334 ++
	g
)

336 
TeCaSu
 
	g
 = *

;

337 i(
	gm_tTeId
 =

.
me
) {

338 
m_tTeId
 = "";

341 i(
	gm_tTeId
.
emy
()) {

342 
RunTeCa
(

);

344 i(
	gm_rme
 =
ue
) {

352 
	gd
::
f_ch
(
m_cs
.
beg
(),

353 
m_cs
.
d
(),

354 [] (cڡ 
TeResusCs
::
vue_ty
 & 
c
)

356 
c
.
cd
->
Fish
();

360 
rtf
(
dr
, "%s%s%s\n\n", 
GREEN_BEGIN
, "Fished", 
GREEN_END
);

363 
	gTeRu
::
CResu
(

364 cڡ 
d
::
rg
& 
id
,

365 cڡ 
d
::
rg
& 
desti
,

366 cڡ 
TeResusCBa
::
FaStus
::
Ty
 
us
,

367 cڡ 
d
::
rg
& 
as
)

369 
d
::
f_ch
(
m_cs
.
beg
(),

370 
m_cs
.
d
(),

371 [&](cڡ 
TeResusCs
::
vue_ty
 & 
c
)

373 
c
.
cd
->
CResu
(
id
,

374 
desti
,

375 
us
,

376 
as
);

380 
	gTeRu
::
Br
()

382 
usg
 
mea
 
VceDPL
::
Cs
::
Text
;

383 
rtf
(
dr
,

385 
BOLD_GREEN_BEGIN
,

387 
BOLD_GREEN_END
);

388 
rtf
(
dr
,

390 
GREEN_BEGIN
,

392 
__TIMESTAMP__
,

393 
GREEN_END
);

396 
	gTeRu
::
InvidArgs
(cڡ 
d
::
rg
& 
mesge
)

398 
usg
 
mea
 
VceDPL
::
Cs
::
Text
;

399 
rtf
(
dr
,

401 
BOLD_RED_BEGIN
,

402 
mesge
.
c_r
(),

403 
BOLD_RED_END
);

406 
	gTeRu
::
Uge
()

408 
rtf
(
dr
, "Usage:unner [options]\n\n");

409 
rtf
(
dr
, "Outputype:\n");

410 
rtf
(
dr
, " --output=<outputype> --output=<outputype> ...\n");

411 
rtf
(
dr
, "\nossible outputypes:\n");

412 
FOREACH
(
ty
, 
TeResusCBa
::
GCsNames
()) {

413 
rtf
(
dr
, " --ouut=%s\n", 
ty
->
c_r
());

415 
rtf
(
dr
, "\nxample:\n");

416 
rtf
(
dr
,

418 
rtf
(
dr
, "Otherarameters:\n");

419 
rtf
(
dr
,

422 
rtf
(
dr
, " --start=<test id>\tStart from concreteest id");

423 
rtf
(
dr
, " --group=<groupame>\t Runests only from one group\n");

424 
rtf
(
dr
, " --runignored\t Runlso ignoredests\n");

425 
rtf
(
dr
, " --list\t Showist of Test IDs\n");

426 
rtf
(
dr
, " --listgroups\t Showist of Test Groupames \n");

427 
rtf
(
dr
, " --only-from-xml=<xml file>\t Run onlyestcases specified in XML file \n"

431 
rtf
(

432 
dr
,

434 
rtf
(
dr
, " --allowchildlogs\t Alloworintogs from childrocess on screen.\n");

435 
rtf
(
dr
, " Whenctive childrocess will bebleorintogs on stdoutnd stderr.\n");

436 
rtf
(
dr
, " Both descriptors will be closedfterest.\n");

437 
rtf
(
dr
, " --help\t This help\n\n");

438 
	gd
::
f_ch
(
m_cs
.
beg
(),

439 
m_cs
.
d
(),

440 [] (cڡ 
TeResusCs
::
vue_ty
 & 
c
)

442 
rtf
(
dr
,

444 
c
.
f
.
c_r
());

445 
rtf
(
dr
,

447 
c
.
cd
->

448 
CScificHp
().
c_r
());

450 
rtf
(
dr
, "For bugeporting,lease writeo:\n");

451 
rtf
(
dr
, "<p.dobrowolsk@samsung.com>\n");

454 
	gTeRu
::
ExecTeRu
(
gc
, *
gv
[])

456 
	gd
::
ve
<
d
::
rg
> 
gs
;

457 
	gi
 = 0; i < 
	ggc
; ++i) {

458 
	ggs
.
push_back
(
gv
[
i
]);

460  
ExecTeRu
(
gs
);

463 
	gTeRu
::
MkAsi
()

465 ++
m_tٮAsis
;

468 
	gTeRu
::
ExecTeRu
(cڡ 
ArgsLi
& 
vue
)

470 
m_runIgned
 = 
l
;

471 
ArgsLi
 
	ggs
 = 
vue
;

473 i(
	ggs
.
size
() == 1) {

474 
InvidArgs
();

475 
Uge
();

479 
	ggs
.
a
(
gs
.
beg
());

481 
bo
 
	gshowHp
 = 
l
;

482 
bo
 
	gjuLi
 = 
l
;

483 
	gd
::
ve
<
d
::
rg
> 
xmlFes
;

485 
TeResusCBaP
 
	gcutC
;

488 
FOREACH
(

, 
gs
)

490 
	gd
::
rg
 
g
 = *

;

491 cڡ 
	gd
::
rg
 
gexp
 = "--regexp=";

492 cڡ 
	gd
::
rg
 
ouut
 = "--output=";

493 cڡ 
	gd
::
rg
 
groupId
 = "--group=";

494 cڡ 
	gd
::
rg
 
runIgned
 = "--runignored";

495 cڡ 
	gd
::
rg
 
liCmd
 = "--list";

496 cڡ 
	gd
::
rg
 
tCmd
 = "--start=";

497 cڡ 
	gd
::
rg
 
liGroupsCmd
 = "--listgroups";

498 cڡ 
	gd
::
rg
 
liInGroup
 = "--listingroup=";

499 cڡ 
	gd
::
rg
 
lowChdLogs
 = "--allowchildlogs";

500 cڡ 
	gd
::
rg
 
lyFromXML
 = "--only-from-xml=";

502 i(
	gcutC
) {

503 i(
	gcutC
->
PCScificArg
(
g
)) {

508 i(
	gg
.
fd
(
tCmd
) == 0) {

509 
g
.
a
(0, 
tCmd
.
ngth
());

510 
FOREACH
(
group
, 
m_Groups
) {

511 
FOREACH
(
tc
, 
group
->
cd
) {

512 i(
	gtc
->
	gme
 =
g
) {

513 
m_tTeId
 = 
g
;

517 i(!
	gm_tTeId
.
emy
()) {

521 i(!
	gm_tTeId
.
emy
()) {

524 
InvidArgs
();

525 
rtf
(
dr
, "Startest id hasot been found\n");

526 
Uge
();

528 } i(
	gg
.
fd
(
groupId
) == 0) {

529 
g
.
a
(0, 
groupId
.
ngth
());

530 
	gTeCaGroupM
::

 
found
 = 
m_Groups
.
fd
(
g
);

531 i(
	gfound
 !
m_Groups
.
d
()) {

532 
d
::
rg
 
me
 = 
found
->
f
;

533 
TeCaSuLi
 
	gwLi
 = 
found
->
cd
;

534 
	gm_Groups
.
r
();

535 
	gm_Groups
[
me
] = 
wLi
;

537 
rtf
(
dr
, "Grou%n found\n", 
g
.
c_r
());

538 
InvidArgs
();

539 
Uge
();

542 } i(
	gg
 =
runIgned
) {

543 
m_runIgned
 = 
ue
;

544 } i(
	gg
 =
liCmd
) {

545 
juLi
 = 
ue
;

546 } i(
	gg
 =
liGroupsCmd
) {

547 
FOREACH
(
group
, 
m_Groups
) {

548 
tf
("GR:%s\n", 
group
->
f
.
c_r
());

551 } i(
	gg
.
fd
(
liInGroup
) == 0) {

552 
g
.
a
(0, 
liInGroup
.
ngth
());

553 
FOREACH
(

, 
m_Groups
[
g
]) {

554 
tf
("ID:%s\n", 

->
me
.
c_r
());

557 } i(
	gg
.
fd
(
lowChdLogs
) == 0) {

558 
g
.
a
(0, 
lowChdLogs
.
ngth
());

559 
	gm_lowChdLogs
 = 
ue
;

560 } i(
	gg
 == "--help") {

561 
showHp
 = 
ue
;

562 } i(
	gg
.
fd
(
ouut
) == 0) {

563 
g
.
a
(0, 
ouut
.
ngth
());

564 i(
	gm_cs
.
fd
(
g
!
m_cs
.
d
()) {

565 
InvidArgs
(

567 
Uge
();

570 
	gcutC
.
t
(
TeResusCBa
::
Ce
(
g
));

571 i(!
	gcutC
) {

572 
InvidArgs
("Unsupported outputype!");

573 
Uge
();

576 
	gm_cs
[
g
] = 
cutC
;

577 } i(
	gg
.
fd
(
gexp
) == 0) {

578 
g
.
a
(0, 
gexp
.
ngth
());

579 i(
	gg
.
ngth
() == 0) {

580 
InvidArgs
();

581 
Uge
();

585 i(
	gg
[0] ='\'' && 
g
[g.
ngth
() - 1] == '\'') {

586 
g
.
a
(0);

587 
	gg
.
a
(
g
.
ngth
() - 1);

590 i(
	gg
.
ngth
() == 0) {

591 
InvidArgs
();

592 
Uge
();

596 
	gpep
::
RE
 

(
g
.
c_r
());

597 
FOREACH
(
group
, 
m_Groups
) {

598 
TeCaSuLi
 
	gwLi
;

599 
FOREACH
(

, 
group
->
cd
)

601 i(
	g
.
PtlMch
(

->
me
)) {

602 
	gwLi
.
push_back
(*

);

605 
	ggroup
->
	gcd
 = 
wLi
;

607 } if(
	gg
.
fd
(
lyFromXML
) == 0) {

608 
g
.
a
(0, 
lyFromXML
.
ngth
());

609 i(
	gg
.
ngth
() == 0) {

610 
InvidArgs
();

611 
Uge
();

615 i(
	gg
[0] ='\'' && 
g
[g.
ngth
() - 1] == '\'') {

616 
g
.
a
(0);

617 
	gg
.
a
(
g
.
ngth
() - 1);

620 i(
	gg
.
ngth
() == 0) {

621 
InvidArgs
();

622 
Uge
();

626 
	gxmlFes
.
push_back
(
g
);

628 
InvidArgs
();

629 
Uge
();

634 if(!
	gxmlFes
.
emy
())

636 if(!
frGroupsByXmls
(
xmlFes
))

638 
rtf
(
dr
, "XML file isot correct\n");

643 if(
	gjuLi
)

645 
FOREACH
(
group
, 
m_Groups
) {

646 
FOREACH
(

, 
group
->
cd
) {

647 
tf
("ID:%s:%s\n", 
group
->
f
.
c_r
(), 

->
me
.c_str());

653 
	gcutC
.
t
();

656 i(
	gshowHp
) {

657 
Uge
();

661 i(
	gm_cs
.
emy
()) {

662 
TeResusCBaP
 
c
(

663 
TeResusCBa
::
Ce
("text"));

664 
	gm_cs
["xt"] = 
c
;

667 aut
	g
 = 
m_cs
.
beg
(); i!m_cs.
d
(); ++it) {

668 i(!
	g
->
	gcd
->
Cfigu
()) {

669 
rtf
(
dr
, "Couldot configure selected output");

675 
RunTes
();

680 
bo
 
	gTeRu
::
gRunIgned
() const

682  
m_runIgned
;

685 
	gTeRu
::
Tme
()

687 
m_rme
 = 
ue
;

690 
bo
 
	gTeRu
::
GAowChdLogs
()

692  
m_lowChdLogs
;

	@vcore/src/dpl/test/src/test_runner_child.cpp

22 
	~<ddef.h
>

23 
	~<d//_ru.h
>

24 
	~<d//_ru_chd.h
>

25 
	~<d//_sus_c.h
>

26 
	~<d/by_queue.h
>

27 
	~<d/exi.h
>

28 
	~<d/sced_.h
>

29 
	~<d/fܗch.h
>

30 
	~<d/cs.h
>

31 
	~<pep.h
>

32 
	~<gܙhm
>

33 
	~<cdio
>

34 
	~<memy.h
>

35 
	~<libg.h
>

36 
	~<crg
>

37 
	~<cdlib
>

38 
	~<ime
>

39 
	~<unid.h
>

40 
	~<pl.h
>

41 
	~<f.h
>

42 
	~<sys/tys.h
>

43 
	~<sys/wa.h
>

44 
	~<sys/.h
>

46 
	gmea
 {

47 cڡ 
	gCHILD_TEST_FAIL
 = 0;

48 cڡ 
	gCHILD_TEST_PASS
 = 1;

49 cڡ 
	gCHILD_TEST_IGNORED
 = 2;

51 
oOuut
() {

52 
	gdevnu
;

53 
	gtcode
 = -1;

54 i(-1 =(
devnu
 = 
TEMP_FAILURE_RETRY
(
ݒ
("/dev/nu", 
O_WRONLY
))))

58 i(-1 =
TEMP_FAILURE_RETRY
(
dup2
(
devnu
, 
STDOUT_FILENO
)))

59 
	gd
;

62 i(-1 =
TEMP_FAILURE_RETRY
(
dup2
(
devnu
, 
STDERR_FILENO
)))

63 
	gd
;

65 
	gtcode
 = 0;

67 
	gd
:

68 
o
(
devnu
);

69  
	gtcode
;

74 
mea
 
	gVceDPL
 {

75 
mea
 
	gTe
 {

77 
	gPeW
::
PeW
()

79 i(-1 =
pe
(
m_pefd
)) {

80 
m_pefd
[0] = 
PIPE_CLOSED
;

81 
	gm_pefd
[1] = 
PIPE_CLOSED
;

85 
	gPeW
::~
PeW
()

87 
oHp
(0);

88 
oHp
(1);

91 
bo
 
	gPeW
::
isRdy
()

93  
m_pefd
[0] !
PIPE_CLOSED
 || m_pipefd[1] != PIPE_CLOSED;

96 
	gPeW
::
tUge
(
Uge
 
uge
)

98 i(
uge
 =
READONLY
) {

99 
oHp
(1);

101 i(
	guge
 =
WRITEONLY
) {

102 
oHp
(0);

106 
	gPeW
::
Stus
 
PeW
::
nd
(
code
, 
d
::
rg
 &
mesge
)

108 i(
m_pefd
[1] =
PIPE_CLOSED
) {

109  
ERROR
;

112 
	gd
::
orgam
 
ouut
;

113 
	gouut
 << 
toBySg
(
code
);

114 
	gouut
 << 
toBySg
(
ic_
<>(
mesge
.
size
()));

115 
	gouut
 << 
	gmesge
;

117 
	gd
::
rg
 
by
 = 
ouut
.
r
();

118 
	gsize
 = 
by
.
size
();

120 i((
wreHp
(&
size
,

121 ()=
ERROR
) ||

122 (
wreHp
(
by
.
c_r
(), 
size
=
ERROR
))

124  
ERROR
;

126  
	gSUCCESS
;

129 
	gPeW
::
Stus
 
PeW
::
ive
(&
code
, 
d
::
rg
 &
da
, 
time_t
 
ddle
)

131 i(
	gm_pefd
[0] =
PIPE_CLOSED
) {

132  
ERROR
;

135 
	gsize
;

136 
Stus
 
	gt
;

138 i((
	gt
 = 
adHp
(&
size
, (), 
ddle
)!
SUCCESS
) {

139  
t
;

142 
	gd
::
ve
<> 
bufr
;

143 
	gbufr
.
size
(
size
);

145 i((
	gt
 = 
adHp
(&
bufr
[0], 
size
, 
ddle
)!
SUCCESS
) {

146  
t
;

149 
	gy
 {

150 
	gVceDPL
::
ByQueue
 
queue
;

151 
	gqueue
.
AdCy
(&
bufr
[0], 
size
);

153 
	gqueue
.
FωCsume
(&
code
, ());

154 
	gqueue
.
FωCsume
(&
size
, ());

156 
	gbufr
.
size
(
size
);

158 
	gqueue
.
FωCsume
(&
bufr
[0], 
size
);

159 
	gda
.
assign
(
bufr
.
beg
(), bufr.
d
());

160 } 
tch
 (
VceDPL
::
ByQueue
::
Exi
::
Ba
 &
e
) {

161  
ERROR
;

163  
	gSUCCESS
;

166 
	gPeW
::
oA
()

168 
oHp
(0);

169 
oHp
(1);

172 
	gd
::
rg
 
PeW
::
toBySg
(
da
)

174 
bufr
[()];

175 
memy
(
bufr
, &
da
, ());

176  
	gd
::
rg
(
bufr
, buffer + ());

179 
	gPeW
::
oHp
(
desc
)

181 i(
m_pefd
[
desc
] !
PIPE_CLOSED
) {

182 
TEMP_FAILURE_RETRY
(
o
(
m_pefd
[
desc
]));

183 
	gm_pefd
[
desc
] = 
PIPE_CLOSED
;

187 
	gPeW
::
Stus
 
PeW
::
wreHp
(cڡ *
bufr
, 
size
)

189 
	gady
 = 0;

190 cڡ *
	gp
 = 
ic_
<cڡ *>(
bufr
);

191 
	gady
 !
size
) {

192 
t
 = 
wre
(
m_pefd
[1], &
p
[
ady
], 
size
 -eady);

194 i(
	gt
 =-1 && (
o
 =
EAGAIN
 ||n=
EINTR
)) {

198 i(
	gt
 == -1) {

199 
oHp
(1);

200  
	gERROR
;

203 
	gady
 +
t
;

205  
	gSUCCESS
;

208 
	gPeW
::
Stus
 
PeW
::
adHp
(*
buf
, 
size
, 
time_t
 
ddle
)

210 
	gady
 = 0;

211 *
	gbufr
 = 
ic_
<*>(
buf
);

212 
	gady
 !
size
) {

213 
time_t
 
wa
 = 
ddle
 - 
time
(0);

214 
	gwa
 = 
wa
 < 1 ? 1 : wait;

215 
plfd
 
	gfds
 = { 
m_pefd
[0], 
POLLIN
, 0 };

217 
	gplRu
 = 
pl
(&
fds
, 1, 
wa
 * 1000);

219 i(
	gplRu
 == 0) {

220  
TIMEOUT
;

223 i(
	gplRu
 < -1) {

224  
	gERROR
;

227 
	gt
 = 
ad
(
m_pefd
[0], &
bufr
[
ady
], 
size
 -eady);

229 i(
	gt
 =-1 && (
o
 =
EAGAIN
 ||n=
EINTR
)) {

233 i(
	gt
 =-1 || 
t
 == 0) {

234 
oHp
(0);

235  
	gERROR
;

238 
	gady
 +
t
;

240  
	gSUCCESS
;

243 
RunChdProc
(
TeRu
::
TeCa
 
ocChd
)

245 
PeW
 
pe
;

246 i(!
	gpe
.
isRdy
()) {

247 
throw
 
	gTeRu
::
TeFaed
("Pipe creation failed");

250 
pid_t
 
	gpid
 = 
fk
();

252 i(
	gpid
 == -1) {

253 
throw
 
TeRu
::
TeFaed
("Child creation failed");

256 i(
	gpid
 != 0) {

258 
pe
.
tUge
(
PeW
::
READONLY
);

260 
	gcode
;

261 
	gd
::
rg
 
mesge
;

263 
	gpeRu
 = 
pe
.
ive
(
code
, 
mesge
, 
time
(0) + 10);

265 i(
	gpeRu
 !
PeW
::
SUCCESS
) {

266 
pe
.
oA
();

267 
kl
(
pid
, 
SIGKILL
);

270 
	gus
;

271 
wapid
(
pid
, &
us
, 0);

273 i(
	gpeRu
 =
PeW
::
TIMEOUT
) {

274 
throw
 
TeRu
::
TeFaed
("Timeout");

277 i(
	gpeRu
 =
PeW
::
ERROR
) {

278 
throw
 
TeRu
::
TeFaed
("Readingiperror");

281 i(
	gcode
 =
CHILD_TEST_FAIL
) {

282 
throw
 
TeRu
::
TeFaed
(
mesge
);

283 } i(
	gcode
 =
CHILD_TEST_IGNORED
) {

284 
throw
 
TeRu
::
Igned
(
mesge
);

290 
	gTeRuSgt
::
In
().
Tme
();

292 
	gcode
 = 
CHILD_TEST_PASS
;

293 
	gd
::
rg
 
msg
;

295 
bo
 
	glowLogs
 = 
TeRuSgt
::
In
().
GAowChdLogs
();

297 
o
(
STDIN_FILENO
);

298 i(!
	glowLogs
) {

299 
oOuut
();

302 
	gpe
.
tUge
(
PeW
::
WRITEONLY
);

304 
	gy
 {

305 
ocChd
();

306 } 
tch
 (cڡ 
VceDPL
::
Te
::
TeRu
::
TeFaed
 &
e
) {

307 
msg
 = 
e
.
GMesge
();

308 
	gcode
 = 
CHILD_TEST_FAIL
;

309 } 
tch
 (cڡ 
VceDPL
::
Te
::
TeRu
::
Igned
 &
e
) {

310 
msg
 = 
e
.
GMesge
();

311 
	gcode
 = 
CHILD_TEST_IGNORED
;

312 } 
tch
 (...) {

313 
	gmsg
 = "unhandledxeception";

314 
	gcode
 = 
CHILD_TEST_FAIL
;

317 i(
	glowLogs
) {

318 
oOuut
();

321 
	gpe
.
nd
(
code
, 
msg
);

	@vcore/src/dpl/test/src/test_runner_multiprocess.cpp

23 
	~<sys/fe.h
>

24 
	~<d//_ru.h
>

25 
	~<d//_ru_chd.h
>

26 
	~<d//_ru_muɝross.h
>

27 
	~<pl.h
>

28 
	~<lims.h
>

29 
	~<sys/wa.h
>

30 
	~<unid.h
>

32 
	gmea
 {

34 cڡ 
	gMULTI_TEST_ERROR
 = -1;

35 cڡ 
	gMULTI_TEST_PASS
 = 0;

36 cڡ 
	gMULTI_TEST_FAILED
 = 1;

37 cڡ 
	gMULTI_TEST_IGNORED
 = 2;

38 cڡ 
	gMULTI_TEST_INTERNAL
 = 3;

42 
mea
 
	gVceDPL
 {

43 
mea
 
	gTe
 {

45 
	gSimePeW
::
SimePeW
()

46 : 
PeW
()

51 
SimePeW
::~SimplePipeWrapper()

56 
PeW
::
Stus
 
SimePeW
::
nd
(
d
::
rg
 &
mesge
)

58 i(
m_pefd
[1] =
PIPE_CLOSED
) {

59  
ERROR
;

62 i(
	gmesge
.
size
(> 
	gPIPE_BUF
-1) {

63  
	gERROR
;

66 
	gbufr
[
PIPE_BUF
] = { 0 };

69 
	gi
 = 0; i < 
	gmesge
.
size
(); ++i) {

70 
	gbufr
[
i
] = 
mesge
[i];

73  
wreHp
(
bufr
, 
PIPE_BUF
);

76 
	gPeW
::
Stus
 
SimePeW
::
ive
(
d
::
rg
 &
da
, 
bo
 &
emy
, 
time_t
 
ddle
)

78 i(
	gm_pefd
[0] =
PIPE_CLOSED
) {

79  
ERROR
;

82 
	gemy
 = 
l
;

84 
	gda
.
size
(
PIPE_BUF
);

86 
	gbufr
[
PIPE_BUF
] = { 0 };

88 
	gady
 = 0;

89 
	gady
 !
PIPE_BUF
) {

90 
time_t
 
wa
 = 
ddle
 - 
time
(0);

91 
	gwa
 = 
wa
 < 1 ? 1 : wait;

92 
plfd
 
	gfds
 = { 
m_pefd
[0], 
POLLIN
, 0 };

94 
	gplRu
 = 
pl
(&
fds
, 1, 
wa
 * 1000);

96 i(
	gplRu
 == 0) {

97  
TIMEOUT
;

100 i(
	gplRu
 < -1) {

101  
	gERROR
;

103 
	gt
 = 
ad
(
m_pefd
[0], &
bufr
[
ady
], 
PIPE_BUF
 -eady);

104 i(
	gt
 =-1 && (
o
 =
EAGAIN
 ||n=
EINTR
)) {

108 i(
	gt
 == -1) {

109 
oHp
(0);

110  
	gERROR
;

112 i(
	gt
 == 0) {

113 
emy
 = 
ue
;

117 
	gady
 +
t
;

121 
	gi
 = 0; i < 
	gPIPE_BUF
; ++i){

122 if(
	gbufr
[
i
] == 0) {

123 
da
.
size
(
i
);

124  
	gSUCCESS
;

126 
	gda
[
i
] = 
bufr
[i];

129  
	gERROR
;

132 
RunMuiProc
(
TeRu
::
TeCa
 
ocMui
)

134 
SimePeW
 
pe
;

135 
	gcode
 = 
MULTI_TEST_PASS
;

136 
	gd
::
rg
 
msg
 = "";

137 
	gpeRu
;

139 
	gwaStus
;

141 
pid_t
 
	gt_pid
 = 
gpid
();

143 i(!
	gpe
.
isRdy
()) {

144 
throw
 
	gTeRu
::
TeFaed
("Pipe creation failed");

148 
	gy
 {

149 
ocMui
();

150 } 
tch
 (cڡ 
TeRu
::
TeFaed
 &
e
) {

151 
code
 = 
MULTI_TEST_FAILED
;

152 
	gmsg
 = 
e
.
GMesge
();

153 } 
tch
 (cڡ 
TeRu
::
Igned
 &
e
) {

154 
code
 = 
MULTI_TEST_IGNORED
;

155 
	gmsg
 = 
e
.
GMesge
();

156 } 
tch
 (cڡ 
VceDPL
::
Exi
 &
e
) {

157 
code
 = 
MULTI_TEST_INTERNAL
;

158 
	gmsg
 = "DPLxi:" + 
e
.
GMesge
();

159 } 
tch
 (cڡ 
d
::
exi
 &) {

160 
code
 = 
MULTI_TEST_INTERNAL
;

161 
	gmsg
 = "stdxception";

162 } 
tch
 (...) {

164 
	gcode
 = 
MULTI_TEST_INTERNAL
;

165 
	gmsg
 = "unknownxception";

168 
	gue
) {

169 
pid_t
 
	gchd_pid
 = 
wa
(&
waStus
);

170 i(
	gchd_pid
 == -1) {

171 i(
o
 =
ECHILD
) {

172 i(
t_pid
 =
gpid
()) {

173 
d
::
rg
 
cMsg
="";

175 
	gpe
.
tUge
(
PeW
::
READONLY
);

177 
bo
 
	gemy
=
l
;

178 
	gue
) {

179 
	gpeRu
 = 
pe
.
ive
(
cMsg
, 
emy
, 
time
(0) + 10);

181 i(
	gemy
) {

184 i(
	gpeRu
 =
PeW
::
ERROR
) {

185 
pe
.
oA
();

186 
throw
 
	gTeRu
::
TeFaed
("Readingiperror");

187 } i(
	gpeRu
 =
PeW
::
TIMEOUT
) {

188 
pe
.
oA
();

189 
throw
 
	gTeRu
::
TeFaed
("Timeoutrror");

191 
	gmsg
 = 
msg
 + "\n" + 
cMsg
;

193 
	gpe
.
oA
();

195 
	gcode
) {

196 
	gMULTI_TEST_PASS
:

198 
	gMULTI_TEST_FAILED
:

199 
throw
 
TeRu
::
TeFaed
(
msg
);

200 
	gMULTI_TEST_IGNORED
:

201 
throw
 
TeRu
::
Igned
(
msg
);

202 
	gMULTI_TEST_INTERNAL
:

203 
throw
 
TeRu
::
TeFaed
(
msg
);

205 
throw
 
TeRu
::
TeFaed
(
msg
);

208 
	gpe
.
tUge
(
PeW
::
WRITEONLY
);

210 
	gpeRu
 = 
pe
.
nd
(
msg
);

212 i(
	gpeRu
 =
PeW
::
ERROR
) {

213 
pe
.
oA
();

214 
	gcode
 = 
MULTI_TEST_ERROR
;

217 
ex
(
code
);

220 } i(
WIFEXITED
(
waStus
)) {

221 i((sigd )
WEXITSTATUS
(
waStus
=
MULTI_TEST_FAILED
) {

222 
code
) {

223 
MULTI_TEST_PASS
:

224 
code
 = 
MULTI_TEST_FAILED
;

226 
	gMULTI_TEST_FAILED
:

228 
	gMULTI_TEST_IGNORED
:

229 
code
 = 
MULTI_TEST_FAILED
;

231 
	gMULTI_TEST_INTERNAL
:

236 } i((sigd )
WEXITSTATUS
(
waStus
=
MULTI_TEST_IGNORED
) {

237 
code
) {

238 
MULTI_TEST_PASS
:

239 
code
 = 
MULTI_TEST_IGNORED
;

241 
	gMULTI_TEST_FAILED
:

243 
	gMULTI_TEST_IGNORED
:

245 
	gMULTI_TEST_INTERNAL
:

250 } i((sigd )
WEXITSTATUS
(
waStus
=
MULTI_TEST_INTERNAL
) {

251 
code
) {

252 
MULTI_TEST_PASS
:

253 
code
 = 
MULTI_TEST_INTERNAL
;

255 
	gMULTI_TEST_FAILED
:

256 
code
 = 
MULTI_TEST_INTERNAL
;

258 
	gMULTI_TEST_IGNORED
:

259 
code
 = 
MULTI_TEST_INTERNAL
;

261 
	gMULTI_TEST_INTERNAL
:

266 } i((sigd )
WEXITSTATUS
(
waStus
!
MULTI_TEST_PASS
) {

267 
code
 = 
MULTI_TEST_ERROR
;

268 
	gmsg
 = "PROCESS BAD CODE RETURN";

	@vcore/src/dpl/test/src/value_separated_policies.cpp

22 
	~<d//vue_d_pics.h
>

23 
	~<d/fܗch.h
>

25 
mea
 
	gVceDPL
 {

27 
	gd
::
rg
 
CSVTokizPicy
::
GSs
()

32 
bo
 
	gCSVTokizPicy
::
SkEmy
()

34  
l
;

37 
	gCSVTokizPicy
::
PVue
(
d
::
rg
 &)

41 
bo
 
CSVTokizPicy
::
TryAgaAtEnd
()

43  
l
;

46 
bo
 
	gCSVPrPicy
::
SkLe
(cڡ 
d
::
ve
<d::
rg
> & )

48  
l
;

51 
bo
 
	gCSVPrPicy
::
Vide
(
d
::
shed_r
<d::
ve
<d::ve<d::
rg
> > > & 
su
)

53 
num
 = -1;

54 
FOREACH
(
r
, *
su
)

56 
	gsize
 = 
r
->
size
();

57 if(
	gnum
 !-1 && 
num
 !
size
)

58  
l
;

60 
	gnum
 = 
size
;

62  
	gue
;

	@vcore/src/dpl/test/src/value_separated_tokens.cpp

22 
	~<d//vue_d_toks.h
>

24 
mea
 
	gVceDPL
 {

26 
	gVSTok
::
VSTok
(cڡ 
d
::
rg
 & 
c
: 
m_wle
(
l
), 
m_
(c)

30 
	gVSTok
::
VSTok
(: 
m_wle
(
ue
)

34 cڡ 
d
::
rg
 & 
VSTok
::

() const

36  
m_
;

39 
bo
 
	gVSTok
::
isNewLe
()

41  
m_wle
;

	@vcore/src/orm/orm_generator_vcore.h

17 #ide
ORM_GENERATOR_VCORE_H


18 
	#ORM_GENERATOR_VCORE_H


	)

20 
	#ORM_GENERATOR_DATABASE_NAME
 
vce_db_defis


	)

21 
	~<d/db/m_g.h
>

22 #unde
ORM_GENERATOR_DATABASE_NAME


	@vcore/src/orm/vcore_db_sql_generator.h

19 
	~<d/db/m_maos.h
>

21 
	~"vce_db_defis
"

	@vcore/src/server/include/cert-server-logic.h

23 #ide
CERT_SVC_SERVER_MAIN_H_


24 
	#CERT_SVC_SERVER_MAIN_H_


	)

26 
	~<db-ut.h
>

28 
gCtifiDaFromSte
(
sqle3
 *
db_hd
, 
eTy
, 
Ty
, cڡ * 
pGme
, * 
pCtBufr
, 
size_t
 *
Lgth
);

30 
gCtifiDaFromSyemSte
(
sqle3
 *
db_hd
, cڡ * 
pGme
, * 
pCtBufr
, 
size_t
 *
Lgth
);

32 
deCtifiFromSte
(
sqle3
 *
db_hd
, 
eTy
, cڡ * 
pGme
);

34 
gCtifiStusFromSte
(
sqle3
 *
db_hd
, 
eTy
, cڡ * 
pGme
, *
us
);

36 
tCtifiStusToSte
(
sqle3
 *
db_hd
, 
eTy
, 
is_ro_p
, cڡ * 
pGme
, 
us
);

38 
checkAlsExisInSte
(
sqle3
 *
db_hd
, 
eTy
, cڡ * 
s
, *
us
);

40 
lCtifiToSte
(
sqle3
 *
db_hd
, 
eTy
, cڡ * 
pGme
, cڡ *
comm_me
, cڡ *
ive_key_gme
, cڡ *
assocd_gme
, cڡ *
pCtBufr
, 
size_t
 
Lgth
, 
Ty
);

42 
gCtifiLiFromSte
(
sqle3
 *
db_hd
, 
qTy
, 
eTy
, 
is_ro_p
, **
CtLiBufr
, 
size_t
 *
bufrL
, *
Cou
);

44 
gCtifiAlsFromSte
(
sqle3
 *
db_hd
, 
eTy
, cڡ * 
pGme
, * 
s
);

46 
ldCtifisFromSte
(
sqle3
 *
db_hd
, 
eTy
, cڡ * 
pGme
, **
CtBlockBufr
, 
size_t
 *
bufrL
, *
BlockCou
);

48 
upde__ifi_fe
(
sqle3
 *
db_hd
, *
Bufr
, 
size_t
 
Lgth
);

	@vcore/src/server/src/cert-server-logic.c

23 
	~<unid.h
>

24 
	~<sys/tys.h
>

25 
	~<sys/.h
>

26 
	~<f.h
>

27 
	~<o.h
>

28 
	~<rg.h
>

29 
	~<glib.h
>

30 
	~<dt.h
>

31 
	~<sys/smack.h
>

32 
	~<sys/sock.h
>

34 
	~<ckmc/ckmc-mag.h
>

35 
	~<ckmc/ckmc-r.h
>

37 
	~<-rvi.h
>

38 
	~<-rvi-debug.h
>

39 
	~<-svc/.h
>

40 
	~<-svc/c.h
>

41 
	~<-svc-.h
>

43 
	~<-rv-logic.h
>

45 *
	$add_shed_owr_efix
(cڡ *
me
)

47 
size_t
 
s_n
 = 
	`
(
me
+ sn(
ckmc_b_shed_owr
+ sn(
ckmc_b_me_t
);

48 *
ckm_s
 = (*)
	`mloc
(
s_n
 + 1);

49 i(!
ckm_s
) {

50 
	`SLOGE
("Failedollocate memory");

51  
NULL
;

53 
	`memt
(
ckm_s
, 0, 
s_n
 + 1);

54 
	`t
(
ckm_s
, 
ckmc_b_shed_owr
, 
s_n
 + 1);

55 
	`t
(
ckm_s
, 
ckmc_b_me_t
, 
s_n
 + 1 - 
	`
(
ckmc_b_shed_owr
));

56 
	`t
(
ckm_s
, 
me
, 
s_n
 + 1 - 
	`
(
ckmc_b_shed_owr
+ sn(
ckmc_b_me_t
));

58  
ckm_s
;

59 
	}
}

61 
	$ckmc_move_s_wh_shed_owr_efix
(cڡ *
me
, *
su
)

63 *
ckm_s
 = 
	`add_shed_owr_efix
(
me
);

64 i(!
ckm_s
) {

65 
	`SLOGE
("Failedollocate memory");

66  
CERTSVC_BAD_ALLOC
;

69 *
su
 = 
	`ckmc_move_s
(
ckm_s
);

71 
	`
(
ckm_s
);

73  
CERTSVC_SUCCESS
;

74 
	}
}

76 *
	$g_come_th
(cڡ *
r1
, cڡ *
r2
)

78 *
su
 = 
NULL
;

79 
as_su
;

81 i(!
r1
 || !
r2
)

82  
NULL
;

84 i(
r1
[
	`
(str1) - 1] != '/')

85 
as_su
 = 
	`artf
(&
su
, "%s/%s", 
r1
, 
r2
);

87 
as_su
 = 
	`artf
(&
su
, "%s%s", 
r1
, 
r2
);

89 i(
as_su
 >
CERTSVC_SUCCESS
)

90  
su
;

92  
NULL
;

93 
	}
}

96 
	$add_fe_to_d
(cڡ * 
d
, cڡ * 
pGme
, cڡ * 
pDa
, 
size_t
 
daL
)

98 *
syemFe
 = 
	`g_come_th
(
d
, 
pGme
);

99 i(!
syemFe
) {

100 
	`SLOGE
("Failedo get system fileath.");

101  
CERTSVC_FAIL
;

104 
Fe
[
FILENAME_MAX
] = {0};

105 i(!
	`th
(
syemFe
, 
Fe
)) {

106 
	`SLOGE
("Faedgͩh. syemFe[%s]", 
syemFe
);

107  
CERTSVC_FAIL
;

110 
FILE
 *
am
 = 
	`fݒ
(
Fe
, "ab");

111 i(!
am
) {

112 
	`SLOGE
("Faݒ f[%s]", 
Fe
);

113  
CERTSVC_FAIL
;

116 i(
	`fwre
(
pDa
, (), 
daL
, 
am
) != dataLen) {

117 
	`SLOGE
("Failo write file in system store.");

118 
	`fo
(
am
);

119  
CERTSVC_FAIL
;

122 
	`fo
(
am
);

123  
CERTSVC_SUCCESS
;

124 
	}
}

126 
	$add_fe_to_syem__d
(cڡ * 
pGme
, cڡ * 
pDa
, 
size_t
 
daL
)

128  
	`add_fe_to_d
(
SYSTEM_CERT_DIR
, 
pGme
, 
pDa
, 
daL
);

129 
	}
}

132 
	$d_fe_om_d
(cڡ * 
d
, cڡ *
pGme
)

134 cڡ *
syemFe
 = 
	`g_come_th
(
d
, 
pGme
);

135 i(!
syemFe
) {

136 
	`SLOGE
("Failedo construct source fileath.");

137  
CERTSVC_FAIL
;

140 
Fe
[
FILENAME_MAX
] = {0};

141 i(!
	`th
(
syemFe
, 
Fe
)) {

142 
	`SLOGE
("Faedgͩh. syemFe[%s]", 
syemFe
);

143  
CERTSVC_FAIL
;

147 
FILE
 *
am
 = 
	`fݒ
(
Fe
, "wb");

148 i(!
am
) {

149 
	`SLOGE
("Faedݒhff wrg, [%s].", 
Fe
);

150  
CERTSVC_FAIL
;

153 
	`fo
(
am
);

154  
CERTSVC_SUCCESS
;

155 
	}
}

157 
	$d_fe_om_syem__d
(cڡ *
pGme
)

159  
	`d_fe_om_d
(
SYSTEM_CERT_DIR
, 
pGme
);

160 
	}
}

162 
	$execu__upde_quy
(
sqle3
 *
db_hd
, *
quy
)

164 i(!
db_hd
) {

165 
	`SLOGE
("Databaseot initialised.");

166  
CERTSVC_WRONG_ARGUMENT
;

169 i(!
quy
) {

170 
	`SLOGE
("Query is NULL.");

171  
CERTSVC_WRONG_ARGUMENT
;

175 
su
 = 
	`sqle3_exec
(
db_hd
, "BEGIN EXCLUSIVE", 
NULL
, NULL, NULL);

176 i(
su
 !
SQLITE_OK
) {

177 
	`SLOGE
("Failedo beginransaction.");

178  
CERTSVC_FAIL
;

182 
su
 = 
	`sqle3_exec
(
db_hd
, 
quy
, 
NULL
, NULL, NULL);

183 i(
su
 !
SQLITE_OK
) {

184 
	`SLOGE
("Faedexecu quy (%s).", 
quy
);

185  
CERTSVC_FAIL
;

189 
su
 = 
	`sqle3_exec
(
db_hd
, "COMMIT", 
NULL
, NULL, NULL);

190 i(
su
) {

191 
	`SLOGE
("Failedo commitransaction. Roll backow.");

192 
su
 = 
	`sqle3_exec
(
db_hd
, "ROLLBACK", 
NULL
, NULL, NULL);

193 i(
su
 !
SQLITE_OK
)

194 
	`SLOGE
("Failedo commitransaction. Roll backow.");

196  
CERTSVC_FAIL
;

199 
	`SLOGD
("Transaction Commitnd End.");

201  
CERTSVC_SUCCESS
;

202 
	}
}

204 
	$execu__quy
(
sqle3
 *
db_hd
, *
quy
, 
sqle3_mt
 **
mt
)

206 i(!
db_hd
 || !
quy
)

207  
CERTSVC_WRONG_ARGUMENT
;

209 
sqle3_mt
 *
mts
 = 
NULL
;

210 i(
	`sqle3_e_v2
(
db_hd
, 
quy
, 
	`
(quy), &
mts
, 
NULL
!
SQLITE_OK
) {

211 
	`SLOGE
("sqle3_e_v2 faed [%s].", 
quy
);

212  
CERTSVC_FAIL
;

215 *
mt
 = 
mts
;

216  
CERTSVC_SUCCESS
;

217 
	}
}

219 
	$wre_to_fe
(cڡ *
feName
, cڡ *
mode_of_wrg
, cڡ *
Bufr
, 
size_t
 
Lgth
)

221 
su
 = 
CERTSVC_SUCCESS
;

222 
FILE
 *
_wre
 = 
NULL
;

224 i(!
Bufr
 || 
Lgth
 <= 0) {

225 
	`SLOGE
("Input buffer is NULL.");

226  
CERTSVC_WRONG_ARGUMENT
;

229 i(!(
_wre
 = 
	`fݒ
(
feName
, 
mode_of_wrg
))) {

230 
	`SLOGE
("Faedݒhff wrg, [%s].", 
feName
);

231  
CERTSVC_FAIL
;

235 i(
	`rcmp
(
mode_of_wrg
,"ab") == 0)

236 
	`fek
(
_wre
, 0L, 
SEEK_END
);

238 i(
	`fwre
(
Bufr
, (), 
Lgth
, 
_wre
) != certLength) {

239 
	`SLOGE
("Failo write into file.");

240 
su
 = 
CERTSVC_FAIL
;

241 
r
;

245 
	`fwre
("\n",(), 1, 
_wre
);

247 
r
:

248 i(
_wre
)

249 
	`fo
(
_wre
);

251  
su
;

252 
	}
}

254 
	$wre_to___t_fe
(cڡ *
mode_of_wrg
, cڡ *
Bufr
, 
size_t
 
Lgth
)

256  
	`wre_to_fe
(
CERTSVC_CRT_FILE_PATH
, 
mode_of_wrg
, 
Bufr
, 
Lgth
);

257 
	}
}

259 
	$veCtifiToSte
(

260 cڡ *
pGme
,

261 cڡ *
pDa
,

262 
size_t
 
daL
)

264 i(!
pGme
 || !
pDa
 || 
daL
 < 1) {

265 
	`SLOGE
("Invalid inputarameterassed.");

266  
CERTSVC_WRONG_ARGUMENT
;

269 
ckmc_picy_s
 
_picy
;

270 
_picy
.
sswd
 = 
NULL
;

271 
_picy
.
exaab
 = 
ue
;

273 
ckmc_w_bufr_s
 
_da
;

274 
_da
.
da
 = (*)
pDa
;

275 
_da
.
size
 = 
daL
;

277 *
ckm_s
 = 
	`add_shed_owr_efix
(
pGme
);

278 i(!
ckm_s
) {

279 
	`SLOGE
("Failedo makelias. memoryllocationrror.");

280  
CERTSVC_BAD_ALLOC
;

283 
su
 = 
	`ckmc_ve_da
(
ckm_s
, 
_da
, 
_picy
);

284 
	`
(
ckm_s
);

286 i(
su
 !
CKMC_ERROR_NONE
) {

287 
	`SLOGE
("Faedاvued da. ckmcode[%d]", 
su
);

288  
CERTSVC_FAIL
;

291  
CERTSVC_SUCCESS
;

292 
	}
}

294 
	$veCtifiToSyemSte
(

295 cڡ *
pGme
,

296 cڡ *
pDa
,

297 
size_t
 
daL
)

299 i(!
pGme
 || !
pDa
 || 
daL
 < 1) {

300 
	`SLOGE
("Invalid inputarameterassed.");

301  
CERTSVC_WRONG_ARGUMENT
;

304 
su
 = 
	`add_fe_to_syem__d
(
pGme
, 
pDa
, 
daL
);

305 i(
su
 !
CERTSVC_SUCCESS
)

306 
	`SLOGE
("Failedo storehe certificate in store.");

308  
su
;

309 
	}
}

311 
	$g_ifi_bufr_om_e
(

312 
sqle3
 *
db_hd
,

313 
CtSteTy
 
eTy
,

314 cڡ *
pGme
,

315 **
Bufr
,

316 
size_t
 *
Size
)

318 
su
 = 
CERTSVC_SUCCESS
;

319 
cds
 = 0;

320 *
mpBufr
 = 
NULL
;

321 *
quy
 = 
NULL
;

322 
sqle3_mt
 *
mt
 = 
NULL
;

324 i(!
pGme
) {

325 
	`SLOGE
("Invalid inputarameterassed.");

326  
CERTSVC_WRONG_ARGUMENT
;

329 i(
eTy
 !
SYSTEM_STORE
)

330 
quy
 = 
	`sqle3_mtf
("select * from %Q where gname=%Qndnabled=%dnd is_root_app_enabled=%d", \

331 ((
eTy
 =
WIFI_STORE
)? "wifi" : (eTy =
VPN_STORE
)? "vpn" : \

332 (
eTy
 =
EMAIL_STORE
)? "ema" : "s"), 
pGme
, 
ENABLED
, ENABLED);

334 
quy
 = 
	`sqle3_mtf
("select certificate from ssl where gname=%Qndnabled=%dnd is_root_app_enabled=%d", \

335 
pGme
, 
ENABLED
, ENABLED);

337 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

338 i(
su
 !
CERTSVC_SUCCESS
) {

339 
	`SLOGE
("Querying database failed.");

340 
su
 = 
CERTSVC_FAIL
;

341 
r
;

344 
cds
 = 
	`sqle3_
(
mt
);

345 i(
cds
 !
SQLITE_ROW
 ||ecd=
SQLITE_DONE
) {

346 
	`SLOGE
("Nvidecdfound f giv gm[%s].",
pGme
);

347 
su
 = 
CERTSVC_FAIL
;

348 
r
;

351 
mpBufr
 = (*)
	`mloc
((* 
VCORE_MAX_RECV_DATA_SIZE
);

352 i(!
mpBufr
) {

353 
	`SLOGE
("Failollocate memory");

354 
su
 = 
CERTSVC_FAIL
;

355 
r
;

358 
	`memt
(
mpBufr
, 0x00, 
VCORE_MAX_RECV_DATA_SIZE
);

360 i(
eTy
 =
SYSTEM_STORE
)

361 
su
 = 
	`gCtifiDaFromSyemSte
(
db_hd
, 
pGme
, 
mpBufr
, 
Size
);

363 
su
 = 
	`gCtifiDaFromSte
(
db_hd
, 
eTy
, 
PEM_CRT
, 
pGme
, 
mpBufr
, 
Size
);

365 i(
su
 !
CERTSVC_SUCCESS
) {

366 
	`SLOGE
("Failedo setequest data.");

367 
su
 = 
CERTSVC_WRONG_ARGUMENT
;

368 
r
;

371 *
Bufr
 = 
mpBufr
;

373 
r
:

374 i(
su
 !
CERTSVC_SUCCESS
)

375 
	`
(
mpBufr
);

377 i(
quy
)

378 
	`sqle3_
(
quy
);

380 i(
mt
)

381 
	`sqle3_fize
(
mt
);

383  
su
;

384 
	}
}

386 
	$upde__ifi_fe
(
sqle3
 *
db_hd
, *
Bufr
, 
size_t
 
Lgth
)

388 
su
 = 
CERTSVC_SUCCESS
;

389 
cds
 = 0;

390 
cou
 = 0;

391 
cou
 = 0;

392 *
pVue
 = 
NULL
;

393 *
quy
 = 
NULL
;

394 cڡ *
xt
;

395 
sqle3_mt
 *
mt
 = 
NULL
;

397 
eTy
[4] = {
SYSTEM_STORE
, 
WIFI_STORE
, 
VPN_STORE
, 
EMAIL_STORE
};

401 i(
Bufr
 && 
Lgth
 > 0) {

402 
su
 = 
	`wre_to___t_fe
("ab", 
Bufr
, 
Lgth
);

403 i(
su
 !
CERTSVC_SUCCESS
) {

404 
	`SLOGE
("Failedo writeo file.");

405 
su
 = 
CERTSVC_FAIL
;

407 
r_d_ex
;

410 
cou
 < 4) {

412 i(
cou
 == 0)

413 
quy
 = 
	`sqle3_mtf
(" ctifi from s whabd=%dnd is_ro_p_abd=%d", 
ENABLED
, ENABLED);

414 i(
cou
 > 0 && count < 4)

416 
quy
 = 
	`sqle3_mtf
("select gname from %Q where is_root_cert=%dndnabled=%dnd is_root_app_enabled=%d", \

417 ((
cou
 =1)?"wifi":(cou =2)?"v":"ema"), 
ENABLED
, ENABLED, ENABLED);

419 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

420 i(
su
 !
CERTSVC_SUCCESS
) {

421 
	`SLOGE
("Querying database failed.");

422 
xt
;

427 
cds
 = 
	`sqle3_
(
mt
);

428 i(
cds
 !
SQLITE_ROW
 ||ecd=
SQLITE_DONE
) {

429 
su
 = 
CERTSVC_SUCCESS
;

433 i(
cds
 =
SQLITE_ROW
) {

434 
Lgth
 = 0;

435 
Bufr
 = 
NULL
;

436 
pVue
 = 
NULL
;

438 i(
cou
 == 0) {

440 
xt
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0);

441 i(
xt
) {

442 
Lgth
 = 
	`
(
xt
);

443 
Bufr
 = 
	`dup
(
xt
, 
Lgth
);

447 
xt
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0);

448 i(
xt
)

449 
pVue
 = 
	`dup
(
xt
, 
	`
(text));

451 
su
 = 
	`g_ifi_bufr_om_e
(
db_hd
, 
eTy
[
cou
], 
pVue
, &
Bufr
, &
Lgth
);

452 i(
su
 !
CERTSVC_SUCCESS
) {

453 
	`SLOGE
("Failedo get certificate buffer from key-manager.");

454 
r_d_ex
;

458 i(
Bufr
) {

459 i(
cou
++ == 0)

460 
su
 = 
	`wre_to___t_fe
("wb", 
Bufr
, 
Lgth
);

462 
su
 = 
	`wre_to___t_fe
("ab", 
Bufr
, 
Lgth
);

464 i(
su
 !
CERTSVC_SUCCESS
) {

465 
	`SLOGE
("Failedo writeo file.");

466 
su
 = 
CERTSVC_FAIL
;

467 
r_d_ex
;

472 
xt
:

473 
cou
++;

474 i(
quy
) {

475 
	`sqle3_
(
quy
);

476 
quy
 = 
NULL
;

479 
	`SLOGD
("Successfully updated ca-certificate.crt file.");

481 
r_d_ex
:

482 i(
quy
)

483 
	`sqle3_
(
quy
);

485 i(
mt
)

486 
	`sqle3_fize
(
mt
);

488  
su
;

489 
	}
}

491 
	$ab_dib__us
(

492 
sqle3
 *
db_hd
,

493 
CtSteTy
 
eTy
,

494 
is_ro_p
,

495 cڡ *
pGme
,

496 
CtStus
 
us
)

498 
ckmc_su
 = 
CKMC_ERROR_UNKNOWN
;

499 
su
 = 
CERTSVC_SUCCESS
;

500 
cds
 = 0;

501 
size_t
 
Size
 = 0;

502 
size_t
 
Lgth
 = 0;

503 *
Bufr
 = 
NULL
;

504 *
quy
 = 
NULL
;

505 cڡ *
xt
 = 
NULL
;

506 
sqle3_mt
 *
mt
 = 
NULL
;

508 i(
us
 !
DISABLED
 && stu!
ENABLED
) {

509 
	`SLOGE
("Invalid cert status");

510  
CERTSVC_INVALID_STATUS
;

513 
quy
 = 
	`sqle3_mtf
(" * from %Q whgme=%Q", ((
eTy
 =
WIFI_STORE
)? "wifi" : \

514 (
eTy
 =
VPN_STORE
)? "v" : (eTy =
EMAIL_STORE
)? "ema" : "s"), 
pGme
);

515 i(!
quy
) {

516 
	`SLOGE
("Failedo generate query");

517  
CERTSVC_BAD_ALLOC
;

520 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

521 
	`sqle3_
(
quy
);

523 i(
su
 !
CERTSVC_SUCCESS
 || !
mt
) {

524 
	`SLOGE
("Querying database failed.");

525  
CERTSVC_FAIL
;

528 
cds
 = 
	`sqle3_
(
mt
);

529 
	`sqle3_fize
(
mt
);

530 
mt
 = 
NULL
;

532 i(
cds
 !
SQLITE_ROW
) {

533 
	`SLOGE
("No validecords found.");

534  
CERTSVC_FAIL
;

537 i(
us
 =
DISABLED
) {

539 
quy
 = 
	`sqle3_mtf
(" * from dibd_whgme=%Q", 
pGme
);

540 i(!
quy
) {

541 
	`SLOGE
("Failedo generate query");

542  
CERTSVC_BAD_ALLOC
;

545 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

546 
	`sqle3_
(
quy
);

547 
quy
 = 
NULL
;

549 i(
su
 !
CERTSVC_SUCCESS
) {

550 
	`SLOGE
("Querying database failed.");

551  
CERTSVC_FAIL
;

554 
cds
 = 
	`sqle3_
(
mt
);

555 
	`sqle3_fize
(
mt
);

556 
mt
 = 
NULL
;

558 i(
cds
 =
SQLITE_ROW
) {

559 
	`SLOGE
("Seed ctifi idtifiady dibd.", 
pGme
);

560  
CERTSVC_FAIL
;

564 
su
 = 
	`g_ifi_bufr_om_e
(
db_hd
, 
eTy
, 
pGme
, &
Bufr
, &
Size
);

565 i(
su
 !
CERTSVC_SUCCESS
) {

566 
	`SLOGE
("Faedg ctifi bufr.esu[%d]", 
su
);

567  
su
;

571 
quy
 = 
	`sqle3_mtf
(" idibd_(gme, ctifivue(%Q, %Q)", 
pGme
, 
Bufr
);

572 
	`
(
Bufr
);

574 i(!
quy
) {

575 
	`SLOGE
("Failedo generate query");

576  
CERTSVC_BAD_ALLOC
;

579 
su
 = 
	`execu__upde_quy
(
db_hd
, 
quy
);

580 
	`sqle3_
(
quy
);

582 i(
su
 !
CERTSVC_SUCCESS
) {

583 
	`SLOGE
("Inserto database failed.");

584  
su
;

587 i(
eTy
 !
SYSTEM_STORE
) {

588 
su
 = 
	`ckmc_move_s_wh_shed_owr_efix
(
pGme
, &
ckmc_su
);

590 i(
su
 !
CERTSVC_SUCCESS
 || 
ckmc_su
 !
CKMC_ERROR_NONE
) {

591 
	`SLOGE
("Faeddifi from key-mag. ckmc_su[%d]", 
ckmc_su
);

592  
CERTSVC_FAIL
;

596 
su
 = 
	`d_fe_om_syem__d
(
pGme
);

597 i(
su
 !
CERTSVC_SUCCESS
) {

598 
	`SLOGE
("E id_fe_om_syem__d.[%d]", 
su
);

599  
su
;

603 
quy
 = 
	`sqle3_mtf
(" ctifi from dibd_whgme=%Q", 
pGme
);

604 i(!
quy
) {

605 
	`SLOGE
("Failedo generate query");

606  
CERTSVC_BAD_ALLOC
;

609 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

610 
	`sqle3_
(
quy
);

612 i(
su
 !
CERTSVC_SUCCESS
) {

613 
	`SLOGE
("Querying database failed.");

614  
CERTSVC_FAIL
;

617 
cds
 = 
	`sqle3_
(
mt
);

618 i(
cds
 =
SQLITE_ROW
) {

619 
xt
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0);

621 i(!
xt
) {

622 
	`SLOGE
("Invalid columnext");

623 
	`sqle3_fize
(
mt
);

624  
CERTSVC_FAIL
;

627 
Bufr
 = 
	`dup
(
xt
, 
	`
(text));

629 
	`sqle3_fize
(
mt
);

631 i(!
Bufr
) {

632 
	`SLOGE
("Failedollocate memory");

633  
CERTSVC_BAD_ALLOC
;

636 
Lgth
 = 
	`
(
Bufr
);

638 i(
eTy
 =
SYSTEM_STORE
)

639 
su
 = 
	`veCtifiToSyemSte
(
pGme
, 
Bufr
, 
Lgth
);

641 
su
 = 
	`veCtifiToSte
(
pGme
, 
Bufr
, 
Lgth
);

643 
	`
(
Bufr
);

645 i(
su
 !
CERTSVC_SUCCESS
) {

646 
	`SLOGE
("Faedاvifikey-mag.[%d]", 
su
);

647  
su
;

650 
quy
 = 
	`sqle3_mtf
("dom dibd_whgme=%Q", 
pGme
);

651 i(!
quy
) {

652 
	`SLOGE
("Failedo generate query");

653  
CERTSVC_BAD_ALLOC
;

656 
su
 = 
	`execu__upde_quy
(
db_hd
, 
quy
);

657 
	`sqle3_
(
quy
);

659 i(
su
 !
CERTSVC_SUCCESS
) {

660 
	`SLOGE
("Ubˁdifiry from daba.[%d]", 
su
);

661  
su
;

666 i(
is_ro_p
 =
ENABLED
)

667 
quy
 = 
	`sqle3_mtf
("upd%Q s is_ro_p_abd=%d ,bd=%d whgme=%Q", ((
eTy
 =
WIFI_STORE
)? "wifi" : \

668 (
eTy
 =
VPN_STORE
)? "v" : (eTy =
EMAIL_STORE
)? "ema" : "s"), 
us
, stus, 
pGme
);

670 
quy
 = 
	`sqle3_mtf
("upd%Q sbd=%d whgme=%Q", ((
eTy
 =
WIFI_STORE
)? "wifi" : \

671 (
eTy
 =
VPN_STORE
)? "v" : (eTy =
EMAIL_STORE
)? "ema" : "s"), 
us
, 
pGme
);

673 i(!
quy
) {

674 
	`SLOGE
("Failedo generate query");

675  
CERTSVC_BAD_ALLOC
;

678 
su
 = 
	`execu__upde_quy
(
db_hd
, 
quy
);

679 
	`sqle3_
(
quy
);

681 i(
su
 !
CERTSVC_SUCCESS
) {

682 
	`SLOGE
("Upded.[%d]", 
su
);

683  
su
;

686  
su
;

687 
	}
}

689 
	$tCtifiStusToSte
(

690 
sqle3
 *
db_hd
,

691 
eTy
,

692 
is_ro_p
,

693 cڡ *
pGme
,

694 
us
)

696 i(!
pGme
) {

697 
	`SLOGE
("Invalid inputarameterassed.");

698  
CERTSVC_WRONG_ARGUMENT
;

701 
su
 = 
	`ab_dib__us
(
db_hd
, 
eTy
, 
is_ro_p
, 
pGme
, 
us
);

702 i(
su
 !
CERTSVC_SUCCESS
) {

703 
	`SLOGE
("Failedo disable certificate.");

704  
su
;

707 
	`SLOGD
("Successfully updatedhe certificate status from %so %s.",

708 (
us
 =
DISABLED
) ? "ENABLED" : "DISABLED", (status == DISABLED) ? "DISABLED" : "ENABLED");

709  
CERTSVC_SUCCESS
;

710 
	}
}

712 
	$gCtifiStusFromSte
(

713 
sqle3
 *
db_hd
,

714 
eTy
,

715 cڡ * 
pGme
,

716 *
us
)

718 i(!
pGme
) {

719 
	`SLOGE
("Invalid inputarameterassed.");

720  
CERTSVC_WRONG_ARGUMENT
;

723 *
quy
 = 
	`sqle3_mtf
("select gname, common_name,nabled from %Q where gname=%Q",\

724 ((
eTy
 =
WIFI_STORE
)? "wifi" : (eTy =
VPN_STORE
)? "vpn" : \

725 (
eTy
 =
EMAIL_STORE
)? "ema" : "s"), 
pGme
);

726 i(!
quy
) {

727 
	`SLOGE
("Failedo generate query");

728  
CERTSVC_BAD_ALLOC
;

731 
sqle3_mt
 *
mt
 = 
NULL
;

732 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

733 
	`sqle3_
(
quy
);

735 i(
su
 !
CERTSVC_SUCCESS
 || !
mt
) {

736 
	`SLOGE
("Querying database failed.");

737 *
us
 = 
DISABLED
;

738  
CERTSVC_FAIL
;

741 
su
 = 
	`sqle3_
(
mt
);

742 i(
su
 !
SQLITE_ROW
 ||esu =
SQLITE_DONE
) {

743 
	`SLOGE
("No validecords found.");

744 *
us
 = 
DISABLED
;

745 
	`sqle3_fize
(
mt
);

746  
CERTSVC_FAIL
;

749 *
us
 = 
	`sqle3_cumn_t
(
mt
, 2);

751 
	`sqle3_fize
(
mt
);

753  
CERTSVC_SUCCESS
;

754 
	}
}

756 
	$check_s_exi__daba
(

757 
sqle3
 *
db_hd
,

758 
CtSteTy
 
eTy
,

759 cڡ *
s
,

760 *
us
)

762 
sqle3_mt
 *
mt
 = 
NULL
;

764 i(!
s
 || !
us
) {

765 
	`SLOGE
("Invalid inputarameterassed.");

766  
CERTSVC_WRONG_ARGUMENT
;

769 *
quy
 = 
	`sqle3_mtf
(" * from %Q whcomm_me=%Q", ((
eTy
 =
WIFI_STORE
)? "wifi" : \

770 (
eTy
 =
VPN_STORE
)? "v" : "ema"),
s
);

772 i(!
quy
) {

773 
	`SLOGE
("Failedo generate query");

774  
CERTSVC_BAD_ALLOC
;

777 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

778 
	`sqle3_
(
quy
);

780 i(
su
 !
CERTSVC_SUCCESS
 || !
mt
) {

781 
	`SLOGE
("Querying database failed.");

782  
CERTSVC_FAIL
;

785 
su
 = 
	`sqle3_
(
mt
);

786 
	`sqle3_fize
(
mt
);

788 i(
su
 !
SQLITE_ROW
) {

789 
	`SLOGD
("Nػcdfound whhsd (%s).", 
s
);

790 *
us
 = 
CERTSVC_TRUE
;

792 
	`SLOGD
("Recdfound whhsd (%s).", 
s
);

793 *
us
 = 
CERTSVC_FALSE
;

796  
CERTSVC_SUCCESS
;

797 
	}
}

799 
	$lCtifiToSte
(

800 
sqle3
 *
db_hd
,

801 
eTy
,

802 cڡ *
pGme
,

803 cڡ *
comm_me
,

804 cڡ *
ive_key_gme
,

805 cڡ *
assocd_gme
,

806 cڡ *
daBlock
,

807 
size_t
 
daBlockL
,

808 
Ty
)

810 i((!
pGme
)

811 || (
Ty
 =
P12_END_USER
 && !
comm_me
 && !
ive_key_gme
)

812 || (
Ty
 !
P12_END_USER
 && !
comm_me
 && !
assocd_gme
)) {

813 
	`SLOGE
("Invalid inputarameterassed.");

814  
CERTSVC_WRONG_ARGUMENT
;

817 i(
eTy
 !
SYSTEM_STORE


818 && 
	`veCtifiToSte
(

819 
pGme
,

820 
daBlock
,

821 
daBlockL
!
CERTSVC_SUCCESS
) {

822 
	`SLOGE
("FAILo save certificateo key-manager.");

823  
CERTSVC_FAIL
;

826 i(
Ty
 =
P12_PKEY
) {

827 
	`SLOGD
("Don't saverivate key in store");

828  
CERTSVC_SUCCESS
;

831 *
quy
 = 
NULL
;

832 i(
Ty
 =
P12_END_USER
 && 
ive_key_gme
) {

833 
quy
 = 
	`sqle3_mtf
("insert into %Q (gname, common_name,rivate_key_gname,ssociated_gname,nabled, is_root_app_enabled) "\

834 "vue(%Q, %Q, %Q, %Q, %d, %d)",((
eTy
 =
WIFI_STORE
)? "wifi" : \

835 (
eTy
 =
VPN_STORE
)? "v" : "ema"), 
pGme
, 
comm_me
, 
ive_key_gme
,Gme, 
ENABLED
, ENABLED);

836 } i(
Ty
 =
PEM_CRT
 || ctTy =
P12_TRUSTED
) {

837 
quy
 = 
	`sqle3_mtf
("insert into %Q (gname, common_name, is_root_cert,ssociated_gname,nabled, is_root_app_enabled) values "\

838 "(%Q, %Q, %d, %Q, %d, %d)", ((
eTy
 =
WIFI_STORE
)? "wifi" : \

839 (
eTy
 =
VPN_STORE
)? "v" : "ema"), 
pGme
, 
comm_me
, 
ENABLED
, 
assocd_gme
, ENABLED, ENABLED);

840 } i(
Ty
 =
P12_INTERMEDIATE
) {

841 
quy
 = 
	`sqle3_mtf
("insert into %Q (gname, common_name,ssociated_gname,nabled, is_root_app_enabled) values (%Q, %Q, %Q, %d, %d)", \

842 ((
eTy
 =
WIFI_STORE
)? "wifi" : (eTy =
VPN_STORE
)? "vpn" : "email"),

843 
pGme
, 
comm_me
, 
assocd_gme
, 
ENABLED
, ENABLED);

846 i(!
quy
) {

847 
	`SLOGE
("Failedo generate query");

848  
CERTSVC_BAD_ALLOC
;

851 
su
 = 
	`execu__upde_quy
(
db_hd
, 
quy
);

852 
	`sqle3_
(
quy
);

854 i(
su
 !
CERTSVC_SUCCESS
) {

855 
	`SLOGE
("Inserto database failed.");

856  
CERTSVC_FAIL
;

859  
CERTSVC_SUCCESS
;

860 
	}
}

862 
	$checkAlsExisInSte
(

863 
sqle3
 *
db_hd
,

864 
eTy
,

865 cڡ * 
s
,

866 *
us
)

868 i(!
s
) {

869 
	`SLOGE
("Invalid inputarameterassed.");

870  
CERTSVC_WRONG_ARGUMENT
;

873 *
us
 = 
CERTSVC_FAIL
;

874 
su
 = 
	`check_s_exi__daba
(
db_hd
, 
eTy
, 
s
, 
us
);

875 i(
su
 !
CERTSVC_SUCCESS
) {

876 
	`SLOGE
("Faedcheck_s_exi__daba.[%d]", 
su
);

877  
CERTSVC_FAIL
;

880 i(*
us
 =
CERTSVC_TRUE
) {

881 
	`SLOGD
("Alias (%s) doesotxist in %s store.",

882 
s
,

883 (
eTy
 =
VPN_STORE
) ? "VPN" :

884 (
eTy
 =
WIFI_STORE
) ? "WIFI" : "EMAIL");

886 
	`SLOGD
("Alias (%s)xist in %s store.",

887 
s
,

888 (
eTy
 =
VPN_STORE
) ? "VPN" :

889 (
eTy
 =
WIFI_STORE
) ? "WIFI" : "EMAIL");

892  
CERTSVC_SUCCESS
;

893 
	}
}

895 
	$gCtifiDaFromSte
(

896 
sqle3
 *
db_hd
,

897 
eTy
,

898 
Ty
,

899 cڡ *
pGme
,

900 *
pOutDa
,

901 
size_t
 *
size
)

903 
su
 = 
CERTSVC_SUCCESS
;

904 
cds
 = 0;

905 *
quy
 = 
NULL
;

906 cڡ *
xt
 = 
NULL
;

907 
sqle3_mt
 *
mt
 = 
NULL
;

908 
ckmc_w_bufr_s
 *
_da
 = 
NULL
;

910 i(!
pGme
 || !
pOutDa
) {

911 
	`SLOGE
("Invalid inputarameterassed.");

912  
CERTSVC_WRONG_ARGUMENT
;

916 i(
Ty
 =
P12_PKEY
) {

919 
quy
 = 
	`sqle3_mtf
("selectssociated_gname from %Q where gname=%Q", \

920 ((
eTy
 =
WIFI_STORE
)? "wifi" : (eTy =
VPN_STORE
)? "v" : "ema"), 
pGme
);

921 i(!
quy
) {

922 
	`SLOGE
("Failedo generate query");

923  
CERTSVC_BAD_ALLOC
;

926 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

927 
	`sqle3_
(
quy
);

929 i(
su
 !
CERTSVC_SUCCESS
) {

930 
	`SLOGE
("Querying database failed.");

931  
su
;

934 
cds
 = 
	`sqle3_
(
mt
);

935 i(
cds
 !
SQLITE_ROW
) {

936 
	`SLOGE
("No validecords found.");

937 
	`sqle3_fize
(
mt
);

938  
CERTSVC_FAIL
;

941 
xt
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0);

943 i(!
xt
) {

944 
	`SLOGE
("No valid columnext");

945 
	`sqle3_fize
(
mt
);

946  
CERTSVC_FAIL
;

949 
quy
 = 
	`sqle3_mtf
("selectrivate_key_gname from %Q where gname=%Qndnabled=%dnd is_root_app_enabled=%d", \

950 ((
eTy
 =
WIFI_STORE
)? "wifi" : (eTy =
VPN_STORE
)? "v" : "ema"), 
xt
, 
ENABLED
, ENABLED);

952 
	`sqle3_fize
(
mt
);

953 } i(
eTy
 !
SYSTEM_STORE
) {

954 
quy
 = 
	`sqle3_mtf
("select * from %Q where gname=%Qndnabled=%dnd is_root_app_enabled=%d", \

955 ((
eTy
 =
WIFI_STORE
)? "wifi" : (eTy =
VPN_STORE
)? "vpn" : \

956 (
eTy
 =
EMAIL_STORE
)? "ema" : "s"), 
pGme
, 
ENABLED
, ENABLED);

959 i(!
quy
) {

960 
	`SLOGE
("Failedo generate query");

961  
CERTSVC_BAD_ALLOC
;

964 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

965 
	`sqle3_
(
quy
);

967 i(
su
 !
CERTSVC_SUCCESS
) {

968 
	`SLOGE
("Querying database failed.");

969  
su
;

972 
cds
 = 
	`sqle3_
(
mt
);

973 i(
cds
 !
SQLITE_ROW
) {

974 
	`SLOGE
("No validecords found.");

975 
	`sqle3_fize
(
mt
);

976  
CERTSVC_FAIL
;

979 i(
Ty
 =
P12_PKEY
) {

980 i(!(
xt
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0))) {

981 
	`SLOGE
("No valid columnext");

982 
	`sqle3_fize
(
mt
);

983  
CERTSVC_FAIL
;

986 
pGme
 = 
xt
;

989 *
ckm_s
 = 
	`add_shed_owr_efix
(
pGme
);

990 i(!
ckm_s
) {

991 
	`SLOGE
("Failedo makelias. memoryllocationrror.");

992  
CERTSVC_BAD_ALLOC
;

995 
su
 = 
	`ckmc_g_da
(
ckm_s
, 
NULL
, &
_da
);

996 
	`
(
ckm_s
);

998 
	`sqle3_fize
(
mt
);

1000 i(
su
 !
CKMC_ERROR_NONE
) {

1001 
	`SLOGE
("Faedg ctifi from key-mag. ckm[%d]", 
su
);

1002 *
size
 = 
CERTSVC_FAIL
;

1003  
CERTSVC_FAIL
;

1006 
	`memy
(
pOutDa
, 
_da
->
da
, ct_da->
size
);

1007 
pOutDa
[
_da
->
size
] = 0;

1008 *
size
 = 
_da
->size;

1010 
	`ckmc_bufr_
(
_da
);

1012  
CERTSVC_SUCCESS
;

1013 
	}
}

1015 
	$gCtifiDaFromSyemSte
(

1016 
sqle3
 *
db_hd
,

1017 cڡ *
pGme
,

1018 *
pOutDa
,

1019 
size_t
 *
size
)

1021 
su
 = 
CERTSVC_SUCCESS
;

1022 
cds
 = 0;

1023 
size_t
 
Lgth
 = 0;

1024 *
quy
 = 
NULL
;

1025 cڡ *
xt
 = 
NULL
;

1026 
sqle3_mt
 *
mt
 = 
NULL
;

1028 i(!
pGme
) {

1029 
	`SLOGE
("Invalid inputarameterassed.");

1030  
CERTSVC_WRONG_ARGUMENT
;

1033 
quy
 = 
	`sqle3_mtf
("select certificate from ssl where gname=%Qnd is_root_app_enabled=%d", \

1034 
pGme
, 
ENABLED
, ENABLED);

1035 i(!
quy
) {

1036 
	`SLOGE
("Query is NULL.");

1037  
CERTSVC_FAIL
;

1040 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

1041 
	`sqle3_
(
quy
);

1043 i(
su
 !
CERTSVC_SUCCESS
) {

1044 
	`SLOGE
("Querying database failed.");

1045  
su
;

1048 
cds
 = 
	`sqle3_
(
mt
);

1049 i(
cds
 !
SQLITE_ROW
) {

1050 
	`SLOGE
("Nvidecdfound f܅asd gm[%s].", 
pGme
);

1051 
	`sqle3_fize
(
mt
);

1052  
CERTSVC_FAIL
;

1055 
xt
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0);

1057 i(!
xt
) {

1058 
	`SLOGE
("Failo sqlite3_column_text");

1059 
	`sqle3_fize
(
mt
);

1060  
CERTSVC_FAIL
;

1063 
Lgth
 = 
	`
(
xt
);

1064 i(
Lgth
 >= 4096) {

1065 
	`sqle3_fize
(
mt
);

1066 
	`SLOGE
("certificate isooong");

1067  
CERTSVC_FAIL
;

1070 
	`memy
(
pOutDa
, 
xt
, 
Lgth
);

1071 
pOutDa
[
Lgth
] = 0;

1072 *
size
 = 
Lgth
;

1074 
	`sqle3_fize
(
mt
);

1075  
CERTSVC_SUCCESS
;

1076 
	}
}

1078 
	$deCtifiFromSte
(
sqle3
 *
db_hd
, 
eTy
, cڡ * 
pGme
) {

1080 
su
 = 
CERTSVC_SUCCESS
;

1081 
ckmc_su
 = 
CKMC_ERROR_UNKNOWN
;

1082 
cds
 = 0;

1083 *
quy
 = 
NULL
;

1084 *
ive_key_me
 = 
NULL
;

1085 
sqle3_mt
 *
mt
 = 
NULL
;

1087 i(!
pGme
) {

1088 
	`SLOGE
("Invalid inputarameterassed.");

1089  
CERTSVC_WRONG_ARGUMENT
;

1092 i(
eTy
 !
SYSTEM_STORE
) {

1094 
quy
 = 
	`sqle3_mtf
("rive_key_gmom %Q whgme=%Q", ((
eTy
 =
WIFI_STORE
)? "wifi" :\

1095 (
eTy
 =
VPN_STORE
)? "v" : "ema"), 
pGme
);

1097 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

1098 i(
su
 !
CERTSVC_SUCCESS
) {

1099 
	`SLOGE
("Querying database failed.");

1100 
su
 = 
CERTSVC_FAIL
;

1101 
r
;

1104 
cds
 = 
	`sqle3_
(
mt
);

1105 i((
cds
 !
SQLITE_ROW
|| (cd=
SQLITE_DONE
)) {

1106 
	`SLOGE
("Nvidecdfound f܅asd gm[%s].",
pGme
);

1107 
su
 = 
CERTSVC_FAIL
;

1108 
r
;

1113 i(
	`sqle3_cumn_xt
(
mt
, 0!
NULL
) {

1114 
ive_key_me
 = 
	`rdup
((cڡ *)
	`sqle3_cumn_xt
(
mt
, 0));

1115 
su
 = 
	`ckmc_move_s_wh_shed_owr_efix
(
ive_key_me
, &
ckmc_su
);

1116 i(
su
 !
CERTSVC_SUCCESS
 || 
ckmc_su
 !
CKMC_ERROR_NONE
) {

1117 
	`SLOGE
("Faeddifi from key-mag. ckmc_su[%d]", 
ckmc_su
);

1118 
su
 = 
CERTSVC_FAIL
;

1119 
r
;

1124 
su
 = 
	`ckmc_move_s_wh_shed_owr_efix
(
pGme
, &
ckmc_su
);

1125 i(
su
 !
CERTSVC_SUCCESS
 || 
ckmc_su
 !
CKMC_ERROR_NONE
) {

1126 
quy
 = 
	`sqle3_mtf
("dom dibd_whgme=%Q", 
pGme
);

1127 
su
 = 
	`execu__upde_quy
(
db_hd
, 
quy
);

1128 i(
su
 !
CERTSVC_SUCCESS
) {

1129 
	`SLOGE
("Unableo delete certificatentry from database.");

1130 
su
 = 
CERTSVC_FAIL
;

1131 
r
;

1135 i(
quy
) {

1136 
	`sqle3_
(
quy
);

1137 
quy
 = 
NULL
;

1140 i(
mt
) {

1141 
	`sqle3_fize
(
mt
);

1142 
mt
 = 
NULL
;

1145 
quy
 = 
	`sqle3_mtf
("dom %Q whgme=%Q", ((
eTy
 =
WIFI_STORE
)? "wifi" : \

1146 (
eTy
 =
VPN_STORE
)? "v" : "ema"), 
pGme
);

1148 
su
 = 
	`execu__upde_quy
(
db_hd
, 
quy
);

1149 i(
su
 !
CERTSVC_SUCCESS
) {

1150 
	`SLOGE
("Unableo delete certificatentry from database.");

1151 
su
 = 
CERTSVC_FAIL
;

1152 
r
;

1155 
	`SLOGE
("Invalid storeypeassed.");

1156 
su
 = 
CERTSVC_INVALID_STORE_TYPE
;

1158 
	`SLOGD
("Success in deletinghe certificate from store.");

1160 
r
:

1161 i(
quy
)

1162 
	`sqle3_
(
quy
);

1164 i(
mt
)

1165 
	`sqle3_fize
(
mt
);

1167 
	`
(
ive_key_me
);

1168  
su
;

1169 
	}
}

1172 
	$gCtifiLiFromSte
(

1173 
sqle3
 *
db_hd
,

1174 
qTy
,

1175 
eTy
,

1176 
is_ro_p
,

1177 **
LiBufr
,

1178 
size_t
 *
bufrL
,

1179 *
Cou
)

1181 
su
 = 
CERTSVC_SUCCESS
;

1182 
CtSvcSteCtLi
 *
roCtHd
 = 
NULL
;

1183 
CtSvcSteCtLi
 *
tmpNode
 = 
NULL
;

1184 
CtSvcSteCtLi
 *
cutNode
 = 
NULL
;

1185 
sqle3_mt
 *
mt
 = 
NULL
;

1186 *
quy
 = 
NULL
;

1187 
loCou
 = 0;

1188 
cds
 = 0;

1189 
cou
 = 0;

1190 
i
 = 0;

1195 i(
loCou
 =(
MAX_STORE_ENUMS
 - 1))

1199 i((1 << 
loCou
& 
eTy
) {

1201 
CtSteTy
 
mpSte
 = (CtSteTy(1 << 
loCou
);

1202 
	`SLOGD
("Prossg stܑy [%s]", (
mpSte
 =
WIFI_STORE
)? "WIFI" : (mpStܐ=
VPN_STORE
)? "VPN" : \

1203 (
mpSte
 =
EMAIL_STORE
)? "EMAIL" : "SYSTEM");

1205 i(
qTy
 =
CERTSVC_GET_ROOT_CERTIFICATE_LIST
) {

1207 i(
eTy
 =
SYSTEM_STORE
) {

1208 
quy
 = 
	`sqle3_mtf
("select gname, common_name,nabled from %Q wherenabled=%d "\

1209 "d is_ro_p_abd=%dnd ord by comm_masc", "s", 
ENABLED
, ENABLED);

1211 
quy
 = 
	`sqle3_mtf
("select gname, common_name,nabled from %Q where "\

1213 (
eTy
=
WIFI_STORE
)? "wifi" : (eTy =
VPN_STORE
)? "vpn" : \

1214 (
eTy
 =
EMAIL_STORE
)? "ema" : "s", 
ENABLED
, ENABLED);

1216 } i(
qTy
 =
CERTSVC_GET_USER_CERTIFICATE_LIST
) {

1218 i(
eTy
 =
SYSTEM_STORE
) {

1219 
	`SLOGE
("Invalid storeypeassed.");

1220  
CERTSVC_WRONG_ARGUMENT
;

1222 
quy
 = 
	`sqle3_mtf
("select gname, common_name,nabled from %Q where "\

1224 (
eTy
=
WIFI_STORE
)? "wifi" : (eTy =
VPN_STORE
)? "vpn" : \

1225 (
eTy
 =
EMAIL_STORE
)? "ema" : "s", 
ENABLED
, ENABLED);

1229 i(
is_ro_p
 !
ENABLED
) {

1231 i(
mpSte
 =
SYSTEM_STORE
) {

1232 
quy
 = 
	`sqle3_mtf
("select gname, common_name,nabled from %Q where "\

1234 (
mpSte
=
WIFI_STORE
)? "wifi" : (mpStܐ=
VPN_STORE
)? "vpn" : \

1235 (
mpSte
 =
EMAIL_STORE
)? "ema" : "s", 
ENABLED
, ENABLED);

1237 
quy
 = 
	`sqle3_mtf
("select gname, common_name,nabled from %Q where is_root_app_enabled=%d", \

1238 (
mpSte
=
WIFI_STORE
)? "wifi" : (mpStܐ=
VPN_STORE
)? "vpn" : \

1239 (
mpSte
 =
EMAIL_STORE
)? "ema" : "s", 
ENABLED
, ENABLED);

1243 i(
mpSte
 =
SYSTEM_STORE
) {

1244 
quy
 = 
	`sqle3_mtf
("select gname, common_name,nabled from %Q order by common_namesc", \

1245 (
mpSte
=
WIFI_STORE
)? "wifi" : (mpStܐ=
VPN_STORE
)? "vpn" : \

1246 (
mpSte
 =
EMAIL_STORE
)? "ema" : "s", 
ENABLED
);

1248 
quy
 = 
	`sqle3_mtf
("select gname, common_name,nabled from %Q", \

1249 (
mpSte
=
WIFI_STORE
)? "wifi" : (mpStܐ=
VPN_STORE
)? "vpn" : \

1250 (
mpSte
 =
EMAIL_STORE
)? "ema" : "s", 
ENABLED
);

1255 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

1256 i(
su
 !
CERTSVC_SUCCESS
) {

1257 
	`SLOGE
("Querying database failed.");

1258 
su
 = 
CERTSVC_FAIL
;

1259 
r
;

1263 
cds
 = 
	`sqle3_
(
mt
);

1264 i(
cds
 !
SQLITE_ROW
 ||ecd=
SQLITE_DONE
) {

1265 i(
cou
 < 0) {

1266 
	`SLOGE
("Noecords found");

1267 
su
 = 
CERTSVC_SUCCESS
;

1268 
r
;

1274 i(
cds
 =
SQLITE_ROW
) {

1275 
tmpNode
 = (
CtSvcSteCtLi
 *)
	`mloc
((CertSvcStoreCertList));

1276 i(!
tmpNode
) {

1277 
	`SLOGE
("Failedollocate memory.");

1278 
su
 = 
CERTSVC_BAD_ALLOC
;

1279 
r
;

1281 
tmpNode
->
xt
 = 
NULL
;

1282 cڡ *
xtGme
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0);

1283 cڡ *
xtAls
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 1);

1284 i(!
xtGme
 || !
xtAls
) {

1285 
	`SLOGE
("Failedoeadexts fromecords");

1286 
	`
(
tmpNode
);

1287 
su
 = 
CERTSVC_FAIL
;

1288 
r
;

1291 
gmeL
 = 
	`
(
xtGme
);

1292 
sL
 = 
	`
(
xtAls
);

1294 
tmpNode
->
gme
 = (*)
	`mloc
((* (
gmeL
 + 1));

1295 
tmpNode
->
t
 = (*)
	`mloc
((* (
sL
 + 1));

1296 i(!
tmpNode
->
t
 || !tmpNode->
gme
) {

1297 
	`
(
tmpNode
->
gme
);

1298 
	`
(
tmpNode
->
t
);

1299 
	`
(
tmpNode
);

1300 
	`SLOGE
("Failedollocate memory");

1301 
su
 = 
CERTSVC_BAD_ALLOC
;

1302 
r
;

1305 
	`memt
(
tmpNode
->
gme
, 0x00, 
gmeL
 + 1);

1306 
	`memt
(
tmpNode
->
t
, 0x00, 
sL
 + 1);

1308 
	`memy
(
tmpNode
->
gme
, 
xtGme
, 
gmeL
);

1309 
	`memy
(
tmpNode
->
t
, 
xtAls
, 
sL
);

1311 
tmpNode
->
us
 = ()
	`sqle3_cumn_t
(
mt
, 2);

1312 
tmpNode
->
eTy
 = 
mpSte
;

1317 i(
cou
 == 0) {

1318 
roCtHd
 = 
tmpNode
;

1319 
cutNode
 = 
roCtHd
;

1320 
tmpNode
 = 
NULL
;

1322 
cutNode
->
xt
 = 
tmpNode
;

1323 
cutNode
 = 
tmpNode
;

1324 
tmpNode
 = 
NULL
;

1326 
cou
++;

1330 i(
cou
 <=0 ) {

1331 
	`SLOGD
("Nontries found in database.");

1332 
su
 = 
CERTSVC_SUCCESS
;

1335 i(
quy
) {

1336 
	`sqle3_
(
quy
);

1337 
quy
 = 
NULL
;

1340 i(
mt
) {

1341 
	`sqle3_fize
(
mt
);

1342 
mt
 = 
NULL
;

1345 
loCou
++;

1348 *
Cou
 = 
cou
;

1349 
VceCtReڣDa
 *
CtDa
 = (VceCtReڣD*)
	`mloc
(
cou
 * (VcoreCertResponseData));

1350 i(!
CtDa
) {

1351 
	`SLOGE
("Failedollocate memory");

1352 
su
 = 
CERTSVC_BAD_ALLOC
;

1353 
r
;

1355 i(
cou
 > 0)

1356 
	`memt
(
CtDa
, 0x00, 
cou
 * (
VceCtReڣDa
));

1357 
VceCtReڣDa
* 
cuReCtDa
 = 
NULL
;

1359 
cutNode
 = 
roCtHd
;

1360 
i
 = 0; i < 
cou
; i++) {

1361 
tmpNode
 = 
cutNode
->
xt
;

1363 
cuReCtDa
 = 
CtDa
 + 
i
;

1364 i(
	`
(
cutNode
->
gme
> (
cuReCtDa
->gname)

1365 || 
	`
(
cutNode
->
t
> (
cuReCtDa
->title)) {

1366 
	`SLOGE
("Sg itolg. [%s], [%s]", 
cutNode
->
gme
, cutNode->
t
);

1367 
su
 = 
CERTSVC_FAIL
;

1368 *
LiBufr
 = 
NULL
;

1369 
	`
(
CtDa
);

1370 
r
;

1372 
	`y
(
cuReCtDa
->
gme
, 
cutNode
->gme, 
	`
(currentNode->gname));

1373 
	`y
(
cuReCtDa
->
t
, 
cutNode
->t, 
	`
(currentNode->title));

1374 
cuReCtDa
->
us
 = 
cutNode
->status;

1375 
cuReCtDa
->
eTy
 = 
cutNode
->storeType;

1378 
cutNode
 = 
tmpNode
;

1381 *
LiBufr
 = (*
CtDa
;

1382 *
bufrL
 = 
cou
 * (
VceCtReڣDa
);

1384 
	`SLOGD
("Sucst ctifii. ct_cou=%d", 
cou
);

1385 
su

CERTSVC_SUCCESS
;

1386 
r
:

1387 i(
quy
)

1388 
	`sqle3_
(
quy
);

1390 i(
mt
)

1391 
	`sqle3_fize
(
mt
);

1393 i(
roCtHd
) {

1394 
cutNode
 = 
roCtHd
;

1395 
cutNode
) {

1396 
tmpNode
 = 
cutNode
->
xt
;

1397 
	`
(
cutNode
->
t
);

1398 
	`
(
cutNode
->
gme
);

1399 
	`
(
cutNode
);

1400 
cutNode
=
tmpNode
;

1402 
roCtHd
 = 
NULL
;

1405  
su
;

1406 
	}
}

1408 
	$gCtifiAlsFromSte
(
sqle3
 *
db_hd
, 
eTy
, cڡ * 
gme
, * 
s
)

1410 
su
 = 
CERTSVC_SUCCESS
;

1411 
cds
 = 0;

1412 
sqle3_mt
 *
mt
 = 
NULL
;

1413 *
quy
 = 
NULL
;

1414 cڡ *
xt
 = 
NULL
;

1416 
quy
 = 
	`sqle3_mtf
(" comm_mom %Q whgme=%Q", ((
eTy
==
WIFI_STORE
)? "wifi" : \

1417 (
eTy
==
VPN_STORE
)? "v" : "ema"), 
gme
);

1419 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

1420 i(
su
 !
CERTSVC_SUCCESS
) {

1421 
	`SLOGE
("Querying database failed.");

1422 
su
 = 
CERTSVC_FAIL
;

1423 
r
;

1426 
cds
 = 
	`sqle3_
(
mt
);

1427 i(
cds
 !
SQLITE_ROW
 ||ecd=
SQLITE_DONE
) {

1428 
	`SLOGE
("Nvidecdfound f gmsd [%s].",
gme
);

1429 
su
 = 
CERTSVC_FAIL
;

1430 
r
;

1433 i(!(
xt
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0))) {

1434 
	`SLOGE
("No columnext ineturnedecords");

1435 
su
 = 
CERTSVC_FAIL
;

1436 
r
;

1439 
	`y
(
s
, 
xt
, 
	`
(text));

1441 i(
	`
(
s
) == 0) {

1442 
	`SLOGE
("Unableo getheliasame forhe gnameassed.");

1443 
su
 = 
CERTSVC_FAIL
;

1444 
r
;

1447 
su
 = 
CERTSVC_SUCCESS
;

1449 
	`SLOGD
("success : getCertificateAliasFromStore");

1450 
r
:

1451 i(
quy
)

1452 
	`sqle3_
(
quy
);

1454 i(
mt
)

1455 
	`sqle3_fize
(
mt
);

1457  
su
;

1458 
	}
}

1460 
	$ldCtifisFromSte
(

1461 
sqle3
 *
db_hd
,

1462 
eTy
,

1463 cڡ * 
gme
,

1464 **
CtBlockBufr
,

1465 
size_t
 *
bufrL
,

1466 *
BlockCou
)

1468 
su
 = 
CERTSVC_SUCCESS
;

1469 
cou
 = 0;

1470 
cds
 = 0;

1471 
sqle3_mt
 *
mt
 = 
NULL
;

1472 *
quy
 = 
NULL
;

1473 **
s
 = 
NULL
;

1474 cڡ *
tmpText
 = 
NULL
;

1475 
i
 = 0;

1477 
quy
 = 
	`sqle3_mtf
("ssocd_gmom %Q whgme=%Q", ((
eTy
==
WIFI_STORE
)? "wifi" : \

1478 (
eTy
==
VPN_STORE
)? "v" : "ema"), 
gme
);

1480 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

1481 i(
su
 !
CERTSVC_SUCCESS
) {

1482 
	`SLOGE
("Querying database failed.");

1483 
su
 = 
CERTSVC_FAIL
;

1484 
r
;

1487 
cds
 = 
	`sqle3_
(
mt
);

1488 i(
cds
 !
SQLITE_ROW
 ||ecd=
SQLITE_DONE
) {

1489 
	`SLOGE
("Nvidecdfound f gmsd [%s].",
gme
);

1490 
su
 = 
CERTSVC_FAIL
;

1491 
r
;

1495 i(
cds
 =
SQLITE_ROW
) {

1496 i(
quy
)

1497 
	`sqle3_
(
quy
);

1499 cڡ *
cumnText
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0);

1500 i(!
cumnText
) {

1501 
	`SLOGE
("Failedo sqlite3_column_text");

1502 
su
 = 
CERTSVC_FAIL
;

1503 
r
;

1506 
quy
 = 
	`sqle3_mtf
("select gname from %Q wheressociated_gname=%Qndnabled=%dnd is_root_app_enabled=%d", \

1507 ((
eTy
==
WIFI_STORE
)? "wifi" : (eTy==
VPN_STORE
)? "vpn" : "email"), \

1508 
cumnText
, 
ENABLED
, ENABLED);

1510 i(
mt
)

1511 
	`sqle3_fize
(
mt
);

1513 
su
 = 
	`execu__quy
(
db_hd
, 
quy
, &
mt
);

1514 i(
su
 !
CERTSVC_SUCCESS
) {

1515 
	`SLOGE
("Querying database failed.");

1516 
su
 = 
CERTSVC_FAIL
;

1517 
r
;

1521 
cds
 = 
	`sqle3_
(
mt
);

1522 i(
cds
 !
SQLITE_ROW
 ||ecd=
SQLITE_DONE
)

1525 i(
cou
 == 0) {

1526 
s
 = (**
	`mloc
(4 * (*));

1527 i(!
s
) {

1528 
	`SLOGE
("Failedollocate memory");

1529 
su
 = 
CERTSVC_BAD_ALLOC
;

1530 
r
;

1532 
	`memt
(
s
, 0x00, 4 * (*));

1535 i(
cds
 =
SQLITE_ROW
) {

1536 
tmpText
 = (cڡ *)
	`sqle3_cumn_xt
(
mt
, 0);

1537 i(!
tmpText
) {

1538 
	`SLOGE
("Failedo sqlite3_column_text.");

1539 
su
 = 
CERTSVC_FAIL
;

1540 
r
;

1543 i(!((
s
)[
cou
] = 
	`rdup
(
tmpText
))) {

1544 
	`SLOGE
("Failedollocate memory");

1545 
su
 = 
CERTSVC_BAD_ALLOC
;

1546 
r
;

1550 
cou
++;

1553 i(
cou
 == 0) {

1554 
	`SLOGE
("Nvidecdfound f܁hgmsd [%s].",
gme
);

1555  
CERTSVC_FAIL
;

1559 *
BlockCou
 = 
cou
;

1560 *
bufrL
 = 
cou
 * (
ReڣCtBlock
);

1561 
ReڣCtBlock
 *
BlockLi
 = (ReڣCtBlock *
	`mloc
(*
bufrL
);

1562 i(!
BlockLi
) {

1563 
	`SLOGE
("Failedollocate memory for ResponseCertBlock");

1564 
su
 = 
CERTSVC_BAD_ALLOC
;

1565 
r
;

1568 i(
cou
 > 0)

1569 
	`memt
(
BlockLi
, 0x00, *
bufrL
);

1571 
ReڣCtBlock
 *
cutBlock
 = 
NULL
;

1572 
i
 = 0; i < 
cou
; i++) {

1573 
cutBlock
 = 
BlockLi
 + 
i
;

1574 i((
cutBlock
->
daBlock
< 
	`
(
s
[
i
])) {

1575 
	`SLOGE
("ilgh d. src[%s] d size[%d]", 
s
[
i
], (
cutBlock
->
daBlock
));

1576 
	`
(
BlockLi
);

1577 
su
 = 
CERTSVC_FAIL
;

1578 
r
;

1580 
	`y
(
cutBlock
->
daBlock
, 
s
[
i
], 
	`
(certs[i]));

1581 
cutBlock
->
daBlockL
 = 
	`
(
s
[
i
]);

1583 *
CtBlockBufr
 = (*)
BlockLi
;

1585 
su
 = 
CERTSVC_SUCCESS
;

1587 
	`SLOGD
("sucss:dCtifisFromSte. CERT_COUNT=%d", 
cou
);

1589 
r
:

1590 i(
quy
)

1591 
	`sqle3_
(
quy
);

1593 i(
mt
)

1594 
	`sqle3_fize
(
mt
);

1596 i(
s
) {

1597 
i
 = 0; i < 
cou
; i++)

1598 
	`
(
s
[
i
]);

1600 
	`
(
s
);

1603  
su
;

1604 
	}
}

	@vcore/src/server/src/cert-server-main.c

24 
	~<sigl.h
>

25 
	~<unid.h
>

26 
	~<o.h
>

27 
	~<sys/un.h
>

28 
	~<sys/tys.h
>

29 
	~<sys/.h
>

30 
	~<sys/sock.h
>

31 
	~<sys/time.h
>

32 
	~<sys/.h
>

33 
	~<syemd/sd-dm.h
>

35 
	~<-rvi-debug.h
>

36 
	~<-svc/.h
>

37 
	~<-svc/c.h
>

38 
	~<-svc-.h
>

40 
	~<-rv-logic.h
>

42 
sqle3
 *
	g_e_db
 = 
NULL
;

44 
	$ݒ_db
(
sqle3
 **
db_hd
, cڡ *
db_th
) {

46 
su
 = 
CERTSVC_FAIL
;

47 
sqle3
 *
hd
;

49 i(
	`acss
(
db_th
, 
F_OK
) == 0) {

50 
su
 = 
	`db_ut_ݒ
(
db_th
, &
hd
, 0);

51 i(
su
 !
SQLITE_OK
) {

52 
	`SLOGE
("c db [%s] faed!", 
db_th
);

53  
CERTSVC_FAIL
;

55 *
db_hd
 = 
hd
;

56  
CERTSVC_SUCCESS
;

58 
	`SLOGD
("%DB d۠nكxis. Cg o!!", 
db_th
);

60 
su
 = 
	`db_ut_ݒ
(
db_th
, &
hd
, 0);

61 i(
su
 !
SQLITE_OK
) {

62 
	`SLOGE
("cdb [%s] faed!.", 
db_th
);

63  
CERTSVC_FAIL
;

65 *
db_hd
 = 
hd
;

66  
CERTSVC_SUCCESS
;

67 
	}
}

69 
	$evue_quy
(
sqle3
 *
db_hd
, *
quy
) {

71 
su
 = 
CERTSVC_SUCCESS
;

72 
sqle3_mt
* 
p_emt
;

74 i(!
db_hd
) {

75 
	`SLOGE
("Databaseot initialised.");

76  
CERTSVC_WRONG_ARGUMENT
;

79 i(!
quy
) {

80 
	`SLOGE
("Query is NULL.");

81  
CERTSVC_WRONG_ARGUMENT
;

84 
su
 = 
	`sqle3_e_v2
(
db_hd
, 
quy
, 
	`
(quy), &
p_emt
, 
NULL
);

85 i(
su
 !
SQLITE_OK
) {

86 
	`SLOGE
("Sqle3 [%d] : <%s>rg <%s> quy.", 
su
, 
	`sqle3_rmsg
(
db_hd
), 
quy
);

87  
CERTSVC_FAIL
;

90 
su
 = 
	`sqle3_
(
p_emt
);

91 i(
su
 !
SQLITE_DONE
) {

92 
	`SLOGE
("Sqle3 [%d] : <%s>xecutg <%s> smt.", 
su
, 
	`sqle3_rmsg
(
db_hd
), 
quy
);

93  
CERTSVC_FAIL
;

96 
su
 = 
	`sqle3_fize
(
p_emt
);

97 i(
su
 !
SQLITE_OK
) {

98 
	`SLOGE
("Sqle3 [%d] : <%s> fisg <%s> smt.", 
su
, 
	`sqle3_rmsg
(
db_hd
), 
quy
);

99  
CERTSVC_FAIL
;

101  
CERTSVC_SUCCESS
;

102 
	}
}

104 
	$lize_db
() {

106 
su
 = 
CERTSVC_SUCCESS
;

112 i(
_e_db
 =
NULL
) {

113 
su
 = 
	`ݒ_db
(&
_e_db
, 
CERTSVC_SYSTEM_STORE_DB
);

114 i(
su
 !
CERTSVC_SUCCESS
) {

115 
	`SLOGE
("CtsvܐDB ci faed.esu[%d]", 
su
);

116  
su
;

155  
CERTSVC_SUCCESS
;

156 
	}
}

158 
	$CtSigHdr
(
signo
)

160 
	`SLOGD
("G Sig%d,xgow.", 
signo
);

161 i(
_e_db
 !
NULL
) {

162 
	`sqle3_o
(
_e_db
);

163 
_e_db
 = 
NULL
;

165 
	`ex
(1);

166 
	}
}

168 
	$CtSvcGSockFromSyemd
(* 
pSockfd
)

170 
n
 = 
	`sd_li_fds
(0);

171 
fd
;

173 
fd
 = 
SD_LISTEN_FDS_START
; fd < SD_LISTEN_FDS_START+
n
; ++fd) {

174 i(0 < 
	`sd_is_sock_unix
(
fd
, 
SOCK_STREAM
, 1, 
VCORE_SOCK_PATH
, 0)) {

175 
	`LOGD
("G sock from syemd. fd[%d]", 
fd
);

176 *
pSockfd
 = 
fd
;

177  
CERTSVC_SUCCESS
;

180  
CERTSVC_FAIL
;

181 
	}
}

183 
	$CtSvcSvComm
()

185 
rv_sockfd
 = 0;

186 
_sockfd
 = 0;

187 
ad_n
 = 0;

188 
_n
 = 0;

189 
sockaddr_un
 
addr
;

190 
su
 = 
CERTSVC_SUCCESS
;

191 *
LiBufr
 = 
NULL
;

192 *
BlockBufr
 = 
NULL
;

193 
size_t
 
bufrL
 = 0;

194 
size_t
 
blockBufrL
 = 0;

196 
timev
 
timeout
;

197 
timeout
.
tv_c
 = 10;

198 
timeout
.
tv_uc
 = 0;

200 
	`SLOGI
("cert-server is starting...");

202 
VceRequeDa
 
cv_da
;

203 
VceReڣDa
 
nd_da
;

205 i(!
	`CtSvcGSockFromSyemd
(&
rv_sockfd
)) {

206 
	`SLOGE
("Failedo get sockfd from systemd.");

210 
_n
 = (
addr
);

211 
	`sigl
(
SIGINT
, (*)
CtSigHdr
);

229 
fd_t
 
fd
;

230 
timev
 
tv
;

232 
o
 = 0;

234 
	`FD_ZERO
(&
fd
);

235 
	`FD_SET
(
rv_sockfd
, &
fd
);

237 
tv
.
tv_c
 = 1;

238 
tv
.
tv_uc
 = 0;

240 
	`memt
(&
cv_da
, 0x00, (
VceRequeDa
));

241 
	`memt
(&
nd_da
, 0x00, (
VceReڣDa
));

243 
t
 = 
	`
(
rv_sockfd
 + 1, &
fd
, 
NULL
, NULL, &
tv
);

244 i(
t
 == 0) {

245 
	`SLOGD
("cert-serverimeout.xit.");

249 i(
t
 == -1) {

250 
	`SLOGE
("select()rror.");

254 i((
_sockfd
 = 
	`ac
(
rv_sockfd
, (
sockaddr
*)&
addr
, (
sockn_t
*)&
_n
)) < 0) {

255 
	`SLOGE
("E ifuniڇc().[sock des:%d,܂:%d].", 
_sockfd
, 
o
);

259 
	`SLOGD
("-rv Ac! cl sock[%d]", 
_sockfd
);

261 i(
	`tsockt
 (
_sockfd
, 
SOL_SOCKET
, 
SO_RCVTIMEO
, (*)&
timeout
, (timeout)) < 0) {

262 
	`SLOGE
("Error in Set SO_RCVTIMEO Socket Option");

263 
nd_da
.
su
 = 
CERTSVC_FAIL
;

264 
E_o_ex
;

267 i(
	`tsockt
 (
_sockfd
, 
SOL_SOCKET
, 
SO_SNDTIMEO
, (*)&
timeout
, (timeout)) < 0) {

268 
	`SLOGE
("Error in Set SO_SNDTIMEO Socket Option");

269 
nd_da
.
su
 = 
CERTSVC_FAIL
;

270 
E_o_ex
;

273 
	`SLOGD
("Connectedo client...");

275 
ad_n
 = 
	`cv
(
_sockfd
, (*)&
cv_da
, (recv_data), 0);

276 i(
ad_n
 < 0) {

277 
	`SLOGE
("Error in functionecv().");

278 
nd_da
.
su
 = 
CERTSVC_FAIL
;

279 
E_o_ex
;

282 i(!
_e_db
) {

283 
su
 = 
	`lize_db
();

284 i(
su
 !
CERTSVC_SUCCESS
) {

285 
	`SLOGE
("Failedo initialize database.");

286 
su
 = 
CERTSVC_IO_ERROR
;

287 
E_o_ex
;

291 
	`SLOGD
("vque:eqTy=%d", 
cv_da
.
qTy
);

293 
cv_da
.
qTy
) {

294 
CERTSVC_EXTRACT_CERT
:

296 
nd_da
.
su
 = 
	`gCtifiDaFromSte
(

297 
_e_db
,

298 
cv_da
.
eTy
,

299 
cv_da
.
Ty
,

300 
cv_da
.
gme
,

301 
nd_da
.
daBlock
,

302 &
nd_da
.
daBlockL
);

303 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

307 
CERTSVC_EXTRACT_SYSTEM_CERT
:

309 
nd_da
.
su
 = 
	`gCtifiDaFromSyemSte
(

310 
_e_db
,

311 
cv_da
.
gme
,

312 
nd_da
.
daBlock
,

313 &
nd_da
.
daBlockL
);

314 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

318 
CERTSVC_DELETE_CERT
:

320 
nd_da
.
su
 = 
	`deCtifiFromSte
(

321 
_e_db
,

322 
cv_da
.
eTy
,

323 
cv_da
.
gme
);

324 i(
nd_da
.
su
 =
CERTSVC_SUCCESS
)

325 
nd_da
.
su
 = 
	`upde__ifi_fe
(
_e_db
, 
NULL
, 0);

326 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

330 
CERTSVC_GET_CERTIFICATE_STATUS
:

332 
nd_da
.
su
 = 
	`gCtifiStusFromSte
(

333 
_e_db
,

334 
cv_da
.
eTy
,

335 
cv_da
.
gme
,

336 &
nd_da
.
Stus
);

337 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

341 
CERTSVC_SET_CERTIFICATE_STATUS
:

343 
nd_da
.
su
 = 
	`tCtifiStusToSte
(

344 
_e_db
,

345 
cv_da
.
eTy
,

346 
cv_da
.
is_ro_p
,

347 
cv_da
.
gme
,

348 
cv_da
.
Stus
);

349 i(
nd_da
.
su
 =
CERTSVC_SUCCESS
)

350 
nd_da
.
su
 = 
	`upde__ifi_fe
(
_e_db
, 
NULL
, 0);

351 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

355 
CERTSVC_CHECK_ALIAS_EXISTS
:

357 
nd_da
.
su
 = 
	`checkAlsExisInSte
(

358 
_e_db
,

359 
cv_da
.
eTy
,

360 
cv_da
.
gme
,

361 &
nd_da
.
Stus
);

362 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

366 
CERTSVC_INSTALL_CERTIFICATE
:

368 
nd_da
.
su
 = 
	`lCtifiToSte
(

369 
_e_db
,

370 
cv_da
.
eTy
,

371 
cv_da
.
gme
,

372 
cv_da
.
comm_me
,

373 
cv_da
.
ive_key_gme
,

374 
cv_da
.
assocd_gme
,

375 
cv_da
.
daBlock
,

376 
cv_da
.
daBlockL
,

377 
cv_da
.
Ty
);

379 i((
nd_da
.
su
 =
CERTSVC_SUCCESS
&& ((
cv_da
.
Ty
 =
PEM_CRT
|| (cv_da.Ty =
P12_TRUSTED
)))

380 
nd_da
.
su
 = 
	`upde__ifi_fe
(
_e_db
, 
cv_da
.
daBlock
,ecv_da.
daBlockL
);

381 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

385 
CERTSVC_GET_CERTIFICATE_LIST
:

386 
CERTSVC_GET_USER_CERTIFICATE_LIST
:

387 
CERTSVC_GET_ROOT_CERTIFICATE_LIST
:

389 
nd_da
.
su
 = 
	`gCtifiLiFromSte
(

390 
_e_db
,

391 
cv_da
.
qTy
,

392 
cv_da
.
eTy
,

393 
cv_da
.
is_ro_p
,

394 &
LiBufr
,

395 &
bufrL
,

396 &
nd_da
.
Cou
);

397 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

398 i(
bufrL
 > 0)

399 
su
 = 
	`nd
(
_sockfd
, 
LiBufr
, 
bufrL
, 0);

404 
CERTSVC_GET_CERTIFICATE_ALIAS
:

406 
nd_da
.
su
 = 
	`gCtifiAlsFromSte
(

407 
_e_db
,

408 
cv_da
.
eTy
,

409 
cv_da
.
gme
,

410 
nd_da
.
comm_me
);

411 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

415 
CERTSVC_LOAD_CERTIFICATES
:

417 
nd_da
.
su
 = 
	`ldCtifisFromSte
(

418 
_e_db
,

419 
cv_da
.
eTy
,

420 
cv_da
.
gme
,

421 &
BlockBufr
,

422 &
blockBufrL
,

423 &
nd_da
.
BlockCou
);

424 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

425 i(
blockBufrL
 > 0)

426 
su
 = 
	`nd
(
_sockfd
, 
BlockBufr
, 
blockBufrL
, 0);

431 
	`SLOGE
("Inputrror. Please checkequestype");

435 i(
su
 <= 0) {

436 
	`SLOGE
("nd faed :%d,n%dry on", 
su
, 
o
);

441 
	`o
(
_sockfd
);

442 i(
_e_db
) {

443 
	`sqle3_o
(
_e_db
);

444 
_e_db
 = 
NULL
;

445 
	`SLOGI
("cert_store db was closed");

449 
E_o_ex
:

450 
	`o
(
rv_sockfd
);

451 i(
_e_db
) {

452 
	`sqle3_o
(
_e_db
);

453 
_e_db
 = 
NULL
;

456 i(
LiBufr
)

457 
	`
(
LiBufr
);

459 i(
BlockBufr
)

460 
	`
(
BlockBufr
);

462 i(
_sockfd
 >= 0) {

463 
su
 = 
	`nd
(
_sockfd
, (*)&
nd_da
, (send_data), 0);

464 
	`o
(
_sockfd
);

467 
	`SLOGE
("cannot connecto client socket.");

469 
	`SLOGI
("CertSvcServerComm done.");

470 
	}
}

472 
	$ma
()

474 
	`SLOGI
("cert-server start");

475 
	`CtSvcSvComm
();

476 
	`SLOGI
("cert-servernd");

479 
	}
}

	@vcore/src/vcore/Base64.cpp

16 
	~<gܙhm
>

17 
	~<rg
>

18 
	~<rg.h
>

19 
	~<ݒs/bio.h
>

20 
	~<ݒs/evp.h
>

21 
	~<ݒs/bufr.h
>

23 
	~<d/log/w_log.h
>

25 
	~<d/sced_.h
>

27 
	~<vce/Ba64.h
>

29 
mea
 
	gVidiCe
 {

30 
	gBa64Encod
::
Ba64Encod
() :

31 
m_b64
(0),

32 
m_bmem
(0),

33 
m_fized
(
l
)

37 
	gBa64Encod
::
nd
(cڡ 
d
::
rg
 &
da
)

39 i(
m_fized
) {

40 
WLogW
("Already finalized.");

41 
VceThrowMsg
(
Exi
::
A̗dyFized
, "Already finalized");

44 i(!
	gm_b64
) {

45 
t
();

47 
BIO_wre
(
m_b64
, 
da
.
c_r
(), da.
size
());

50 
	gBa64Encod
::
fize
()

52 i(
m_fized
) {

53 
WLogW
("Already finalized.");

54 
VceThrowMsg
(
Exi
::
A̗dyFized
, "Already finalized.");

56 
	gm_fized
 = 
ue
;

57 
BIO_ush
(
m_b64
);

60 
	gd
::
rg
 
Ba64Encod
::
g
()

62 i(!
m_fized
) {

63 
WLogW
("Not finalized");

64 
VceThrowMsg
(
Exi
::
NFized
, "Not finalized");

66 
BUF_MEM
 *
	gbr
 = 0;

67 
BIO_g_mem_r
(
m_b64
, &
br
);

68 i(
	gbr
 == 0) {

69 
WLogE
("Bio internalrror");

70 
VceThrowMsg
(
Exi
::
IlE
, "Bio internalrror");

73 i(
	gbr
->
	gngth
 > 0) {

74  
	gd
::
rg
(
br
->
da
, br->
ngth
);

76  
	gd
::
rg
();

79 
	gBa64Encod
::
t
()

81 
m_fized
 = 
l
;

82 
BIO__l
(
m_b64
);

83 
	gm_b64
 = 
BIO_w
(
BIO_f_ba64
());

84 
	gm_bmem
 = 
BIO_w
(
BIO_s_mem
());

85 i(!
	gm_b64
 || !
	gm_bmem
) {

86 
WLogE
("Error duringllocation memory in BIO");

87 
VceThrowMsg
(
Exi
::
IlE
,

90 
BIO_t_ags
(
m_b64
, 
BIO_FLAGS_BASE64_NO_NL
);

91 
	gm_b64
 = 
BIO_push
(
m_b64
, 
m_bmem
);

94 
	gBa64Encod
::~
Ba64Encod
()

96 
BIO__l
(
m_b64
);

99 
	gBa64Decod
::
Ba64Decod
() :

100 
m_fized
(
l
)

104 
Ba64Decod
::
nd
(cڡ 
d
::
rg
 &
da
)

106 i(
m_fized
) {

107 
WLogW
("Already finalized.");

108 
VceThrowMsg
(
Exi
::
A̗dyFized
, "Already finalized.");

110 
	gm_put
.
nd
(
da
);

113 
bo
 
wheCha
(
a
)

115 i(
	ga
 ='\n'{  
ue
; }

116  
	gl
;

119 
bo
 
	gBa64Decod
::
fize
()

121 i(
m_fized
) {

122 
WLogW
("Already finalized.");

123 
VceThrowMsg
(
Exi
::
A̗dyFized
, "Already finalized.");

126 
	gm_fized
 = 
ue
;

128 
	gm_put
.
a
(
d
::
move_if
(
m_put
.
beg
(),

129 
m_put
.
d
(),

130 
wheCha
),

131 
m_put
.
d
());

133 
size_t
 
	gi
 = 0; i<
	gm_put
.
size
(); ++i) {

134 i(
ium
(
m_put
[
i
])

135 || 
	gm_put
[
i
] == '+'

136 || 
m_put
[
i
] == '/'

137 || 
m_put
[
i
] == '=')

141 
WLogE
("Ba64 iucڏg chs: %c", 
m_put
[
i
]);

142  
	gl
;

145 
BIO
 *
	gb64
, *
	gbmem
;

146 
size_t
 
	gn
 = 
m_put
.
size
();

148 
	gVceDPL
::
ScedFe
<> 
bufr
(
ic_
<*>(
mloc
(
n
)));

150 i(!
	gbufr
) {

151 
WLogE
("Error in malloc.");

152 
VceThrowMsg
(
Exi
::
IlE
, "Error in malloc.");

155 
memt
(
bufr
.
G
(), 0, 
n
);

156 
	gb64
 = 
BIO_w
(
BIO_f_ba64
());

157 i(!
	gb64
) {

158 
WLogE
("Couldn't create BIO object.");

159 
VceThrowMsg
(
Exi
::
IlE
, "Couldn't create BIO object.");

161 
BIO_t_ags
(
b64
, 
BIO_FLAGS_BASE64_NO_NL
);

162 
	gVceDPL
::
ScedFe
<> 
tmp
(
rdup
(
m_put
.
c_r
()));

163 
	gm_put
.
r
();

165 
	gbmem
 = 
BIO_w_mem_buf
(
tmp
.
G
(), 
n
);

167 i(!
	gbmem
) {

168 
BIO_
(
b64
);

169 
WLogE
("Internalrror in BIO");

170 
VceThrowMsg
(
Exi
::
IlE
, "Internalrror in BIO");

173 
	gbmem
 = 
BIO_push
(
b64
, 
bmem
);

175 i(!
	gbmem
) {

176 
BIO_
(
b64
);

177 
WLogE
("Internalrror in BIO");

178 
VceThrowMsg
(
Exi
::
IlE
, "Internalrror in BIO");

181 
	gadn
 = 
BIO_ad
(
bmem
, 
bufr
.
G
(), 
n
);

182 
	gm_ouut
.
r
();

184 
bo
 
	gus
 = 
ue
;

186 i(
	gadn
 > 0) {

187 
	gm_ouut
.
nd
(
bufr
.
G
(), 
adn
);

189 
	gus
 = 
l
;

192 
BIO__l
(
bmem
);

193  
	gus
;

196 
	gd
::
rg
 
Ba64Decod
::
g
() const

198 i(!
m_fized
) {

199 
WLogW
("Not finalized.");

200 
VceThrowMsg
(
Exi
::
NFized
, "Not finalized");

202  
	gm_ouut
;

205 
	gBa64Decod
::
t
()

207 
m_fized
 = 
l
;

208 
	gm_put
.
r
();

209 
	gm_ouut
.
r
();

	@vcore/src/vcore/Base64.h

16 #ide
_BASE64_H_


17 
	#_BASE64_H_


	)

19 
	~<rg
>

20 
	~<vce/exi.h
>

22 
	gbio_
;

23 
bio_
 
	tBIO
;

25 
mea
 
	gVidiCe
 {

26 as
	cBa64Encod
 {

27 
	gpublic
:

28 as
	cExi
 {

29 
public
:

30 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
)

31 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
IlE
)

32 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
NFized
)

33 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
A̗dyFized
)

35 
Ba64Encod
();

36 
nd
(cڡ 
d
::
rg
 &
da
);

37 
fize
();

38 
	gd
::
rg
 
g
();

39 
t
();

40 ~
Ba64Encod
();

42 
	give
:

43 
Ba64Encod
(const Base64Encoder &);

44 cڡ 
	gBa64Encod
 &
	gݔ
=(cڡ 
Ba64Encod
 &);

46 
BIO
 *
	gm_b64
;

47 
BIO
 *
	gm_bmem
;

48 
bo
 
	gm_fized
;

51 as
	cBa64Decod
 {

52 
	gpublic
:

53 as
	cExi
 {

54 
public
:

55 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
)

56 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
IlE
)

57 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
NFized
)

58 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
A̗dyFized
)

60 
Ba64Decod
();

61 
nd
(cڡ 
d
::
rg
 &
da
);

67 
bo
 
fize
();

68 
	gd
::
rg
 
g
() const;

69 
t
();

70 ~
Ba64Decod
() {}

72 
	give
:

73 
Ba64Decod
(const Base64Decoder &);

74 cڡ 
	gBa64Decod
 &
	gݔ
=(cڡ 
Ba64Decod
 &);

76 
	gd
::
rg
 
m_put
;

77 
	gd
::
rg
 
m_ouut
;

78 
bo
 
	gm_fized
;

	@vcore/src/vcore/CRL.cpp

23 
	~<vce/CRL.h
>

24 
	~<vce/CRLIm.h
>

26 
mea
 
	gVidiCe
 {

28 
	gCRL
::
CRL
(
CRLCacheI
 *
r
)

29 : 
m_im
(
w
 
CRLIm
(
r
))

32 
CRL
::~CRL() {

33 
de
 
m_im
;

36 
	gCRL
::
RevotiStus
 
CRL
::
checkCtifi
(cڡ 
CtifiP
 &
gCt
) {

37  
m_im
->
checkCtifi
(
gCt
);

40 
	gCRL
::
RevotiStus
 
CRL
::
checkCtifiCha
(

41 
CtifiCi
 
Cha
)

43  
m_im
->
checkCtifiCha
(
Cha
);

46 
VifitiStus
 
	gCRL
::
checkEndEy
(
CtifiCi
 &
cha
) {

47  
m_im
->
checkEndEy
(
cha
);

50 
	gCRL
::
addToSte
(cڡ 
CtifiP
 &
gCt
) {

51 
m_im
->
addToSte
(
gCt
);

54 
bo
 
	gCRL
::
updeLi
(cڡ 
CtifiP
 &
gCt
,

55 cڡ 
UpdePicy
 
updePicy
)

57  
	gm_im
->
updeLi
(
gCt
, 
updePicy
);

60 
	gCRL
::
addToSte
(cڡ 
CtifiCi
 &
ci
) {

61 
m_im
->
addToSte
(
ci
);

64 
bo
 
	gCRL
::
updeLi
(cڡ 
CtifiCi
 &
ci
,

65 
UpdePicy
 
updePicy
)

67  
	gm_im
->
updeLi
(
ci
, 
updePicy
);

	@vcore/src/vcore/CRL.h

23 #ide
_VALIDATION_CORE_ENGINE_CRL_H_


24 
	#_VALIDATION_CORE_ENGINE_CRL_H_


	)

26 
	~<li
>

27 
	~<rg
>

29 
	~<vce/Ctifi.h
>

30 
	~<vce/CtifiCi.h
>

31 
	~<vce/VifitiStus.h
>

32 
	~<vce/CRLCacheI.h
>

33 
	~<vce/exi.h
>

35 
mea
 
	gVidiCe
 {

36 
mea
 
	gCRLExi
 {

37 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
)

38 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
StageE
)

39 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
IlE
)

40 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
InvidPam
)

44 
ass
 
	gCRLIm
;

46 as
	cCRL
 {

47 
	gpublic
:

48 
d
::
	tli
<
	td
::
	trg
> 
	tSgLi
;

50 
	eUpdePicy


52 
	gUPDATE_ON_EXPIRED
,

54 
	gUPDATE_ON_DEMAND


58 
	sRevotiStus


60 
bo
 
	gisCRLVid
;

62 
bo
 
	gisRevoked
;

65 
CRL
(
de
;

66 
CRL
(
CRLCacheI
 *
r
);

67 
	gvtu
 ~
CRL
();

81 
RevotiStus
 
checkCtifi
(cڡ 
CtifiP
 &
gCt
);

98 
RevotiStus
 
checkCtifiCha
(
CtifiCi
 
Cha
);

100 
VifitiStus
 
checkEndEy
(
CtifiCi
 &
cha
);

114 
bo
 
updeLi
(cڡ 
CtifiP
 &
gCt
,

115 cڡ 
UpdePicy
 
updePicy
);

130 
bo
 
updeLi
(cڡ 
CtifiCi
 &
ci
,

131 cڡ 
UpdePicy
 
updePisy
);

139 
addToSte
(cڡ 
CtifiCi
 &
ci
);

147 
addToSte
(cڡ 
CtifiP
 &
gCt
);

148 
	give
:

149 
nd
 
ass
 
CachedCRL
;

150 
CRLIm
 *
	gm_im
;

152 
CRL
(const CRL &);

153 cڡ 
	gCRL
 &
	gݔ
=(cڡ 
CRL
 &);

	@vcore/src/vcore/CRLCacheDAO.cpp

23 
	~<vce/CRLCacheDAO.h
>

24 
	~<vce/CtifiCacheDAO.h
>

26 
mea
 
	gVidiCe
 {

28 
bo
 
	gCRLCacheDAO
::
gCRLReڣ
(
CRLCachedDa
 *
r
){

29  
CtifiCacheDAO
::
gCRLReڣ
(
r
);

32 
	gCRLCacheDAO
::
tCRLReڣ
(
CRLCachedDa
 *
r
){

33 
CtifiCacheDAO
::
tCRLReڣ
(
r
);

	@vcore/src/vcore/CRLCacheDAO.h

22 #ide
_CRLCACHEDAO_H_


23 
	#_CRLCACHEDAO_H_


	)

25 
	~<vce/CRLCacheI.h
>

27 
mea
 
	gVidiCe
 {

29 as
	cCRLCacheDAO
 : 
public
 
CRLCacheI
 {

30 
public
:

31 
vtu
 
bo
 
gCRLReڣ
(
CRLCachedDa
 *
r
);

32 
vtu
 
tCRLReڣ
(
CRLCachedDa
 *
r
);

	@vcore/src/vcore/CRLCacheInterface.h

22 #ide
_CRLCACHEINTERFACE_H_


23 
	#_CRLCACHEINTERFACE_H_


	)

25 
	~<rg
>

27 
mea
 
	gVidiCe
 {

29 
	sCRLCachedDa


31 
	gd
::
rg
 
diributi_pot
;

32 
	gd
::
rg
 
l_body
;

33 
time_t
 
	gxt_upde_time
;

36 as
	cCRLCacheI
 {

37 
	gpublic
:

38 
vtu
 
bo
 
gCRLReڣ
(
CRLCachedDa
 *
r
) = 0;

39 
vtu
 
tCRLReڣ
(
CRLCachedDa
 *
r
) = 0;

	@vcore/src/vcore/CRLImpl.cpp

23 
	~<vce/CRL.h
>

24 
	~<vce/CRLIm.h
>

26 
	~<t
>

27 
	~<gܙhm
>

29 
	~<ݒs/r.h
>

30 
	~<ݒs/objes.h
>

31 
	~<ݒs/oc.h
>

32 
	~<ݒs/m.h
>

33 
	~<ݒs/x509v3.h
>

35 
	~<d/log/w_log.h
>

36 
	~<d/as.h
>

37 
	~<d/db/m.h
>

38 
	~<d/fܗch.h
>

40 
	~<vce/Ba64.h
>

41 
	~<vce/Ctifi.h
>

42 
	~<vce/SoupMesgeSdSync.h
>

43 
	~<vce/CRLCacheI.h
>

45 
	gmea
 {

46 cڡ *
	gCRL_LOOKUP_DIR
 = "/usr/share/ca-certificates/wac";

49 
mea
 
	gVidiCe
 {

51 
	gCRL
::
SgLi
 
CRLIm
::
gCUris
(cڡ 
CtifiP
 &
gCt
)

53 
CRL
::
SgLi
 
su
 = 
gCt
->
gCUris
();

55 i(!
	gsu
.
emy
()) {

56  
	gsu
;

58 
WLogI
("No distributionoints found. Getting from CA cert.");

59 
X509_STORE_CTX
 *
	gx
 = 
Cڋxt
(
gCt
);

60 
X509_OBJECT
 
	gobj
;

63 
	gtV
 = 
X509_STORE_g_by_subje
(
x
, 
X509_LU_X509
,

64 
X509_g_issu_me
(
gCt
->

65 
gX509
()),

66 &
obj
);

67 
X509_STORE_CTX_
(
x
);

68 i(0 >
tV
) {

69 
WLogE
("No dedicated CA certificatevailable");

70  
	gsu
;

72 
CtifiP
 
Ct
(
w
 
Ctifi
(
obj
.
da
.
x509
));

73 
X509_OBJECT__cڋs
(&
obj
);

74  
	gCt
->
gCUris
();

77 
	gCRLIm
::
CRLIm
(
CRLCacheI
 *
r
)

78 : 
m_lCache
(
r
)

80 
As
(
m_lCache
 !
NULL
);

82 
WLogI
("CRL storage initialization.");

83 
	gm_e
 = 
X509_STORE_w
();

84 i(!
	gm_e
)

85 
VceThrowMsg
(
CRLExi
::
StageE
,

88 
	gm_lookup
 = 
X509_STORE_add_lookup
(
m_e
, 
X509_LOOKUP_hash_d
());

89 i(!
	gm_lookup
) {

90 
nup
();

91 
VceThrowMsg
(
CRLExi
::
StageE
,

95 
bo
 
	gtV
 = 
X509_LOOKUP_add_d
(
m_lookup
, 
CRL_LOOKUP_DIR
, 
X509_FILETYPE_PEM
) == 1;

96 
	gtV
 &
X509_LOOKUP_add_d
(
m_lookup
, 
CRL_LOOKUP_DIR
, 
X509_FILETYPE_ASN1
) == 1;

97 i(!
	gtV
) {

98 
nup
();

99 
VceThrowMsg
(
CRLExi
::
StageE
,

102 
WLogI
("CRL storage initialization complete.");

105 
	gCRLIm
::~
CRLIm
()

107 
nup
();

108 
de
 
	gm_lCache
;

111 
	gCRLIm
::
nup
()

113 
WLogI
("Free CRL storage");

116 
X509_STORE_
(
m_e
);

119 
	gCRL
::
RevotiStus
 
CRLIm
::
checkCtifi
(cڡ 
CtifiP
 &
gCt
)

121 
CRL
::
RevotiStus
 
tStus
 = {
l
, false};

122 
	gtV
 = 0;

123 
	gCRL
::
SgLi
 
lUris
 = 
gCUris
(
gCt
);

124 
FOREACH
(

, 
lUris
) {

125 
CRLDaP
 
	gl
 = 
gCRL
(*

);

126 i(!
	gl
) {

127 
WLogD
("CRL found f URI: %s", (*

).
c_r
());

130 
X509_CRL
 *
	glIl
 = 
cvtToIl
(
l
);

133 i(
X509_CRL_g_xtUpde
(
lIl
)) {

134 
	gtV
 = 
X509_cmp_cut_time
(

135 
X509_CRL_g_xtUpde
(
lIl
));

136 
	gtStus
.
	gisCRLVid
 = 
tV
 > 0;

139 
	gtStus
.
	gisCRLVid
 = 
ue
;

141 
WLogI
("CRL vid: %d", 
tStus
.
isCRLVid
);

142 
X509_REVOKED
 
	gv
;

143 
	gv
.
	grlNumb
 = 
X509_g_rlNumb
(
gCt
->
gX509
());

145 
	gtV
 = 
sk_X509_REVOKED_fd
(
lIl
->
l
->
voked
, &
v
);

146 
X509_CRL_
(
lIl
);

147 
	gtStus
.
	gisRevoked
 = 
tV
 != -1;

148 
WLogI
("CRLevoked: %d", 
tStus
.
isRevoked
);

150 i(!
	gtStus
.
	gisRevoked
 && 
isOutOfDe
(
l
)) {

151 
WLogD
("Certificate isot Revoked, but CRL is outOfDate.");

155  
	gtStus
;

159  
	gtStus
;

162 
	gCRL
::
RevotiStus
 
CRLIm
::
checkCtifiCha
(
CtifiCi
 
Cha
)

164 i(!
Cha
.
st
())

165 
VceThrowMsg
(
CRLExi
::
InvidPam
,

168 
	gCRL
::
RevotiStus
 
t
;

169 
	gt
.
	gisCRLVid
 = 
ue
;

170 
	gt
.
	gisRevoked
 = 
l
;

171 cڡ 
	gCtifiLi
 &
	gLi
 = 
Cha
.
gCha
();

172 
FOREACH
(

, 
Li
) {

173 i(!(*
	g
)->
isRoCt
()) {

174 
WLogI
("Ctifi commڂame: %s", (*

)->
gCommName
().
c_r
());

175 
	gCRL
::
RevotiStus
 
Resu
 = 
checkCtifi
(*

);

176 
	gt
.
	gisCRLVid
 &
Resu
.
isCRLVid
;

177 
	gt
.
	gisRevoked
 |
Resu
.
isRevoked
;

178 i(
	gt
.
	gisCRLVid
 && !t.
	gisRevoked
) {

179 
addToSte
(*

);

182 i(
	gt
.
	gisRevoked
) {

183  
	gt
;

188  
	gt
;

191 
VifitiStus
 
	gCRLIm
::
checkEndEy
(
CtifiCi
 &
cha
)

193 i(!
cha
.
st
(&& !cha.
emy
()) {

194 
WLogI
("Couldot find End Entity certificate. "

196  
	gVERIFICATION_STATUS_ERROR
;

198 
	gCtifiLi
::
cڡ_
 

 = 
cha
.
beg
();

199 
	gCRL
::
RevotiStus
 

 = 
checkCtifi
(*

);

200 i(
	g
.
	gisRevoked
) {

201  
	gVERIFICATION_STATUS_REVOKED
;

203 i(
	g
.
	gisCRLVid
) {

204  
	gVERIFICATION_STATUS_GOOD
;

206  
	gVERIFICATION_STATUS_ERROR
;

209 
	gCRLIm
::
addToSte
(cڡ 
CtifiP
 &
gCt
)

211 
X509_STORE_add_
(
m_e
, 
gCt
->
gX509
());

214 
bo
 
	gCRLIm
::
isOutOfDe
(cڡ 
CRLDaP
 &
l
) const {

215 
X509_CRL
 *
lIl
 = 
cvtToIl
(
l
);

217 
bo
 
	gsu
 = 
l
;

218 i(
X509_CRL_g_xtUpde
(
lIl
)) {

219 i(0 > 
X509_cmp_cut_time
(
X509_CRL_g_xtUpde
(
lIl
))) {

220 
	gsu
 = 
ue
;

222 
	gsu
 = 
l
;

225 
	gsu
 = 
ue
;

227 
X509_CRL_
(
lIl
);

228  
	gsu
;

231 
bo
 
	gCRLIm
::
updeLi
(cڡ 
CtifiP
 &
gCt
,

232 cڡ 
CRL
::
UpdePicy
 
updePicy
)

234 
WLogI
("Update CRL for certificate");

237 
	gCRL
::
SgLi
 
lUris
 = 
gCUris
(
gCt
);

238 
FOREACH
(

, 
lUris
) {

240 
WLogI
("Gtg CRL f URI: %s", (*

).
c_r
());

242 
bo
 
	gdowded
 = 
l
;

244 
CRLDaP
 
	gl
;

248 i(
	gupdePicy
 =
CRL
::
UPDATE_ON_EXPIRED
) {

249 
l
 = 
gCRL
(*

);

252 i(!!
	gl
 && 
isOutOfDe
(
l
)) {

253 
WLogD
("Crl out of date - downloading.");

254 
	gl
 = 
dowdCRL
(*

);

255 
	gdowded
 = 
ue
;

258 i(!
	gl
) {

259 
WLogD
("Crlot found in cache - downloading.");

260 
	gl
 = 
dowdCRL
(*

);

261 
	gdowded
 = 
ue
;

264 i(!
	gl
) {

265 
WLogD
("Faedob CRL. URL: %s", (*

).
c_r
());

269 i(!!
	gl
 && 
isOutOfDe
(
l
)) {

270 
WLogE
("CRL ouode. Brok URL: %s", (*

).
c_r
());

274 
X509_CRL
 *
	glIl
 = 
cvtToIl
(
l
);

277 i(!
vifyCRL
(
lIl
, 
gCt
)) {

278 
WLogE
("Faedvify CRL. URI: %s", (
l
->
uri
).
c_r
());

279 
X509_CRL_
(
lIl
);

280  
	gl
;

282 
X509_CRL_
(
lIl
);

284 i(
	gdowded
) {

285 
updeCRL
(
l
);

287  
	gue
;

290  
	gl
;

293 
	gCRLIm
::
addToSte
(cڡ 
CtifiCi
 &
ci
)

295 
FOREACH
(

, 
ci
){

296 
addToSte
(*

);

300 
bo
 
	gCRLIm
::
updeLi
(cڡ 
CtifiCi
 &
ci
,

301 
CRL
::
UpdePicy
 
updePicy
)

303 
bo
 
ed
 = 
l
;

305 
FOREACH
(

, 
ci
){

306 
	ged
 |!
updeLi
(*

, 
updePicy
);

309  !
	ged
;

312 
bo
 
	gCRLIm
::
vifyCRL
(
X509_CRL
 *
l
,

313 cڡ 
CtifiP
 &

)

315 
X509_OBJECT
 
	gobj
;

316 
X509_STORE_CTX
 *
	gx
 = 
Cڋxt
(

);

319 
	gtV
 = 
X509_STORE_g_by_subje
(
x
, 
X509_LU_X509
,

320 
X509_CRL_g_issu
(
l
), &
obj
);

321 
X509_STORE_CTX_
(
x
);

322 i(0 >
tV
) {

323 
WLogE
("Unknown CRL issuer certificate!");

324  
	gl
;

328 
EVP_PKEY
 *
	gpkey
 = 
X509_g_pubkey
(
obj
.
da
.
x509
);

329 
X509_OBJECT__cڋs
(&
obj
);

330 i(!
	gpkey
) {

331 
WLogE
("Failedo get issuer'sublic key.");

332  
	gl
;

334 
	gtV
 = 
X509_CRL_vify
(
l
, 
pkey
);

335 
EVP_PKEY_
(
pkey
);

336 i(0 > 
	gtV
) {

337 
WLogE
("Failedo verify CRL.");

338  
	gl
;

339 } i(0 =
tV
) {

340 
WLogE
("CRL is invalid");

341  
	gl
;

343 
WLogI
("CRL is valid.");

344  
	gue
;

347 
bo
 
	gCRLIm
::
isPEMFm
(cڡ 
CRLDaP
 &
l
) const

349 cڡ *
n
 = "-----BEGIN X509 CRL-----";

350 
	gd
::
rg
 
cڋ
(
l
->
bufr
, c->
ngth
);

351 i(
	gcڋ
.
fd
(
n
!
d
::
rg
::
os
) {

352 
WLogI
("CRL is in PEM format.");

353  
	gue
;

355 
WLogI
("CRL is in DER format.");

356  
	gl
;

359 
X509_CRL
 *
	gCRLIm
::
cvtToIl
(cڡ 
CRLDaP
 &
l
) const

362 
X509_CRL
 *
t
 = 
NULL
;

363 i(
isPEMFm
(
l
)) {

364 
BIO
 *
	gbmem
 = 
BIO_w_mem_buf
(
l
->
bufr
, c->
ngth
);

365 i(!
	gbmem
)

366 
VceThrowMsg
(
CRLExi
::
IlE
,

369 
	gt
 = 
PEM_ad_bio_X509_CRL
(
bmem
, 
NULL
, NULL, NULL);

370 
BIO__l
(
bmem
);

373 
	gd
::
rg
 
cڋ
(
l
->
bufr
, c->
ngth
);

374 cڡ *
	gbufr
 =

375 
t_
<*>(
l
->
bufr
);

376 
	gt
 = 
d2i_X509_CRL
(
NULL
, &
bufr
, 
l
->
ngth
);

379 i(!
	gt
)

380 
VceThrowMsg
(
CRLExi
::
IlE
,

382  
	gt
;

385 
X509_STORE_CTX
 *
	gCRLIm
::
Cڋxt
(cڡ 
CtifiP
 &
gCt
)

387 
X509_STORE_CTX
 *
x
;

388 
	gx
 = 
X509_STORE_CTX_w
();

389 i(!
	gx
)

390 
VceThrowMsg
(
CRLExi
::
StageE
, "Failedo createew ctx");

392 
X509_STORE_CTX_
(
x
, 
m_e
, 
gCt
->
gX509
(), 
NULL
);

393  
	gx
;

396 
	gCRLIm
::
CRLDaP
 
CRLIm
::
dowdCRL
(cڡ 
d
::
rg
 &
uri
)

398 
usg
 
mea
 
SoupW
;

400 *
	gt
 = 0, *
	gcho
 = 0,*
	gh
 = 0;

401 
	gu_s
 = 0;

403 i(!
OCSP_r_u
(
cڡ_
<*>(
uri
.
c_r
()),

404 &
cho
,

405 &
t
,

406 &
h
,

407 &
u_s
))

409 
WLogW
("Error in OCSP_parse_url");

410  
CRLDaP
();

413 
	gd
::
rg
 
ho
 = 
cho
;

414 i(
	gt
) {

415 
	gho
 += ":";

416 
	gho
 +
t
;

419 

(
t
);

420 

(
cho
);

421 

(
h
);

423 
SoupMesgeSdSync
 
	gmesge
;

424 
	gmesge
.
tHo
(
uri
);

425 
	gmesge
.
tHd
("Ho", 
ho
);

427 i(
	gSoupMesgeSdSync
::
REQUEST_STATUS_OK
 !
mesge
.
ndSync
()) {

428 
WLogW
("Error in sendingetworkequest.");

429  
CRLDaP
();

432 
	gSoupMesgeSdBa
::
MesgeBufr
 
mBufr
 = 
mesge
.
gReڣ
();

433  
CRLDaP
(
w
 
CRLDa
(
mBufr
,
uri
));

436 
	gCRLIm
::
CRLDaP
 
CRLIm
::
gCRL
(cڡ 
d
::
rg
 &
uri
) const

438 
CRLCachedDa
 
chedC
;

439 
	gchedC
.
	gdiributi_pot
 = 
uri
;

440 i(!(
	gm_lCache
->
gCRLReڣ
(&
chedC
))) {

441 
WLogI
("CRLم idaba. URI: %s", 
uri
.
c_r
());

442  
CRLDaP
();

445 
	gd
::
rg
 
body
 = 
chedC
.
l_body
;

447 
WLogI
("CRL found in database.");

451 
Ba64Decod
 
	gdecod
;

452 
	gdecod
.
nd
(
body
);

453 i(!
	gdecod
.
fize
())

454 
VceThrowMsg
(
CRLExi
::
StageE
,

456 
	gd
::
rg
 
lBody
 = 
decod
.
g
();

458 
	gd
::
unique_r
<[]> 
bodyBufr
(
w
 [
lBody
.
ngth
()]);

459 
	glBody
.
cy
(
bodyBufr
.
g
(), 
lBody
.
ngth
());

460  
CRLDaP
(
w
 
CRLDa
(
bodyBufr
.
a
(), 
lBody
.
ngth
(),

461 
uri
));

464 
	gCRLIm
::
updeCRL
(cڡ 
CRLDaP
 &
l
)

468 
Ba64Encod
 
cod
;

469 i(!
	gl
 || !l->
	gbufr
)

470 
VceThrowMsg
(
CRLExi
::
IlE
, "CRL buffer ismpty");

472 
	gcod
.
nd
(
d
::
rg
(
l
->
bufr
, c->
ngth
));

473 
	gcod
.
fize
();

474 
	gd
::
rg
 
b64CRLBody
 = 
cod
.
g
();

476 
time_t
 
	gxtUpdeTime
 = 0;

477 
X509_CRL
 *
	glIl
 = 
cvtToIl
(
l
);

479 i(
X509_CRL_g_xtUpde
(
lIl
)) {

480 
a1TimeToTimeT
(
X509_CRL_g_xtUpde
(
lIl
),

481 &
xtUpdeTime
);

484 
X509_CRL_
(
lIl
);

486 
CRLCachedDa
 
	gda
;

487 
	gda
.
	gdiributi_pot
 = 
l
->
uri
;

488 
	gda
.
	gl_body
 = 
b64CRLBody
;

489 
	gda
.
	gxt_upde_time
 = 
xtUpdeTime
;

491 
	gm_lCache
->
tCRLReڣ
(&
da
);

	@vcore/src/vcore/CRLImpl.h

23 #ide
_VALIDATION_CORE_ENGINE_CRLIMPL_H_


24 
	#_VALIDATION_CORE_ENGINE_CRLIMPL_H_


	)

26 
	~<rg.h
>

27 
	~<memy
>

28 
	~<ݒs/x509.h
>

30 
	~<d/ncyab.h
>

32 
	~<vce/Ctifi.h
>

33 
	~<vce/CtifiCi.h
>

34 
	~<vce/SoupMesgeSdBa.h
>

35 
	~<vce/VifitiStus.h
>

36 
	~<vce/CRLCacheI.h
>

37 
	~<vce/TimeCvsi.h
>

39 
	~<vce/CRL.h
>

41 
mea
 
	gVidiCe
 {

43 as
	cCRLIm
 : 
VceDPL
::
Ncyab
 {

44 
eed
:

45 
X509_STORE
 *
m_e
;

46 
X509_LOOKUP
 *
	gm_lookup
;

47 
CRLCacheI
 *
	gm_lCache
;

49 as
	cCRLDa
 : 
VceDPL
::
Ncyab
 {

50 
public
:

52 *
bufr
;

53 
size_t
 
	gngth
;

54 
	gd
::
rg
 
uri
;

56 
CRLDa
(* 
_bufr
,

57 
size_t
 
_ngth
,

58 cڡ 
d
::
rg
 &
_uri
) :

59 
bufr
(
_bufr
),

60 
ngth
(
_ngth
),

61 
uri
(
_uri
)

65 
CRLDa
(cڡ 
SoupW
::
SoupMesgeSdBa
::
MesgeBufr
 &
mBuff
,

66 cڡ 
d
::
rg
 &
mUri
)

67 : 
uri
(
mUri
)

69 
bufr
 = 
w
 [
mBuff
.
size
()];

70 
	gngth
 = 
mBuff
.
size
();

71 
memy
(
bufr
, &
mBuff
[0], mBuff.
size
());

74 ~
CRLDa
()

76 
	gde
[] 
	gbufr
;

79 
	gd
::
	tshed_r
<
	tCRLDa
> 
	tCRLDaP
;

81 
CRLDaP
 
gCRL
(cڡ 
d
::
rg
 &
uri
) const;

82 
CRLDaP
 
dowdCRL
(cڡ 
d
::
rg
 &
uri
);

83 
X509_STORE_CTX
 *
Cڋxt
(cڡ 
CtifiP
 &
gCt
);

84 
updeCRL
(cڡ 
CRLDaP
 &
l
);

85 
X509_CRL
 *
cvtToIl
(cڡ 
CRLDaP
 &
l
) const;

86 
	gCRL
::
SgLi
 
gCUris
(cڡ 
CtifiP
 &
gCt
);

87 
bo
 
isPEMFm
(cڡ 
CRLDaP
 &
l
) const;

88 
bo
 
vifyCRL
(
X509_CRL
 *
l
,

89 cڡ 
CtifiP
 &

);

90 
nup
();

91 
bo
 
isOutOfDe
(cڡ 
CRLDaP
 &
l
) const;

93 
nd
 
ass
 
	gCachedCRL
;

95 
	gpublic
:

96 
CRLIm
(
CRLCacheI
 *
r
);

97 ~
CRLIm
();

111 
	gCRL
::
RevotiStus
 
checkCtifi
(cڡ 
CtifiP
 &
gCt
);

128 
	gCRL
::
RevotiStus
 
checkCtifiCha
(
CtifiCi
 
Cha
);

130 
VifitiStus
 
checkEndEy
(
CtifiCi
 &
cha
);

144 
bo
 
updeLi
(cڡ 
CtifiP
 &
gCt
,

145 cڡ 
CRL
::
UpdePicy
 
updePicy
);

160 
bo
 
updeLi
(cڡ 
CtifiCi
 &
ci
,

161 cڡ 
CRL
::
UpdePicy
 
updePisy
);

169 
addToSte
(cڡ 
CtifiCi
 &
ci
);

177 
addToSte
(cڡ 
CtifiP
 &
gCt
);

	@vcore/src/vcore/CachedCRL.cpp

23 
	~<vce/CachedCRL.h
>

25 
	~<d/fܗch.h
>

26 
	~<d/log/w_log.h
>

27 
	~<d/fܗch.h
>

29 
	~<vce/CRLIm.h
>

30 
	~<vce/CtifiCacheDAO.h
>

31 
	~<vce/CRLCacheDAO.h
>

33 
	gmea
 {

35 cڡ 
time_t
 
	gCRL_mTimeVid
 = 3600;

37 cڡ 
time_t
 
	gCRL_maxTimeVid
 = 3600 * 24 * 7;

39 cڡ 
time_t
 
	gCRL_eshBefe
 = 3600;

41 
time_t
 
gNextUpdeTime
ime_
now
,ime_
ڣ_vidy
)

43 
time_t
 
	gm
 = 
now
 + 
CRL_mTimeVid
;

44 
time_t
 
	gmax
 = 
now
 + 
CRL_maxTimeVid
;

45 i(
	gڣ_vidy
 < 
	gm
) {

46  
	gm
;

48 i(
	gڣ_vidy
 > 
	gmax
) {

49  
	gmax
;

51  
	gڣ_vidy
;

56 
mea
 
	gVidiCe
 {

58 
time_t
 
	gCachedCRL
::
gCRLMTimeVid
() {

59  
CRL_mTimeVid
;

62 
time_t
 
	gCachedCRL
::
gCRLMaxTimeVid
() {

63  
CRL_maxTimeVid
;

66 
time_t
 
	gCachedCRL
::
gCRLReeshBefe
() {

67  
CRL_eshBefe
;

70 
	gCachedCRL
::
CachedCRL
(){}

71 
CachedCRL
::~CachedCRL(){}

73 
VifitiStus
 
CachedCRL
::
check
(cڡ 
CtifiCi
 &
s
)

75 
CRLIm
 
l
(
w
 
CRLCacheDAO
);

76 
bo
 
	glVid
 = 
ue
;

80 
	gl
.
addToSte
(
s
);

81 
FOREACH
(

, 
s
){

82 
	gCRL
::
SgLi
 
lUris
 = 
l
.
gCUris
(*

);

83 
FOREACH
(
uri
, 
lUris
) {

84 
	glVid
 = 
lVid
 && 
updeCRLFUri
(*
uri
,
l
);

87 i(!
	glVid
) {

89 
WLogD
("Some CRLsot valid");

91 
	gCRL
::
RevotiStus
 

;

92 
	gTry
 {

93 
	g
 = 
l
.
checkCtifiCha
(
s
);

94 } 
Cch
(
CRLExi
::
InvidPam
) {

96  
VERIFICATION_STATUS_ERROR
;

98 i(
	g
.
	gisRevoked
) {

99 
WLogD
("Status REVOKED");

100  
	gVERIFICATION_STATUS_REVOKED
;

102 
WLogD
("Status GOOD");

103  
	gVERIFICATION_STATUS_GOOD
;

106 
VifitiStus
 
	gCachedCRL
::
checkEndEy
(
CtifiCi
 &
s
)

108 i(
s
.
emy
()) {

109 
WLogE
("Collectionmpty. This shouldever happen.");

110 
WLogD
("Status ERROR");

111  
	gVERIFICATION_STATUS_ERROR
;

113 i(!
	gs
.
st
()) {

114 
WLogE
("Couldot find End Entity certificate. "

116 
WLogD
("Status ERROR");

117  
	gVERIFICATION_STATUS_ERROR
;

119 
CRLIm
 
l
(
w
 
CRLCacheDAO
);

120 
bo
 
	glVid
 = 
ue
;

124 
	gl
.
addToSte
(
s
);

125 
	gCtifiLi
::
cڡ_
 
i
 = 
s
.
beg
();

126 i(
	gi
 !
s
.
d
()) {

127 
CRL
::
SgLi
 
lUris
 = 
l
.
gCUris
(*
i
);

128 
FOREACH
(
uri
, 
lUris
) {

129 
	glVid
 = 
lVid
 && 
updeCRLFUri
(*
uri
,
l
);

132 i(!
	glVid
) {

134 
WLogD
("Some CRLsot valid");

136 
	gCtifiLi
::
cڡ_
 

 = 
s
.
beg
();

137 
	gCRL
::
RevotiStus
 

 = 
l
.
checkCtifi
(*

);

138 i(
	g
.
	gisRevoked
) {

139 
WLogD
("Status REVOKED");

140  
	gVERIFICATION_STATUS_REVOKED
;

142 
WLogD
("Status GOOD");

143  
	gVERIFICATION_STATUS_GOOD
;

146 
	gCachedCRL
::
updeCache
()

148 
CRLCachedDaLi
 
li
;

149 
	gCtifiCacheDAO
::
gCRLReڣLi
(&
li
);

150 
FOREACH
(
db_l
, 
li
) {

151 
updeCRLFUri
(
db_l
->
diributi_pot
, 
ue
);

155 
bo
 
	gCachedCRL
::
updeCRLFUri
(cڡ 
d
::
rg
 &
uri
, bo 
uExpedShi
)

157 
usg
 
mea
 
	gVidiCe
;

158 
CRLCachedDa
 
	gchedCRL
;

159 
	gchedCRL
.
	gdiributi_pot
 = 
uri
;

160 
time_t
 
	gnow
;

161 
time
(&
now
);

162 i(
	guExpedShi
) {

163 
	gnow
 +
CRL_eshBefe
;

165 i(
	gCtifiCacheDAO
::
gCRLReڣ
(&
chedCRL
)) {

166 i(
now
 < 
chedCRL
.
xt_upde_time
) {

167 
WLogD
("Cached CRL stvid f: %s", 
uri
.
c_r
());

168  
	gue
;

172 
CRLIm
 
l
(
w
 
CRLCacheDAO
);

173 
	gCRLIm
::
CRLDaP
 
li
 = 
l
.
dowdCRL
(
uri
);

174 i(!
	gli
) {

175 
WLogW
("CouldلivCRL from %s", 
uri
.
c_r
());

176  
	gl
;

178 
	gl
.
updeCRL
(
li
);

179 
	gCtifiCacheDAO
::
gCRLReڣ
(&
chedCRL
);

180 
	gchedCRL
.
	gxt_upde_time
 =

181 
gNextUpdeTime
(
now
,
chedCRL
.
xt_upde_time
);

182 
	gCtifiCacheDAO
::
tCRLReڣ
(
chedCRL
.
diributi_pot
,

183 
chedCRL
.
l_body
,

184 
chedCRL
.
xt_upde_time
);

185  
	gue
;

	@vcore/src/vcore/CachedCRL.h

24 #ide
_VALIDATION_CORE_CACHED_CRL_H_


25 
	#_VALIDATION_CORE_CACHED_CRL_H_


	)

27 
	~<ime
>

28 
	~<rg
>

30 
	~<vce/Ctifi.h
>

31 
	~<vce/CtifiCi.h
>

32 
	~<vce/VifitiStus.h
>

33 
	~<vce/IAbReڣCache.h
>

35 
mea
 
	gVidiCe
 {

37 as
	cCachedCRL
 : 
public
 
IAbReڣCache
 {

38 
public
:

40 
time_t
 
gCRLMTimeVid
();

44 
time_t
 
gCRLMaxTimeVid
();

48 
time_t
 
gCRLReeshBefe
();

50 
VifitiStus
 
check
(cڡ 
CtifiCi
 &
s
);

51 
VifitiStus
 
checkEndEy
(
CtifiCi
 &
s
);

52 
updeCache
();

54 
CachedCRL
();

56 
	gvtu
 ~
CachedCRL
();

58 
	give
:

64 
bo
 
updeCRLFUri
(cڡ 
d
::
rg
 & 
uri
, bo 
uExpedShi
);

	@vcore/src/vcore/CachedOCSP.cpp

24 
	~<rg
>

25 
	~<time.h
>

27 
	~<d/fܗch.h
>

28 
	~<d/log/w_log.h
>

29 
	~<d/fܗch.h
>

31 
	~<vce/OCSP.h
>

32 
	~<vce/OCSPIm.h
>

33 
	~<vce/CachedOCSP.h
>

34 
	~<vce/Ctifi.h
>

35 
	~<vce/CtifiCacheDAO.h
>

37 
	gmea
 {

40 cڡ 
time_t
 
	gOCSP_mTimeVid
 = 3600;

43 cڡ 
time_t
 
	gOCSP_maxTimeVid
 = 3600 * 24 * 7;

46 cڡ 
time_t
 
	gOCSP_eshBefe
 = 3600;

50 
mea
 
	gVidiCe
 {

52 
time_t
 
	gCachedOCSP
::
gOCSPMTimeVid
() {

53  
OCSP_mTimeVid
;

56 
time_t
 
	gCachedOCSP
::
gOCSPMaxTimeVid
() {

57  
OCSP_maxTimeVid
;

60 
time_t
 
	gCachedOCSP
::
gOCSPReeshBefe
() {

61  
OCSP_eshBefe
;

64 
	gCachedOCSP
::
CachedOCSP
(){}

66 
CachedOCSP
::~CachedOCSP(){}

68 
VifitiStus
 
CachedOCSP
::
check
(cڡ 
CtifiCi
 &
s
)

70 
OCSPCachedStus
 
db_us
;

71 
time_t
 
	gnow
;

72 
time
(&
now
);

74 
	gdb_us
.
	g_cha
 = 
s
.
toBa64Sg
();

75 
	gdb_us
.
	gd_ty_check
 = 
l
;

77 i(
	gCtifiCacheDAO
::
gOCSPStus
(&
db_us
)) {

78 
WLogD
("Found cachentry for OCSP");

79 i(
	gnow
 < 
	gdb_us
.
	gxt_upde_time
) {

80 
WLogD
("Cacheesponse valid");

81  
	gdb_us
.
	goc_us
;

86 
OCSP
 
	goc
;

87 
CtifiLi
 
	gli
 = 
s
.
gCha
();

88 
	goc
.
tTruedSte
(
li
);

90 
VifitiStusS
 
	gusS
 = 
oc
.
videCtifiLi
(
li
);

91 
	gdb_us
.
	goc_us
 = 
usS
.
cvtToStus
();

92 
	gdb_us
.
	gxt_upde_time
 = 
oc
.
gReڣVidy
();

93 
	gCtifiCacheDAO
::
tOCSPStus
(
db_us
.
_cha
,

94 
db_us
.
oc_us
,

95 
db_us
.
d_ty_check
,

96 
gNextUpdeTime
(

97 
now
,

98 
db_us
.
xt_upde_time
));

99  
	gdb_us
.
	goc_us
;

102 
VifitiStus
 
	gCachedOCSP
::
checkEndEy
(
CtifiCi
 &
s
)

104 
OCSPCachedStus
 
db_us
;

105 
time_t
 
	gnow
;

106 
time
(&
now
);

108 
	gdb_us
.
	g_cha
 = 
s
.
toBa64Sg
();

109 
	gdb_us
.
	gd_ty_check
 = 
ue
;

111 i(
	gCtifiCacheDAO
::
gOCSPStus
(&
db_us
)) {

112 
WLogD
("Found cachentry for OCSP");

113 i(
	gnow
 < 
	gdb_us
.
	gxt_upde_time
) {

114 
WLogD
("Cacheesponse valid");

115  
	gdb_us
.
	goc_us
;

120 
CtifiLi
 
	g
;

121 
gCtsFEndEy
(
s
, &

);

123 
OCSP
 
	goc
;

124 
	goc
.
tTruedSte
(
s
.
gCtifiLi
());

126 
VifitiStusS
 
	gusS
 = 
oc
.
videCtifiLi
(

);

127 
	gdb_us
.
	goc_us
 = 
usS
.
cvtToStus
();

128 
	gdb_us
.
	gxt_upde_time
 = 
oc
.
gReڣVidy
();

130 
	gCtifiCacheDAO
::
tOCSPStus
(
db_us
.
_cha
,

131 
db_us
.
oc_us
,

132 
db_us
.
d_ty_check
,

133 
gNextUpdeTime
(

134 
now
,

135 
db_us
.
xt_upde_time
));

137  
	gdb_us
.
	goc_us
;

140 
	gCachedOCSP
::
updeCache
()

142 
time_t
 
now
;

143 
time
(&
now
);

144 
	gnow
 +
OCSP_eshBefe
;

145 
OCSPCachedStusLi
 
	gli
;

146 
	gCtifiCacheDAO
::
gOCSPStusLi
(&
li
);

147 
FOREACH
(
db_us
, 
li
) {

148 i(
	gnow
 >
db_us
->
xt_upde_time
) {

150 
CtifiCi
 
c
;

151 
	gc
.
ld
(
db_us
->
_cha
);

152 i(!
	gc
.
st
()) {

153 
WLogE
("Certificate collection doesot create chain.");

157 
OCSP
 
	goc
;

158 
CtifiLi
 
	gcha
 = 
c
.
gCha
();

159 
	goc
.
tTruedSte
(
cha
);

161 
VifitiStusS
 
	gusS
;

163 i(
	gdb_us
->
	gd_ty_check
) {

164 
CtifiLi
 
	g
;

165 
gCtsFEndEy
(
c
, &

);

166 
	gusS
 = 
oc
.
videCtifiLi
(

);

168 
	gusS
 = 
oc
.
videCtifiLi
(
cha
);

171 
	gdb_us
->
	goc_us
 = 
usS
.
cvtToStus
();

172 
	gdb_us
->
	gxt_upde_time
 = 
oc
.
gReڣVidy
();

174 
	gCtifiCacheDAO
::
tOCSPStus
(
db_us
->
_cha
,

175 
db_us
->
oc_us
,

176 
db_us
->
d_ty_check
,

177 
db_us
->
xt_upde_time
);

182 
	gCachedOCSP
::
gCtsFEndEy
(

183 cڡ 
CtifiCi
 &
s
, 
CtifiLi
* 

)

185 i(
	gNULL
 =

) {

186 
WLogE
("NULLointer");

190 i(
	gs
.
isCha
(&& cts.
size
() >= 2) {

191 
CtifiLi
::
cڡ_
 
i
 = 
s
.
beg
();

192 
	g
->
push_back
(*
i
);

193 ++
	gi
;

194 
	g
->
push_back
(*
i
);

198 
time_t
 
	gCachedOCSP
::
gNextUpdeTime
ime_
now
,ime_
ڣ_vidy
)

200 
	gm
 = 
now
 + 
OCSP_mTimeVid
;

201 
	gmax
 = 
now
 + 
OCSP_maxTimeVid
;

202 i(
	gڣ_vidy
 < 
	gm
) {

203  
	gm
;

205 i(
	gڣ_vidy
 > 
	gmax
) {

206  
	gmax
;

208  
	gڣ_vidy
;

	@vcore/src/vcore/CachedOCSP.h

24 #ide
_SRC_VALIDATION_CORE_CACHED_OCSP_


25 
	#_SRC_VALIDATION_CORE_CACHED_OCSP_


	)

27 
	~<vce/OCSP.h
>

28 
	~<vce/IAbReڣCache.h
>

30 
mea
 
	gVidiCe
 {

32 as
	cCachedOCSP
 : 
public
 
IAbReڣCache
 {

33 
public
:

35 
time_t
 
gOCSPMTimeVid
();

38 
time_t
 
gOCSPMaxTimeVid
();

42 
time_t
 
gOCSPReeshBefe
();

44 
VifitiStus
 
check
(cڡ 
CtifiCi
 &
s
);

45 
VifitiStus
 
checkEndEy
(
CtifiCi
 &
s
);

46 
updeCache
();

48 
CachedOCSP
();

50 
	gvtu
 ~
CachedOCSP
();

52 
	give
:

54 
gCtsFEndEy
(cڡ 
CtifiCi
 &
s
,

55 
CtifiLi
* 

);

56 
time_t
 
gNextUpdeTime
ime_
now
,ime_
ڣ_vidy
);

	@vcore/src/vcore/CertStoreType.cpp

24 
	~<vce/CtSteTy.h
>

26 
	~<rg.h
>

28 
mea
 
	gVidiCe
 {

29 
mea
 
	gCtSteId
 {

31 
	gS
::
S
()

32 : 
m_ifiStage
(0)

33 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


34 , 
m_ocU
(
NULL
)

38 
	gS
::~
S
()

40 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


41 
de
[] 
m_ocU
;

45 
	gS
::
add
(
Ty
 
cd
)

47 
m_ifiStage
 |
cd
;

50 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


51 
	gS
::
add
(
d
::
rg
 
ocU
)

54 i(
ocU
.
ngth
() == 0)

57 
	gm_ocU
 = 
w
 [
ocU
.
ngth
() + 1];

58 i(
	gm_ocU
)

59 
y
(
m_ocU
, 
ocU
.
c_r
(), ocU.
ngth
() + 1);

63 
bo
 
	gS
::
cڏs
(
Ty
 
cd
) const

65  
ic_
<
bo
>(
m_ifiStage
 & 
cd
);

68 
bo
 
	gS
::
isEmy
() const

70  
m_ifiStage
 == 0;

73 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


74 * 
	gS
::
gOcU
()

76  
m_ocU
;

	@vcore/src/vcore/CertStoreType.h

24 #ide
_VALIDATION_CORE_CERTSTORETYPE_H_


25 
	#_VALIDATION_CORE_CERTSTORETYPE_H_


	)

27 
	~<rg
>

29 
mea
 
	gVidiCe
 {

30 
mea
 
	gCtSteId
 {

31 
	tTy
;

34 cڡ 
Ty
 
	gTIZEN_DEVELOPER
 = 1;

36 cڡ 
Ty
 
	gTIZEN_TEST
 = 1 << 1;

37 cڡ 
Ty
 
	gTIZEN_VERIFY
 = 1 << 2;

38 cڡ 
Ty
 
	gTIZEN_STORE
 = 1 << 3;

40 cڡ 
Ty
 
	gVIS_PUBLIC
 = 1 << 6;

42 cڡ 
Ty
 
	gVIS_PARTNER
 = 1 << 7;

44 cڡ 
Ty
 
	gVIS_PARTNER_OPERATOR
 = 1 << 8;

46 cڡ 
Ty
 
	gVIS_PARTNER_MANUFACTURER
 = 1 << 9;

48 cڡ 
Ty
 
	gVIS_PLATFORM
 = 1 << 10;

50 as
	cS
 {

51 
	gpublic
:

52 
S
();

53 
	gvtu
 ~
S
();

55 
add
(
Ty
 
cd
);

57 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


58 
add
(
d
::
rg
 
ocU
);

59 * 
gOcU
();

62 
bo
 
cڏs
(
Ty
 
cd
) const;

63 
bo
 
isEmy
() const;

65 
	give
:

66 
Ty
 
m_ifiStage
;

67 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


68 * 
	gm_ocU
;

	@vcore/src/vcore/Certificate.cpp

22 
	~<vce/Ctifi.h
>

24 
	~<memy
>

25 
	~<sam
>

26 
	~<iom
>

28 
	~<ݒs/x509v3.h
>

29 
	~<ݒs/bn.h
>

31 
	~<d/as.h
>

32 
	~<d/log/w_log.h
>

34 
	~<vce/Ba64.h
>

35 
	~<vce/TimeCvsi.h
>

37 
mea
 
	gVidiCe
 {

39 
	gCtifi
::
Ctifi
(
X509
 *

)

41 
As
(

);

42 
	gm_x509
 = 
X509_dup
(

);

43 i(!
	gm_x509
)

44 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

48 
	gCtifi
::
Ctifi
(
_svc_mem_buff
 &
bufr
)

50 
As
(
bufr
.
da
);

51 cڡ *
	gr
 = 
bufr
.
da
;

52 
	gm_x509
 = 
d2i_X509
(
NULL
, &
r
, 
bufr
.
size
);

53 i(!
	gm_x509
)

54 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

58 
	gCtifi
::
Ctifi
(cڡ 
d
::
rg
 &
d
,

59 
Ctifi
::
FmTy
 
fm
)

61 
As
(
d
.
size
());

63 
	gsize
;

64 cڡ *
	gr
;

65 
	gd
::
rg
 
tmp
;

67 i(
	gFORM_BASE64
 =
fm
) {

68 
Ba64Decod
 
ba64
;

69 
	gba64
.
t
();

70 
	gba64
.
nd
(
d
);

71 i(!
	gba64
.
fize
()) {

72 
WLogW
("Error during decoding");

74 
	gtmp
 = 
ba64
.
g
();

75 
	gr
 = 
t_
<cڡ *>(
tmp
.
c_r
());

76 
	gsize
 = 
ic_
<>(
tmp
.
size
());

78 
	gr
 = 
t_
<cڡ *>(
d
.
c_r
());

79 
	gsize
 = 
ic_
<>(
d
.
size
());

82 
	gm_x509
 = 
d2i_X509
(
NULL
, &
r
, 
size
);

83 i(!
	gm_x509
)

84 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

88 
	gCtifi
::~
Ctifi
()

90 
X509_
(
m_x509
);

93 
X509
* 
	gCtifi
::
gX509
() const

95  
m_x509
;

98 
	gd
::
rg
 
Ctifi
::
gDER
() const

100 *
wD
 = 
NULL
;

101 
	gsize
 = 
i2d_X509
(
m_x509
, &
wD
);

102 i(!
	gwD
 || 
	gsize
 <= 0)

103 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

106 
	gd
::
rg
 
ouut
(
t_
<*>(
wD
), 
size
);

107 
OPENSSL_
(
wD
);

108  
	gouut
;

111 
	gd
::
rg
 
Ctifi
::
gBa64
() const

113 
Ba64Encod
 
ba64
;

114 
	gba64
.
t
();

115 
	gba64
.
nd
(
gDER
());

116 
	gba64
.
fize
();

117  
	gba64
.
g
();

120 
bo
 
	gCtifi
::
isSigdBy
(cڡ 
CtifiP
 &

) const

122 i(!

) {

123 
WLogD
("Invalid certificatearameter.");

124  
	gl
;

126  0 =
X509_NAME_cmp
(
X509_g_subje_me
(

->
m_x509
),

127 
X509_g_issu_me
(
m_x509
));

130 
	gCtifi
::
Fgt
 
Ctifi
::
gFgt
(

131 
Ctifi
::
FgtTy
 
ty
) const

133 
fggth
 = 
EVP_MAX_MD_SIZE
;

134 
	gfgt
[
EVP_MAX_MD_SIZE
];

135 
Fgt
 
	gw
;

137 i(
	gty
 =
FINGERPRINT_MD5
) {

138 i(!
X509_dige
(
m_x509
, 
EVP_md5
(), 
fgt
, &
fggth
))

139 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

143 i(
	gty
 =
FINGERPRINT_SHA1
) {

144 i(!
X509_dige
(
m_x509
, 
EVP_sha1
(), 
fgt
, &
fggth
))

145 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

149 
	gw
.
size
(
fggth
);

150 
	gd
::
cy
(
fgt
, fg+ 
fggth
, 
w
.
beg
());

152  
	gw
;

155 
X509_NAME
 *
	gCtifi
::
gX509Name
(
FldTy
 
ty
) const

157 
X509_NAME
 *
me
 = 
NULL
;

159 
	gty
) {

160 
	gFIELD_ISSUER
:

161 
me
 = 
X509_g_issu_me
(
m_x509
);

163 
	gFIELD_SUBJECT
:

164 
me
 = 
X509_g_subje_me
(
m_x509
);

167 
As
("Invalid fieldype.");

170 i(!
	gme
)

171 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

174  
	gme
;

177 
	gd
::
rg
 
Ctifi
::
gOLe
(
FldTy
 
ty
) const

179 
X509_NAME
 *
me
 = 
gX509Name
(
ty
);

180 cڡ 
	gMAXB
 = 1024;

181 
	gbufr
[
MAXB
] = {0, };

182 
X509_NAME_ږe
(
me
, 
bufr
, 
MAXB
);

184  
	gd
::
rg
(
bufr
);

187 
	gd
::
rg
 
Ctifi
::
gFld
(
FldTy
 
ty
, 
fldNid
) const

189 
X509_NAME
 *
	gsubjeName
 = 
gX509Name
(
ty
);

190 
X509_NAME_ENTRY
 *
	gsubjeEry
 = 
NULL
;

191 
	gd
::
rg
 
ouut
;

192 
	gyCou
 = 
X509_NAME_y_cou
(
subjeName
);

194 
	gi
 = 0; i < 
	gyCou
; ++i) {

195 
	gsubjeEry
 = 
X509_NAME_g_y
(
subjeName
,

196 
i
);

198 i(!
	gsubjeEry
) {

202 
	gnid
 = 
OBJ_obj2nid
(

203 
ic_
<
ASN1_OBJECT
*>(

204 
X509_NAME_ENTRY_g_obje
(
subjeEry
)));

206 i(
	gnid
 !
fldNid
) {

210 
ASN1_STRING
* 
	gpASN1S
 = 
subjeEry
->
vue
;

212 * 
	gpDa
 = 
NULL
;

213 
	gnLgth
 = 
ASN1_STRING_to_UTF8
(&
pDa
,

214 
pASN1S
);

216 i(
	gnLgth
 < 0)

217 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

220 i(!
	gpDa
) {

221 
	gouut
 = 
d
::
rg
();

224 
	gouut
 = 
d
::
rg
(
t_
<*>(
pDa
), 
nLgth
);

225 
OPENSSL_
(
pDa
);

229  
	gouut
;

232 
	gd
::
rg
 
Ctifi
::
gCommName
(
FldTy
 
ty
) const

234  
gFld
(
ty
, 
NID_commName
);

237 
	gd
::
rg
 
Ctifi
::
gCouryName
(
FldTy
 
ty
) const

239  
gFld
(
ty
, 
NID_couryName
);

242 
	gd
::
rg
 
Ctifi
::
gSOrProvName
(
FldTy
 
ty
) const

244  
gFld
(
ty
, 
NID_eOrProvName
);

247 
	gd
::
rg
 
Ctifi
::
gLolyName
(
FldTy
 
ty
) const

249  
gFld
(
ty
, 
NID_lolyName
);

252 
	gd
::
rg
 
Ctifi
::
gOrgiziName
(
FldTy
 
ty
) const

254  
gFld
(
ty
, 
NID_giziName
);

257 
	gd
::
rg
 
Ctifi
::
gOrgiziڮUnName
(
FldTy
 
ty
) const

259  
gFld
(
ty
, 
NID_giziڮUnName
);

262 
	gd
::
rg
 
Ctifi
::
gEmaAdds
(
FldTy
 
ty
) const

264  
gFld
(
ty
, 
NID_pkcs9_emaAddss
);

267 
	gd
::
rg
 
Ctifi
::
gOCSPURL
() const

270 
d
::
rg
 
tVue
;

271 
AUTHORITY_INFO_ACCESS
 *
	ga
 = 
ic_
<AUTHORITY_INFO_ACCESS*>(

272 
X509_g_ext_d2i
(
m_x509
,

273 
NID_fo_acss
,

274 
NULL
,

275 
NULL
));

278 i(
	gNULL
 =
a
) {

279  
tVue
;

282 
	gcou
 = 
sk_ACCESS_DESCRIPTION_num
(
a
);

284 
	gi
 = 0; i < 
	gcou
; ++i) {

285 
ACCESS_DESCRIPTION
* 
	gad
 = 
sk_ACCESS_DESCRIPTION_vue
(
a
, 
i
);

287 i(
OBJ_obj2nid
(
ad
->
mhod
=
NID_ad_OCSP
 &&

288 
ad
->
loti
->
ty
 =
GEN_URI
)

290 *
da
 = 
ASN1_STRING_da
(
ad
->
loti
->
d
.
5
);

291 i(!
	gda
)

292 
	gtVue
 = 
d
::
rg
();

294 
	gtVue
 = 
d
::
rg
(
ic_
<*>(
da
));

298 
sk_ACCESS_DESCRIPTION_
(
a
);

299  
	gtVue
;

302 
	gCtifi
::
ANameS
 
Ctifi
::
gAɔtiveNameDNS
() const

304 
ANameS
 
t
;

306 
GENERAL_NAME
 *
	gmePt
 = 
NULL
;

308 
STACK_OF
(
GENERAL_NAME
)* 
	gn
 =

309 
ic_
<
STACK_OF
(
GENERAL_NAME
)*>(

310 
X509_g_ext_d2i
(
m_x509
,
NID_subje_t_me
,
NULL
,NULL));

312 
sk_GENERAL_NAME_num
(
n
) > 0) {

313 
	gmePt
 = 
sk_GENERAL_NAME_p
(
n
);

314 i(
	gGEN_DNS
 =
mePt
->
ty
) {

315 *
mp
 = 
t_
<*>(
ASN1_STRING_da
(
mePt
->
d
.
dNSName
));

316 i(!
	gmp
) {

317 
	gt
.

(
d
::
rg
());

320 
	gt
.

(
d
::
rg
(
mp
));

321 
WLogD
("FOUND GEN_DNS: %s", 
mp
);

324 
WLogD
("FOUND GEN TYPE ID: %d", 
mePt
->
ty
);

327  
	gt
;

330 
time_t
 
	gCtifi
::
gNA
() const

332 
ASN1_TIME
 *
time
 = 
X509_g_nA
(
m_x509
);

333 i(!
	gtime
)

334 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

337 
time_t
 
	gouut
;

338 i(
a1TimeToTimeT
(
time
, &
ouut
))

339 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

342  
	gouut
;

345 
time_t
 
	gCtifi
::
gNBefe
() const

347 
ASN1_TIME
 *
time
 = 
X509_g_nBefe
(
m_x509
);

348 i(!
	gtime
)

349 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

352 
time_t
 
	gouut
;

353 i(
a1TimeToTimeT
(
time
, &
ouut
))

354 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

357  
	gouut
;

360 
ASN1_TIME
* 
	gCtifi
::
gNATime
() const

362 
ASN1_TIME
 *
tim
 = 
X509_g_nA
(
m_x509
);

363 i(!
	gtim
)

364 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

367  
	gtim
;

370 
ASN1_TIME
* 
	gCtifi
::
gNBefeTime
() const

372 
ASN1_TIME
 *
timebefe
 = 
X509_g_nBefe
(
m_x509
);

373 i(!
	gtimebefe
)

374 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

377  
	gtimebefe
;

380 
bo
 
	gCtifi
::
isRoCt
()

383  
isSigdBy
(
this
->
shed_om_this
());

386 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


387 
	gd
::
li
<
d
::
rg
>

388 
Ctifi
::
gCUris
() const

390 
d
::
li
<d::
rg
> 
su
;

392 
STACK_OF
(
DIST_POINT
)* 
	gdiPots
 =

393 
ic_
<
STACK_OF
(
DIST_POINT
)*>(

394 
X509_g_ext_d2i
(

395 
gX509
(),

396 
NID_l_diributi_pots
,

397 
NULL
,

398 
NULL
));

399 i(!
	gdiPots
) {

400 
WLogD
("No distributionoints in certificate.");

401  
	gsu
;

404 
	gcou
 = 
sk_DIST_POINT_num
(
diPots
);

405 
	gi
 = 0; i < 
	gcou
; ++i) {

406 
DIST_POINT
* 
	gpot
 = 
sk_DIST_POINT_vue
(
diPots
, 
i
);

407 i(!
	gpot
) {

408 
WLogE
("Failedo get distributionoint.");

411 i(
	gpot
->
	gdipot
 !
NULL
 &&

412 
pot
->
dipot
->
me
.
fume
 !
NULL
)

414 
couName
 =

415 
sk_GENERAL_NAME_num
(
pot
->
dipot
->
me
.
fume
);

416 
	gj
 = 0; j < 
	gcouName
; ++j) {

417 
GENERAL_NAME
* 
	gme
 = 
sk_GENERAL_NAME_vue
(

418 
pot
->
dipot
->
me
.
fume
, 
j
);

419 i(
	gme
 !
NULL
 && 
GEN_URI
 =
me
->
ty
) {

420 *
lUri
 =

421 
t_
<*>(
me
->
d
.
5
->
da
);

422 i(!
	glUri
) {

423 
WLogE
("Failedo get URI.");

426 
	gsu
.
push_back
(
lUri
);

431 
sk_DIST_POINT_p_
(
diPots
, 
DIST_POINT_
);

432  
	gsu
;

436 
	gCtifi
::
gVsi
() const

438  
X509_g_vsi
(
m_x509
);

441 
	gd
::
rg
 
Ctifi
::
gSlNumbSg
() const

443 
ASN1_INTEGER
 *
ai
 = 
X509_g_rlNumb
(
m_x509
);

444 i(!
	gai
)

445 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

448 
	gd
::
rgam
 
am
;

449 
	gam
 << 
	gd
::
hex
 << 
d
::
tfl
('0');

450 i(
	gai
->
	gty
 =
V_ASN1_NEG_INTEGER
) {

451 
am
 << "(Negetive) ";

453 
	gi
=0; i<
	gai
->
	gngth
; ++i) {

454 
	gam
 << 
	gd
::
tw
(2<< ()
ai
->
da
[
i
] << ":";

456 
	gd
::
rg
 
da
 = 
am
.
r
();

457 i(!
	gda
.
emy
()) {

458 
	gda
.
a
(--
da
.
d
());

461  
	gda
;

464 
	gd
::
rg
 
Ctifi
::
gKeyUgeSg
() const

467 cڡ *
uge
[] = {

478 
	g
 = -1;

479 
	gidx
 = -1;

480 
ASN1_BIT_STRING
 *
	gkeyUge
 = (ASN1_BIT_STRING*)

481 
X509_g_ext_d2i
(
m_x509
, 
NID_key_uge
, &

, &
idx
);

483 
	gd
::
rgam
 
am
;

484 
	gi
=0; i<9; ++i) {

485 i(
ASN1_BIT_STRING_g_b
(
keyUge
, 
i
)) {

486 
	gam
 << 
	guge
[
i
] << ",";

489 
	gd
::
rg
 
su
 = 
am
.
r
();

490 i(!
	gsu
.
emy
()) {

491 
	gsu
.
a
(--
su
.
d
());

494  
	gsu
;

497 
	gd
::
rg
 
Ctifi
::
gSigtuAlgܙhmSg
() const

499 
d
::
unique_r
<
BIO
, 
	gd
::
funi
<(BIO*)>>

500 
b
(
BIO_w
(
BIO_s_mem
()),
BIO_
);

502 i(!
	gb
.
g
())

503 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

506 i(
i2a_ASN1_OBJECT
(
b
.
g
(), 
m_x509
->
_fo
->
sigtu
->
gܙhm
) < 0)

507 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

510 
BUF_MEM
 *
	gbr
 = 0;

511 
BIO_g_mem_r
(
b
.
g
(), &
br
);

512 i(
	gbr
 == 0)

513 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

516 
	gd
::
rg
 
su
(
br
->
da
, br->
ngth
);

518  
	gsu
;

521 
	gd
::
rg
 
Ctifi
::
gPublicKeySg
() const

523 
d
::
unique_r
<
BIO
, 
	gd
::
funi
<(BIO*)>>

524 
b
(
BIO_w
(
BIO_s_mem
()),
BIO_
);

526 i(!
	gb
.
g
())

527 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

530 
EVP_PKEY
 *
	gpkey
 = 
X509_g_pubkey
(
m_x509
);

531 i(!
	gpkey
)

532 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

535 
EVP_PKEY_t_public
(
b
.
g
(), 
pkey
, 16, 
NULL
);

536 
EVP_PKEY_
(
pkey
);

538 
BUF_MEM
 *
	gbr
 = 0;

539 
BIO_g_mem_r
(
b
.
g
(), &
br
);

540 i(
	gbr
 == 0)

541 
VceThrowMsg
(
Ctifi
::
Exi
::
OnsIlE
,

544 
	gd
::
rg
 
su
(
br
->
da
, br->
ngth
);

546  
	gsu
;

549 
	gCtifi
::
isCA
() const

551  
X509_check_
(
m_x509
);

554 
	gd
::
rg
 
Ctifi
::
FgtToCHex
(

555 cڡ 
Ctifi
::
Fgt
 &
fgt
)

557 
d
::
rg
 
outSg
;

558 
	gbuff
[8];

560 
size_t
 
	gi
 = 0; i < 
	gfgt
.
size
(); ++i) {

561 
tf
(
buff
,

562 (
buff
),

564 
ic_
<>(
fgt
[
i
]));

565 
	goutSg
 +
buff
;

569 
	goutSg
.
a
(
outSg
.
d
() - 1);

570  
	goutSg
;

	@vcore/src/vcore/Certificate.h

22 #ide
_VALIDATION_CORE_CERTIFICATE_H_


23 
	#_VALIDATION_CORE_CERTIFICATE_H_


	)

25 
	~<li
>

26 
	~<t
>

27 
	~<rg
>

28 
	~<ve
>

29 
	~<ime
>

30 
	~<memy
>

32 
	~<ݒs/x509.h
>

34 
	~<vce/exi.h
>

36 
	~<-rvi.h
>

39 
x509_
;

40 
x509_
 
	tX509
;

41 
X509_me_
;

42 
X509_me_
 
	tX509_NAME
;

45 
mea
 
VidiCe
 {

47 
ass
 
Ctifi
;

49 
d
::
	tshed_r
<
	tCtifi
> 
	tCtifiP
;

50 
d
::
	tli
<
	tCtifiP
> 
	tCtifiLi
;

52 
ass
 
Ctifi
 : 
public
 
d
::
ab_shed_om_this
<Certificate> {

53 
public
:

54 as
	cExi
 {

55 
public
:

56 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
);

57 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
OnsIlE
);

60 
d
::
	tve
<> 
	tFgt
;

63 
d
::
	trg
 
	tAName
;

64 
d
::
	tt
<
	tAName
> 
	tANameS
;

66 
	eFgtTy


68 
FINGERPRINT_MD5
,

69 
FINGERPRINT_SHA1


71 
	eFldTy


73 
FIELD_ISSUER
,

74 
FIELD_SUBJECT


77 
	eFmTy


79 
FORM_DER
,

80 
FORM_BASE64


83 
exic
 
Ctifi
(
X509
 *

);

85 
exic
 
Ctifi
(
_svc_mem_buff
 &
bufr
);

87 
exic
 
Ctifi
(cڡ 
d
::
rg
 &
d
,

88 
FmTy
 
fm
 = 
FORM_DER
);

90 ~
Ctifi
();

94 
X509
 *
gX509
() const;

96 
d
::
rg
 
gDER
() const;

98 
d
::
rg
 
gBa64
() const;

103 
bo
 
isSigdBy
(cڡ 
CtifiP
 &

) const;

105 
Fgt
 
gFgt
(
FgtTy
 
ty
) const;

109 
d
::
rg
 
gOLe
(
FldTy
 
ty
 = 
FIELD_SUBJECT
) const;

110 
d
::
rg
 
gCommName
(
FldTy
 
ty
 = 
FIELD_SUBJECT
) const;

111 
d
::
rg
 
gCouryName
(
FldTy
 
ty
 = 
FIELD_SUBJECT
) const;

112 
d
::
rg
 
gSOrProvName
(
FldTy
 
ty
 = 
FIELD_SUBJECT
) const;

113 
d
::
rg
 
gLolyName
(
FldTy
 
ty
 = 
FIELD_SUBJECT
) const;

114 
d
::
rg
 
gOrgiziName
(
FldTy
 
ty
 = 
FIELD_SUBJECT
) const;

115 
d
::
rg
 
gOrgiziڮUnName
(
FldTy
 
ty
 = 
FIELD_SUBJECT
) const;

116 
d
::
rg
 
gEmaAdds
(
FldTy
 
ty
 = 
FIELD_SUBJECT
) const;

117 
d
::
rg
 
gOCSPURL
() const;

123 
ANameS
 
gAɔtiveNameDNS
() const;

125 
time_t
 
gNA
() const;

127 
time_t
 
gNBefe
() const;

129 
ASN1_TIME
* 
gNATime
() const;

131 
ASN1_TIME
* 
gNBefeTime
() const;

139 
bo
 
isRoCt
();

144 
d
::
li
<d::
rg
> 
gCUris
() const;

146 
gVsi
() const;

149 
d
::
rg
 
gSlNumbSg
() const;

150 
d
::
rg
 
gKeyUgeSg
() const;

151 
d
::
rg
 
gSigtuAlgܙhmSg
() const;

152 
d
::
rg
 
gPublicKeySg
() const;

162 
isCA
() const;

164 
d
::
rg
 
FgtToCHex
(

165 cڡ 
Fgt
 &
fgt
);

167 
eed
:

168 
X509_NAME
 *
gX509Name
(
FldTy
 
ty
) const;

171 
d
::
rg
 
gFld
(
FldTy
 
ty
, 
fldNid
) const;

173 
X509
 *
m_x509
;

	@vcore/src/vcore/CertificateCacheDAO.cpp

25 
	~<vce/CtifiCacheDAO.h
>

26 
	~<vce/VCePrive.h
>

28 
	~<d/fܗch.h
>

29 
	~<d/log/w_log.h
>

30 
	~<d/db/m.h
>

31 
	~<m_g_vce.h
>

32 
	~<vce/Daba.h
>

34 
usg
 
mea
 
	gVceDPL
::
DB
::
ORM
;

35 
usg
 
mea
 
	gVceDPL
::
DB
::
ORM
::
vce
;

37 
mea
 
	gVidiCe
 {

39 
	gCtifiCacheDAO
::
tOCSPStus
(cڡ 
d
::
rg
& 
_cha
,

40 
VifitiStus
 
oc_us
,

41 
bo
 
d_ty_check
,

42 
time_t
 
xt_upde_time
)

44 
	gTry
 {

45 
ScedTni
 
i
(&
ThadI
());

46 
OCSPCachedStus
 
	gus
;

47 
	gus
.
	g_cha
 = 
_cha
;

48 
	gus
.
	gd_ty_check
 = 
d_ty_check
;

49 i(
gOCSPStus
(&
us
)) {

51 
	gEqus
<
	gOCSPReڣStage
::
_cha
> 
e1
(

52 
VceDPL
::
FromUTF8Sg
(
_cha
));

53 
	gEqus
<
	gOCSPReڣStage
::
d_ty_check
> 
e2
(

54 
d_ty_check
 ? 1 : 0);

56 
	gOCSPReڣStage
::
Row
 
row
;

58 
	grow
.
S_oc_us
(
oc_us
);

59 
	grow
.
S_xt_upde_time
(
xt_upde_time
);

61 
VCORE_DB_UPDATE
(
upde
, 
OCSPReڣStage
, &
ThadI
())

62 
	gupde
->
Whe
(
And
(
e1
,
e2
));

63 
	gupde
->
Vues
(
row
);

64 
	gupde
->
Execu
();

67 
	gOCSPReڣStage
::
Row
 
row
;

69 
	grow
.
S__cha
(
VceDPL
::
FromUTF8Sg
(
_cha
));

70 
	grow
.
S_oc_us
(
oc_us
);

71 
	grow
.
S_xt_upde_time
(
xt_upde_time
);

72 
	grow
.
S_d_ty_check
(
d_ty_check
 ? 1 : 0);

74 
VCORE_DB_INSERT
(

, 
OCSPReڣStage
, &
ThadI
())

75 
	g
->
Vues
(
row
);

76 
	g
->
Execu
();

78 
	gi
.
Comm
();

79 } 
Cch
(
VceDPL
::
DB
::
SqlCi
::
Exi
::
Ba
) {

80 
ReThrowMsg
(
Exi
::
DabaE
, "Failedo setOCSPStatus");

84 
bo
 
	gCtifiCacheDAO
::
gOCSPStus
(
OCSPCachedStus
* 
ched_us
)

86 i(
NULL
 =
ched_us
) {

87 
WLogE
("NULLointer");

88  
	gl
;

90 
	gTry
 {

91 
	gEqus
<
	gOCSPReڣStage
::
_cha
> 
e1
(

92 
VceDPL
::
FromUTF8Sg
(
ched_us
->
_cha
));

93 
	gEqus
<
	gOCSPReڣStage
::
d_ty_check
> 
e2
(

94 
ched_us
->
d_ty_check
 ? 1 : 0);

96 
VCORE_DB_SELECT
(

, 
OCSPReڣStage
, &
ThadI
())

98 
	g
->
Whe
(
And
(
e1
,
e2
));

99 
	gd
::
li
<
OCSPReڣStage
::
Row
> 
rows
 = 

->
GRowLi
();

100 i(1 =
rows
.
size
()) {

101 
OCSPReڣStage
::
Row
 
row
 = 
rows
.
t
();

102 
	gched_us
->
	goc_us
 = 
tToVifitiStus
(

103 *(
row
.
G_oc_us
()));

104 
	gched_us
->
	gxt_upde_time
 = *(
row
.
G_xt_upde_time
());

105  
	gue
;

108 
WLogD
("Cached OCSP statusot found");

109  
	gl
;

111 
Cch
(
VceDPL
::
DB
::
SqlCi
::
Exi
::
Ba
) {

112 
ReThrowMsg
(
Exi
::
DabaE
, "Failedo getOCSPStatus");

116 
	gCtifiCacheDAO
::
gOCSPStusLi
(

117 
OCSPCachedStusLi
* 
ched_us_li
)

119 i(
NULL
 =
ched_us_li
) {

120 
WLogE
("NULLointer");

123 
	gTry
 {

124 
VCORE_DB_SELECT
(

, 
OCSPReڣStage
, &
ThadI
())

125 
	gd
::
	tli
<
	tOCSPReڣStage
::
	tRow
> 
	tRowLi
;

126 
RowLi
 
	gli
 = 

->
GRowLi
();

128 
FOREACH
(
i
, 
li
) {

129 
OCSPCachedStus
 
	gus
;

130 
	gus
.
	g_cha
 = 
VceDPL
::
ToUTF8Sg
(
i
->
G__cha
());

131 
	gus
.
	goc_us
 = 
tToVifitiStus
(

132 *(
i
->
G_oc_us
()));

133 
	gus
.
	gd_ty_check
 =

134 *(
i
->
G_d_ty_check
()=1 ? 
ue
 : 
l
;

135 
	gus
.
	gxt_upde_time
 = *(
i
->
G_xt_upde_time
());

136 
	gched_us_li
->
push_back
(
us
);

140 
Cch
(
VceDPL
::
DB
::
SqlCi
::
Exi
::
Ba
) {

141 
ReThrowMsg
(
Exi
::
DabaE
, "Failedo getOCSPStatusList");

146 
	gCtifiCacheDAO
::
tCRLReڣ
(cڡ 
d
::
rg
& 
diributi_pot
,

147 cڡ 
d
::
rg
& 
l_body
,

148 
time_t
 
xt_upde_time
)

150 
	gTry
 {

151 
ScedTni
 
i
(&
ThadI
());

152 
CRLCachedDa
 
	gda
;

153 
	gda
.
	gdiributi_pot
 = 
diributi_pot
;

154 i(
gCRLReڣ
(&
da
)) {

156 
VCORE_DB_UPDATE
(
upde
, 
CRLReڣStage
, &
ThadI
())

157 
	gEqus
<
	gCRLReڣStage
::
diributi_pot
> 
e1
(

158 
VceDPL
::
FromUTF8Sg
(
diributi_pot
));

159 
	gCRLReڣStage
::
Row
 
row
;

161 
	gupde
->
Whe
(
e1
);

162 
	grow
.
S_l_body
(
VceDPL
::
FromUTF8Sg
(
l_body
));

163 
	grow
.
S_xt_upde_time
(
xt_upde_time
);

164 
	gupde
->
Vues
(
row
);

165 
	gupde
->
Execu
();

168 
VCORE_DB_INSERT
(

, 
CRLReڣStage
, &
ThadI
())

169 
	gCRLReڣStage
::
Row
 
row
;

171 
	grow
.
S_diributi_pot
(
VceDPL
::
FromUTF8Sg
(
diributi_pot
));

172 
	grow
.
S_l_body
(
VceDPL
::
FromUTF8Sg
(
l_body
));

173 
	grow
.
S_xt_upde_time
(
xt_upde_time
);

174 
	g
->
Vues
(
row
);

175 
	g
->
Execu
();

177 
	gi
.
Comm
();

178 } 
Cch
(
VceDPL
::
DB
::
SqlCi
::
Exi
::
Ba
) {

179 
ReThrowMsg
(
Exi
::
DabaE
, "Failedo setOCSPStatus");

183 
bo
 
	gCtifiCacheDAO
::
gCRLReڣ
(
CRLCachedDa
* 
ched_da
)

185 i(
NULL
 =
ched_da
) {

186 
WLogE
("NULLointer");

187  
	gl
;

189 
	gTry
 {

190 
VCORE_DB_SELECT
(

, 
CRLReڣStage
, &
ThadI
())

191 
	gEqus
<
	gCRLReڣStage
::
diributi_pot
> 
e1
(

192 
VceDPL
::
FromUTF8Sg
(
ched_da
->
diributi_pot
));

194 
	g
->
Whe
(
e1
);

195 
	gd
::
li
<
CRLReڣStage
::
Row
> 
rows
 = 

->
GRowLi
();

196 i(1 =
rows
.
size
()) {

197 
CRLReڣStage
::
Row
 
row
 = 
rows
.
t
();

198 
	gched_da
->
	gl_body
 = 
VceDPL
::
ToUTF8Sg
(
row
.
G_l_body
());

199 
	gched_da
->
	gxt_upde_time
 = *(
row
.
G_xt_upde_time
());

200  
	gue
;

203 
WLogD
("Cached CRLot found");

204  
	gl
;

206 
Cch
(
VceDPL
::
DB
::
SqlCi
::
Exi
::
Ba
) {

207 
ReThrowMsg
(
Exi
::
DabaE
, "Failedo getCRLResponse");

211 
	gCtifiCacheDAO
::
gCRLReڣLi
(

212 
CRLCachedDaLi
* 
ched_da_li
)

214 i(
NULL
 =
ched_da_li
) {

215 
WLogE
("NULLointer");

218 
	gTry
 {

219 
VCORE_DB_SELECT
(

, 
CRLReڣStage
, &
ThadI
())

220 
	gd
::
	tli
<
	tCRLReڣStage
::
	tRow
> 
	tRowLi
;

221 
RowLi
 
	gli
 = 

->
GRowLi
();

223 
FOREACH
(
i
, 
li
) {

224 
CRLCachedDa
 
	gڣ
;

225 
	gڣ
.
	gdiributi_pot
 = 
VceDPL
::
ToUTF8Sg
(

226 
i
->
G_diributi_pot
());

227 
	gڣ
.
	gl_body
 = 
VceDPL
::
ToUTF8Sg
(
i
->
G_l_body
());

228 
	gڣ
.
	gxt_upde_time
 = *(
i
->
G_xt_upde_time
());

229 
	gched_da_li
->
push_back
(
ڣ
);

233 
Cch
(
VceDPL
::
DB
::
SqlCi
::
Exi
::
Ba
) {

234 
ReThrowMsg
(
Exi
::
DabaE
, "Failedo getCRLResponses");

238 
	gCtifiCacheDAO
::
rCtifiCache
()

240 
Try
 {

241 
ScedTni
 
i
(&
ThadI
());

242 
VCORE_DB_DELETE
(
d1
, 
OCSPReڣStage
, &
ThadI
())

243 
	gd1
->
Execu
();

244 
VCORE_DB_DELETE
(
d2
, 
CRLReڣStage
, &
ThadI
())

245 
	gd2
->
Execu
();

246 
	gi
.
Comm
();

248 
Cch
(
VceDPL
::
DB
::
SqlCi
::
Exi
::
Ba
) {

249 
ReThrowMsg
(
Exi
::
DabaE
, "Failedo clearUserSettings");

253 
VifitiStus
 
	gCtifiCacheDAO
::
tToVifitiStus
(
p
)

255 
p
) {

257  
VERIFICATION_STATUS_GOOD
;

259  
VERIFICATION_STATUS_REVOKED
;

261  
VERIFICATION_STATUS_UNKNOWN
;

263  
VERIFICATION_STATUS_VERIFICATION_ERROR
;

265  
VERIFICATION_STATUS_NOT_SUPPORT
;

267  
VERIFICATION_STATUS_CONNECTION_FAILED
;

269  
VERIFICATION_STATUS_ERROR
;

271  
VERIFICATION_STATUS_ERROR
;

	@vcore/src/vcore/CertificateCacheDAO.h

25 #ide
_WRT_SRC_CONFIGURATION_CERTIFICATE_CACHE_DAO_H_


26 
	#_WRT_SRC_CONFIGURATION_CERTIFICATE_CACHE_DAO_H_


	)

28 
	~<rg
>

29 
	~<li
>

31 
	~<d/exi.h
>

33 
	~<vce/VifitiStus.h
>

34 
	~<vce/CRLCacheI.h
>

36 
mea
 
	gVidiCe
 {

38 
	sOCSPCachedStus


40 
	gd
::
rg
 
_cha
;

41 
VifitiStus
 
	goc_us
;

42 
bo
 
	gd_ty_check
;

43 
time_t
 
	gxt_upde_time
;

46 
	gd
::
	tli
<
	tOCSPCachedStus
> 
	tOCSPCachedStusLi
;

48 
	gd
::
	tli
<
	tCRLCachedDa
> 
	tCRLCachedDaLi
;

50 as
	cCtifiCacheDAO
 {

51 
	gpublic
:

52 as
	cExi


54 
public
:

55 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

56 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
DabaE
)

61 
tOCSPStus
(cڡ 
d
::
rg
& 
_cha
,

62 
VifitiStus
 
oc_us
,

63 
bo
 
d_ty_check
,

64 
time_t
 
xt_upde_time
);

70 
bo
 
gOCSPStus
(
OCSPCachedStus
* 
ched_us
);

71 
gOCSPStusLi
(
OCSPCachedStusLi
* 
ched_us_li
);

75 
tCRLReڣ
(cڡ 
d
::
rg
& 
diributi_pot
,

76 cڡ 
d
::
rg
& 
l_body
,

77 
time_t
 
xt_upde_time
);

78 
tCRLReڣ
(
CRLCachedDa
 *
r
) {

79 
tCRLReڣ
(

80 
r
->
diributi_pot
,

81 
r
->
l_body
,

82 
r
->
xt_upde_time
);

88 
bo
 
gCRLReڣ
(
CRLCachedDa
* 
ched_da
);

89 
gCRLReڣLi
(
CRLCachedDaLi
* 
ched_da_li
);

93 
rCtifiCache
();

95 
	give
:

97 
VifitiStus
 
tToVifitiStus
(
p
);

99 
CtifiCacheDAO
()

	@vcore/src/vcore/CertificateCollection.cpp

22 
	~<vce/CtifiCi.h
>

24 
	~<vce/Ba64.h
>

25 
	~<d/by_queue.h
>

26 
	~<d/fܗch.h
>

27 
	~<d/log/w_log.h
>

29 
	~<gܙhm
>

31 
	gmea
 {

33 
usg
 
mea
 
	gVidiCe
;

35 
le
 
	gd
::
rg
 
toBySg
(
da
)

37 
bufr
[()];

38 
memy
(
bufr
, &
da
, ());

39  
	gd
::
rg
(
bufr
, ());

44 
mea
 
	gVidiCe
 {

46 
	gCtifiCi
::
CtifiCi
()

47 : 
m_ciStus
(
COLLECTION_UNSORTED
)

50 
CtifiCi
::
r
()

52 
m_ciStus
 = 
COLLECTION_UNSORTED
;

53 
	gm_Li
.
r
();

56 
	gCtifiCi
::
ld
(cڡ 
CtifiLi
 &
Li
)

58 
m_ciStus
 = 
COLLECTION_UNSORTED
;

59 
	gd
::
cy
(
Li
.
beg
(),

60 
Li
.
d
(),

61 
d
::
back_
(
m_Li
));

64 
bo
 
	gCtifiCi
::
ld
(cڡ 
d
::
rg
 &
bufr
)

66 
Ba64Decod
 
ba64
;

67 
	gba64
.
t
();

68 
	gba64
.
nd
(
bufr
);

69 i(!
	gba64
.
fize
()) {

70 
WLogW
("Error during chain decoding");

71  
	gl
;

73 
	gd
::
rg
 
byDa
 = 
ba64
.
g
();

75 
	gVceDPL
::
ByQueue
 
queue
;

76 
	gqueue
.
AdCy
(
byDa
.
c_r
(), byDa.
size
());

78 
	gNum
;

79 
	gqueue
.
FωCsume
(&
Num
, ());

81 
CtifiLi
 
	gli
;

82 
CtifiP
 
	gP
;

84 
	gi
 = 0; i < 
	gNum
; ++i) {

85 
	gSize
;

86 
	gqueue
.
FωCsume
(&
Size
, ());

87 
	gd
::
ve
<> 
wDERCt
;

88 
	gwDERCt
.
size
(
Size
);

89 
	gqueue
.
FωCsume
(&
wDERCt
[0], 
Size
);

90 
	gVceTry
 {

91 
	gli
.
push_back
(
CtifiP
(
w
 
Ctifi
(
d
::
rg
(

92 
wDERCt
.
beg
(),

93 
wDERCt
.
d
()))));

94 } 
VceCch
 (
Ctifi
::
Exi
::
Ba
) {

95 
WLogW
("Error during certificate creation.");

96  
	gl
;

99 
WLogD
("Ldg ctifi. Ctifi commڂame: %s", 
li
.
back
()->
gCommName
().
c_r
());

101 
ld
(
li
);

102  
	gue
;

105 
	gd
::
rg
 
CtifiCi
::
toBa64Sg
() const

107 
d
::
orgam
 
ouut
;

108 
	gNum
 = 
m_Li
.
size
();

109 
	gouut
 << 
toBySg
(
Num
);

110 
FOREACH
(
i
, 
m_Li
){

111 
	gd
::
rg
 
dCt
 = (*
i
)->
gDER
();

112 
	gouut
 << 
toBySg
(
dCt
.
size
());

113 
	gouut
 << 
	gdCt
;

115 
Ba64Encod
 
	gba64
;

116 
	gba64
.
t
();

117 
	gba64
.
nd
(
ouut
.
r
());

118 
	gba64
.
fize
();

119  
	gba64
.
g
();

122 
CtifiLi
 
	gCtifiCi
::
gCtifiLi
() const

124  
m_Li
;

127 
bo
 
	gCtifiCi
::
isCha
() const

129 i(
COLLECTION_SORTED
 !
m_ciStus
)

130 
VceThrowMsg
(
CtifiCi
::
Exi
::
WrgUge
,

133  (
	gCOLLECTION_SORTED
 =
m_ciStus
? 
ue
 : 
l
;

136 
bo
 
	gCtifiCi
::
st
()

138 i(
COLLECTION_UNSORTED
 =
m_ciStus
) {

139 
stCi
();

141  (
	gCOLLECTION_SORTED
 =
m_ciStus
? 
ue
 : 
l
;

144 
CtifiLi
 
	gCtifiCi
::
gCha
() const

146 i(
COLLECTION_SORTED
 !
m_ciStus
)

147 
VceThrowMsg
(
CtifiCi
::
Exi
::
WrgUge
,

149  
	gm_Li
;

152 
	gCtifiCi
::
stCi
()

155 i(
m_Li
.
emy
()) {

156 
m_ciStus
 = 
COLLECTION_SORTED
;

160 
CtifiLi
 
	gs܋d
;

161 
	gd
::
m
<
d
::
rg
, 
	gCtifiP
> 
	gsubTn
;

162 
	gd
::
m
<
d
::
rg
, 
	gCtifiP
> 
	gissTn
;

165 aut
	g
 = 
m_Li
.
beg
(); i!m_Li.
d
(); ++it) {

166 
	gsubTn
.

(
d
::
make_
((*

)->
gOLe
(), (*it)));

169 
	gs܋d
.
push_back
(
subTn
.
beg
()->
cd
);

170 
	gsubTn
.
a
(
subTn
.
beg
());

174 !
	gsubTn
.
emy
()) {

175 
	gd
::
rg
 
issu
 = 
s܋d
.
back
()->
gOLe
(
Ctifi
::
FIELD_ISSUER
);

176 aut
	g
 = 
subTn
.
fd
(
issu
);

177 i(
	g
 =
subTn
.
d
()) {

180 
	gs܋d
.
push_back
(

->
cd
);

181 
	gsubTn
.
a
(

);

185 aut
	g
 = 
subTn
.
beg
(); i!subTn.
d
(); ++it) {

186 
	gissTn
.

(
d
::
make_
(

->
cd
->
gOLe
(
Ctifi
::
FIELD_ISSUER
), it->second));

191 !
	gissTn
.
emy
()) {

192 
	gd
::
rg
 
sub
 = 
s܋d
.
t
()->
gOLe
();

193 aut
	g
 = 
issTn
.
fd
(
sub
);

194 i(
	g
 =
issTn
.
d
()) {

197 
	gs܋d
.
push_t
(

->
cd
);

198 
	gissTn
.
a
(

);

201 i(!
	gissTn
.
emy
()) {

202 
WLogW
("Certificates don't form valid chain.");

203 
	gm_ciStus
 = 
COLLECTION_CHAIN_BROKEN
;

207 
	gm_ciStus
 = 
COLLECTION_SORTED
;

208 
	gm_Li
 = 
s܋d
;

211 
size_t
 
	gCtifiCi
::
size
() const {

212  
m_Li
.
size
();

215 
bo
 
	gCtifiCi
::
emy
() const {

216  
m_Li
.
emy
();

219 
	gCtifiCi
::
cڡ_
 
CtifiCi
::
beg
() const {

220  
m_Li
.
beg
();

223 
	gCtifiCi
::
cڡ_
 
CtifiCi
::
d
() const {

224  
m_Li
.
d
();

227 
CtifiP
 
	gCtifiCi
::
back
() const {

228  
m_Li
.
back
();

	@vcore/src/vcore/CertificateCollection.h

22 #ide
_VALIDATION_CORE_CERTIFICATECOLLECTION_H_


23 
	#_VALIDATION_CORE_CERTIFICATECOLLECTION_H_


	)

25 
	~<li
>

26 
	~<rg
>

27 
	~<m
>

29 
	~<vce/exi.h
>

31 
	~<vce/Ctifi.h
>

33 
mea
 
	gVidiCe
 {

41 as
	cCtifiCi
 {

42 
	gpublic
:

43 as
	cExi
 {

44 
public
:

45 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
);

46 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
WrgUge
);

49 
CtifiCi
();

51 
	gCtifiLi
::
	tcڡ_
 const_iterator;

56 
r
();

64 
ld
(cڡ 
CtifiLi
 &
Li
);

74 
bo
 
ld
(cڡ 
d
::
rg
 &
ba64
);

80 
	gd
::
rg
 
toBa64Sg
() const;

85 
CtifiLi
 
gCtifiLi
() const;

94 
bo
 
isCha
() const;

105 
bo
 
st
();

118 
CtifiLi
 
gCha
() const;

123 
size_t
 
size
() const;

128 
bo
 
emy
() const;

136 
cڡ_
 
beg
() const;

144 
cڡ_
 
d
() const;

152 
CtifiP
 
back
() const;

154 
	geed
:

155 
stCi
();

157 
	eCiStus


160 
	gCOLLECTION_UNSORTED
,

162 
	gCOLLECTION_SORTED
,

164 
	gCOLLECTION_CHAIN_BROKEN
,

167 
CiStus
 
	gm_ciStus
;

168 
CtifiLi
 
	gm_Li
;

171 
	gd
::
	tli
<
	tCtifiCi
> 
	tCtifiCiLi
;

	@vcore/src/vcore/CertificateConfigReader.cpp

23 
	~<vce/CtifiCfigRd.h
>

25 
	~<d/as.h
>

27 
	~<cdlib
>

29 
	gmea
 {

30 cڡ 
	gd
::
rg
 
XML_EMPTY_NAMESPACE
 = "";

32 cڡ 
	gd
::
rg
 
TOKEN_CERTIFICATE_SET
 = "CertificateSet";

33 cڡ 
	gd
::
rg
 
TOKEN_CERTIFICATE_DOMAIN
 = "CertificateDomain";

34 cڡ 
	gd
::
rg
 
TOKEN_FINGERPRINT_SHA1
 = "FingerprintSHA1";

36 cڡ 
	gd
::
rg
 
TOKEN_ATTR_NAME
 = "name";

37 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


38 cڡ 
	gd
::
rg
 
TOKEN_ATTR_URL_NAME
 = "ocspUrl";

40 cڡ 
	gd
::
rg
 
TOKEN_VALUE_TIZEN_DEVELOPER
 = "tizen-developer";

41 cڡ 
	gd
::
rg
 
TOKEN_VALUE_TIZEN_TEST
 = "tizen-test";

42 cڡ 
	gd
::
rg
 
TOKEN_VALUE_TIZEN_VERIFY
 = "tizen-verify";

43 cڡ 
	gd
::
rg
 
TOKEN_VALUE_TIZEN_STORE
 = "tizen-store";

44 cڡ 
	gd
::
rg
 
TOKEN_VALUE_VISIBILITY_PUBLIC
 = "tizen-public";

45 cڡ 
	gd
::
rg
 
TOKEN_VALUE_VISIBILITY_PARTNER
 = "tizen-partner";

46 cڡ 
	gd
::
rg
 
TOKEN_VALUE_VISIBILITY_PARTNER_OPERATOR
 = "tizen-partner-operator";

47 cڡ 
	gd
::
rg
 
TOKEN_VALUE_VISIBILITY_PARTNER_MANUFACTURER
 = "tizen-partner-manufacturer";

48 cڡ 
	gd
::
rg
 
TOKEN_VALUE_VISIBILITY_PLATFORM
 = "tizen-platform";

50 
hexChToI
(
c
)

52 i(
	gc
 >'a' && 
c
 <= 'f') {

53  10 + 
ic_
<>(
c
) - 'a';

55 i(
	gc
 >'A' && 
c
 <= 'F') {

56  10 + 
ic_
<>(
c
) - 'A';

58 i(
	gc
 >'0' && 
c
 <= '9') {

59  
ic_
<>(
c
) - '0';

61  
	gc
;

65 
mea
 
	gVidiCe
 {

66 
	gCtifiCfigRd
::
CtifiCfigRd
()

67 : 
m_ifiDoma
(0)

68 , 
m_rrSchema
(
this
)

70 
	gm_rrSchema
.
addBegTagClback
(

71 
TOKEN_CERTIFICATE_SET
,

72 
XML_EMPTY_NAMESPACE
,

73 &
CtifiCfigRd
::
bnkFuni
);

75 
	gm_rrSchema
.
addBegTagClback
(

76 
TOKEN_CERTIFICATE_DOMAIN
,

77 
XML_EMPTY_NAMESPACE
,

78 &
CtifiCfigRd
::
tokCtifiDoma
);

80 
	gm_rrSchema
.
addBegTagClback
(

81 
TOKEN_FINGERPRINT_SHA1
,

82 
XML_EMPTY_NAMESPACE
,

83 &
CtifiCfigRd
::
bnkFuni
);

85 
	gm_rrSchema
.
addEndTagClback
(

86 
TOKEN_CERTIFICATE_SET
,

87 
XML_EMPTY_NAMESPACE
,

88 &
CtifiCfigRd
::
bnkFuni
);

90 
	gm_rrSchema
.
addEndTagClback
(

91 
TOKEN_CERTIFICATE_DOMAIN
,

92 
XML_EMPTY_NAMESPACE
,

93 &
CtifiCfigRd
::
bnkFuni
);

95 
	gm_rrSchema
.
addEndTagClback
(

96 
TOKEN_FINGERPRINT_SHA1
,

97 
XML_EMPTY_NAMESPACE
,

98 &
CtifiCfigRd
::
tokEndFgtSHA1
);

101 
	gCtifiCfigRd
::
lize
(

102 cڡ 
d
::
rg
 &
fe
,

103 cڡ 
d
::
rg
 &
scheme
)

105 
m_rrSchema
.
lize
(
fe
, 
ue
, 
SaxRd
::
VALIDATION_XMLSCHEME
, 
scheme
);

108 
	gCtifiCfigRd
::
ad
(
CtifiIdtifr
 &
idtifit
)

110 
m_rrSchema
.
ad
(
idtifit
);

113 
	gCtifiCfigRd
::
bnkFuni
(
CtifiIdtifr
 &)

117 
CtifiCfigRd
::
tokCtifiDoma
(
CtifiIdtifr
 &)

119 
d
::
rg
 
me
 = 
m_rrSchema
.
gRd
().
ibu
(
TOKEN_ATTR_NAME
);

121 i(
	gme
.
emy
()) {

122 
VceThrowMsg
(
CtifiCfigRd
::
Exi
::
InvidFe
,

124 } i(
	gme
 =
TOKEN_VALUE_TIZEN_DEVELOPER
) {

125 
m_ifiDoma
 = 
CtSteId
::
TIZEN_DEVELOPER
;

126 } i(
	gme
 =
TOKEN_VALUE_TIZEN_TEST
) {

127 
m_ifiDoma
 = 
CtSteId
::
TIZEN_TEST
;

128 } i(
	gme
 =
TOKEN_VALUE_TIZEN_VERIFY
) {

129 
m_ifiDoma
 = 
CtSteId
::
TIZEN_VERIFY
;

130 } i(
	gme
 =
TOKEN_VALUE_TIZEN_STORE
) {

131 
m_ifiDoma
 = 
CtSteId
::
TIZEN_STORE
;

132 } i(
	gme
 =
TOKEN_VALUE_VISIBILITY_PUBLIC
) {

133 
m_ifiDoma
 = 
CtSteId
::
VIS_PUBLIC
;

134 } i(
	gme
 =
TOKEN_VALUE_VISIBILITY_PARTNER
) {

135 
m_ifiDoma
 = 
CtSteId
::
VIS_PARTNER
;

136 } i(
	gme
 =
TOKEN_VALUE_VISIBILITY_PARTNER_OPERATOR
) {

137 
m_ifiDoma
 = 
CtSteId
::
VIS_PARTNER_OPERATOR
;

138 } i(
	gme
 =
TOKEN_VALUE_VISIBILITY_PARTNER_MANUFACTURER
) {

139 
m_ifiDoma
 = 
CtSteId
::
VIS_PARTNER_MANUFACTURER
;

140 } i(
	gme
 =
TOKEN_VALUE_VISIBILITY_PLATFORM
) {

141 
m_ifiDoma
 = 
CtSteId
::
VIS_PLATFORM
;

143 
	gm_ifiDoma
 = 0;

147 
	gCtifiCfigRd
::
tokEndFgtSHA1
(

148 
CtifiIdtifr
 &
idtifit
)

150 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


151 
d
::
rg
 
u
 = 
m_rrSchema
.
gRd
().
ibu
(
TOKEN_ATTR_URL_NAME
);

154 
	gd
::
rg
 
xt
 = 
m_rrSchema
.
gText
();

155 
	gxt
 += ":";

156 
	gCtifi
::
Fgt
 
fgt
;

157 
	gs
 = 0;

158 
	gbyDescL
 = 0;

159 
size_t
 
	gi
 = 0; i < 
	gxt
.
size
(); ++i) {

160 i(
isxdig
(
xt
[
i
])) {

161 
	gs
 <<= 4;

162 
	gs
 +
hexChToI
(
xt
[
i
]);

163 
	gbyDescL
++;

164 i(
	gbyDescL
 > 2) {

165 
As
(0 && "Unsupported fingerprint format in xml file.");

167 } i(
	gxt
[
i
] == ':') {

168 
fgt
.
push_back
(
ic_
<>(
s
));

169 
	gs
 = 0;

170 
	gbyDescL
 = 0;

172 
As
(0 && "Unussported fingerprint format in xml file.");

176 
	gidtifit
.
add
(
fgt
, 
m_ifiDoma
);

177 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


178 
	gidtifit
.
add
(
fgt
, 
u
);

	@vcore/src/vcore/CertificateConfigReader.h

22 #ide
_VALIDATION_CORE_CERTIFICATE_CONFIG_READER_H_


23 
	#_VALIDATION_CORE_CERTIFICATE_CONFIG_READER_H_


	)

25 
	~<rg
>

27 
	~<vce/CtifiIdtifr.h
>

28 
	~<vce/CtSteTy.h
>

29 
	~<vce/PrSchema.h
>

30 
	~<vce/exi.h
>

32 
mea
 
	gVidiCe
 {

33 as
	cCtifiCfigRd
 {

34 
	gpublic
:

35 as
	cExi
 {

36 
public
:

37 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
);

38 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
InvidFe
);

41 
CtifiCfigRd
();

43 
lize
(cڡ 
d
::
rg
 &
fe
, cڡ std::rg &
scheme
);

44 
ad
(
CtifiIdtifr
 &
idtifit
);

46 
	give
:

47 
bnkFuni
(
CtifiIdtifr
 &);

48 
tokCtifiDoma
(
CtifiIdtifr
 &
idtifit
);

49 
tokEndFgtSHA1
(
CtifiIdtifr
 &
idtifit
);

51 
	gCtSteId
::
Ty
 
m_ifiDoma
;

52 
	gPrSchema
<
	gCtifiCfigRd
, 
	gCtifiIdtifr
> 
	gm_rrSchema
;

	@vcore/src/vcore/CertificateIdentifier.h

23 
	g_WRT_ENGINE_SRC_INSTALLER_CORE_VALIDATION_CORE_CERTIFICATEIDENTIFICATOR_H_


25 
	g_WRT_ENGINE_SRC_INSTALLER_CORE_VALIDATION_CORE_CERTIFICATEIDENTIFICATOR_H_


27 
	~<m
>

28 
	~<d/ncyab.h
>

30 
	~<vce/Ctifi.h
>

31 
	~<vce/CtSteTy.h
>

33 
mea
 
	gVidiCe
 {

34 as
	cCtifiIdtifr
 : 
public
 
VceDPL
::
Ncyab
 {

35 
public
:

36 
d
::
	tm
<
	tCtifi
::
	tFgt
, 
	tCtSteId
::
	tS
> 
	tFgPrtM
;

38 
CtifiIdtifr
()

41 ~
CtifiIdtifr
()

45 
add
(cڡ 
Ctifi
::
Fgt
 &
fgt
,

46 
CtSteId
::
Ty
 
doma
)

48 
fgPrtM
[
fgt
].
add
(
doma
);

51 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


52 
add
(cڡ 
Ctifi
::
Fgt
 &
fgt
,

53 
d
::
rg
 
ocU
)

55 
fgPrtM
[
fgt
].
add
(
ocU
);

59 
	gCtSteId
::
S
 
fd
(cڡ 
Ctifi
::
Fgt
 &
fgt
) const

61 
FgPrtM
::
cڡ_
 

 = 
fgPrtM
.
fd
(
fgt
);

62 i(
	g
 =
fgPrtM
.
d
()) {

63  
CtSteId
::
S
();

65  
	g
->
	gcd
;

68 
	gCtSteId
::
S
 
fd
(cڡ 
CtifiP
 &
ifi
) const

71 
fd
(
ifi
->
gFgt
(
Ctifi
::
FINGERPRINT_SHA1
));

74 
	give
:

75 
FgPrtM
 
fgPrtM
;

	@vcore/src/vcore/CertificateLoader.cpp

16 
	~<d/as.h
>

17 
	~<ݒs/x509v3.h
>

18 
	~<d/log/w_log.h
>

19 
	~<d/ncyab.h
>

20 
	~<ݒs/ecd.h
>

21 
	~<ݒs/evp.h
>

23 
	~<vce/Ba64.h
>

24 
	~<vce/CtifiLd.h
>

25 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


26 
	~<vce/SSLCڏs.h
>

29 
	gmea
 {

30 cڡ 
	gMIN_RSA_KEY_LENGTH
 = 1024;

34 
mea
 
	gVidiCe
 {

159 
	gCtifiLd
::
CtifiLdResu
 
CtifiLd
::

160 
ldCtifiBadOnExpڒtAndModulus
(cڡ 
d
::
rg
 &
m_modulus
,

161 cڡ 
d
::
rg
 &
m_expڒt
)

163 (
m_modulus
;

164 (
	gm_expڒt
;

165 
WLogE
("Not implemented.");

166  
	gUNKNOWN_ERROR
;

185 
	gCtifiLd
::
CtifiLdResu
 
CtifiLd
::
ldCtifi
(

186 cڡ 
d
::
rg
 &
ageName
,

187 
CtifiLd
::
CtifiLdComt
 *
cmp
)

189 (
ageName
;

190 (
	gcmp
;

191 
WLogE
("Not Implemented");

192  
	gUNKNOWN_ERROR
;

262 
	gCtifiLd
::
CtifiLdResu
 
CtifiLd
::

263 
ldCtifiBadOnSubjeName
(cڡ 
d
::
rg
 &
subjeName
)

265 (
subjeName
;

266 
WLogE
("Not implemented.");

267  
	gUNKNOWN_ERROR
;

407 
	gCtifiLd
::
CtifiLdResu
 
CtifiLd
::

408 
ldCtifiWhECKEY
(cڡ 
d
::
rg
 &
curveName
,

409 cڡ 
d
::
rg
 &
publicKey
)

411 (
curveName
;

412 (
	gpublicKey
;

413 
WLogE
("Not implemented.");

414  
	gUNKNOWN_ERROR
;

435 
	gCtifiLd
::
CtifiLdResu
 
CtifiLd
::
ldCtifiFromRawDa
(cڡ 
d
::
rg
 &
wDa
)

437 
VceTry
 {

438 
m_ifiP
 = 
CtifiP
(
w
 
Ctifi
(
wDa
, Ctifi::
FORM_BASE64
));

439 } 
VceCch
(
Ctifi
::
Exi
::
Ba
) {

440 
WLogW
("Erroreading certificate by openssl.");

441  
	gUNKNOWN_ERROR
;

445 
EVP_PKEY
 *
	gpKey
 = 
X509_g_pubkey
(
m_ifiP
->
gX509
());

447 i(
	gpKey
 !
NULL
) {

448 i(
pKey
->
ty
 =
EVP_PKEY_RSA
) {

449 
RSA
* 
pRSA
 = 
pKey
->
pkey
.
r
;

451 i(
	gpRSA
) {

452 
	gkeyLgth
 = 
RSA_size
(
pRSA
);

455 
	gkeyLgth
 <<= 3;

456 
WLogD
("RSA keygth: %d bs", 
keyLgth
);

458 i(
	gkeyLgth
 < 
	gMIN_RSA_KEY_LENGTH
) {

459 
WLogE
(

460 "RSA keyosht! Haly %d bs", 
keyLgth
);

461  
	gCERTIFICATE_SECURITY_ERROR
;

467  
	gNO_ERROR
;

529 
	gCtifiLd
::
CtifiLdResu
 
CtifiLd
::

530 
ldCtifiBadOnDSACompڒts
(cڡ 
d
::
rg
& 
rP
,

531 cڡ 
d
::
rg
& 
rQ
,

532 cڡ 
d
::
rg
& 
rG
,

533 cڡ 
d
::
rg
& 
rY
,

534 cڡ 
d
::
rg
& 
rJ
,

535 cڡ 
d
::
rg
& 
rSd
,

536 cڡ 
d
::
rg
& 
rPGCou
)

538 (
rP
;

539 (
	grQ
;

540 (
	grG
;

541 (
	grY
;

542 (
	grJ
;

543 (
	grSd
;

544 (
	grPGCou
;

545 
WLogE
("Not implemented.");

546  
	gUNKNOWN_ERROR
;

652 
bo
 
	gCtifiLd
::
cvtBa64NodeToBigNum
(cڡ 
d
::
rg
& 
rNode
,

653 
BIGNUM
** 
BigNum
)

655 (
	grNode
;

656 (
	gBigNum
;

657 
WLogE
("Not implemented.");

658  
	gl
;

	@vcore/src/vcore/CertificateLoader.h

16 #ide
_CERTIFICATELOADER_H_


17 
	#_CERTIFICATELOADER_H_


	)

19 
	~<rg
>

20 
	~<rg.h
>

22 
	~<d/ncyab.h
>

23 
	~<ݒs/s.h
>

25 
	~<-rvi.h
>

27 
	~<vce/Ctifi.h
>

29 
mea
 
	gVidiCe
 {

30 as
	cCtifiLd
 : 
public
 
VceDPL
::
Ncyab


32 
public
:

33 as
	cCtifiLdComt


35 
public
:

36 
vtu
 
bo
 
com
(
X509
 *
x509
) = 0;

37 
	gvtu
 ~
CtifiLdComt
()

42 
	eCtifiLdResu


44 
	gNO_ERROR
,

45 
	gCERTIFICATE_NOT_FOUND
,

46 
	gUNSUPPORTED_CERTIFICATE_FIELD
,

47 
	gWRONG_ARGUMENTS
,

48 
	gCERTIFICATE_SECURITY_ERROR
,

49 
	gUNKNOWN_ERROR


52 
CtifiLd
()

56 
	gvtu
 ~
CtifiLd
()

60 
CtifiLdResu
 
ldCtifi
(cڡ 
d
::
rg
& 
age
,

61 
CtifiLdComt
 *
cmp
);

63 
CtifiLdResu
 
ldCtifiBadOnSubjeName
(

64 cڡ 
d
::
rg
 &
subjeName
);

65 
CtifiLdResu
 
ldCtifiBadOnExpڒtAndModulus
(

66 cڡ 
d
::
rg
 &
m_modulus
,

67 cڡ 
d
::
rg
 &
m_expڒt
);

71 
CtifiLdResu
 
ldCtifiFromRawDa
(

72 cڡ 
d
::
rg
 &
wDa
);

74 
CtifiLdResu
 
ldCtifiBadOnDSACompڒts
(

75 cڡ 
d
::
rg
& 
rP
,

76 cڡ 
d
::
rg
& 
rQ
,

77 cڡ 
d
::
rg
& 
rG
,

78 cڡ 
d
::
rg
& 
rY
,

79 cڡ 
d
::
rg
& 
rJ
,

80 cڡ 
d
::
rg
& 
rSd
,

81 cڡ 
d
::
rg
& 
rPGCou
);

83 
CtifiLdResu
 
ldCtifiWhECKEY
(

84 cڡ 
d
::
rg
 &
curveName
,

85 cڡ 
d
::
rg
 &
publicKey
);

92 
bo
 
cvtBa64NodeToBigNum
(cڡ 
d
::
rg
& 
rNode
,

93 
BIGNUM
** 
BigNum
);

101 
CtifiP
 
gCtifiP
() const

103  
	gm_ifiP
;

105 
	give
:

106 
CtifiP
 
m_ifiP
;

	@vcore/src/vcore/CertificateStorage.h

16 #ide
VCORE_SRC_VCORE_CERTIFICATESTORAGE_H


17 
	#VCORE_SRC_VCORE_CERTIFICATESTORAGE_H


	)

19 
	~<li
>

20 
	~<ݒs/x509.h
>

22 
mea
 
	gVidiCe
 {

23 
	gd
::
	tli
 < 
	tX509
* > 
	tX509CtifisLi
;

	@vcore/src/vcore/CertificateVerifier.cpp

22 
	~<vce/CtifiVifr.h
>

24 
	~<d/as.h
>

25 
	~<d/fܗch.h
>

26 
	~<d/log/w_log.h
>

28 
mea
 
	gVidiCe
 {

30 
	gCtifiVifr
::
CtifiVifr
(
bo
 
abOc
, bo 
abC
)

31 : 
m_abOc
(
abOc
)

32 , 
m_abC
(
abC
)

35 
VifitiStus
 
	gCtifiVifr
::
check
(

36 
CtifiCi
 &
Ci
) const

38 
WLogD
("== Certificate collection validation start ==");

39 
As
(
Ci
.
isCha
() && "Collection must form chain.");

41 
VifitiStus
 
	gusOc
;

42 
VifitiStus
 
	gusC
;

44 i(
	gm_abOc
) {

45 
	gusOc
 = 
obOcStus
(
Ci
);

47 
	gusOc
 = 
VERIFICATION_STATUS_GOOD
;

50 i(
	gm_abC
) {

51 
	gusC
 = 
obCStus
(
Ci
);

53 
	gusC
 = 
VERIFICATION_STATUS_GOOD
;

55 
WLogD
("== Certificate collection validationnd ==");

56  
gStus
(
usOc
, 
usC
);

59 
VifitiStus
 
	gCtifiVifr
::
obOcStus
(

60 cڡ 
CtifiCi
 &
cha
) const

62 
WLogD
("== Obtain ocsp status ==");

63 
CachedOCSP
 
	goc
;

64  
	goc
.
check
(
cha
);

67 
VifitiStus
 
	gCtifiVifr
::
obCStus
(

68 cڡ 
CtifiCi
 &
cha
) const

70 
WLogD
("== Obtain crl status ==");

71 
CachedCRL
 
	gl
;

72  
	gl
.
check
(
cha
);

75 
VifitiStus
 
	gCtifiVifr
::
gStus
(

76 
VifitiStus
 
oc
,

77 
VifitiStus
 
l
) const

79 i(
	goc
 =
VERIFICATION_STATUS_REVOKED
 ||

80 
l
 =
VERIFICATION_STATUS_REVOKED
)

82 
WLogD
("Return status: REVOKED");

83  
	gVERIFICATION_STATUS_REVOKED
;

86 i(
	goc
 =
VERIFICATION_STATUS_GOOD
) {

87 
WLogD
("Return status: GOOD");

88  
	gVERIFICATION_STATUS_GOOD
;

91 i(
	goc
 =
VERIFICATION_STATUS_UNKNOWN
) {

92 
WLogD
("Return status: UNKNOWN");

93  
	gVERIFICATION_STATUS_UNKNOWN
;

96 i(
	goc
 =
VERIFICATION_STATUS_NOT_SUPPORT
) {

97 
WLogD
("Return status: NOT_SUPPORT");

98  
	gVERIFICATION_STATUS_GOOD
;

101 
WLogD
("Return status: ERROR");

102  
	gVERIFICATION_STATUS_ERROR
;

105 
VifitiStus
 
	gCtifiVifr
::
checkEndEy
(

106 
CtifiCiLi
 &
ciLi
) const

108 
VifitiStusS
 
usOc
;

109 
VifitiStusS
 
	gusC
;

111 i(
	gm_abOc
) {

112 
CachedOCSP
 
	goc
;

113 
FOREACH
(

, 
ciLi
){

114 
	gusOc
.
add
(
oc
.
checkEndEy
(*

));

117 
	gusOc
.
add
(
VERIFICATION_STATUS_GOOD
);

120 i(
	gm_abC
) {

121 
CachedCRL
 
	gl
;

122 
FOREACH
(

, 
ciLi
){

123 
	gusC
.
add
(
l
.
checkEndEy
(*

));

126 
	gusC
.
add
(
VERIFICATION_STATUS_GOOD
);

128 
WLogD
("== Certificate collection validateionnd ==");

129  
gStus
(
usOc
.
cvtToStus
(), 
usC
.convertToStatus());

	@vcore/src/vcore/CertificateVerifier.h

22 #ide
_VALIDATION_CORE_CERTIFICATE_VERIFIER_H_


23 
	#_VALIDATION_CORE_CERTIFICATE_VERIFIER_H_


	)

25 
	~<vce/Ctifi.h
>

26 
	~<vce/CtifiCi.h
>

27 
	~<vce/CachedCRL.h
>

28 
	~<vce/CachedOCSP.h
>

29 
	~<vce/VifitiStus.h
>

31 
mea
 
	gVidiCe
 {

33 as
	cCtifiVifr
 {

34 
	gpublic
:

35 
exic
 
CtifiVifr
(
bo
 
abOc
, bo 
abC
);

36 ~
CtifiVifr
(){}

65 
VifitiStus
 
check
(
CtifiCi
 &
Ci
) const;

67 
VifitiStus
 
checkEndEy
(

68 
CtifiCiLi
 &
CiLi
) const;

70 
	give
:

71 
VifitiStus
 
obOcStus
(

72 cڡ 
CtifiCi
 &
cha
) const;

73 
VifitiStus
 
obCStus
(

74 cڡ 
CtifiCi
 &
cha
) const;

75 
VifitiStus
 
gStus
(VifitiStu
oc
,

76 
VifitiStus
 
l
) const;

78 
bo
 
	gm_abOc
;

79 
bo
 
	gm_abC
;

	@vcore/src/vcore/Config.cpp

17 
	~<vce/Cfig.h
>

19 
	~<d/sgt_im.h
>

20 
IMPLEMENT_SINGLETON
(
VidiCe
::
Cfig
)

	@vcore/src/vcore/Config.h

17 #ide
_SRC_VALIDATION_CORE_VALIDATION_CORE_CONFIG_H_


18 
	#_SRC_VALIDATION_CORE_VALIDATION_CORE_CONFIG_H_


	)

20 
	~<rg
>

22 
	~<d/sgt.h
>

24 
mea
 
	gVidiCe
 {

25 as
	cCfig
 {

26 
	gpublic
:

30 
bo
 
tXMLCfigPh
(cڡ 
d
::
rg
& 
th
) {

31 i(!
m_ifiXMLCfigPh
.
emy
()) {

32  
l
;

34 
	gm_ifiXMLCfigPh
 = 
th
;

35  
	gue
;

41 
bo
 
tXMLSchemaPh
(cڡ 
d
::
rg
& 
th
) {

42 i(!
m_ifiXMLSchemaPh
.
emy
()) {

43  
l
;

45 
	gm_ifiXMLSchemaPh
 = 
th
;

46  
	gue
;

52 
	gd
::
rg
 
gXMLCfigPh
() {

53  
m_ifiXMLCfigPh
;

59 
	gd
::
rg
 
gXMLSchemaPh
() {

60  
m_ifiXMLSchemaPh
;

63 
	give
:

64 
d
::
rg
 
m_ifiXMLCfigPh
;

65 
	gd
::
rg
 
m_ifiXMLSchemaPh
;

68 
	gVceDPL
::
	tSgt
<
	tCfig
> 
	tCfigSgt
;

	@vcore/src/vcore/CryptoHash.cpp

22 
	~<vce/CryoHash.h
>

24 
	~<ݒs/bio.h
>

25 
	~<ݒs/s.h
>

26 
	~<ݒs/evp.h
>

27 
	~<dex
>

29 
	~<vce/Ba64.h
>

31 
mea
 
	gVidiCe


33 
mea
 
	gCryo


35 
mea
 
	gHash


37 
	gmea


39 cڡ 
size_t
 
	gHASH_DIGEST_STREAM_FEED_SIZE
 = 1024;

42 
	gBa
::
Ba
()

43 : 
m_hasF
(
l
)

47 
Ba
::~Base()

51 
Ba
::
Ad
(cڡ *
bufr
)

53 i(
m_hasF
)

54 
VceThrowMsg
(
Cryo
::
Hash
::
OutOfSequ
,

57 
HashUpde
(
bufr
, 

(buffer));

60 
	gBa
::
Ad
(cڡ *
bufr
, 
size_t
 
bufrSize
)

62 i(
	gm_hasF
)

63 
VceThrowMsg
(
Cryo
::
Hash
::
OutOfSequ
,

66 
HashUpde
(
bufr
, 
bufrSize
);

69 
	gBa
::
Ad
(cڡ 
d
::
rg
 &
bufr
)

71 i(
m_hasF
)

72 
VceThrowMsg
(
Cryo
::
Hash
::
OutOfSequ
,

75 
HashUpde
(
bufr
.
c_r
(), bufr.
size
());

78 
	gBa
::
Ad
(
d
::
iam
 &
am
)

80 i(
m_hasF
)

81 
VceThrowMsg
(
Cryo
::
Hash
::
OutOfSequ
,

84 
	gbufr
[
HASH_DIGEST_STREAM_FEED_SIZE
];

88 
	gam
.
ad
(
bufr
, 
HASH_DIGEST_STREAM_FEED_SIZE
);

90 i(
	gam
.
gcou
() > 0)

91 
Ad
(
ic_
<*>(
bufr
), stic_<
size_t
>(
am
.
gcou
()));

93 } 
	gam
.
gcou
() > 0);

96 
	gBa
::
Ad
(cڡ *
da
, 
size_t
 
daSize
)

98 i(
	gm_hasF
)

99 
VceThrowMsg
(
Cryo
::
Hash
::
OutOfSequ
,

102 
HashUpde
(
da
, 
daSize
);

105 
	gBa
::
Fish
()

107 i(
m_hasF
)

111 
	gm_w
 = 
HashF
();

114 
Ba64Encod
 
	gcod
;

115 
	gcod
.
t
();

116 
	gcod
.
nd
(
d
::
rg
(
m_w
.
beg
(), m_w.
d
()));

117 
	gcod
.
fize
();

118 
	gm_ba64SgHash
 = 
cod
.
g
();

120 
	gm_hasF
 = 
ue
;

123 
	gd
::
rg
 
Ba
::
ToBa64Sg
() const

125  
m_ba64SgHash
;

128 
Raw
 
	gBa
::
GHash
() const

130  
m_w
;

133 
	gOnSSL
::
OnSSL
(cڡ 
EVP_MD
 *
evpMd
)

134 : 
m_fized
(
l
)

136 
EVP_MD_CTX_
(&
m_cڋxt
);

138 i(
EVP_DigeIn
(&
m_cڋxt
, 
evpMd
) != 1)

139 
VceThrowMsg
(
Cryo
::
Hash
::
AdFaed
,

143 
	gOnSSL
::~
OnSSL
()

145 i(!
m_fized
)

148 
EVP_MD_CTX_nup
(&
m_cڋxt
);

149 
	gm_fized
 = 
ue
;

153 
	gOnSSL
::
HashUpde
(cڡ *
da
, 
size_t
 
daSize
)

155 i(
	gm_fized
)

156 
VceThrowMsg
(
Cryo
::
Hash
::
AdFaed
,

159 i(
EVP_DigeUpde
(&
m_cڋxt
, 
da
, 
daSize
) != 1)

160 
VceThrowMsg
(
Cryo
::
Hash
::
AdFaed
,

164 
	gHash
::
Raw
 
OnSSL
::
HashF
()

166 i(
m_fized
)

167 
VceThrowMsg
(
Cryo
::
Hash
::
AdFaed
,

170 
	ghash
[
EVP_MAX_MD_SIZE
] = {};

171 
	ghashLgth
;

174 i(
EVP_DigeF
(&
m_cڋxt
, 
hash
, &
hashLgth
) != 1)

175 
VceThrowMsg
(
Cryo
::
Hash
::
AdFaed
,

178 
	gm_fized
 = 
ue
;

179  
Raw
(
hash
, hash + 
hashLgth
);

	@vcore/src/vcore/CryptoHash.h

22 #ide
_CRYPTO_HASH_H_


23 
	#_CRYPTO_HASH_H_


	)

25 
	~<ݒs/evp.h
>

26 
	~<iam
>

27 
	~<rg
>

28 
	~<ve
>

30 
	~<vce/exi.h
>

32 
mea
 
	gVidiCe


34 
mea
 
	gCryo


36 
mea
 
	gHash


38 
	gd
::
	tve
<> 
	tRaw
;

40 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
OutOfSequ
)

41 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
AdFaed
)

43 as
	cBa


45 
	give
:

46 
Raw
 
m_w
;

47 
	gd
::
rg
 
m_ba64SgHash
;

48 
bo
 
	gm_hasF
;

50 
	geed
:

51 
vtu
 
HashUpde
(cڡ *
da
, 
size_t
 
daSize
) = 0;

52 
vtu
 
Raw
 
HashF
() = 0;

54 
	gpublic
:

55 
Ba
();

56 
	gvtu
 ~
Ba
();

58 
vtu
 
Ad
(cڡ *
bufr
);

59 
vtu
 
Ad
(cڡ *
bufr
, 
size_t
 
bufrSize
);

60 
vtu
 
Ad
(cڡ 
d
::
rg
 &
bufr
);

61 
vtu
 
Ad
(
d
::
iam
 &
am
);

62 
vtu
 
Ad
(cڡ *
da
, 
size_t
 
daSize
);

64 
vtu
 
Fish
();

66 
vtu
 
	gd
::
rg
 
ToBa64Sg
() const;

67 
vtu
 
Raw
 
GHash
() const;

73 as
	cOnSSL


74 : 
public
 
Ba


76 
ive
:

77 
EVP_MD_CTX
 
m_cڋxt
;

78 
bo
 
	gm_fized
;

80 
	geed
:

81 
vtu
 
HashUpde
(cڡ *
da
, 
size_t
 
daSize
);

82 
vtu
 
Raw
 
HashF
();

84 
	gpublic
:

85 
OnSSL
(cڡ 
EVP_MD
 *
evpMd
);

86 
	gvtu
 ~
OnSSL
();

89 
	#DECLARE_OPENSSL_HASH_ALGORITHM
(
CssName
, 
EvpMd
) \

90 
ass
 
CssName
 \

91 : 
public
 
OnSSL
 \

93 
public
: \

94 
	`CssName
(: 
	`OnSSL
(
	`EvpMd
()) {} \

95 
vtu
 ~
	`CssName
() {} \

96 };

	)

98 
DECLARE_OPENSSL_HASH_ALGORITHM
(
MD2
, 
EVP_md2
)

99 
DECLARE_OPENSSL_HASH_ALGORITHM
(
MD4
, 
EVP_md4
)

100 
DECLARE_OPENSSL_HASH_ALGORITHM
(
MD5
, 
EVP_md5
)

101 
DECLARE_OPENSSL_HASH_ALGORITHM
(
SHA
, 
EVP_sha
)

102 
DECLARE_OPENSSL_HASH_ALGORITHM
(
SHA1
, 
EVP_sha1
)

103 
DECLARE_OPENSSL_HASH_ALGORITHM
(
DSS
, 
EVP_dss
)

104 
DECLARE_OPENSSL_HASH_ALGORITHM
(
DSS1
, 
EVP_dss1
)

105 
DECLARE_OPENSSL_HASH_ALGORITHM
(
ECDSA
, 
EVP_ecd
)

106 
DECLARE_OPENSSL_HASH_ALGORITHM
(
SHA224
, 
EVP_sha224
)

107 
DECLARE_OPENSSL_HASH_ALGORITHM
(
SHA256
, 
EVP_sha256
)

108 
DECLARE_OPENSSL_HASH_ALGORITHM
(
SHA384
, 
EVP_sha384
)

109 
DECLARE_OPENSSL_HASH_ALGORITHM
(
SHA512
, 
EVP_sha512
)

111 #unde
DECLARE_OPENSSL_HASH_ALGORITHM


	@vcore/src/vcore/Database.cpp

22 
	~<vce/Daba.h
>

23 
	~<mux
>

25 
	gd
::
mux
 
g_vceDbQusMux
;

	@vcore/src/vcore/Database.h

22 #ide
VCORE_SRC_VCORE_DATABASE_H


23 
	#VCORE_SRC_VCORE_DATABASE_H


	)

25 
	~<d/db/thad_daba_sut.h
>

26 
	~<d/db/sql_ci.h
>

27 
	~<d/thad.h
>

28 
	~<mux
>

30 
d
::
mux
 
g_vceDbQusMux
;

32 
	#VCORE_DB_INTERNAL
(
sCommd
, 
IlTy
, 
r
) \

33 
VceDPL
::
ThadLolVb
<
IlTy
> *
sCommd
 ## 
P
 = 
NULL
; \

35 
d
::
lock_gud
<d::
mux
> 
	`lock
(
g_vceDbQusMux
); \

36 i(!
sCommd
 ## 
P
) { \

37 
VceDPL
::
ThadLolVb
<
IlTy
> 
tmp
; \

38 
sCommd
 ## 
P
 = &
tmp
; \

41 
VceDPL
::
ThadLolVb
<
IlTy
> &
sCommd
 = *sCommd ## 
P
; \

42 i(
sCommd
.
	`IsNu
(){lsCommd = 
	`IlTy
(
r
); }

	)

44 
	#VCORE_DB_SELECT
(
me
, 
ty
, 
r
) \

45 
	`VCORE_DB_INTERNAL
(
me
, 
ty
::
Se
, 
r
)

	)

47 
	#VCORE_DB_INSERT
(
me
, 
ty
, 
r
) \

48 
	`VCORE_DB_INTERNAL
(
me
, 
ty
::
In
, 
r
)

	)

50 
	#VCORE_DB_UPDATE
(
me
, 
ty
, 
r
) \

51 
	`VCORE_DB_INTERNAL
(
me
, 
ty
::
Upde
, 
r
)

	)

53 
	#VCORE_DB_DELETE
(
me
, 
ty
, 
r
) \

54 
	`VCORE_DB_INTERNAL
(
me
, 
ty
::
De
, 
r
)

	)

	@vcore/src/vcore/IAbstractResponseCache.h

25 #ide
_VALIDATION_CORE_IABSTRACT_RESPONSE_CACHE_H_


26 
	#_VALIDATION_CORE_IABSTRACT_RESPONSE_CACHE_H_


	)

28 
	~<vce/VifitiStus.h
>

30 
mea
 
	gVidiCe
 {

32 
ass
 
	gCtifiCi
;

34 as
	cIAbReڣCache
 {

35 
	gpublic
:

36 
vtu
 
VifitiStus
 
check
(cڡ 
CtifiCi
 &
s
) = 0;

37 
vtu
 
VifitiStus
 
checkEndEy
(
CtifiCi
 &
s
) = 0;

38 
vtu
 
updeCache
() = 0;

40 
	gvtu
 ~
IAbReڣCache
()

	@vcore/src/vcore/OCSP.cpp

23 
	~<vce/OCSPIm.h
>

25 
mea
 
	gVidiCe
 {

27 
	gOCSP
::
OCSP
()

28 : 
m_im
(
w
 
OCSPIm
())

31 
OCSP
::~OCSP()

33 
de
 
m_im
;

36 
	gVidiCe
::
VifitiStusS
 
OCSP
::
videCtifiLi
(

37 cڡ 
CtifiLi
 &
s
)

39  
m_im
->
videCtifiLi
(
s
);

42 
VifitiStus
 
	gOCSP
::
checkEndEy
(

43 cڡ 
CtifiCi
 &
cha
)

45  
m_im
->
checkEndEy
(
cha
);

48 
VifitiStus
 
	gOCSP
::
videCtifi
(
CtifiP
 
gCt
,

49 
CtifiP
 
gIssu
)

51  
	gm_im
->
videCtifi
(
gCt
, 
gIssu
);

54 
	gOCSP
::
tDigeAlgܙhmFCtId
(
DigeAlgܙhm
 
g
) {

55  
m_im
->
tDigeAlgܙhmFCtId
(
g
);

58 
	gOCSP
::
tDigeAlgܙhmFReque
(
DigeAlgܙhm
 
g
) {

59  
m_im
->
tDigeAlgܙhmFReque
(
g
);

62 
	gOCSP
::
tTruedSte
(cڡ 
CtifiLi
& 
s
) {

63 
m_im
->
tTruedSte
(
s
);

66 
	gOCSP
::
tDeuRed
(cڡ *
uri
) {

67 
m_im
->
tDeuRed
(
uri
);

70 
	gOCSP
::
tUDeuRed
(
bo
 
vue
) {

71 
m_im
->
tUDeuRed
(
vue
);

74 
time_t
 
	gOCSP
::
gReڣVidy
() {

75  
m_im
->
gReڣVidy
();

	@vcore/src/vcore/OCSP.h

23 #ide
_VALIDATION_CORE_OCSP_H_


24 
	#_VALIDATION_CORE_OCSP_H_


	)

26 
	~<ime
>

28 
	~<vce/Ctifi.h
>

29 
	~<vce/CtifiCi.h
>

30 
	~<vce/VifitiStus.h
>

32 
mea
 
	gVidiCe
 {

34 
ass
 
	gOCSPIm
;

36 as
	cOCSP
 {

37 
	gpublic
:

39 
OCSP
(cڡ OCSP &
de
;

40 cڡ 
	gOCSP
 &
	gݔ
=(cڡ 
OCSP
 &
de
;

42 
OCSP
();

44 
VifitiStus
 
checkEndEy
(cڡ 
CtifiCi
 &
Li
);

46 
	eDigeAlgܙhm


48 
	gSHA1
,

49 
	gSHA224
,

50 
	gSHA256
,

51 
	gSHA384
,

52 
	gSHA512


58 
tDigeAlgܙhmFCtId
(
DigeAlgܙhm
 
g
);

63 
tDigeAlgܙhmFReque
(
DigeAlgܙhm
 
g
);

65 
tTruedSte
(cڡ 
CtifiLi
& 
s
);

67 
VifitiStusS
 
videCtifiLi
(cڡ 
CtifiLi
 &
s
);

69 
VifitiStus
 
videCtifi
(
CtifiP
 
gCt
,

70 
CtifiP
 
gIssu
);

72 
tDeuRed
(cڡ * 
uri
);

74 
tUDeuRed
(
bo
 
vue
);

81 
time_t
 
gReڣVidy
();

83 
	gvtu
 ~
OCSP
();

84 
	give
:

85 
OCSPIm
 *
m_im
;

	@vcore/src/vcore/OCSPCertMgrUtil.cpp

22 
	~<vce/OCSPCtMgrUt.h
>

23 
	~<vce/SSLCڏs.h
>

24 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


25 
	~<ݒs/oc.h
>

28 
	~<ݒs/m.h
>

29 
	~<ݒs/x509.h
>

30 
	~<d/as.h
>

31 
	~<d/log/w_log.h
>

32 
	~<d/sced_sour.h
>

33 
	~<rg.h
>

34 
	~<ioam
>

35 
	~<rg
>

37 
	~<-rvi.h
>

39 
	gmea
 {

40 cڡ 
	gMAX_BUF
 = 1024;

42 
	sCڋxtD


44 
CERT_CONTEXT
* 
	tTy
;

45 
Ty
 
NuVue
()

47  
	gNULL
;

49 
Deroy
(
Ty
 
cڋxt
)

51 i(
	gcڋxt
) {

52 
_svc__cڋxt_f
(
cڋxt
);

58 
mea
 
	gVidiCe
 {

59 
mea
 
	gOCSPCtMgrUt
 {

68 
gCtFromSte
(
X509_NAME
 *
subje
,

69 
X509
 **
x
)

71 i(!
	gx
 || *x || !
	gsubje
) {

72 
WLogE
("Invalid input!");

76 
	gVceDPL
::
	tScedResour
<
	tCڋxtD
> 
	tScedCڋxt
;

78 
	gsu
;

79 
	gbufr
[
MAX_BUF
];

80 cڡ * 
	gr
 = 
NULL
;

81 
X509
 *
	gpCtifi
 = 
NULL
;

82 
_svc_fame_li
 *
	gfeLi
 = 
NULL
;

84 
X509_NAME_ږe
(
subje
, 
bufr
, 
MAX_BUF
);

86 
ScedCڋxt
 
x
(
_svc__cڋxt_
());

87 i(
	gx
.
G
(=
NULL
) {

88 
WLogW
("Error in cert_svc_cert_context_init.");

92 
WLogD
("Srch ctifi wh subje: %s", 
bufr
);

93 
	gsu
 = 
_svc_ch_ifi
(
x
.
G
(), 
SUBJECT_STR
, 
bufr
);

94 
WLogD
("Search finished!");

96 i(
	gCERT_SVC_ERR_NO_ERROR
 !
su
) {

97 
WLogW
("Error during certificate search");

101 
	gfeLi
 = 
x
.
G
()->
feNames
;

103 i(
	gfeLi
 =
NULL
) {

104 
WLogD
("No certificate found");

108 i(
	gfeLi
->
	gfame
 =
NULL
) {

109 
WLogW
("Empty filename");

113 
WLogD
("Found cfe: %s", 
feLi
->
fame
);

114 
ScedCڋxt
 
x2
(
_svc__cڋxt_
());

116 i(
	gx2
.
G
(=
NULL
) {

117 
WLogW
("Error in cert_svc_cert_context_init.");

122 i(
	gCERT_SVC_ERR_NO_ERROR
 !=

123 
_svc_ld_fe_to_cڋxt
(
x2
.
G
(), 
feLi
->
fame
)) {

124 
WLogW
("Error in cert_svc_load_file_to_context");

128 
	gr
 = 
x2
.
G
()->
Buf
->
da
;

130 
	gpCtifi
 = 
d2i_X509
(
NULL
, &
r
, 
x2
.
G
()->
Buf
->
size
);

132 i(
	gpCtifi
 =
NULL
) {

133 
WLogW
("Error during certificate conversion in d2i_X509");

137 *
	gx
 = 
pCtifi
;

138 i(
	gfeLi
->
	gxt
 !
NULL
) {

139 
WLogE
("There is morehen one certificate with same subject :/");

141 
	gfeLi
 = 
feLi
->
xt
;

142 
	gfeLi
 !
NULL
;

143 
	gfeLi
 = 
feLi
->
xt
) {

144 
WLogE
("Addiڮ ctifi wh samsubje: %s", 
feLi
->
fame
);

149 
CtifiP
 
gPtFromSte
(cڡ CtifiP &
ifi
)

151 
As
(
ifi
.
g
());

152 
X509
* 
	gwP
 = 
ifi
->
gX509
();

155 
X509_NAME
 *
	gme
 = 
X509_g_issu_me
(
wP
);

157 
X509
* 
	gwTemp
 = 
NULL
;

158 
gCtFromSte
(
me
, &
wTemp
);

160 i(
	gwTemp
 =
NULL
) {

161  
CtifiP
();

163 
	gSSLSmtCڏ
<
	gX509
> 
sce
(
wTemp
);

164  
CtifiP
(
w
 
Ctifi
(
wTemp
));

167 
CtifiLi
 
comeCtifiCha
(cڡ CtifiLi &
ifiLi
)

169 
CtifiLi
 
	gsu
 = 
ifiLi
;

170 
CtifiP
 
	gϡ
 = 
su
.
back
();

171 i(
	gϡ
->
isSigdBy
(
ϡ
)) {

172  
	gsu
;

174 
CtifiP
 
	g
 = 
gPtFromSte
(
ϡ
);

175 i(
	g
.
g
()) {

176 
	gsu
.
push_back
(

);

178  
	gsu
;

	@vcore/src/vcore/OCSPCertMgrUtil.h

23 #ide
_OCSP_CERT_MGR_UTIL_H_


24 
	#_OCSP_CERT_MGR_UTIL_H_


	)

26 
	~<vce/Ctifi.h
>

28 
mea
 
	gVidiCe
 {

29 
mea
 
	gOCSPCtMgrUt
 {

30 
gCtFromSte
(
X509_NAME
 *
subje
,

31 
X509
 **
x
);

32 
CtifiP
 
gPtFromSte
(cڡ CtifiP &
ifi
);

37 
CtifiLi
 
comeCtifiCha
(cڡ CtifiLi &
Li
);

	@vcore/src/vcore/OCSPImpl.cpp

25 
	~<vce/OCSPIm.h
>

27 
	~<rg.h
>

28 
	~<gܙhm
>

30 
	~<ݒs/s.h
>

31 
	~<ݒs/yo.h
>

32 
	~<ݒs/r.h
>

33 
	~<ݒs/x509v3.h
>

34 
	~<boo/tiڮ.h
>

36 
	~<d/log/w_log.h
>

37 
	~<d/as.h
>

38 
	~<d/fܗch.h
>

39 
	~<d/sced_.h
>

41 
	~<libsoup/soup.h
>

43 
	~<vce/Ctifi.h
>

44 
	~<vce/SoupMesgeSdSync.h
>

45 
	~<vce/VidFaܛs.h
>

51 
bo
 
cvtToBufr
(
OCSP_REQUEST
* 
q
,

52 ** 
buf
,

53 * 
size
);

56 
	gmea
 {

57 cڡ 
	gCiTimeoutInSecds
 = 6;

58 cڡ 
	gCiRryCou
 = 3;

64 cڡ 
	gMaxVidyPiodInSecds
 = 24 * 60 * 60;

67 cڡ 
	gMaxAge
 = -1;

70 
mea
 
	gVidiCe
 {

72 cڡ * 
	gOCSPIm
::
DEFAULT_RESPONDER_URI_ENV
 = "OCSP_DEFAULT_RESPONDER_URI";

74 cڡ 
EVP_MD
* 
gDigeAlg
(
OCSP
::
DigeAlgܙhm
 
g
)

76 
g
) {

77 
OCSP
::
SHA1
:

78  
EVP_sha1
();

79 
	gOCSP
::
SHA224
:

80  
EVP_sha224
();

81 
	gOCSP
::
SHA256
:

82  
EVP_sha256
();

83 
	gOCSP
::
SHA384
:

84  
EVP_sha384
();

85 
	gOCSP
::
SHA512
:

86  
EVP_sha512
();

88  
NULL
;

92 
	gOCSPIm
::
OCSPIm
() :

96 
m_pCtIdDigeAlg
(
EVP_sha1
()),

97 
m_pRequeDigeAlg
(
EVP_sha1
()),

98 
m_bUN
(
l
),

99 
m_bUDefRed
(
l
),

100 
m_bSignReque
(
l
),

101 
m_pSignKey
(0)

104 
	gSoupW
::
SoupMesgeSdBa
::
RequeStus
 
OCSPIm
::
ndOcReque
(

105 
OCSP_REQUEST
* 
gReque
,

106 cڡ 
d
::
rg
& 
gUri
)

108 
usg
 
mea
 
SoupW
;

110 * 
	gqueBufr
;

111 
	gqueSizeI
;

112 i(!
cvtToBufr
(
gReque
, &
queBufr
, &
queSizeI
)) {

113 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
,

117 
As
(
queSizeI
 >= 0);

119 
	gSoupMesgeSdBa
::
MesgeBufr
 
bufr
;

120 
	gbufr
.
size
(
queSizeI
);

121 
memy
(&
bufr
[0], 
queBufr
, 
queSizeI
);

122 

(
queBufr
);

124 *
	gt
 = 0,*
	gcho
 = 0,*
	gh
 = 0;

125 
	gu_s
 = 0;

127 i(!
OCSP_r_u
(
cڡ_
<*>(
gUri
.
c_r
()),

128 &
cho
,

129 &
t
,

130 &
h
,

131 &
u_s
))

133 
WLogW
("Error in OCSP_parse_url");

134  
	gSoupMesgeSdBa
::
REQUEST_STATUS_CONNECTION_ERROR
;

137 
	gd
::
rg
 
ho
 = 
cho
;

139 i(
	gt
) {

140 
	gho
 += ":";

141 
	gho
 +
t
;

144 

(
t
);

145 

(
cho
);

146 

(
h
);

148 
	gm_soupMesge
.
tHo
(
gUri
);

149 
	gm_soupMesge
.
tHd
("Ho", 
ho
);

150 
	gm_soupMesge
.
tReque
(
d
::
rg
("application/ocsp-request"),

151 
bufr
);

153  
	gm_soupMesge
.
ndSync
();

156 
	gVidiCe
::
VifitiStusS
 
OCSPIm
::
videCtifiLi
(

157 cڡ 
CtifiLi
 &
s
)

159 
VifitiStusS
 
usS
;

161 i(
	gs
.
size
() < 2) {

163 
WLogW
("No validation will beroceed. OCSPequiret"

164 " 2 ctifi cha. Found oy %d", 
s
.
size
());

165 
	gusS
.
add
(
VERIFICATION_STATUS_ERROR
);

166  
	gusS
;

169 
CtifiP
 
	gro
 = 
s
.
back
();

170 
	gCtSteId
::
S
 
edSId
 = 
CtifiIdtifr
().
fd
(
ro
);

171 * 
	gocU
 = 
edSId
.
gOcU
();

173 i(
	gocU
 !
NULL
)

175 
tUDeuRed
(
ue
);

176 
tDeuRed
(
ocU
);

179 
	gCtifiLi
::
cڡ_
 

 = 
s
.
beg
();

180 
	gCtifiLi
::
cڡ_
 

 = 

;

182 
time_t
 
	gmVidy
 = 0;

183 ++
	g
;!
s
.
d
(); ++
	g
, ++parent) {

184 
WLogD
("Ctifi vidi (CN:%s)", (*

)->
gOLe
().
c_r
());

185 
WLogD
("Pifi (CN:%s)", (*

)->
gOLe
().
c_r
());

186 
	gusS
.
add
(
videCtifi
(*

, *

));

187 i((0 =
mVidy
 || mVidy > 
m_ڣVidy
) &&

188 
m_ڣVidy
 > 0)

190 
mVidy
 = 
m_ڣVidy
;

193 
	gm_ڣVidy
 = 
mVidy
;

195  
	gusS
;

198 
VifitiStus
 
	gOCSPIm
::
checkEndEy
(

199 cڡ 
CtifiCi
 &
cha
)

202 
VifitiStusS
 
vS
;

204 
CtifiLi
 
	g
;

205 i(
	gcha
.
isCha
(&& cha.
size
() >= 2) {

206 
CtifiLi
::
cڡ_
 
i
 = 
cha
.
beg
();

207 
	g
.
push_back
(*
i
);

208 ++
	gi
;

209 
	g
.
push_back
(*
i
);

211 
	gvS
 +
videCtifiLi
(

);

213  
	gvS
.
cvtToStus
();

216 
VifitiStus
 
	gOCSPIm
::
videCtifi
(
CtifiP
 
gCt
,

217 
CtifiP
 
gIssu
)

219 
usg
 
mea
 
	gSoupW
;

221 
As
(!!
gCt
);

222 
As
(!!
gIssu
);

224 
	gVceTry
 {

225 
	gd
::
rg
 
uri
;

227 i(!
	gm_bUDefRed
) {

228 
	guri
 = 
gCt
->
gOCSPURL
();

229 i(
	guri
.
emy
()) {

230  
	gVERIFICATION_STATUS_NOT_SUPPORT
;

233 i(
	gm_rRedURI
.
emy
()) {

234 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
,

237 
WLogW
("Defaultesponder will be used");

239 
	guri
 = 
m_rRedURI
;

243 
CeRequeResu
 
	gwReque
 = 
Reque
(
gCt
, 
gIssu
);

244 i(!
	gwReque
.
	gsucss
) {

245 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
, "Request creation failed");

251 
	gSSLSmtCڏ
 <
	gOCSP_REQUEST
> 
queCt
(
wReque
.
ocReque
);

253 
	gSoupMesgeSdBa
::
RequeStus
 
queStus
;

254 
	gqueStus
 = 
ndOcReque
(
queCt
, 
uri
);

256 i(
	gqueStus
 !
SoupMesgeSdBa
::
REQUEST_STATUS_OK
) {

257  
VERIFICATION_STATUS_CONNECTION_FAILED
;

261 
OcReڣ
 
	gڣ
 = 
cvtToReڣ
();

263 i(!
	gڣ
.
	gf
) {

264 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
,

268 
	gSSLSmtCڏ
 <
	gOCSP_RESPONSE
> 
ڣCt
(
ڣ
.
cd
);

271 
videReڣ
(
queCt
,

272 
ڣCt
,

273 
wReque
.
ocCtId
);

274 } 
VceCch
(
OCSPIm
::
Exi
::
CiE
) {

275 
WLogW
("OCSP: ConnectionError");

276  
	gVERIFICATION_STATUS_CONNECTION_FAILED
;

277 } 
VceCch
(
OCSPIm
::
Exi
::
CtifiRevoked
) {

278 
WLogW
("OCSP: Revoked");

279  
	gVERIFICATION_STATUS_REVOKED
;

280 } 
VceCch
(
OCSPIm
::
Exi
::
CtifiUnknown
) {

281 
WLogW
("OCSP: Unknown");

282  
	gVERIFICATION_STATUS_UNKNOWN
;

283 } 
VceCch
(
OCSPIm
::
Exi
::
VifitiE
) {

284 
WLogW
("OCSP: Verificationrror");

285  
	gVERIFICATION_STATUS_VERIFICATION_ERROR
;

286 } 
VceCch
(
OCSPIm
::
Exi
::
Ba
) {

287 
WLogW
("OCSP: Error");

288  
	gVERIFICATION_STATUS_ERROR
;

290 
WLogW
("OCSP: Good");

291  
	gVERIFICATION_STATUS_GOOD
;

294 
	gOCSPIm
::
tDeuRed
(cڡ *
uri
)

296 
As
(
uri
);

297 
	gm_rRedURI
 = 
d
::
rg
(
uri
);

300 
	gOCSPIm
::
tUDeuRed
(
bo
 
vue
)

302 
m_bUDefRed
 = 
vue
;

305 
time_t
 
	gOCSPIm
::
gReڣVidy
()

307  
m_ڣVidy
;

310 
	gOCSPIm
::
CeRequeResu
 
OCSPIm
::
Reque
(
CtifiP
 
gCt
,

311 
CtifiP
 
gIssu
)

313 
OCSP_REQUEST
* 
	gwReque
 = 
OCSP_REQUEST_w
();

315 i(!
	gwReque
) {

316 
WLogW
("OCSP: Failedo createequest");

317  
CeRequeResu
();

320 
	gSSLSmtCڏ
 <
	gOCSP_REQUEST
> 
queCt
(
wReque
);

322 
OCSP_CERTID
* 
	gId
 = 
addSl
(
gCt
, 
gIssu
);

324 i(!
	gId
) {

325 
WLogW
("OCSP: Unableo create serial id");

326  
CeRequeResu
();

328 
	gSSLSmtCڏ
 <
	gOCSP_CERTID
> 
IdCt
(
Id
);

331 i(!
OCSP_que_add0_id
(
queCt
, 
IdCt
)) {

332 
WLogW
("OCSP: Unableo create certificate id");

333  
CeRequeResu
();

336 i(
	gm_bUN
) {

337 
OCSP_que_add1_n
(
queCt
, 0, -1);

340 i(
	gm_bSignReque
) {

341 i(!
	gm_pSignCt
 || !
	gm_pSignKey
) {

342 
WLogW
("OCSP: Unableo signequest if "

344  
CeRequeResu
();

347 i(!
OCSP_que_sign
(
queCt
,

348 
m_pSignCt
->
gX509
(),

349 
m_pSignKey
,

350 
m_pRequeDigeAlg
,

354 
WLogW
("OCSP: Unableo signequest");

355  
CeRequeResu
();

358  
CeRequeResu
(
ue
,

359 
queCt
.
DachP
(),

360 
IdCt
.
DachP
());

363 
OCSP_CERTID
* 
	gOCSPIm
::
addSl
(
CtifiP
 
gCt
,

364 
CtifiP
 
gIssu
)

366 
X509_NAME
* 
	game
 = 
X509_g_subje_me
(
gIssu
->
gX509
());

367 
ASN1_BIT_STRING
* 
	gikey
 = 
X509_g0_pubkey_br
(
gIssu
->
gX509
());

368 
ASN1_INTEGER
* 
	grl
 = 
X509_g_rlNumb
(
gCt
->
gX509
());

370  
OCSP__id_w
(
m_pCtIdDigeAlg
, 
ame
, 
ikey
, 
rl
);

373 
	gOCSPIm
::
tDigeAlgܙhmFCtId
(
OCSP
::
DigeAlgܙhm
 
g
)

375 cڡ 
EVP_MD
* 
foundAlg
 = 
gDigeAlg
(
g
);

377 i(
	gNULL
 !
foundAlg
) {

378 
m_pCtIdDigeAlg
 = 
foundAlg
;

380 
WLogD
("Request for unsupported CertId digestlgorithm"

385 
	gOCSPIm
::
tDigeAlgܙhmFReque
(
OCSP
::
DigeAlgܙhm
 
g
)

387 cڡ 
EVP_MD
* 
foundAlg
 = 
gDigeAlg
(
g
);

389 i(
	gNULL
 !
foundAlg
) {

390 
m_pRequeDigeAlg
 = 
foundAlg
;

392 
WLogD
("Request for unsupported OCSPequest digestlgorithm"

397 
	gOCSPIm
::
tTruedSte
(cڡ 
CtifiLi
& 
s
)

399 
X509_STORE
 *
e
 = 
X509_STORE_w
();

400 
	gm_pTruedSte
 = 
e
;

402 
FOREACH
(

, 
s
) {

403 
X509_STORE_add_
(
e
, (*

)->
gX509
());

407 
	gOCSPIm
::
videReڣ
(
OCSP_REQUEST
* 
gReque
,

408 
OCSP_RESPONSE
* 
gReڣ
,

409 
OCSP_CERTID
* 
gCtId
)

411 
	gsu
 = 
OCSP_ڣ_us
(
gReڣ
);

413 i(
	gsu
 !
OCSP_RESPONSE_STATUS_SUCCESSFUL
) {

414 
hdInvidReڣ
(
su
);

415 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
, "OCSP_response_status failed");

419 
OCSP_BASICRESP
* 
	gbasic
 = 
OCSP_ڣ_g1_basic
(
gReڣ
);

420 i(!
	gbasic
) {

421 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
,

425 
	gSSLSmtCڏ
 <
	gOCSP_BASICRESP
> 
basicReCt
(
basic
);

426 i(
	gm_bUN
 && 
OCSP_check_n
(
gReque
, 
basicReCt
) <= 0) {

427 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
, "OCSP: Invalidonce");

430 i(!
vifyReڣ
(
basic
)) {

431 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
,

435 
checkRevotiStus
(
basicReCt
, 
gCtId
);

438 
bo
 
	gOCSPIm
::
vifyReڣ
(
OCSP_BASICRESP
* 
basic
)

440 
As
(
m_pTruedSte
);

442 
	gڣ
 = 
OCSP_basic_vify
(
basic
, 
NULL
, 
m_pTruedSte
, 0);

443 i(
	gڣ
 <= 0) {

444 
WLogW
("OCSP verification failed");

447  
	gڣ
 > 0;

450 
	gOCSPIm
::
checkRevotiStus
(
OCSP_BASICRESP
* 
basic
,

451 
OCSP_CERTID
* 
id
)

453 
ASN1_GENERALIZEDTIME
* 
	godudAt
;

454 
ASN1_GENERALIZEDTIME
* 
	gthisUpde
;

455 
ASN1_GENERALIZEDTIME
* 
	gxtUpde
;

456 
	gas
;

457 
	gus
;

459 
	gm_ڣVidy
 = 0;

461 i(!
OCSP__fd_us
(
basic
,

462 
id
,

463 &
us
,

464 &
as
,

465 &
odudAt
,

466 &
thisUpde
,

467 &
xtUpde
))

469 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
,

473 i(!
OCSP_check_vidy
(
thisUpde
,

474 
xtUpde
,

475 
MaxVidyPiodInSecds
,

476 
MaxAge
))

478 
VceThrowMsg
(
OCSPIm
::
Exi
::
VifitiE
,

482 i(
	gxtUpde
) {

483 
a1GizedTimeToTimeT
(
xtUpde
,&
m_ڣVidy
);

484 
time_t
 
	gnow
;

485 
time
(&
now
);

486 
WLogD
("TimoxOCSP updg from sv: %d", 
m_ڣVidy
);

487 
WLogD
("Expe: %d", (
m_ڣVidy
 - 
now
));

488 
WLogD
("Orig: %d", 
xtUpde
->
da
);

491 
	gus
) {

492 
	gV_OCSP_CERTSTATUS_GOOD
:

494 
	gV_OCSP_CERTSTATUS_REVOKED
:

495 
VceThrowMsg
(
OCSPIm
::
Exi
::
CtifiRevoked
, "Certificate is Revoked");

496 
	gV_OCSP_CERTSTATUS_UNKNOWN
:

497 
VceThrowMsg
(
OCSPIm
::
Exi
::
CtifiUnknown
, "Certificate is Unknown");

499 
As
(
l
 && "Invalid status");

503 
	gOCSPIm
::
OcReڣ
 
OCSPIm
::
cvtToReڣ
()

505 
usg
 
mea
 
SoupW
;

508 
BUF_MEM
 
	gs_bmem
;

509 
OCSP_RESPONSE
* 
	gڣ
;

511 
	gSoupMesgeSdBa
::
MesgeBufr
 
bufr
 = 
m_soupMesge
.
gReڣ
();

513 
	gs_bmem
.
	gngth
 = 
bufr
.
size
();

514 
	gs_bmem
.
	gda
 = &
bufr
[0];

515 
	gs_bmem
.
	gmax
 = 
bufr
.
size
();

517 
BIO
* 
	gs_mem_bio
 = 
BIO_w
(
BIO_s_mem
());

518 
BIO_t_mem_buf
(
s_mem_bio
, &
s_bmem
, 
BIO_NOCLOSE
);

520 
	gڣ
 = 
d2i_OCSP_RESPONSE_bio
(
s_mem_bio
, 
NULL
);

521 
BIO__l
(
s_mem_bio
);

523 i(!
	gڣ
) {

524 
WLogW
("OCSP: Failedo convert OCSP Responseo DER format");

525  
	gd
::
make_
(
l
, 
ic_
<
OCSP_RESPONSE
*>(
NULL
));

528  
	gd
::
make_
(
ue
, 
ڣ
);

531 
	gOCSPIm
::
hdInvidReڣ
(
su
)

533 
su
) {

534 
OCSP_RESPONSE_STATUS_MALFORMEDREQUEST
:

535 
WLogW
("OCSP: Servereturns "

538 
	gOCSP_RESPONSE_STATUS_INTERNALERROR
:

539 
WLogW
("OCSP: Servereturns "

542 
	gOCSP_RESPONSE_STATUS_TRYLATER
:

543 
WLogW
("OCSP: Servereturns "

546 
	gOCSP_RESPONSE_STATUS_SIGREQUIRED
:

547 
WLogW
("OCSP: Servereturns "

550 
	gOCSP_RESPONSE_STATUS_UNAUTHORIZED
:

551 
WLogW
("OCSP: Servereturns "

555 
As
(
l
 && "Invalidesult value");

	@vcore/src/vcore/OCSPImpl.h

26 #ide
_VALIDATION_CORE_OCSPIMPL_H_


27 
	#_VALIDATION_CORE_OCSPIMPL_H_


	)

29 
	~<vce/OCSP.h
>

31 
	~<rg
>

32 
	~<ve
>

33 
	~<li
>

35 
	~<ݒs/m.h
>

36 
	~<ݒs/oc.h
>

37 
	~<libsoup/soup.h
>

39 
	~<vce/sced_gpor.h
>

40 
	~<vce/OCSPCtMgrUt.h
>

41 
	~<vce/CtifiCi.h
>

42 
	~<vce/CtifiStage.h
>

43 
	~<vce/VifitiStus.h
>

44 
	~<vce/SSLCڏs.h
>

45 
	~<vce/SoupMesgeSdBa.h
>

46 
	~<vce/SoupMesgeSdSync.h
>

47 
	~<vce/TimeCvsi.h
>

48 
	~<vce/exi.h
>

81 
mea
 
	gVidiCe
 {

83 as
	cOCSPIm
 {

84 
	gpublic
:

85 
OCSPIm
();

87 cڡ * 
	gDEFAULT_RESPONDER_URI_ENV
;

89 
VifitiStus
 
checkEndEy
(cڡ 
CtifiCi
 &
Li
);

94 
tDigeAlgܙhmFCtId
(
OCSP
::
DigeAlgܙhm
 
g
);

99 
tDigeAlgܙhmFReque
(
OCSP
::
DigeAlgܙhm
 
g
);

101 
tTruedSte
(cڡ 
CtifiLi
& 
s
);

103 
VifitiStusS
 
videCtifiLi
(cڡ 
CtifiLi
 &
s
);

105 
VifitiStus
 
videCtifi
(
CtifiP
 
gCt
,

106 
CtifiP
 
gIssu
);

108 
tDeuRed
(cڡ * 
uri
);

110 
tUDeuRed
(
bo
 
vue
);

117 
time_t
 
gReڣVidy
();

119 
	give
:

120 as
	cExi
 {

121 
public
:

122 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
)

123 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
CiE
)

124 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
CtifiRevoked
)

125 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
CtifiUnknown
)

126 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
VifitiE
)

127 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
RrveCtFromSteE
)

128 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
VifitiNSut
)

130 
	gWRT
::
	tScedGPor
<
	tSoupSessi
> 
	tScedSoupSessi
;

131 
	gWRT
::
	tScedGPor
<
	tSoupMesge
> 
	tScedSoupMesge
;

133 
hdInvidReڣ
(
su
);

134 
ndHTTPReque
(
ScedSoupSessi
& 
ssi
,

135 
ScedSoupMesge
& 
msg
,

136 cڡ * 
ho
,

137 cڡ * 
pt
,

138 cڡ * 
th
,

139 * 
queBufr
,

140 
size_t
 
qeSize
);

141 
ndReque
(cڡ 
d
::
rg
& 
uri
,

142 * 
queBufr
,

143 
size_t
 
queSize
,

144 ** 
ڣBufr
,

145 
size_t
* 
ڣSize
);

147 cڡ 
EVP_MD
* 
	gm_pCtIdDigeAlg
;

148 cڡ 
EVP_MD
* 
	gm_pRequeDigeAlg
;

150 
	gd
::
	t
<*, 
	tsize_t
> 
	tHpReڣBufr
;

152 
	gSoupW
::
SoupMesgeSdBa
::
RequeStus
 
ndOcReque
(

153 
OCSP_REQUEST
* 
gReque
,

154 cڡ 
d
::
rg
& 
gUri
);

164 
	sCeRequeResu


166 
bo
 
	gsucss
;

167 
OCSP_REQUEST
* 
	gocReque
;

168 
OCSP_CERTID
* 
	gocCtId
;

169 
CeRequeResu
(
bo
 
gSucss
 = 
l
,

170 
OCSP_REQUEST
* 
gOcReque
 = 
NULL
,

171 
OCSP_CERTID
* 
gOcCtId
 = 
NULL
) :

172 
sucss
(
gSucss
),

173 
ocReque
(
gOcReque
),

174 
ocCtId
(
gOcCtId
)

186 
CeRequeResu
 
Reque
(
CtifiP
 
gCt
,

187 
CtifiP
 
gIssu
);

189 
OCSP_CERTID
* 
addSl
(
CtifiP
 
gCt
,

190 
CtifiP
 
gIssu
);

192 
videReڣ
(
OCSP_REQUEST
* 
gReque
,

193 
OCSP_RESPONSE
* 
gReڣ
,

194 
OCSP_CERTID
* 
gCtId
);

197 
bo
 
vifyReڣ
(
OCSP_BASICRESP
* 
gReڣ
);

199 
checkRevotiStus
(
OCSP_BASICRESP
* 
gBasicReڣ
,

200 
OCSP_CERTID
* 
gCtId
);

202 
	gd
::
	t
<
	tbo
, 
	tOCSP_RESPONSE
*> 
	tOcReڣ
;

204 
OcReڣ
 
cvtToReڣ
();

206 
time_t
 
	gm_ڣVidy
;

207 
bo
 
	gm_bUN
;

208 
bo
 
	gm_bUDefRed
;

209 
	gd
::
rg
 
m_rRedURI
;

210 
bo
 
	gm_bSignReque
;

211 
EVP_PKEY
* 
	gm_pSignKey
;

212 
CtifiP
 
	gm_pSignCt
;

213 
	gSSLSmtCڏ
 <
	gX509_STORE
> 
	gm_pTruedSte
;

214 
	gSoupW
::
SoupMesgeSdSync
 
m_soupMesge
;

	@vcore/src/vcore/OCSPUtil.c

22 
	~<ݒs/oc.h
>

28 
cvtToBufr
(
OCSP_REQUEST
 *
q
, **
buf
, *
size
);

30 
	$cvtToBufr
(
OCSP_REQUEST
 *
q
, **
buf
, *
size
) {

31 
BIO
 *
q_mem_bio
;

32 
BUF_MEM
 
q_bmem
;

37 *
size
 = 
	`i2d_OCSP_REQUEST
(
q
, 
NULL
);

38 *
buf
 = (*
	`mloc
(*
size
);

40 i(!*
buf
)

44 
q_bmem
.
ngth
 = 0;

45 
q_bmem
.
da
 = *
buf
;

46 
q_bmem
.
max
 = *
size
;

51 
q_mem_bio
 = 
	`BIO_w
(
	`BIO_s_mem
());

53 i(!
q_mem_bio
) {

57 
	`
(*
buf
);

58 *
buf
 = 
NULL
;

62 
	`BIO_t_mem_buf
(
q_mem_bio
, &
q_bmem
, 
BIO_NOCLOSE
);

67 i(
	`i2d_OCSP_REQUEST_bio
(
q_mem_bio
, 
q
) <= 0) {

68 
	`
(*
buf
);

69 *
buf
 = 
NULL
;

70 
	`BIO__l
(
q_mem_bio
);

77 i(*
size
 !(()
q_bmem
.
ngth
||eq_bmem.ngth !q_bmem.
max
)

79 
	`
(*
buf
);

80 *
buf
 = 
NULL
;

81 
	`BIO__l
(
q_mem_bio
);

88 
	`BIO__l
(
q_mem_bio
);

94 
	}
}

	@vcore/src/vcore/ParserSchema.h

22 #ide
_PARSERSCHEMA_H_


23 
	#_PARSERSCHEMA_H_


	)

25 
	~<m
>

26 
	~<rg
>

28 
	~<vce/SaxRd.h
>

29 
	~<vce/exi.h
>

31 
mea
 
	gVidiCe
 {

32 
mea
 
	gPrSchemaExi
 {

33 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
);

34 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
XmlRdE
);

35 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
CtifiLdE
);

36 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
Unsu܋dAlgܙhm
);

37 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
Unsu܋dVue
);

40 
	gme
<
tyme
 
	gPrTy
,ym
	gDaTy
>

41 as
	cPrSchema
 {

42 
	gpublic
:

44 
	sTagDesti
 {

45 
TagDesti
(cڡ 
d
::
rg
 &
g
,

46 cڡ 
d
::
rg
 & 
xmlNamea
) :

47 
gName
(
g
),

48 
meaUri
(
xmlNamea
)

52 
	gd
::
rg
 
gName
;

53 
	gd
::
rg
 
meaUri
;

55 
bo
 
	gݔ
<(cڡ 
	gTagDesti
 &
	gcd
) const

57 i(
	ggName
 < 
	gcd
.tagName) {

58  
	gue
;

60 i(
	ggName
 > 
	gcd
.tagName) {

61  
	gl
;

63 i(
	gmeaUri
 < 
	gcd
.namespaceUri) {

64  
	gue
;

66  
	gl
;

71 
PrSchema
(
PrTy
 *
rr
)

72 : 
m_funis
(
rr
) {}

74 
vtu
 ~
PrSchema
() {}

76 
lize
(

77 cڡ 
d
::
rg
 &
fame
,

78 
bo
 
deuArgs
,

79 
SaxRd
::
VidiTy
 
vTy
,

80 cڡ 
d
::
rg
 &
xmlschema
)

82 
VceTry


84 
m_ad
.
lize
(
fame
, 
deuArgs
, 
vTy
, 
xmlschema
);

86 
VceCch
 (
SaxRd
::
Exi
::
Ba
)

88 
VceReThrowMsg
(
PrSchemaExi
::
XmlRdE
, "XmlReaderError");

92 
delize
()

94 
	gm_ad
.
delize
();

97 
ad
(
DaTy
 &
daCڏ
)

99 
	gVceTry


101 
	gm_ad
.
xt
()) {

102 
	gm_ad
.
ty
()) {

103 
	gSaxRd
::
NODE_BEGIN
:

104 
begNode
(
daCڏ
);

106 
	gSaxRd
::
NODE_END
:

107 
dNode
(
daCڏ
);

109 
	gSaxRd
::
NODE_TEXT
:

110 
xtNode
(
daCڏ
);

117 
VceCch
 (
SaxRd
::
Exi
::
Ba
)

119 
VceReThrowMsg
(
PrSchemaExi
::
XmlRdE
, "XmlReaderError");

123 (
	gPrTy
::*
	tFuniP
)(
	tDaTy
 &
	tda
);

124 
	gd
::
	tm
<
	tTagDesti
, 
	tFuniP
> 
	tFuniM
;

126 
addBegTagClback
(

127 cڡ 
d
::
rg
 &
g
,

128 cڡ 
d
::
rg
 &
meaUri
,

129 
FuniP
 
funi
)

131 
TagDesti
 
desc
(
g
, 
meaUri
);

132 
	gm_begFuniM
[
desc
] = 
funi
;

135 
addEndTagClback
(

136 cڡ 
d
::
rg
 &
g
,

137 cڡ 
d
::
rg
 &
meaUri
,

138 
FuniP
 
funi
)

140 
TagDesti
 
desc
(
g
, 
meaUri
);

141 
	gm_dFuniM
[
desc
] = 
funi
;

144 
	gSaxRd
& 
gRd
()

146  
	gm_ad
;

149 
	gd
::
rg
& 
gText
()

151  
m_xtNode
;

154 
	geed
:

155 
begNode
(
DaTy
 &
daCڏ
)

157 
TagDesti
 
desc
(
m_ad
.
me
(), m_ad.
meaURI
());

158 
FuniP
 
	gfun
 = 
m_begFuniM
[
desc
];

160 i(
	gfun
 == 0) {

164 (
	gm_funis
->*
	gfun
)(
	gdaCڏ
);

167 
dNode
(
DaTy
 &
daCڏ
)

169 
TagDesti
 
desc
(
m_ad
.
me
(), m_ad.
meaURI
());

170 
FuniP
 
	gfun
 = 
m_dFuniM
[
desc
];

172 i(
	gfun
 == 0) {

176 (
	gm_funis
->*
	gfun
)(
	gdaCڏ
);

179 
xtNode
(
DaTy
 &
daCڏ
)

181 ()
	gdaCڏ
;

182 
	gm_xtNode
 = 
m_ad
.
vue
();

185 
PrTy
 *
	gm_funis
;

186 
SaxRd
 
	gm_ad
;

187 
FuniM
 
	gm_begFuniM
;

188 
FuniM
 
	gm_dFuniM
;

191 
	gd
::
rg
 
m_xtNode
;

	@vcore/src/vcore/ReferenceValidator.cpp

22 
	~<vce/RenVid.h
>

24 
	~<dt.h
>

25 
	~<o.h
>

26 
	~<fam
>

27 
	~<memy
>

29 
	~<pep.h
>

31 
	~<d/o_rg.h
>

32 
	~<d/log/w_log.h
>

34 
	gmea
 {

36 cڡ *
	gSPECIAL_SYMBOL_CURRENT_DIR
 = ".";

37 cڡ *
	gSPECIAL_SYMBOL_UPPER_DIR
 = "..";

38 cڡ *
	gSPECIAL_SYMBOL_AUTHOR_SIGNATURE_FILE
 = "author-signature.xml";

39 cڡ *
	gREGEXP_DISTRIBUTOR_SIGNATURE
 = "^signature[1-9][0-9]*\\.xml";

41 cڡ 
	gMARK_ENCODED_CHAR
 = '%';

45 
mea
 
	gVidiCe
 {

47 as
	cRenVid
::
Im


49 
public
:

50 
Im
(cڡ 
d
::
rg
 &
dth
)

51 : 
m_dth
(
dth
)

52 , 
m_sigtuRegexp
(
REGEXP_DISTRIBUTOR_SIGNATURE
)

55 
	gvtu
 ~
Im
(){}

57 
Resu
 
checkRens
(cڡ 
SigtuDa
 &
sigtuDa
){

58 cڡ 
	gRenS
 &
	gfS
 = 
sigtuDa
.
gRenS
();

59 
RenS
 
	gfDecoded
;

61 
	gy
 {

62 aut
	g
 = 
fS
.
beg
(); i!fS.
d
(); ++it) {

63 i(
	gd
::
rg
::
os
 !

->
fd
(
MARK_ENCODED_CHAR
))

64 
fDecoded
.

(
decodePro
(*

));

66 
	gfDecoded
.

(*

);

68 } 
tch
 (
Resu
 &) {

69  
	gERROR_DECODING_URL
;

71  
dfsCheckDeܛs
(

72 
fDecoded
,

73 
d
::
rg
(),

74 
sigtuDa
.
isAuthSigtu
());

77 
	give
:

78 
hexToI
(
hex
);

79 
	gd
::
rg
 
decodePro
(cڡ 
d
::rg &
th
);

81 
Resu
 
dfsCheckDeܛs
(

82 cڡ 
RenS
 &
nS
,

83 cڡ 
d
::
rg
 &
dey
,

84 
bo
 
isAuthSigtu
);

86 
le
 
bo
 
isDiributSigtu
(cڡ *
crg
) const

88  
	gm_sigtuRegexp
.
FuMch
(
crg
);

91 
	gd
::
rg
 
m_dth
;

92 
	gd
::
rg
 
m_rDesti
;

93 
	gpep
::
RE
 
m_sigtuRegexp
;

96 
	gRenVid
::
Im
::
	$hexToI
(
a
) {

97 i(
a
 >= '0' && <= '9') -'0';

98 i(
a
 >= 'A' && <= 'F') -'A' + 10;

99 i(
a
 >= 'a' && <= 'f') -'a' + 10;

100 
	`WLogE
("Symb '%c' iouosce.", 
a
);

101 
throw
 
ERROR_DECODING_URL
;

102 
	}
}

104 
	gd
::
rg
 
RenVid
::
Im
::
	$decodePro
(cڡ 
d
::
rg
 &
th
) {

105 
d
::
ve
<> 
	`put
(
th
.
	`beg
(),h.
	`d
());

106 
d
::
ve
<> 
ouut
;

107 
y
 {

108 
size_t
 
i
 = 0;

109 
i
<
put
.
	`size
()) {

110 i(
MARK_ENCODED_CHAR
 =
put
[
i
]) {

111 i(
i
+2 >
put
.
	`size
())

112 
throw
 
ERROR_DECODING_URL
;

114 
su
 = 
	`hexToI
(
put
[
i
+1])*16 + hexToInt(input[i+2]);

117 i(
su
 >= 128)

118 
throw
 
ERROR_DECODING_URL
;

120 
ouut
.
	`push_back
(
ic_
<>(
su
));

121 
i
+=3;

123 
ouut
.
	`push_back
(
ic_
<>(
put
[
i
]));

124 ++
i
;

127 } 
	`tch
 (
Resu
 &) {

128 
	`WLogE
("E whdecodg uh: %s", 
th
.
	`c_r
());

129 
throw
 
ERROR_DECODING_URL
;

131  
d
::
	`rg
(
ouut
.
	`beg
(), ouut.
	`d
());

132 
	}
}

134 
	gRenVid
::
Resu
 
RenVid
::
Im
::
	$dfsCheckDeܛs
(

135 cڡ 
RenS
 &
nS
,

136 cڡ 
d
::
rg
 &
dey
,

137 
bo
 
isAuthSigtu
)

139 
DIR
 *
dp
;

140 
dt
 *
dp
;

141 
d
::
rg
 
cutD
 = 
m_dth
 + 
dey
;

143 i((
dp
 = 
	`ݒd
(
cutD
.
	`c_r
())=
NULL
) {

144 
	`WLogE
("E ong dey: %s", 
cutD
.
	`c_r
());

145 
m_rDesti
 = 
cutD
;

146  
ERROR_OPENING_DIR
;

149 
o
 = 0; (
dp
 = 
	`add
(
dp
)!
NULL
;rrno = 0) {

150 i(!
	`rcmp
(
dp
->
d_me
, 
SPECIAL_SYMBOL_CURRENT_DIR
)) {

154 i(!
	`rcmp
(
dp
->
d_me
, 
SPECIAL_SYMBOL_UPPER_DIR
)) {

158 i(
cutD
 =
m_dth
 && 
dp
->
d_ty
 =
DT_REG
 &&

159 !
	`rcmp
(
dp
->
d_me
, 
SPECIAL_SYMBOL_AUTHOR_SIGNATURE_FILE
) &&

160 
isAuthSigtu
)

165 i(
cutD
 =
m_dth
 && 
dp
->
d_ty
 =
DT_REG
 &&

166 
	`isDiributSigtu
(
dp
->
d_me
)) {

170 i(
dp
->
d_ty
 =
DT_DIR
) {

171 
	`WLogD
("Odey: %s", (
dey
 + 
dp
->
d_me
).
	`c_r
());

172 
d
::
rg
 
tmp_dey
 = 
dey
 + 
dp
->
d_me
 + "/";

173 
Resu
 
su
 = 
	`dfsCheckDeܛs
(
nS
,

174 
tmp_dey
,

175 
isAuthSigtu
);

176 i(
su
 !
NO_ERROR
) {

177 
	`od
(
dp
);

178  
su
;

180 } i(
dp
->
d_ty
 =
DT_REG
) {

181 i(
nS
.
	`d
() ==

182 
nS
.
	`fd
(
dey
 + 
dp
->
d_me
))

184 
	`WLogD
("Found fe: %s", (
dey
 + 
dp
->
d_me
).
	`c_r
());

185 
	`WLogE
("Unknown ERROR_REFERENCE_NOT_FOUND.");

186 
	`od
(
dp
);

187 
m_rDesti
 = 
dey
 + 
dp
->
d_me
;

188  
ERROR_REFERENCE_NOT_FOUND
;

191 
	`WLogE
("Unknown fileype.");

192 
	`od
(
dp
);

193 
m_rDesti
 = 
dey
 + 
dp
->
d_me
;

194  
ERROR_UNSUPPORTED_FILE_TYPE
;

198 i(
o
 != 0) {

199 
m_rDesti
 = 
VceDPL
::
	`GEnoSg
();

200 
	`WLogE
("add faed. Encode: %d, Desti: ", 
o
, 
m_rDesti
.
	`c_r
());

201 
	`od
(
dp
);

202  
ERROR_READING_DIR
;

205 
	`od
(
dp
);

207  
NO_ERROR
;

208 
	}
}

210 
	gRenVid
::
	$RenVid
(cڡ 
d
::
rg
 &
dth
)

211 : 
	`m_im
(
w
 
	$Im
(
dth
))

212 {
	}
}

214 
RenVid
::~
	$RenVid
(){

215 
de
 
m_im
;

216 
	}
}

218 
	gRenVid
::
Resu
 
RenVid
::
	$checkRens
(

219 cڡ 
SigtuDa
 &
sigtuDa
)

221  
m_im
->
	`checkRens
(
sigtuDa
);

222 
	}
}

	@vcore/src/vcore/ReferenceValidator.h

22 #ide
_VALIDATION_CORE_REFERENCEVALIDATOR_H_


23 
	#_VALIDATION_CORE_REFERENCEVALIDATOR_H_


	)

25 
	~<d/ncyab.h
>

27 
	~<vce/SigtuDa.h
>

29 
mea
 
	gVidiCe
 {

31 as
	cRenVid
 : 
VceDPL
::
Ncyab


33 
public
:

34 
	eResu


36 
NO_ERROR
 = 0,

37 
	gERROR_OPENING_DIR
,

38 
	gERROR_READING_DIR
,

39 
	gERROR_UNSUPPORTED_FILE_TYPE
,

40 
	gERROR_REFERENCE_NOT_FOUND
,

41 
	gERROR_DECODING_URL


44 
RenVid
(cڡ 
d
::
rg
 &
dth
);

46 
	gvtu
 ~
RenVid
();

48 
Resu
 
checkRens
(cڡ 
SigtuDa
 &
sigtuDa
);

50 
	give
:

51 
ass
 
Im
;

52 
Im
 *
	gm_im
;

	@vcore/src/vcore/RevocationCheckerBase.cpp

23 
	~"RevotiCheckBa.h
"

25 
	~<cdlib
>

27 
	~<ݒs/m.h
>

29 
	~<d/sced_fo.h
>

31 
	~"Ctifi.h
"

32 
	~"CtifiCi.h
"

34 
	gmea
 {

35 cڡ 
	gDeuBundPch
[] = "/opt/etc/ssl/certs/ca-certificates.crt";

38 
mea
 
	gVidiCe
 {

39 
CtifiP
 
	gRevotiCheckBa
::
ldPEMFe
(cڡ * 
feName
)

41 
VceDPL
::
ScedFClo
 
fd
(
fݒ
(
feName
, "rb"));

44 i(!
	gfd
.
G
()) {

45  
CtifiP
();

49 
CtifiP
 

(
w
 
Ctifi
(
PEM_ad_X509
(
fd
.
G
(),

50 
NULL
,

51 
NULL
,

52 
NULL
)));

53  
	g
;

56 
bo
 
	gRevotiCheckBa
::
stCtLi
(
CtifiLi
 &
lCtifis
)

58 
CtifiCi
 
ci
;

59 
	gci
.
ld
(
lCtifis
);

61 i(
	gci
.
st
()) {

62 
	glCtifis
 = 
ci
.
gCha
();

63  
	gue
;

65  
	gl
;

	@vcore/src/vcore/RevocationCheckerBase.h

23 #ide
WRT_ENGINE_SRC_VALIDATION_CORE_REVOCATIONCHECKERBASE_H_


24 
	#WRT_ENGINE_SRC_VALIDATION_CORE_REVOCATIONCHECKERBASE_H_


	)

26 
	~<rg
>

28 
	~"Ctifi.h
"

30 
mea
 
	gVidiCe
 {

31 as
	cRevotiCheckBa


33 
	gpublic
:

35 
CtifiP
 
ldPEMFe
(cڡ * 
th
);

39 
bo
 
stCtLi
(
CtifiLi
 &


__ibu__
((
dd
));

	@vcore/src/vcore/SSLContainers.h

16 #ide
_SSLCONTAINERS_H


17 
	#_SSLCONTAINERS_H


	)

19 
	~<ݒs/x509v3.h
>

20 
	~<ݒs/oc.h
>

25 
	gme
 <
tyme
 
	gT
>

26 
	sMySSLFe
 {};

32 
	#DECLARE_DELETER
(
Ty

me
<> \

33 
MySSLFe
 <
Ty
> \

35 
	`ݔ
((
Ty
* 
p
) \

37 
Ty
 ## 
	`_
(
p
); \

40 };

	)

45 
	$DECLARE_DELETER
(
X509
)

49 
	$DECLARE_DELETER
(
OCSP_REQUEST
)

53 
	$DECLARE_DELETER
(
OCSP_RESPONSE
)

57 
	$DECLARE_DELETER
(
OCSP_CERTID
)

61 
	$DECLARE_DELETER
(
OCSP_BASICRESP
)

65 
	$DECLARE_DELETER
(
X509_STORE
)

70 #unde
DECLARE_DELETER


77 
me
 <
tyme
 
T
,ym
d
 = 
MySSLFe
<T> >

78 as
	cSSLSmtCڏ


80 
public
:

81 
	$SSLSmtCڏ
(: 
	$m_pDa
(
NULL
)

88 
exic
 
	$SSLSmtCڏ
(
T
* 
pDa
)

90 
m_pDa
 = 
pDa
;

91 
	}
}

96 
	gSSLSmtCڏ
 & 
	gݔ
=(
SSLSmtCڏ
& 
pCڏ
)

101 i(
this
 !&
pCڏ
) {

103 
d
 
s_
;

104 
s_
(
m_pDa
);

107 
	gm_pDa
 = 
pCڏ
.
m_pDa
;

109 
	gpCڏ
.
	gm_pDa
 = 
NULL
;

112  *
	gthis
;

115 
	gSSLSmtCڏ
 & 
	gݔ
=(
T
* 
pDa
)

120 i(
m_pDa
 !
pDa
) {

122 
d
 
s_
;

123 
s_
(
m_pDa
);

126 
	gm_pDa
 = 
pDa
;

129  *
	gthis
;

132 ~
	$SSLSmtCڏ
()

134 
d
 
s_
;

135 
	`s_
(
m_pDa
);

136 
	}
}

141 
	gSSLSmtCڏ
 & 
	gݔ
*()

143  *
	gm_pDa
;

145 
SSLSmtCڏ
* 
	gݔ
->()

147  
	gm_pDa
;

153 
ݔ
 
	gT
 *(cڡ {  
	gm_pDa
;

159 
T
* 
	$DachP
()

161 
T
* 
pDa
 = 
m_pDa
;

162 
m_pDa
 = 
NULL
;

163  
pDa
;

164 
	}
}

166 
	give
:

170 
me
 <
tyme
 
S
>

171 
T
 & 
ݔ
 = (
S
& 
pCڏ
)

173  *
this
;

179 
T
* 
	gm_pDa
;

	@vcore/src/vcore/SaxReader.cpp

22 
	~<d/as.h
>

23 
	~<d/log/w_log.h
>

25 
	~<vce/SaxRd.h
>

27 
mea
 
	gVidiCe
 {

30 
	gSaxRd
::
SaxRd
() :

31 
m_ad
(0)

35 
SaxRd
::~SaxReader()

37 i(
m_ad
) {

38 
delize
();

42 
	gSaxRd
::
lize
(

43 cڡ 
d
::
rg
 &
fame
,

44 
bo
 
deuArgs
,

45 
VidiTy
 
vide
,

46 cڡ 
d
::
rg
 &
schema
)

48 
As
(
m_ad
 == 0 && "Double initialization of SaxReader");

50 
WLogD
("SaxRd ong fe: %s", 
fame
.
c_r
());

52 
	gm_ad
 = 
xmlNewTextRdFame
(
fame
.
c_r
());

54 i(!
	gm_ad
) {

55 
VceThrowMsg
(
SaxRd
::
Exi
::
FeOngE
,

56 "ݒg f" << 
fame
 << "rror");

59 i(
	gvide
 =
VALIDATION_XMLSCHEME
 &&

60 
xmlTextRdSchemaVide
(
m_ad
, 
schema
.
c_r
())) {

64 
VceThrowMsg
(
SaxRd
::
Exi
::
PrIlE
,

69 i(
	gvide
 =
VALIDATION_DTD
 &&

70 
xmlTextRdSPrPr
(
m_ad
, 
XML_PARSER_VALIDATE
, 1)) {

74 
VceThrowMsg
(
SaxRd
::
Exi
::
PrIlE
,

78 i(
	gdeuArgs
 &&

79 
xmlTextRdSPrPr
(
m_ad
, 
XML_PARSER_DEFAULTATTRS
, 1)) {

83 
VceThrowMsg
(
SaxRd
::
Exi
::
PrIlE
,

88 
	gSaxRd
::
delize
()

90 
xmlFeTextRd
(
m_ad
);

91 
	gm_ad
 = 0;

94 
bo
 
	gSaxRd
::
xt
()

96 
s
 = 
xmlTextRdRd
(
m_ad
);

98 i(
	gs
 < 0)

99 
VceThrowMsg
(
SaxRd
::
Exi
::
PrIlE
,

102 i(!
xmlTextRdIsVid
(
m_ad
))

103 
VceThrowMsg
(
SaxRd
::
Exi
::
FeNVid
,

106  
	gs
 ? 
	gue
 : 
l
;

109 
	gSaxRd
::
xt
(cڡ 
d
::
rg
 &
tok
)

111 
s
 = 
xmlTextRdRd
(
m_ad
);

113 i(
	gs
 < 0)

114 
VceThrowMsg
(
SaxRd
::
Exi
::
PrIlE
,

117 i(!
xmlTextRdIsVid
(
m_ad
))

118 
VceThrowMsg
(
SaxRd
::
Exi
::
FeNVid
,

121 
xmlCh
 *
	gme
 = 
xmlTextRdName
(
m_ad
);

123 i(!
	gme
)

124 
VceThrowMsg
(
SaxRd
::
Exi
::
PrIlE
,

127 
xmlCh
 *
	gxmlTok
 = 
xmlChSdup
(
tok
.
c_r
());

129 i(
xmlScmp
(
me
, 
xmlTok
)) {

130 
xmlFe
(
me
);

131 
xmlFe
(
xmlTok
);

133 
VceThrowMsg
(
SaxRd
::
Exi
::
WrgTok
, "Wrong Token");

136 
xmlFe
(
me
);

137 
xmlFe
(
xmlTok
);

140 
bo
 
	gSaxRd
::
isEmy
()

142 
t
 = 
xmlTextRdIsEmyEmt
(
m_ad
);

143 i(-1 =
t
)

144 
VceThrowMsg
(
SaxRd
::
Exi
::
PrIlE
,

147  
	gt
 ? 
	gue
 : 
l
;

150 
	gd
::
rg
 
SaxRd
::
ibu
(cڡ 
d
::rg &
tok
, 
ThrowTy
 
throwStus
)

152 
xmlCh
 *
	g
 = 
xmlTextRdGAribu
(
m_ad
, 
BAD_CAST
(
tok
.
c_r
()));

153 i(!
	g
) {

154 i(
	gthrowStus
 =
THROW_DISABLE
) {

155  
d
::
rg
();

158 
VceThrowMsg
(
SaxRd
::
Exi
::
PrIlE
,

163 
	gd
::
rg
 
vue
 = 
t_
<cڡ *>(

);

164 
xmlFe
(

);

166  
	gvue
;

169 
	gd
::
rg
 
SaxRd
::
me
()

171 
xmlCh
 *
me
 = 
xmlTextRdName
(
m_ad
);

172 i(!
	gme
)

173 
VceThrowMsg
(
SaxRd
::
Exi
::
RdgNameE
,

176 
	gd
::
rg
 
vue
 = 
t_
<cڡ *>(
me
);

177 
xmlFe
(
me
);

178 
size_t
 
	gpos
 = 
vue
.
fd_ϡ_of
(":");

179 i(
	gpos
 !
d
::
rg
::
os
) {

180 
vue
.
a
(0, 
pos
 + 1);

183  
	gvue
;

186 
	gd
::
rg
 
SaxRd
::
meaURI
()

188 
xmlCh
 *
me
 = 
xmlTextRdNameaUri
(
m_ad
);

189 i(!
	gme
) {

190  
	gd
::
rg
();

193 
	gd
::
rg
 
vue
 = 
t_
<cڡ *>(
me
);

194 
xmlFe
(
me
);

196  
	gvue
;

199 
	gd
::
rg
 
SaxRd
::
vue
()

201 
xmlCh
 *
xt
 = 
xmlTextRdVue
(
m_ad
);

202 i(!
	gxt
)

203 
VceThrowMsg
(
SaxRd
::
Exi
::
RdgVueE
,

206 
	gd
::
rg
 
vue
 = 
t_
<cڡ *>(
xt
);

207 
xmlFe
(
xt
);

209  
	gvue
;

212 
	gSaxRd
::
NodeTy
 
SaxRd
::
ty
()

214 
xmlRdTys
 
ty
 =

215 
ic_
<
xmlRdTys
>(
xmlTextRdNodeTy
(
m_ad
));

216 
	gty
) {

217 
	gXML_READER_TYPE_ELEMENT
:

218  
NODE_BEGIN
;

219 
	gXML_READER_TYPE_END_ELEMENT
:

220  
NODE_END
;

221 
	gXML_READER_TYPE_TEXT
:

222  
NODE_TEXT
;

223 
	gXML_READER_TYPE_NONE
:

224 
XML_READER_TYPE_ATTRIBUTE
:

225 
XML_READER_TYPE_CDATA
:

226 
XML_READER_TYPE_ENTITY_REFERENCE
:

227 
XML_READER_TYPE_ENTITY
:

228 
XML_READER_TYPE_PROCESSING_INSTRUCTION
:

229 
XML_READER_TYPE_COMMENT
:

230 
XML_READER_TYPE_DOCUMENT
:

231 
XML_READER_TYPE_DOCUMENT_TYPE
:

232 
XML_READER_TYPE_DOCUMENT_FRAGMENT
:

233 
XML_READER_TYPE_NOTATION
:

234 
XML_READER_TYPE_WHITESPACE
:

235 
XML_READER_TYPE_SIGNIFICANT_WHITESPACE
:

236 
XML_READER_TYPE_END_ENTITY
:

237 
XML_READER_TYPE_XML_DECLARATION
:

239  
NODE_UNSUPPORTED
;

243 
	gSaxRd
::
dumpNode
(
d
::
rg
 &
bufr
)

245 
xmlBufrP
 
buff
 = 
xmlBufrCe
();

247 
xmlNodeP
 
	gnode
 = 
xmlTextRdExnd
(
m_ad
);

248 i(!
	gnode
) {

249 
xmlBufrFe
(
buff
);

250 
VceThrowMsg
(
SaxRd
::
Exi
::
PrIlE
,

254 
	gsize
 = 
xmlNodeDump
(
buff
, 
node
->
doc
,ode, 0, 0);

255 i(
	gsize
 > 0) {

256 
	gbufr
.

(0, 
t_
<*>(
buff
->
cڋ
), 
size
);

258 
xmlBufrFe
(
buff
);

	@vcore/src/vcore/SaxReader.h

24 #ide
_SAXREADER_H_


25 
	#_SAXREADER_H_


	)

27 
	~<rg
>

28 
	~<libxml/xm̗d.h
>

30 
	~<vce/exi.h
>

32 
mea
 
	gVidiCe
 {

33 as
	cSaxRd
 {

34 
	gpublic
:

35 
SaxRd
();

36 ~
SaxRd
();

38 as
	cExi
 {

39 
	gpublic
:

40 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
);

41 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
FeOngE
);

42 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
FeNVid
);

43 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
PrIlE
);

44 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
WrgTok
);

45 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
RdgVueE
);

46 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
RdgNameE
);

47 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
Unsu܋dTy
);

50 
	eNodeTy


52 
	gNODE_UNSUPPORTED
,

53 
	gNODE_BEGIN
,

54 
	gNODE_END
,

55 
	gNODE_TEXT


58 
	eThrowTy


60 
	gTHROW_ENABLE
 = 0,

61 
	gTHROW_DISABLE


67 
	eVidiTy


69 
	gVALIDATION_DISABLE
,

70 
	gVALIDATION_XMLSCHEME
,

71 
	gVALIDATION_DTD


77 
lize
(

78 cڡ 
d
::
rg
 &
fame
,

79 
bo
 
deuArgs
 = 
l
,

80 
VidiTy
 
vidi
 = 
VALIDATION_DISABLE
,

81 cڡ 
d
::
rg
 &
schema
 = std::string());

85 
delize
();

90 
bo
 
xt
();

96 
xt
(cڡ 
d
::
rg
 &
tok
);

101 
bo
 
isEmy
();

106 
	gd
::
rg
 
ibu
(cڡ 
d
::rg &
tok
, 
ThrowTy
 
throwStus
 = 
THROW_ENABLE
);

111 
	gd
::
rg
 
me
();

116 
	gd
::
rg
 
meaURI
();

121 
	gd
::
rg
 
vue
();

126 
NodeTy
 
ty
();

132 
dumpNode
(
d
::
rg
 &
bufr
);

134 
	give
:

138 
xmlTextRdP
 
m_ad
;

	@vcore/src/vcore/SignatureData.cpp

22 
	~<vce/SigtuDa.h
>

24 
	~<d/log/log.h
>

26 
mea
 
	gVidiCe
 {

28 
	gSigtuDa
::
SigtuDa
()

29 : 
m_sigtuNumb
(-1)

30 , 
m_ifiS܋d
(
l
)

33 
	gSigtuDa
::
SigtuDa
(cڡ 
d
::
rg
 &
feName
, 
feNumb
)

34 : 
m_sigtuNumb
(
feNumb
)

35 , 
m_feName
(
feName
)

36 , 
m_ifiS܋d
(
l
)

39 
	gSigtuDa
::~
SigtuDa
()

42 cڡ 
RenS
& 
SigtuDa
::
gRenS
() const

44  
m_nS
;

47 
	gSigtuDa
::
tRen
(cڡ 
RenS
 &
nS
)

49 
m_nS
 = 
nS
;

52 
CtifiLi
 
	gSigtuDa
::
gCtLi
() const

54  
m_Li
;

57 
	gSigtuDa
::
tS܋dCtifiLi
(cڡ 
CtifiLi
 &
li
)

59 
m_Li
 = 
li
;

60 
	gm_ifiS܋d
 = 
ue
;

63 
bo
 
	gSigtuDa
::
isAuthSigtu
() const

65  
m_sigtuNumb
 == -1;

68 
	gd
::
rg
 
SigtuDa
::
gSigtuFeName
() const

70  
m_feName
;

73 
	gSigtuDa
::
gSigtuNumb
() const

75  
m_sigtuNumb
;

78 
	gd
::
rg
 
SigtuDa
::
gReURI
() const

80  
m_reURI
;

83 
	gd
::
rg
 
SigtuDa
::
gProfeURI
() const

85  
m_ofeURI
;

88 
bo
 
	gSigtuDa
::
cڏObjeRen
(cڡ 
d
::
rg
 &
f
) const

90 
d
::
rg
 
rName
 = "#";

91 
	grName
 +
f
;

92  
	gm_nS
.
d
(!
m_nS
.
fd
(
rName
);

95 
ObjeLi
 
	gSigtuDa
::
gObjeLi
() const

97  
m_objeLi
;

100 
	gSigtuDa
::
tStageTy
(cڡ 
CtSteId
::
S
 &
eIdS
)

102 
m_eIdS
 = 
eIdS
;

105 cڡ 
	gCtSteId
::
S
& 
SigtuDa
::
gStageTy
() const

107  
m_eIdS
;

110 
	gCtSteId
::
Ty
 
SigtuDa
::
gVisibyLev
() const

112 i(
m_eIdS
.
cڏs
(
CtSteId
::
VIS_PLATFORM
))

113  
CtSteId
::
VIS_PLATFORM
;

114 i(
	gm_eIdS
.
cڏs
(
CtSteId
::
VIS_PARTNER_MANUFACTURER
))

115  
CtSteId
::
VIS_PLATFORM
;

116 i(
	gm_eIdS
.
cڏs
(
CtSteId
::
VIS_PARTNER_OPERATOR
))

117  
CtSteId
::
VIS_PLATFORM
;

118 i(
	gm_eIdS
.
cڏs
(
CtSteId
::
VIS_PARTNER
))

119  
CtSteId
::
VIS_PARTNER
;

120 i(
	gm_eIdS
.
cڏs
(
CtSteId
::
VIS_PUBLIC
))

121  
CtSteId
::
VIS_PUBLIC
;

123 
LogWng
("Visibilityevel was broken.");

128 cڡ 
	gSigtuDa
::
IMEILi
& 
SigtuDa
::
gIMEILi
() const

130  
m_imeiLi
;

133 cڡ 
	gSigtuDa
::
MEIDLi
& 
SigtuDa
::
gMEIDLi
() const

135  
m_meidLi
;

138 
CtifiP
 
	gSigtuDa
::
gEndEyCtifiP
() const

140 i(
m_ifiS܋d
)

141  
m_Li
.
t
();

143  
CtifiP
();

146 
CtifiP
 
	gSigtuDa
::
gRoCaCtifiP
() const

148 i(
m_ifiS܋d
)

149  
m_Li
.
back
();

151  
CtifiP
();

	@vcore/src/vcore/SignatureData.h

22 #ide
_SIGNATUREDATA_H_


23 
	#_SIGNATUREDATA_H_


	)

25 
	~<li
>

26 
	~<t
>

27 
	~<rg
>

29 
	~<vce/Ctifi.h
>

30 
	~<vce/CtSteTy.h
>

32 
mea
 
	gVidiCe
 {

34 
	gd
::
	tt
<
	td
::
	trg
> 
	tRenS
;

35 
	gd
::
	tli
<
	td
::
	trg
> 
	tObjeLi
;

37 as
	cSigtuDa
 {

38 
	gpublic
:

39 
SigtuDa
();

40 
SigtuDa
(cڡ 
d
::
rg
 &
feName
, 
feNumb
);

42 
	gvtu
 ~
SigtuDa
();

44 
	gd
::
	tli
<
	td
::
	trg
> 
	tIMEILi
;

45 
	gd
::
	tli
<
	td
::
	trg
> 
	tMEIDLi
;

47 
tRen
(cڡ 
RenS
 &
nS
);

48 
tS܋dCtifiLi
(cڡ 
CtifiLi
 &
li
);

49 
tStageTy
(cڡ 
CtSteId
::
S
 &
eIdS
);

51 cڡ 
	gRenS
& 
gRenS
() const;

52 
CtifiLi
 
gCtLi
() const;

53 
ObjeLi
 
gObjeLi
() const;

54 
bo
 
cڏObjeRen
(cڡ 
d
::
rg
 &
f
) const;

55 
bo
 
isAuthSigtu
() const;

56 
gSigtuNumb
() const;

57 
	gd
::
rg
 
gSigtuFeName
() const;

58 
	gd
::
rg
 
gReURI
() const;

59 
	gd
::
rg
 
gProfeURI
() const;

60 cڡ 
	gCtSteId
::
S
& 
gStageTy
() const;

61 
	gCtSteId
::
Ty
 
gVisibyLev
() const;

62 cڡ 
	gIMEILi
& 
gIMEILi
() const;

63 cڡ 
	gMEIDLi
& 
gMEIDLi
() const;

64 
CtifiP
 
gEndEyCtifiP
() const;

65 
CtifiP
 
gRoCaCtifiP
() const;

67 
nd
 
ass
 
	gSigtuRd
;

69 
	give
:

70 
RenS
 
m_nS
;

71 
CtifiLi
 
	gm_Li
;

74 
IMEILi
 
	gm_imeiLi
;

75 
MEIDLi
 
	gm_meidLi
;

82 
	gm_sigtuNumb
;

83 
	gd
::
rg
 
m_feName
;

84 
	gd
::
rg
 
m_reURI
;

85 
	gd
::
rg
 
m_ofeURI
;

86 
	gd
::
rg
 
m_idtifr
;

87 
ObjeLi
 
	gm_objeLi
;

88 
	gCtSteId
::
S
 
m_eIdS
;

89 
bo
 
	gm_ifiS܋d
;

92 
	gd
::
	tt
<
	tSigtuDa
> 
	tSigtuDaS
;

	@vcore/src/vcore/SignatureFinder.cpp

22 
	~<vce/SigtuFd.h
>

23 
	~<d/log/w_log.h
>

25 
	~<dt.h
>

26 
	~<o.h
>

27 
	~<iam
>

28 
	~<sam
>

30 
	~<pep.h
>

33 
mea
 
	gVidiCe
 {

34 cڡ *
	gSIGNATURE_AUTHOR
 = "author-signature.xml";

35 cڡ *
	gREGEXP_DISTRIBUTOR_SIGNATURE
 =

38 as
	cSigtuFd
::
Im
 {

39 
public
:

40 
Im
(cڡ 
d
::
rg
& 
d
)

41 : 
m_d
(
d
)

42 , 
m_sigtuRegexp
(
REGEXP_DISTRIBUTOR_SIGNATURE
)

45 
	gvtu
 ~
Im
(){}

47 
Resu
 
fd
(
SigtuFeInfoS
 &
t
);

49 
	give
:

50 
d
::
rg
 
m_d
;

51 
	gpep
::
RE
 
m_sigtuRegexp
;

54 
	gSigtuFd
::
Resu
 
SigtuFd
::
Im
::
	$fd
(
SigtuFeInfoS
 &
t
)

56 
DIR
 *
dp
;

57 
dt
 *
dp
;

62 i((
dp
 = 
	`ݒd
(
m_d
.
	`c_r
())=
NULL
) {

63 
	`WLogE
("E ong dey: %s", 
m_d
.
	`c_r
());

64  
ERROR_OPENING_DIR
;

67 
o
 = 0; (
dp
 = 
	`add
(
dp
)!
NULL
;rrno = 0) {

71 i(!
	`rcmp
(
dp
->
d_me
, 
SIGNATURE_AUTHOR
)) {

72 
t
.
	`
(
	`SigtuFeInfo
(
d
::
	`rg
(
dp
->
d_me
), -1));

76 
d
::
rg
 
sig
, 
num
, 
xml
;

77 i(
m_sigtuRegexp
.
	`FuMch
(
dp
->
d_me
, &
sig
, &
num
, &
xml
)) {

78 
d
::
irgam
 
	`am
(
num
);

79 
numb
;

80 
am
 >> 
numb
;

82 i(
am
.
	`
()) {

83 
	`od
(
dp
);

84  
ERROR_ISTREAM
;

87 
t
.
	`
(
	`SigtuFeInfo
(
d
::
	`rg
(
dp
->
d_me
), 
numb
));

91 i(
o
 != 0) {

92 
	`WLogE
("Error ineaddir");

93 
	`od
(
dp
);

94  
ERROR_READING_DIR
;

97 
	`od
(
dp
);

98  
NO_ERROR
;

99 
	}
}

101 
	gSigtuFd
::
	$SigtuFd
(cڡ 
d
::
rg
& 
d
)

102 : 
	`m_im
(
w
 
	$Im
(
d
))

103 {
	}
}

105 
SigtuFd
::~
	$SigtuFd
()

107 
de
 
m_im
;

108 
	}
}

110 
	gSigtuFd
::
Resu
 
SigtuFd
::
	$fd
(
SigtuFeInfoS
 &
t
) {

111  
m_im
->
	`fd
(
t
);

112 
	}
}

	@vcore/src/vcore/SignatureFinder.h

24 #ide
_VALIDATION_CORE_SIGNATUREFINDER_H_


25 
	#_VALIDATION_CORE_SIGNATUREFINDER_H_


	)

27 
	~<t
>

28 
	~<rg
>

30 
mea
 
	gVidiCe
 {

32 as
	cSigtuFeInfo
 {

33 
	gpublic
:

34 
SigtuFeInfo
(cڡ 
d
::
rg
 &
feName
, 
num
)

35 : 
m_feName
(
feName
)

36 , 
m_feNumb
(
num
)

39 
	gd
::
rg
 
gFeName
() const

41  
m_feName
;

44 
gFeNumb
() const

46  
	gm_feNumb
;

49 
bo
 
	gݔ
<(cڡ 
	gSigtuFeInfo
 &
	gcd
) const

51  
	gm_feNumb
 < 
	gcd
.m_fileNumber;

54 
	give
:

55 
d
::
rg
 
m_feName
;

56 
	gm_feNumb
;

59 
	gd
::
	tt
<
	tSigtuFeInfo
> 
	tSigtuFeInfoS
;

61 as
	cSigtuFd
 {

62 
	gpublic
:

63 
	eResu


65 
NO_ERROR
,

66 
	gERROR_OPENING_DIR
,

67 
	gERROR_READING_DIR
,

68 
	gERROR_ISTREAM


71 
SigtuFd
(
de
;

72 
exic
 
SigtuFd
(cڡ 
d
::
rg
& 
d
);

74 
	gvtu
 ~
SigtuFd
();

76 
Resu
 
fd
(
SigtuFeInfoS
 &
t
);

78 
	give
:

79 
ass
 
Im
;

80 
Im
 *
	gm_im
;

82 
SigtuFd
(const SignatureFinder &);

83 cڡ 
	gSigtuFd
 &
	gݔ
=(cڡ 
SigtuFd
 &);

	@vcore/src/vcore/SignatureReader.cpp

22 
	~<vce/SigtuRd.h
>

24 
	~<vce/CtifiLd.h
>

26 
mea
 
	gVidiCe
 {

27 cڡ 
	gd
::
rg
 
XML_NAMESPACE
 =

29 cڡ 
	gd
::
rg
 
XML_NAMESPACE_DIGITALSIG
 =

31 cڡ 
	gd
::
rg
 
XML_OBJ_NS
 =

35 cڡ 
	gd
::
rg
 
TOKEN_SIGNATURE
 = "Signature";

36 cڡ 
	gd
::
rg
 
TOKEN_SIGNED_INFO
 = "SignedInfo";

37 cڡ 
	gd
::
rg
 
TOKEN_CANONICALIZATION_METHOD
 =

39 cڡ 
	gd
::
rg
 
TOKEN_SIGNATURE_METHOD
 = "SignatureMethod";

40 cڡ 
	gd
::
rg
 
TOKEN_REFERENCE
 = "Reference";

41 cڡ 
	gd
::
rg
 
TOKEN_TRANSFORMS
 = "Transforms";

42 cڡ 
	gd
::
rg
 
TOKEN_TRANSFORM
 = "Transform";

43 cڡ 
	gd
::
rg
 
TOKEN_DIGEST_METHOD
 = "DigestMethod";

44 cڡ 
	gd
::
rg
 
TOKEN_DIGEST_VALUE
 = "DigestValue";

45 cڡ 
	gd
::
rg
 
TOKEN_SIGNATURE_VALUE
 = "SignatureValue";

46 cڡ 
	gd
::
rg
 
TOKEN_KEY_INFO
 = "KeyInfo";

47 cڡ 
	gd
::
rg
 
TOKEN_X509DATA
 = "X509Data";

48 cڡ 
	gd
::
rg
 
TOKEN_X509CERTIFICATE
 = "X509Certificate";

49 cڡ 
	gd
::
rg
 
TOKEN_KEY_VALUE
 = "KeyValue";

50 cڡ 
	gd
::
rg
 
TOKEN_RSA_KEY_VALUE
 = "RSAKeyValue";

51 cڡ 
	gd
::
rg
 
TOKEN_MODULUS_COMPONENT
 = "Modulus";

52 cڡ 
	gd
::
rg
 
TOKEN_EXPONENT_COMPONENT
 = "Exponent";

53 cڡ 
	gd
::
rg
 
TOKEN_ECKEY_VALUE
 = "ECKeyValue";

54 cڡ 
	gd
::
rg
 
TOKEN_NAMED_CURVE
 = "NamedCurve";

55 cڡ 
	gd
::
rg
 
TOKEN_PUBLIC_KEY
 = "PublicKey";

56 cڡ 
	gd
::
rg
 
TOKEN_OBJECT
 = "Object";

57 cڡ 
	gd
::
rg
 
TOKEN_SIGNATURE_PROPERTIES
 = "SignatureProperties";

58 cڡ 
	gd
::
rg
 
TOKEN_SIGNATURE_PROPERTY
 = "SignatureProperty";

59 cڡ 
	gd
::
rg
 
TOKEN_PROFILE
 = "Profile";

60 cڡ 
	gd
::
rg
 
TOKEN_ROLE
 = "Role";

61 cڡ 
	gd
::
rg
 
TOKEN_IDENTIFIER
 = "Identifier";

62 cڡ 
	gd
::
rg
 
TOKEN_DSAKEYVALUE
 = "DSAKeyValue";

63 cڡ 
	gd
::
rg
 
TOKEN_DSA_P_COMPONENT
 = "P";

64 cڡ 
	gd
::
rg
 
TOKEN_DSA_Q_COMPONENT
 = "Q";

65 cڡ 
	gd
::
rg
 
TOKEN_DSA_G_COMPONENT
 = "G";

66 cڡ 
	gd
::
rg
 
TOKEN_DSA_Y_COMPONENT
 = "Y";

67 cڡ 
	gd
::
rg
 
TOKEN_DSA_J_COMPONENT
 = "J";

68 cڡ 
	gd
::
rg
 
TOKEN_DSA_SEED_COMPONENT
 = "Seed";

69 cڡ 
	gd
::
rg
 
TOKEN_DSA_PGENCOUNTER_COMPONENT
 = "PgenCounter";

70 cڡ 
	gd
::
rg
 
TOKEN_TARGET_RESTRICTION
 = "TargetRestriction";

74 cڡ 
	gd
::
rg
 
TOKEN_ALGORITHM
 = "Algorithm";

75 cڡ 
	gd
::
rg
 
TOKEN_URI
 = "URI";

76 cڡ 
	gd
::
rg
 
TOKEN_ID
 = "Id";

77 cڡ 
	gd
::
rg
 
TOKEN_TARGET
 = "Target";

78 cڡ 
	gd
::
rg
 
TOKEN_IMEI
 = "IMEI";

79 cڡ 
	gd
::
rg
 
TOKEN_MEID
 = "MEID";

83 cڡ 
	gd
::
rg
 
TOKEN_ATTR_PROFILE
 = "profile";

84 cڡ 
	gd
::
rg
 
TOKEN_ATTR_ROLE
 = "role";

85 cڡ 
	gd
::
rg
 
TOKEN_ATTR_IDENTIFIER
 = "identifier";

106 
	gSigtuRd
::
SigtuRd
() :

107 
m_sigtuPrݔtsCou
(0),

108 
m_rgReriiObjeFound
(
l
),

109 
m_rrSchema
(
this
)

114 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_SIGNATURE
,

115 
XML_NAMESPACE
,

116 &
SigtuRd
::
bnkFuni
);

117 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_SIGNED_INFO
,

118 
XML_NAMESPACE
,

119 &
SigtuRd
::
bnkFuni
);

120 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_CANONICALIZATION_METHOD
,

121 
XML_NAMESPACE
,

122 &
SigtuRd
::
bnkFuni
);

123 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_SIGNATURE_METHOD
,

124 
XML_NAMESPACE
,

125 &
SigtuRd
::
bnkFuni
);

126 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_REFERENCE
,

127 
XML_NAMESPACE
,

128 &
SigtuRd
::
bnkFuni
);

129 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_TRANSFORMS
,

130 
XML_NAMESPACE
,

131 &
SigtuRd
::
bnkFuni
);

132 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_TRANSFORM
,

133 
XML_NAMESPACE
,

134 &
SigtuRd
::
bnkFuni
);

135 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DIGEST_METHOD
,

136 
XML_NAMESPACE
,

137 &
SigtuRd
::
bnkFuni
);

138 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DIGEST_VALUE
,

139 
XML_NAMESPACE
,

140 &
SigtuRd
::
bnkFuni
);

141 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_SIGNATURE_VALUE
,

142 
XML_NAMESPACE
,

143 &
SigtuRd
::
bnkFuni
);

144 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_KEY_INFO
,

145 
XML_NAMESPACE
,

146 &
SigtuRd
::
tokKeyInfo
);

147 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_X509DATA
,

148 
XML_NAMESPACE
,

149 &
SigtuRd
::
tokX509Da
);

150 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_X509CERTIFICATE
,

151 
XML_NAMESPACE
,

152 &
SigtuRd
::
tokX509Ctifi
);

153 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_ECKEY_VALUE
,

154 
XML_NAMESPACE
,

155 &
SigtuRd
::
bnkFuni
);

156 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_NAMED_CURVE
,

157 
XML_NAMESPACE
,

158 &
SigtuRd
::
tokNamedCurve
);

159 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_PUBLIC_KEY
,

160 
XML_NAMESPACE
,

161 &
SigtuRd
::
tokPublicKey
);

162 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_OBJECT
,

163 
XML_NAMESPACE
,

164 &
SigtuRd
::
tokObje
);

165 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_SIGNATURE_PROPERTIES
,

166 
XML_NAMESPACE
,

167 &
SigtuRd
::
tokSigtuPrݔts
);

168 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_SIGNATURE_PROPERTY
,

169 
XML_NAMESPACE
,

170 &
SigtuRd
::
bnkFuni
);

171 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_PROFILE
,

172 
XML_OBJ_NS
,

173 &
SigtuRd
::
tokProfe
);

174 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_ROLE
,

175 
XML_OBJ_NS
,

176 &
SigtuRd
::
tokRe
);

177 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_IDENTIFIER
,

178 
XML_OBJ_NS
,

179 &
SigtuRd
::
bnkFuni
);

180 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_KEY_VALUE
,

181 
XML_NAMESPACE
,

182 &
SigtuRd
::
bnkFuni
);

183 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DSAKEYVALUE
,

184 
XML_NAMESPACE
,

185 &
SigtuRd
::
bnkFuni
);

186 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DSA_P_COMPONENT
,

187 
XML_NAMESPACE
,

188 &
SigtuRd
::
bnkFuni
);

189 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DSA_Q_COMPONENT
,

190 
XML_NAMESPACE
,

191 &
SigtuRd
::
bnkFuni
);

192 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DSA_G_COMPONENT
,

193 
XML_NAMESPACE
,

194 &
SigtuRd
::
bnkFuni
);

195 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DSA_Y_COMPONENT
,

196 
XML_NAMESPACE
,

197 &
SigtuRd
::
bnkFuni
);

198 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DSA_J_COMPONENT
,

199 
XML_NAMESPACE
,

200 &
SigtuRd
::
bnkFuni
);

201 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DSA_SEED_COMPONENT
,

202 
XML_NAMESPACE
,

203 &
SigtuRd
::
bnkFuni
);

204 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_DSA_PGENCOUNTER_COMPONENT
,

205 
XML_NAMESPACE
,

206 &
SigtuRd
::
bnkFuni
);

207 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_RSA_KEY_VALUE
,

208 
XML_NAMESPACE
,

209 &
SigtuRd
::
bnkFuni
);

210 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_MODULUS_COMPONENT
,

211 
XML_NAMESPACE
,

212 &
SigtuRd
::
bnkFuni
);

213 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_EXPONENT_COMPONENT
,

214 
XML_NAMESPACE
,

215 &
SigtuRd
::
bnkFuni
);

216 
	gm_rrSchema
.
addBegTagClback
(
TOKEN_TARGET_RESTRICTION
,

217 
XML_NAMESPACE_DIGITALSIG
,

218 &
SigtuRd
::
tokTgRerii
);

220 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_SIGNATURE
,

221 
XML_NAMESPACE
,

222 &
SigtuRd
::
bnkFuni
);

223 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_SIGNED_INFO
,

224 
XML_NAMESPACE
,

225 &
SigtuRd
::
bnkFuni
);

226 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_CANONICALIZATION_METHOD
,

227 
XML_NAMESPACE
,

228 &
SigtuRd
::
bnkFuni
);

229 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_SIGNATURE_METHOD
,

230 
XML_NAMESPACE
,

231 &
SigtuRd
::
bnkFuni
);

232 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_REFERENCE
,

233 
XML_NAMESPACE
,

234 &
SigtuRd
::
bnkFuni
);

235 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_TRANSFORMS
,

236 
XML_NAMESPACE
,

237 &
SigtuRd
::
bnkFuni
);

238 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_TRANSFORM
,

239 
XML_NAMESPACE
,

240 &
SigtuRd
::
bnkFuni
);

241 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DIGEST_METHOD
,

242 
XML_NAMESPACE
,

243 &
SigtuRd
::
bnkFuni
);

244 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DIGEST_VALUE
,

245 
XML_NAMESPACE
,

246 &
SigtuRd
::
bnkFuni
);

247 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_SIGNATURE_VALUE
,

248 
XML_NAMESPACE
,

249 &
SigtuRd
::
bnkFuni
);

250 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_KEY_INFO
,

251 
XML_NAMESPACE
,

252 &
SigtuRd
::
tokEndKeyInfo
);

253 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_X509DATA
,

254 
XML_NAMESPACE
,

255 &
SigtuRd
::
tokEndX509Da
);

256 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_X509CERTIFICATE
,

257 
XML_NAMESPACE
,

258 &
SigtuRd
::
tokEndX509Ctifi
);

259 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_ECKEY_VALUE
,

260 
XML_NAMESPACE
,

261 &
SigtuRd
::
tokEndECKeyVue
);

262 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_PUBLIC_KEY
,

263 
XML_NAMESPACE
,

264 &
SigtuRd
::
tokEndPublicKey
);

265 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_OBJECT
,

266 
XML_NAMESPACE
,

267 &
SigtuRd
::
tokEndObje
);

268 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_SIGNATURE_PROPERTIES
,

269 
XML_NAMESPACE
,

270 &
SigtuRd
::
bnkFuni
);

271 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_SIGNATURE_PROPERTY
,

272 
XML_NAMESPACE
,

273 &
SigtuRd
::
bnkFuni
);

274 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_PROFILE
,

275 
XML_OBJ_NS
,

276 &
SigtuRd
::
bnkFuni
);

277 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_ROLE
,

278 
XML_OBJ_NS
,

279 &
SigtuRd
::
bnkFuni
);

280 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_IDENTIFIER
,

281 
XML_OBJ_NS
,

282 &
SigtuRd
::
tokEndIdtifr
);

283 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_KEY_VALUE
,

284 
XML_NAMESPACE
,

285 &
SigtuRd
::
bnkFuni
);

286 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DSAKEYVALUE
,

287 
XML_NAMESPACE
,

288 &
SigtuRd
::
tokEndDSAKeyVue
);

289 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DSA_P_COMPONENT
,

290 
XML_NAMESPACE
,

291 &
SigtuRd
::
tokEndDSAPCompڒt
);

292 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DSA_Q_COMPONENT
,

293 
XML_NAMESPACE
,

294 &
SigtuRd
::
tokEndDSAQCompڒt
);

295 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DSA_G_COMPONENT
,

296 
XML_NAMESPACE
,

297 &
SigtuRd
::
tokEndDSAGCompڒt
);

298 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DSA_Y_COMPONENT
,

299 
XML_NAMESPACE
,

300 &
SigtuRd
::
tokEndDSAYCompڒt
);

301 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DSA_J_COMPONENT
,

302 
XML_NAMESPACE
,

303 &
SigtuRd
::
tokEndDSAJCompڒt
);

304 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DSA_SEED_COMPONENT
,

305 
XML_NAMESPACE
,

306 &
SigtuRd
::
tokEndDSASdCompڒt
);

307 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_DSA_PGENCOUNTER_COMPONENT
,

308 
XML_NAMESPACE
,

309 &
SigtuRd
::
tokEndDSAPGCouCompڒt
);

310 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_RSA_KEY_VALUE
,

311 
XML_NAMESPACE
,

312 &
SigtuRd
::
tokEndRSAKeyVue
);

313 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_MODULUS_COMPONENT
,

314 
XML_NAMESPACE
,

315 &
SigtuRd
::
tokEndKeyModulus
);

316 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_EXPONENT_COMPONENT
,

317 
XML_NAMESPACE
,

318 &
SigtuRd
::
tokEndKeyExpڒt
);

319 
	gm_rrSchema
.
addEndTagClback
(
TOKEN_TARGET_RESTRICTION
,

320 
XML_NAMESPACE
,

321 &
SigtuRd
::
bnkFuni
);

325 
	gSigtuRd
::
lize
(

326 
SigtuDa
 &
sigtuDa
,

327 cڡ 
d
::
rg
 &
xmlscheme
)

329 
m_rrSchema
.
lize
(

330 
sigtuDa
.
gSigtuFeName
(),

331 
ue
,

332 
SaxRd
::
VALIDATION_XMLSCHEME
,

333 
xmlscheme
);

336 
	gSigtuRd
::
ad
(
SigtuDa
 &
sigtuDa
)

338 
m_rrSchema
.
ad
(
sigtuDa
);

341 
	gSigtuRd
::
bnkFuni
(
SigtuDa
 &)

345 
SigtuRd
::
tokKeyInfo
(
SigtuDa
 &)

349 
SigtuRd
::
tokX509Da
(
SigtuDa
 &)

353 
SigtuRd
::
tokX509Ctifi
(
SigtuDa
 &)

357 
SigtuRd
::
tokPublicKey
(
SigtuDa
 &)

361 
SigtuRd
::
tokNamedCurve
(
SigtuDa
 &)

363 
m_meCurveURI
 = 
m_rrSchema
.
gRd
().
ibu
(
TOKEN_URI
);

366 
	gSigtuRd
::
tokTgRerii
(
SigtuDa
 &
sigtuDa
)

368 
d
::
rg
 
IMEI
 = 
m_rrSchema
.
gRd
().
ibu
(
TOKEN_IMEI
);

369 
	gd
::
rg
 
MEID
 = 
m_rrSchema
.
gRd
().
ibu
(
TOKEN_MEID
);

372 i(
	gIMEI
.
emy
(=
MEID
.empty()) {

374 
VceThrowMsg
(
SigtuRd
::
Exi
::
TgRerii
,

378 i(!
	gIMEI
.
emy
()) {

379 
	gsigtuDa
.
	gm_imeiLi
.
push_back
(
IMEI
);

381 i(!
	gMEID
.
emy
()) {

382 
	gsigtuDa
.
	gm_meidLi
.
push_back
(
MEID
);

386 
	gSigtuRd
::
tokEndKeyInfo
(
SigtuDa
 &)

390 
SigtuRd
::
tokEndX509Da
(
SigtuDa
 &)

394 
SigtuRd
::
tokEndX509Ctifi
(
SigtuDa
 &
sigtuDa
)

396 
CtifiLd
 
ld
;

397 i(
	gCtifiLd
::
NO_ERROR
 !=

398 
ld
.
ldCtifiFromRawDa
(
m_rrSchema
.
gText
())) {

399 
rtf
(
dr
, "## [validaterror]: Certificate couldot beoaded\n");

400 
VceThrowMsg
(
PrSchemaExi
::
CtifiLdE
,

403 
	gsigtuDa
.
	gm_Li
.
push_back
(
ld
.
gCtifiP
());

406 
	gSigtuRd
::
tokEndRSAKeyVue
(
SigtuDa
 &
sigtuDa
)

408 
CtifiLd
 
ld
;

409 i(
	gCtifiLd
::
NO_ERROR
 !=

410 
ld
.
ldCtifiBadOnExpڒtAndModulus
(
m_modulus
,

411 
m_expڒt
)) {

412 
rtf
(
dr
, "## [validaterror]: Certificate couldot beoaded\n");

413 
VceThrowMsg
(
PrSchemaExi
::
CtifiLdE
,

416 
	gsigtuDa
.
	gm_Li
.
push_back
(
ld
.
gCtifiP
());

419 
	gSigtuRd
::
tokEndKeyModulus
(
SigtuDa
 &)

421 
m_modulus
 = 
m_rrSchema
.
gText
();

424 
	gSigtuRd
::
tokEndKeyExpڒt
(
SigtuDa
 &)

426 
m_expڒt
 = 
m_rrSchema
.
gText
();

429 
	gSigtuRd
::
tokEndPublicKey
(
SigtuDa
 &)

431 
m_publicKey
 = 
m_rrSchema
.
gText
();

434 
	gSigtuRd
::
tokEndECKeyVue
(
SigtuDa
 &
sigtuDa
)

436 
CtifiLd
 
ld
;

437 i(
	gCtifiLd
::
NO_ERROR
 !=

438 
ld
.
ldCtifiWhECKEY
(
m_meCurveURI
, 
m_publicKey
)) {

439 
rtf
(
dr
, "## [validaterror]: Certificate couldot beoaded\n");

440 
VceThrowMsg
(
PrSchemaExi
::
CtifiLdE
,

443 
	gsigtuDa
.
	gm_Li
.
push_back
(
ld
.
gCtifiP
());

446 
	gSigtuRd
::
tokEndObje
(
SigtuDa
 &
sigtuDa
)

448 
m_sigtuPrݔtsCou
 = 0;

450 i(((!
	gsigtuDa
.
	gm_imeiLi
.
emy
()) ||

451 (!
	gsigtuDa
.
	gm_meidLi
.
emy
())) &&

452 
	gm_rgReriiObjeFound
) {

454 
VceThrowMsg
(
SigtuRd
::
Exi
::
TgRerii
,

459 i((!
	gsigtuDa
.
	gm_imeiLi
.
emy
()) ||

460 (!
	gsigtuDa
.
	gm_meidLi
.
emy
())) {

461 
	gm_rgReriiObjeFound
 = 
ue
;

465 
	gSigtuRd
::
tokEndDSAPCompڒt
(
SigtuDa
 &)

467 
m_dKeyPCompڒt
 = 
m_rrSchema
.
gText
();

470 
	gSigtuRd
::
tokEndDSAQCompڒt
(
SigtuDa
 &)

472 
m_dKeyQCompڒt
 = 
m_rrSchema
.
gText
();

475 
	gSigtuRd
::
tokEndDSAGCompڒt
(
SigtuDa
 &)

477 
m_dKeyGCompڒt
 = 
m_rrSchema
.
gText
();

480 
	gSigtuRd
::
tokEndDSAYCompڒt
(
SigtuDa
 &)

482 
m_dKeyYCompڒt
 = 
m_rrSchema
.
gText
();

485 
	gSigtuRd
::
tokEndDSAJCompڒt
(
SigtuDa
 &)

487 
m_dKeyJCompڒt
 = 
m_rrSchema
.
gText
();

490 
	gSigtuRd
::
tokEndDSASdCompڒt
(
SigtuDa
 &)

492 
m_dKeySdCompڒt
 = 
m_rrSchema
.
gText
();

495 
	gSigtuRd
::
tokEndDSAPGCouCompڒt
(
SigtuDa
 &)

497 
m_dKeyPGCou
 = 
m_rrSchema
.
gText
();

500 
	gSigtuRd
::
tokEndDSAKeyVue
(
SigtuDa
 &
sigtuDa
)

502 
CtifiLd
 
ld
;

504 i(
	gCtifiLd
::
NO_ERROR
 !=

505 
ld
.
ldCtifiBadOnDSACompڒts
(
m_dKeyPCompڒt
,

506 
m_dKeyQCompڒt
,

507 
m_dKeyGCompڒt
,

508 
m_dKeyYCompڒt
,

509 
m_dKeyJCompڒt
,

510 
m_dKeySdCompڒt
,

511 
m_dKeyPGCou
)) {

512 
rtf
(
dr
, "## [validaterror]: Certificate couldot beoaded\n");

513 
VceThrowMsg
(
PrSchemaExi
::
CtifiLdE
,

516 
	gsigtuDa
.
	gm_Li
.
push_back
(
ld
.
gCtifiP
());

519 
	gSigtuRd
::
tokRe
(
SigtuDa
 &
sigtuDa
)

521 i(!
sigtuDa
.
m_reURI
.
emy
()) {

522 
rtf
(
dr
, "## [validaterror]: Multiple definition of Role isotllowed\n");

523 
VceThrowMsg
(
PrSchemaExi
::
Unsu܋dVue
,

526 
	gsigtuDa
.
	gm_reURI
 = 
m_rrSchema
.
gRd
().
ibu
(
TOKEN_URI
);

529 
	gSigtuRd
::
tokProfe
(
SigtuDa
 &
sigtuDa
)

531 i(!
sigtuDa
.
m_ofeURI
.
emy
()) {

532 
rtf
(
dr
, "## [validaterror]: Multiple definition of Profile isotllowed\n");

533 
VceThrowMsg
(
PrSchemaExi
::
Unsu܋dVue
,

536 
	gsigtuDa
.
	gm_ofeURI
 = 
m_rrSchema
.
gRd
().
ibu
(
TOKEN_URI
);

539 
	gSigtuRd
::
tokEndIdtifr
(
SigtuDa
 &
sigtuDa
)

541 i(!
sigtuDa
.
m_idtifr
.
emy
()) {

542 
rtf
(
dr
, "## [validaterror]: Multiple definition of Identifier isotllowed\n");

543 
VceThrowMsg
(
PrSchemaExi
::
Unsu܋dVue
,

546 
	gsigtuDa
.
	gm_idtifr
 = 
m_rrSchema
.
gText
();

549 
	gSigtuRd
::
tokObje
(
SigtuDa
 &
sigtuDa
)

551 
d
::
rg
 
id
 = 
m_rrSchema
.
gRd
().
ibu
(
TOKEN_ID
);

553 i(
	gid
.
emy
()) {

554 
rtf
(
dr
, "## [validaterror]: Unsupported value of Attribute Id in Objectag\n");

555 
VceThrowMsg
(
PrSchemaExi
::
Unsu܋dVue
,

559 
	gsigtuDa
.
	gm_objeLi
.
push_back
(
id
);

562 
	gSigtuRd
::
tokSigtuPrݔts
(
SigtuDa
 &)

564 i(++
m_sigtuPrݔtsCou
 > 1) {

565 
rtf
(
dr
, "## [validaterror]: Only one SignaturePropertiesag isllowed in Object\n");

566 
VceThrowMsg
(
PrSchemaExi
::
Unsu܋dVue
,

	@vcore/src/vcore/SignatureReader.h

22 #ide
_VALIDATION_CORE_SIGNATUREREADER_H_


23 
	#_VALIDATION_CORE_SIGNATUREREADER_H_


	)

25 
	~<vce/SigtuDa.h
>

26 
	~<vce/PrSchema.h
>

27 
	~<vce/exi.h
>

29 
	~<m
>

31 
mea
 
	gVidiCe
 {

33 as
	cSigtuRd
 {

34 
	gpublic
:

35 as
	cExi
 {

36 
public
:

37 
VCORE_DECLARE_EXCEPTION_TYPE
(
VidiCe
::
Exi
, 
Ba
);

38 
VCORE_DECLARE_EXCEPTION_TYPE
(
Ba
, 
TgRerii
);

41 
SigtuRd
();

43 
lize
(
SigtuDa
 &
sigtuDa
, cڡ 
d
::
rg
 &
xmlscheme
);

45 
ad
(
SigtuDa
 &
sigtuDa
);

47 
	give
:

48 
bnkFuni
(
SigtuDa
 &
sigtuDa
);

50 
tokKeyInfo
(
SigtuDa
 &
sigtuDa
);

51 
tokKeyModulus
(
SigtuDa
 &
sigtuDa
);

52 
tokKeyExpڒt
(
SigtuDa
 &
sigtuDa
);

53 
tokX509Da
(
SigtuDa
 &
sigtuDa
);

54 
tokX509Ctifi
(
SigtuDa
 &
sigtuDa
);

55 
tokPublicKey
(
SigtuDa
 &
sigtuDa
);

56 
tokNamedCurve
(
SigtuDa
 &
sigtuDa
);

57 
tokRe
(
SigtuDa
 &
sigtuDa
);

58 
tokProfe
(
SigtuDa
 &
sigtuDa
);

59 
tokObje
(
SigtuDa
 &
sigtuDa
);

60 
tokSigtuPrݔts
(
SigtuDa
 &
sigtuDa
);

62 
tokTgRerii
(
SigtuDa
 &
sigtuDa
);

64 
tokEndKeyInfo
(
SigtuDa
 &
sigtuDa
);

67 
tokEndRSAKeyVue
(
SigtuDa
 &
sigtuDa
);

69 
tokEndKeyModulus
(
SigtuDa
 &
sigtuDa
);

70 
tokEndKeyExpڒt
(
SigtuDa
 &
sigtuDa
);

71 
tokEndX509Da
(
SigtuDa
 &
sigtuDa
);

73 
tokEndX509Ctifi
(
SigtuDa
 &
sigtuDa
);

75 
tokEndPublicKey
(
SigtuDa
 &
sigtuDa
);

76 
tokEndECKeyVue
(
SigtuDa
 &
sigtuDa
);

77 
tokEndIdtifr
(
SigtuDa
 &
sigtuDa
);

78 
tokEndObje
(
SigtuDa
 &
sigtuDa
);

81 
tokEndDSAPCompڒt
(
SigtuDa
& 
sigtuDa
);

82 
tokEndDSAQCompڒt
(
SigtuDa
& 
sigtuDa
);

83 
tokEndDSAGCompڒt
(
SigtuDa
& 
sigtuDa
);

84 
tokEndDSAYCompڒt
(
SigtuDa
& 
sigtuDa
);

85 
tokEndDSAJCompڒt
(
SigtuDa
& 
sigtuDa
);

87 
tokEndDSAKeyVue
(
SigtuDa
& 
sigtuDa
);

89 
tokEndDSASdCompڒt
(
SigtuDa
& 
sigtuDa
);

90 
tokEndDSAPGCouCompڒt
(
SigtuDa
& 
sigtuDa
);

94 
	gd
::
rg
 
m_dKeyPCompڒt
;

95 
	gd
::
rg
 
m_dKeyQCompڒt
;

96 
	gd
::
rg
 
m_dKeyGCompڒt
;

97 
	gd
::
rg
 
m_dKeyYCompڒt
;

98 
	gd
::
rg
 
m_dKeyJCompڒt
;

99 
	gd
::
rg
 
m_dKeySdCompڒt
;

100 
	gd
::
rg
 
m_dKeyPGCou
;

102 
	gd
::
rg
 
m_publicKey
;

103 
	gd
::
rg
 
m_meCurveURI
;

104 
	gd
::
rg
 
m_modulus
;

105 
	gd
::
rg
 
m_expڒt
;

108 
	gm_sigtuPrݔtsCou
;

109 
bo
 
	gm_rgReriiObjeFound
;

111 
	gPrSchema
<
	gSigtuRd
, 
	gSigtuDa
> 
	gm_rrSchema
;

	@vcore/src/vcore/SignatureValidator.cpp

22 
	~<vce/SigtuVid.h
>

23 
	~<vce/CtifiCi.h
>

24 
	~<vce/Ctifi.h
>

25 
	~<vce/OCSPCtMgrUt.h
>

26 
	~<vce/RenVid.h
>

27 
	~<vce/VidFaܛs.h
>

28 
	~<vce/XmlcAdr.h
>

29 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


30 
	~<vce/CtifiVifr.h
>

33 
	~<d/log/w_log.h
>

35 
	gmea
 {

36 cڡ 
time_t
 
	gTIMET_DAY
 = 60 * 60 * 24;

38 cڡ 
	gd
::
rg
 
TOKEN_ROLE_AUTHOR_URI
 =

40 cڡ 
	gd
::
rg
 
TOKEN_ROLE_DISTRIBUTOR_URI
 =

42 cڡ 
	gd
::
rg
 
TOKEN_PROFILE_URI
 =

48 
tm
 
	$_ASN1_GTimeT
(
ASN1_TIME
* 
time
)

50 
tm
 
t
;

51 cڡ * 
r
 = (cڡ *
time
->
da
;

52 
size_t
 
i
 = 0;

54 
	`memt
(&
t
, 0, (t));

56 i(
time
->
ty
 =
V_ASN1_UTCTIME
)

58 
t
.
tm_yr
 = (
r
[
i
] - '0') * 10 + (str[i+1] - '0');

59 
i
 += 2;

60 i(
t
.
tm_yr
 < 70)

61 
t
.
tm_yr
 += 100;

63 i(
time
->
ty
 =
V_ASN1_GENERALIZEDTIME
)

65 
t
.
tm_yr
 =

66 (
r
[
i
] - '0') * 1000

67 + (
r
[
i
+1] - '0') * 100

68 + (
r
[
i
+2] - '0') * 10

69 + (
r
[
i
+3] - '0');

70 
i
 += 4;

71 
t
.
tm_yr
 -= 1900;

73 
t
.
tm_m
 = ((
r
[
i
] - '0') * 10 + (str[i+1] - '0')) - 1;

74 
t
.
tm_mday
 = (
r
[
i
+2] - '0') * 10 + (str[i+3] - '0');

75 
t
.
tm_hour
 = (
r
[
i
+4] - '0') * 10 + (str[i+5] - '0');

76 
t
.
tm_m
 = (
r
[
i
+6] - '0') * 10 + (str[i+7] - '0');

77 
t
.
tm_c
 = (
r
[
i
+8] - '0') * 10 + (str[i+9] - '0');

80  
t
;

81 
	}
}

84 
mea
 
	gVidiCe
 {

86 as
	cSigtuVid
::
ImSigtuVid
 {

87 
public
:

88 
vtu
 
SigtuVid
::
Resu
 
check
(

89 
SigtuDa
 &
da
,

90 cڡ 
d
::
rg
 &
widgCڋPh
) = 0;

92 
vtu
 
	gSigtuVid
::
Resu
 
checkLi
(

93 
SigtuDa
 &
da
,

94 cڡ 
d
::
rg
 &
widgCڋPh
,

95 cڡ 
d
::
li
<d::
rg
>& 
uriLi
) = 0;

97 
exic
 
ImSigtuVid
(
bo
 
ocEb
,

98 
bo
 
lEb
,

99 
bo
 
comnMode
)

100 : 
m_comnModeEbd
(
comnMode
)

102 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


103 
m_ocEb
 = 
ocEb
;

104 
	gm_lEb
 = 
lEb
;

106 (
	gocEb
;

107 (
	glEb
;

111 
	gvtu
 ~
ImSigtuVid
(){ }

113 
bo
 
checkReURI
(cڡ 
SigtuDa
 &
da
) {

114 
	gd
::
rg
 
reURI
 = 
da
.
gReURI
();

116 i(
	greURI
.
emy
()) {

117 
WLogW
("URIttribute in Roleag couldn't bempty.");

118  
	gl
;

121 i(
	greURI
 !
TOKEN_ROLE_AUTHOR_URI
 && 
da
.
isAuthSigtu
()) {

122 
WLogW
("URIttribute in Roleag doesot "

124  
	gl
;

127 i(
	greURI
 !
TOKEN_ROLE_DISTRIBUTOR_URI
 && !
da
.
isAuthSigtu
()) {

128 
WLogW
("URIttribute in Roleag doesot "

130  
	gl
;

132  
	gue
;

135 
bo
 
checkProfeURI
(cڡ 
SigtuDa
 &
da
) {

136 i(
	gTOKEN_PROFILE_URI
 !
da
.
gProfeURI
()) {

137 
WLogW
(

138 "Profg cڏunsu܋d vu URIribu%).", (
da
.
gProfeURI
()).
c_r
());

139  
	gl
;

141  
	gue
;

144 
bo
 
checkObjeRens
(cڡ 
SigtuDa
 &
da
) {

145 
ObjeLi
 
	gobjeLi
 = 
da
.
gObjeLi
();

146 
	gObjeLi
::
cڡ_
 

;

147 
	g
 = 
objeLi
.
beg
(); i!objeLi.
d
(); ++iter) {

148 i(!
	gda
.
cڏObjeRen
(*

)) {

149 
WLogW
("Sigtu d۠n cڏen f obje %s", (*

).
c_r
());

150  
	gl
;

153  
	gue
;

155 
	geed
:

156 
bo
 
m_comnModeEbd
;

157 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


158 
bo
 
	gm_ocEb
;

159 
bo
 
	gm_lEb
;

163 as
	cImTizSigtuVid
 : 
public
 
SigtuVid
::
ImSigtuVid


165 
public
:

166 
SigtuVid
::
Resu
 
check
(
SigtuDa
 &
da
,

167 cڡ 
d
::
rg
 &
widgCڋPh
);

169 
	gSigtuVid
::
Resu
 
checkLi
(
SigtuDa
 &
da
,

170 cڡ 
d
::
rg
 &
widgCڋPh
,

171 cڡ 
d
::
li
<d::
rg
>& 
uriLi
);

172 
exic
 
ImTizSigtuVid
(
bo
 
ocEb
,

173 
bo
 
lEb
,

174 
bo
 
comnMode
)

175 : 
ImSigtuVid
(
ocEb
, 
lEb
, 
comnMode
)

178 
	gvtu
 ~
ImTizSigtuVid
() {}

181 
	gSigtuVid
::
Resu
 
ImTizSigtuVid
::
	$check
(

182 
SigtuDa
 &
da
,

183 cڡ 
d
::
rg
 &
widgCڋPh
)

185 
bo
 
diegd
 = 
l
;

187 i(!
	`checkReURI
(
da
)) {

188  
SigtuVid
::
SIGNATURE_INVALID
;

191 i(!
	`checkProfeURI
(
da
)) {

192  
SigtuVid
::
SIGNATURE_INVALID
;

197 
CtifiCi
 
ci
;

198 
ci
.
	`ld
(
da
.
	`gCtLi
());

201 i(!
ci
.
	`st
()) {

202 
	`WLogW
("Certificates doot form valid chain.");

203  
SigtuVid
::
SIGNATURE_INVALID_CERT_CHAIN
;

207 i(
ci
.
	`emy
()) {

208 
	`WLogW
("Certificateist in signature ismpty.");

209  
SigtuVid
::
SIGNATURE_INVALID_CERT_CHAIN
;

212 
CtifiLi
 
s܋dCtifiLi
 = 
ci
.
	`gCha
();

216 
s܋dCtifiLi
 =

217 
OCSPCtMgrUt
::
	`comeCtifiCha
(
s܋dCtifiLi
);

219 
CtifiP
 
ro
 = 
s܋dCtifiLi
.
	`back
();

222 
CtSteId
::
S
 
eIdS
 = 
	`CtifiIdtifr
().
	`fd
(
ro
);

224 
	`WLogD
("Iro ctifi from TIZEN_DEVELOPER doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
));

225 
	`WLogD
("Iro ctifi from TIZEN_TEST doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_TEST
));

226 
	`WLogD
("Iro ctifi from TIZEN_VERIFY doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_VERIFY
));

227 
	`WLogD
("Iro ctifi from TIZEN_STORE doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_STORE
));

228 
	`WLogD
("Iro ctifi from TIZEN_PUBLIC doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
));

229 
	`WLogD
("Iro ctifi from TIZEN_PARTNER doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PARTNER
));

230 
	`WLogD
("Iro ctifi from TIZEN_PLATFORM doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PLATFORM
));

232 
	`WLogD
("Visibyev ipubli: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
));

233 
	`WLogD
("Visibyev iø: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PARTNER
));

234 
	`WLogD
("Visibyev ifm : %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PLATFORM
));

236 i(
da
.
	`isAuthSigtu
())

238 i(!
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
))

240 
	`WLogW
("author-signature.xml has got unrecognized Root CA "

242 
diegd
 = 
ue
;

247 
	`WLogD
("sigtufm%s", 
da
.
	`gSigtuFeName
().
	`c_r
());

248 i(
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
))

250 
	`WLogE
("distributor hasuthorevel siganture! Signature will be disregarded.");

251  
SigtuVid
::
SIGNATURE_IN_DISTRIBUTOR_CASE_AUTHOR_CERT
;

255 i(
da
.
	`gSigtuNumb
() == 1)

257 i(
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
|| steIdS.cڏs(CtSteId::
VIS_PARTNER
|| steIdS.cڏs(CtSteId::
VIS_PLATFORM
))

259 
	`WLogD
("Root CA for signature1.xml is correct.");

263 
	`WLogW
("signature1.xml has got unrecognized Root CA "

265 
diegd
 = 
ue
;

270 
da
.
	`tStageTy
(
eIdS
);

271 
da
.
	`tS܋dCtifiLi
(
s܋dCtifiLi
);

275 
XmlSec
::
XmlSecCڋxt
 
cڋxt
;

276 
cڋxt
.
sigtuFe
 = 
da
.
	`gSigtuFeName
();

277 
cڋxt
.
ifiP
 = 
ro
;

282 i(!(
ro
->
	`isSigdBy
(root))) {

283 
	`WLogW
("Root CA certificateot found. Chain is incomplete.");

287 
time_t
 
nowTime
 = 
	`time
(
NULL
);

289 
	#CHECK_TIME


	)

290 #ifde
CHECK_TIME


292 
ASN1_TIME
* 
nATime
 = 
da
.
	`gEndEyCtifiP
()->
	`gNATime
();

293 
ASN1_TIME
* 
nBefeTime
 = 
da
.
	`gEndEyCtifiP
()->
	`gNBefeTime
();

295 i(
	`X509_cmp_time
(
nBefeTime
, &
nowTime
> 0 || X509_cmp_time(
nATime
, &nowTime) < 0)

297 
tm
 *
t
;

298 
tm
 

, 
tb
, 
tc
;

299 
msg
[1024];

301 
t
 = 
	`loime
(&
nowTime
);

302 i(!
t
)

303  
SigtuVid
::
SIGNATURE_INVALID_CERT_TIME
;

305 
	`memt
(&
tc
, 0, (tc));

307 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
t
->
tm_yr
 + 1900,->
tm_m
 + 1,t->
tm_mday
 );

308 
	`WLogD
("## Syem'cutTim: %s", 
msg
);

309 
	`rtf
(
dr
, "## Syem'cutTim: %s\n", 
msg
);

311 
tb
 = 
	`_ASN1_GTimeT
(
nBefeTime
);

312 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tb
.
tm_yr
 + 1900,b.
tm_m
 + 1,tb.
tm_mday
 );

313 
	`WLogD
("## ctifi'nBefeTim: %s", 
msg
);

314 
	`rtf
(
dr
, "## ctifi'nBefeTim: %s\n", 
msg
);

316 

 = 
	`_ASN1_GTimeT
(
nATime
);

317 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 

.
tm_yr
 + 1900,a.
tm_m
 + 1,.
tm_mday
 );

318 
	`WLogD
("## ctifi'nATim: %s", 
msg
);

319 
	`rtf
(
dr
, "## ctifi'nATim: %s\n", 
msg
);

321 i(
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_TEST
|| steIdS.cڏs(CtSteId::
TIZEN_VERIFY
))

323 
	`WLogD
("## TIZEN_VERIFY : check certificate Time : FALSE");

324 
	`rtf
(
dr
, "## TIZEN_VERIFY : check certificate Time : FALSE\n");

325  
SigtuVid
::
SIGNATURE_INVALID_CERT_TIME
;

328 
yr
 = (

.
tm_yr
 - 
tb
.tm_year) / 4;

330 if(
yr
 == 0)

332 
tc
.
tm_yr
 = 
tb
.tm_year;

333 
tc
.
tm_m
 = 
tb
.tm_mon + 1;

334 
tc
.
tm_mday
 = 
tb
.tm_mday;

336 if(
tc
.
tm_m
 == 12)

338 
tc
.
tm_yr
 = 

.tm_year;

339 
tc
.
tm_m
 = 

.tm_mon - 1;

340 
tc
.
tm_mday
 = 

.tm_mday;

342 if(
tc
.
tm_m
 < 0)

344 
tc
.
tm_yr
 = 

.tm_year;

345 
tc
.
tm_m
 = 

.tm_mon;

346 
tc
.
tm_mday
 = 

.tm_mday -1;

348 if(
tc
.
tm_mday
 == 0)

350 
tc
.
tm_yr
 = 
tb
.tm_year;

351 
tc
.
tm_m
 = 
tb
.tm_mon;

352 
tc
.
tm_mday
 = 
tb
.tm_mday +1;

358 
tc
.
tm_yr
 = 
tb
.tm_y+ 
yr
;

359 
tc
.
tm_m
 = (
tb
.tm_m + 

.tm_mon )/2;

360 
tc
.
tm_mday
 = (
tb
.tm_mday + 

.tm_mday)/2;

363 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tc
.
tm_yr
 + 1900,c.
tm_m
 + 1,tc.
tm_mday
 );

364 
	`WLogD
("## cm wh vidiځim: %s", 
msg
);

365 
	`rtf
(
dr
, "## cm wh vidiځim: %s\n", 
msg
);

367 
time_t
 
outCut
 = 
	`mktime
(&
tc
);

368 
cڋxt
.
vidiTime
 = 
outCut
;

369 
	`rtf
(
dr
, "## cmoutCutim: %ld\n", 
outCut
);

377 
time_t
 
nA
 = 
da
.
	`gEndEyCtifiP
()->
	`gNA
();

378 
time_t
 
nBefe
 = 
da
.
	`gEndEyCtifiP
()->
	`gNBefe
();

380 
tm
 *
t
;

382 i(
da
.
	`isAuthSigtu
())

393 i(
nBefe
 > 
nowTime
)

395 
	`WLogW
("Author certificate isxpired.otBeforeime is greaterhan system-time.");

397 
t
 = 
	`loime
(&
nowTime
);

398 
	`WLogD
("Syem'cuY: %d", (
t
->
tm_yr
 + 1900));

399 
	`WLogD
("Syem'cumth : %d", (
t
->
tm_m
 + 1));

400 
	`WLogD
("Syem'cuday : %d", (
t
->
tm_mday
));

402 
t
 = 
	`loime
(&
nBefe
);

403 
	`WLogD
("Auth ctifi'nBefܐY: %d", (
t
->
tm_yr
 + 1900));

404 
	`WLogD
("Auth ctifi'nBefܐmth : %d", (
t
->
tm_m
 + 1));

405 
	`WLogD
("Auth ctifi'nBefܐday : %d", (
t
->
tm_mday
));

407 
cڋxt
.
vidiTime
 = 
nBefe
 + 
TIMET_DAY
;

409 
t
 = 
	`loime
(&
cڋxt
.
vidiTime
);

410 
	`WLogD
("Modifd cuY: %d", (
t
->
tm_yr
 + 1900));

411 
	`WLogD
("Modifd cunBefܐmth : %d", (
t
->
tm_m
 + 1));

412 
	`WLogD
("Modifd cunBefܐday : %d", (
t
->
tm_mday
));

421 i(!
da
.
	`isAuthSigtu
())

423 i(
XmlSec
::
NO_ERROR
 !
XmlSecSgt
::
	`In
().
	`vide
(&
cڋxt
)) {

424 
	`WLogW
("Installation break - invalidackage!");

425  
SigtuVid
::
SIGNATURE_INVALID_HASH_SIGNATURE
;

428 
da
.
	`tRen
(
cڋxt
.
nS
);

429 i(!
	`checkObjeRens
(
da
)) {

430 
	`WLogW
("Failedo check Object References");

431  
SigtuVid
::
SIGNATURE_INVALID_HASH_SIGNATURE
;

434 (
widgCڋPh
;

444 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


449 i(!
m_comnModeEbd
 && !
da
.
	`isAuthSigtu
()) {

450 
CtifiCi
 
cl
;

451 
cl
.
	`ld
(
s܋dCtifiLi
);

453 i(!
cl
.
	`st
()) {

454 
	`WLogD
("Collection doesot contain chain!");

455  
SigtuVid
::
SIGNATURE_INVALID_CERT_CHAIN
;

458 
CtifiVifr
 
	`vifit
(
m_ocEb
, 
m_lEb
);

459 
VifitiStus
 
su
 = 
vifit
.
	`check
(
cl
);

461 i(
su
 =
VERIFICATION_STATUS_REVOKED
) {

462  
SigtuVid
::
SIGNATURE_REVOKED
;

465 i(
su
 =
VERIFICATION_STATUS_UNKNOWN
 ||

466 
su
 =
VERIFICATION_STATUS_ERROR
)

468 #ifde
_OCSP_POLICY_DISREGARD_UNKNOWN_OR_ERROR_CERTS_


469 
diegd
 = 
ue
;

475 i(
diegd
) {

476 
	`WLogW
("Signature is disregard. RootCA isot member of Tizen");

477  
SigtuVid
::
SIGNATURE_INVALID_DISTRIBUTOR_CERT
;

479  
SigtuVid
::
SIGNATURE_VERIFIED
;

480 
	}
}

482 
	gSigtuVid
::
Resu
 
ImTizSigtuVid
::
checkLi
(
SigtuDa
 &
da
,

483 cڡ 
d
::
rg
 &
widgCڋPh
,

484 cڡ 
d
::
li
<d::
rg
>& 
uriLi
)

486 if(
uriLi
.
size
() == 0 )

487 
WLogW
("checkList >>o hash");

489 
bo
 
	gdiegd
 = 
l
;

491 i(!
checkReURI
(
da
)) {

492  
	gSigtuVid
::
SIGNATURE_INVALID
;

495 i(!
checkProfeURI
(
da
)) {

496  
	gSigtuVid
::
SIGNATURE_INVALID
;

501 
CtifiCi
 
	gci
;

502 
	gci
.
ld
(
da
.
gCtLi
());

505 i(!
	gci
.
st
()) {

506 
WLogW
("Certificates doot form valid chain.");

507  
	gSigtuVid
::
SIGNATURE_INVALID
;

511 i(
	gci
.
emy
()) {

512 
WLogW
("Certificateist in signature ismpty.");

513  
	gSigtuVid
::
SIGNATURE_INVALID
;

516 
CtifiLi
 
	gs܋dCtifiLi
 = 
ci
.
gCha
();

520 
	gs܋dCtifiLi
 =

521 
OCSPCtMgrUt
::
comeCtifiCha
(
s܋dCtifiLi
);

523 
CtifiP
 
	gro
 = 
s܋dCtifiLi
.
back
();

526 
	gCtSteId
::
S
 
eIdS
 = 
CtifiIdtifr
().
fd
(
ro
);

528 
WLogD
("Iro ctifi from TIZEN_DEVELOPER doma: %d", 
eIdS
.
cڏs
(
CtSteId
::
TIZEN_DEVELOPER
));

529 
WLogD
("Iro ctifi from TIZEN_TEST doma: %d", 
eIdS
.
cڏs
(
CtSteId
::
TIZEN_TEST
));

530 
WLogD
("Iro ctifi from TIZEN_VERIFY doma: %d", 
eIdS
.
cڏs
(
CtSteId
::
TIZEN_VERIFY
));

531 
WLogD
("Iro ctifi from TIZEN_PUBLIC doma: %d", 
eIdS
.
cڏs
(
CtSteId
::
VIS_PUBLIC
));

532 
WLogD
("Iro ctifi from TIZEN_PARTNER doma: %d", 
eIdS
.
cڏs
(
CtSteId
::
VIS_PARTNER
));

533 
WLogD
("Iro ctifi from TIZEN_PLATFORM doma: %d", 
eIdS
.
cڏs
(
CtSteId
::
VIS_PLATFORM
));

535 
WLogD
("Visibyev ipubli: %d", 
eIdS
.
cڏs
(
CtSteId
::
VIS_PUBLIC
));

536 
WLogD
("Visibyev iø: %d", 
eIdS
.
cڏs
(
CtSteId
::
VIS_PARTNER
));

537 
WLogD
("Visibyev ifm : %d", 
eIdS
.
cڏs
(
CtSteId
::
VIS_PLATFORM
));

539 i(
	gda
.
isAuthSigtu
())

541 i(!
	geIdS
.
cڏs
(
CtSteId
::
TIZEN_DEVELOPER
))

543 
WLogW
("author-signature.xml has got unrecognized Root CA "

545 
	gdiegd
 = 
ue
;

547 
WLogD
("Root CA foruthor signature is correct.");

551 
WLogD
("sigtufm%s", 
da
.
gSigtuFeName
().
c_r
());

553 i(
	gda
.
gSigtuNumb
() == 1)

555 i(
eIdS
.
cڏs
(
CtSteId
::
VIS_PUBLIC
|| steIdS.cڏs(CtSteId::
VIS_PARTNER
|| steIdS.cڏs(CtSteId::
VIS_PLATFORM
))

557 
WLogD
("Root CA for signature1.xml is correct.");

561 
WLogW
("signature1.xml has got unrecognized Root CA "

563 
	gdiegd
 = 
ue
;

568 
	gda
.
tStageTy
(
eIdS
);

569 
	gda
.
tS܋dCtifiLi
(
s܋dCtifiLi
);

573 
	gXmlSec
::
XmlSecCڋxt
 
cڋxt
;

574 
	gcڋxt
.
	gsigtuFe
 = 
da
.
gSigtuFeName
();

575 
	gcڋxt
.
	gifiP
 = 
ro
;

580 i(!(
	gro
->
isSigdBy
(
ro
))) {

581 
WLogW
("Root CA certificateot found. Chain is incomplete.");

587 
time_t
 
	gnowTime
 = 
time
(
NULL
);

589 
	#CHECK_TIME


	)

590 #ifde
CHECK_TIME


592 
ASN1_TIME
* 
	gnATime
 = 
da
.
gEndEyCtifiP
()->
gNATime
();

593 
ASN1_TIME
* 
	gnBefeTime
 = 
da
.
gEndEyCtifiP
()->
gNBefeTime
();

596 i(
X509_cmp_time
(
nBefeTime
, &
nowTime
> 0 || X509_cmp_time(
nATime
, &nowTime) < 0)

598 
tm
 *
	gt
;

599 
tm
 
	g
, 
	gtb
, 
	gtc
;

600 
	gmsg
[1024];

602 
	gt
 = 
loime
(&
nowTime
);

603 i(!
	gt
)

604  
	gSigtuVid
::
SIGNATURE_INVALID_CERT_TIME
;

606 
memt
(&
tc
, 0, (tc));

608 
tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
t
->
tm_yr
 + 1900,->
tm_m
 + 1,t->
tm_mday
 );

609 
WLogD
("## Syem'cutTim: %s", 
msg
);

610 
rtf
(
dr
, "## Syem'cutTim: %s\n", 
msg
);

612 
	gtb
 = 
_ASN1_GTimeT
(
nBefeTime
);

613 
tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tb
.
tm_yr
 + 1900,b.
tm_m
 + 1,tb.
tm_mday
 );

614 
WLogD
("## ctifi'nBefeTim: %s", 
msg
);

615 
rtf
(
dr
, "## ctifi'nBefeTim: %s\n", 
msg
);

617 
	g
 = 
_ASN1_GTimeT
(
nATime
);

618 
tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 

.
tm_yr
 + 1900,a.
tm_m
 + 1,.
tm_mday
 );

619 
WLogD
("## ctifi'nATim: %s", 
msg
);

620 
rtf
(
dr
, "## ctifi'nATim: %s\n", 
msg
);

622 i(
	geIdS
.
cڏs
(
CtSteId
::
TIZEN_VERIFY
))

624 
WLogD
("## TIZEN_VERIFY : check certificate Time : FALSE");

625 
rtf
(
dr
, "## TIZEN_VERIFY : check certificate Time : FALSE\n");

626  
	gSigtuVid
::
SIGNATURE_INVALID
;

629 
	gyr
 = (

.
tm_yr
 - 
tb
.tm_year) / 4;

630 
	gtc
.
	gtm_yr
 = 
tb
.
tm_yr
 + 
yr
;

631 
	gtc
.
	gtm_m
 = (
tb
.
tm_m
 + 

.tm_mon )/2;

632 
	gtc
.
	gtm_mday
 = (
tb
.
tm_mday
 + 

.tm_mday)/2;

634 
tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tc
.
tm_yr
 + 1900,c.
tm_m
 + 1,tc.
tm_mday
 );

635 
WLogD
("## cm wh vidiځim: %s", 
msg
);

636 
rtf
(
dr
, "## cm wh vidiځim: %s\n", 
msg
);

638 
time_t
 
	goutCut
 = 
mktime
(&
tc
);

639 
	gcڋxt
.
	gvidiTime
 = 
outCut
;

646 
time_t
 
	gnA
 = 
da
.
gEndEyCtifiP
()->
gNA
();

647 
time_t
 
	gnBefe
 = 
da
.
gEndEyCtifiP
()->
gNBefe
();

649 
tm
 *
	gt
;

651 i(
	gda
.
isAuthSigtu
())

662 i(
	gnBefe
 > 
	gnowTime
)

664 
WLogW
("Author certificate isxpired.otBeforeime is greaterhan system-time.");

666 
	gt
 = 
loime
(&
nowTime
);

667 
WLogD
("Syem'cuY: %d", (
t
->
tm_yr
 + 1900));

668 
WLogD
("Syem'cumth : %d", (
t
->
tm_m
 + 1));

669 
WLogD
("Syem'cuday : %d", (
t
->
tm_mday
));

671 
	gt
 = 
loime
(&
nBefe
);

672 
WLogD
("Auth ctifi'nBefܐY: %d", (
t
->
tm_yr
 + 1900));

673 
WLogD
("Auth ctifi'nBefܐmth : %d", (
t
->
tm_m
 + 1));

674 
WLogD
("Auth ctifi'nBefܐday : %d", (
t
->
tm_mday
));

676 
	gcڋxt
.
	gvidiTime
 = 
nBefe
 + 
TIMET_DAY
;

678 
	gt
 = 
loime
(&
cڋxt
.
vidiTime
);

679 
WLogD
("Modifd cuY: %d", (
t
->
tm_yr
 + 1900));

680 
WLogD
("Modifd cunBefܐmth : %d", (
t
->
tm_m
 + 1));

681 
WLogD
("Modifd cunBefܐday : %d", (
t
->
tm_mday
));

689 if(
	guriLi
.
size
() == 0)

691 i(
XmlSec
::
NO_ERROR
 !
XmlSecSgt
::
In
().
videNoHash
(&
cڋxt
)) {

692 
WLogW
("Installation break - invalidackage! >> validateNoHash");

693  
	gSigtuVid
::
SIGNATURE_INVALID
;

696 if(
	guriLi
.
size
() != 0)

698 
XmlSecSgt
::
In
().
tPtlHashLi
(
uriLi
);

699 i(
	gXmlSec
::
NO_ERROR
 !
XmlSecSgt
::
In
().
videPtlHash
(&
cڋxt
)) {

700 
WLogW
("Installation break - invalidackage! >> validatePartialHash");

701  
	gSigtuVid
::
SIGNATURE_INVALID
;

705 
	gda
.
tRen
(
cڋxt
.
nS
);

710 (
	gwidgCڋPh
;

719 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


724 i(!
	gm_comnModeEbd
 && !
	gda
.
isAuthSigtu
()) {

725 
CtifiCi
 
	gcl
;

726 
	gcl
.
ld
(
s܋dCtifiLi
);

728 i(!
	gcl
.
st
()) {

729 
WLogD
("Collection doesot contain chain!");

730  
	gSigtuVid
::
SIGNATURE_INVALID
;

733 
CtifiVifr
 
vifit
(
m_ocEb
, 
m_lEb
);

734 
VifitiStus
 
	gsu
 = 
vifit
.
check
(
cl
);

736 i(
	gsu
 =
VERIFICATION_STATUS_REVOKED
) {

737  
SigtuVid
::
SIGNATURE_REVOKED
;

740 i(
	gsu
 =
VERIFICATION_STATUS_UNKNOWN
 ||

741 
su
 =
VERIFICATION_STATUS_ERROR
)

743 #ifde
_OCSP_POLICY_DISREGARD_UNKNOWN_OR_ERROR_CERTS_


744 
diegd
 = 
ue
;

750 i(
	gdiegd
) {

751 
WLogW
("Signature is disregard. RootCA isot member of Tizen.");

752  
	gSigtuVid
::
SIGNATURE_DISREGARD
;

754  
	gSigtuVid
::
SIGNATURE_VERIFIED
;

757 as
	cImWacSigtuVid
 : 
public
 
SigtuVid
::
ImSigtuVid


759 
public
:

760 
SigtuVid
::
Resu
 
check
(
SigtuDa
 &
da
,

761 cڡ 
d
::
rg
 &
widgCڋPh
);

763 
	gSigtuVid
::
Resu
 
checkLi
(
SigtuDa
 &
da
,

764 cڡ 
d
::
rg
 &
widgCڋPh
,

765 cڡ 
d
::
li
<d::
rg
>& 
uriLi
);

766 
exic
 
ImWacSigtuVid
(
bo
 
ocEb
,

767 
bo
 
lEb
,

768 
bo
 
comnMode
)

769 : 
ImSigtuVid
(
ocEb
, 
lEb
, 
comnMode
)

772 
	gvtu
 ~
ImWacSigtuVid
() {}

776 
	gSigtuVid
::
Resu
 
ImWacSigtuVid
::
checkLi
(

777 
SigtuDa
 & ,

778 cڡ 
d
::
rg
 & ,

779 cڡ 
d
::
li
<d::
rg
>& )

781  
SigtuVid
::
SIGNATURE_INVALID
;

785 
	gSigtuVid
::
Resu
 
ImWacSigtuVid
::
	$check
(

786 
SigtuDa
 &
da
,

787 cڡ 
d
::
rg
 &
widgCڋPh
)

789 
bo
 
diegd
 = 
l
;

791 i(!
	`checkReURI
(
da
)) {

792  
SigtuVid
::
SIGNATURE_INVALID
;

795 i(!
	`checkProfeURI
(
da
)) {

796  
SigtuVid
::
SIGNATURE_INVALID
;

801 
CtifiCi
 
ci
;

802 
ci
.
	`ld
(
da
.
	`gCtLi
());

805 i(!
ci
.
	`st
()) {

806 
	`WLogW
("Certificates doot form valid chain.");

807  
SigtuVid
::
SIGNATURE_INVALID
;

811 i(
ci
.
	`emy
()) {

812 
	`WLogW
("Certificateist in signature ismpty.");

813  
SigtuVid
::
SIGNATURE_INVALID
;

816 
CtifiLi
 
s܋dCtifiLi
 = 
ci
.
	`gCha
();

820 
s܋dCtifiLi
 =

821 
OCSPCtMgrUt
::
	`comeCtifiCha
(
s܋dCtifiLi
);

823 
CtifiP
 
ro
 = 
s܋dCtifiLi
.
	`back
();

826 
CtSteId
::
S
 
eIdS
 = 
	`CtifiIdtifr
().
	`fd
(
ro
);

828 
	`WLogD
("Iro ctifi from TIZEN_DEVELOPER doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
));

829 
	`WLogD
("Iro ctifi from TIZEN_TEST doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_TEST
));

830 
	`WLogD
("Iro ctifi from TIZEN_VERIFY doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_VERIFY
));

831 
	`WLogD
("Iro ctifi from TIZEN_PUBLIC doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
));

832 
	`WLogD
("Iro ctifi from TIZEN_PARTNER doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PARTNER
));

833 
	`WLogD
("Iro ctifi from TIZEN_PLATFORM doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PLATFORM
));

835 
	`WLogD
("Visibyev ipubli: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
));

836 
	`WLogD
("Visibyev iø: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PARTNER
));

837 
	`WLogD
("Visibyev ifm : %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PLATFORM
));

839 i(
da
.
	`isAuthSigtu
())

841 i(!
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
))

843 
	`WLogW
("author-signature.xml has got unrecognized Root CA "

845 
diegd
 = 
ue
;

848 
	`WLogD
("sigtufm%s", 
da
.
	`gSigtuFeName
().
	`c_r
());

849 i(
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
))

851 
	`WLogE
("distributor hasuthorevel siganture! Signature will be disregarded.");

852  
SigtuVid
::
SIGNATURE_INVALID
;

856 i(
da
.
	`gSigtuNumb
() == 1)

858 i(
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
|| steIdS.cڏs(CtSteId::
VIS_PARTNER
|| steIdS.cڏs(CtSteId::
VIS_PLATFORM
))

860 
	`WLogD
("Root CA for signature1.xml is correct.");

864 
	`WLogW
("signature1.xml has got unrecognized Root CA "

866 
diegd
 = 
ue
;

871 
da
.
	`tStageTy
(
eIdS
);

872 
da
.
	`tS܋dCtifiLi
(
s܋dCtifiLi
);

876 
XmlSec
::
XmlSecCڋxt
 
cڋxt
;

877 
cڋxt
.
sigtuFe
 = 
da
.
	`gSigtuFeName
();

878 
cڋxt
.
ifiP
 = 
ro
;

883 i(!(
ro
->
	`isSigdBy
(root))) {

884 
	`WLogW
("Root CA certificateot found. Chain is incomplete.");

888 
time_t
 
nowTime
 = 
	`time
(
NULL
);

891 
	#CHECK_TIME


	)

892 #ifde
CHECK_TIME


894 
ASN1_TIME
* 
nATime
 = 
da
.
	`gEndEyCtifiP
()->
	`gNATime
();

895 
ASN1_TIME
* 
nBefeTime
 = 
da
.
	`gEndEyCtifiP
()->
	`gNBefeTime
();

897 i(
	`X509_cmp_time
(
nBefeTime
, &
nowTime
> 0 || X509_cmp_time(
nATime
, &nowTime) < 0)

899 
tm
 *
t
;

900 
tm
 

, 
tb
, 
tc
;

901 
msg
[1024];

903 
t
 = 
	`loime
(&
nowTime
);

904 i(!
t
)

905  
SigtuVid
::
SIGNATURE_INVALID_CERT_TIME
;

907 
	`memt
(&
tc
, 0, (tc));

909 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
t
->
tm_yr
 + 1900,->
tm_m
 + 1,t->
tm_mday
 );

910 
	`WLogD
("## Syem'cutTim: %s", 
msg
);

911 
	`rtf
(
dr
, "## Syem'cutTim: %s\n", 
msg
);

913 
tb
 = 
	`_ASN1_GTimeT
(
nBefeTime
);

914 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tb
.
tm_yr
 + 1900,b.
tm_m
 + 1,tb.
tm_mday
 );

915 
	`WLogD
("## ctifi'nBefeTim: %s", 
msg
);

916 
	`rtf
(
dr
, "## ctifi'nBefeTim: %s\n", 
msg
);

918 

 = 
	`_ASN1_GTimeT
(
nATime
);

919 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 

.
tm_yr
 + 1900,a.
tm_m
 + 1,.
tm_mday
 );

920 
	`WLogD
("## ctifi'nATim: %s", 
msg
);

921 
	`rtf
(
dr
, "## ctifi'nATim: %s\n", 
msg
);

923 i(
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_VERIFY
))

925 
	`WLogD
("## TIZEN_VERIFY : check certificate Time : FALSE");

926 
	`rtf
(
dr
, "## TIZEN_VERIFY : check certificate Time : FALSE\n");

927  
SigtuVid
::
SIGNATURE_INVALID
;

930 
yr
 = (

.
tm_yr
 - 
tb
.tm_year) / 4;

931 
tc
.
tm_yr
 = 
tb
.tm_y+ 
yr
;

932 
tc
.
tm_m
 = (
tb
.tm_m + 

.tm_mon )/2;

933 
tc
.
tm_mday
 = (
tb
.tm_mday + 

.tm_mday)/2;

935 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tc
.
tm_yr
 + 1900,c.
tm_m
 + 1,tc.
tm_mday
 );

936 
	`WLogD
("## cm wh vidiځim: %s", 
msg
);

937 
	`rtf
(
dr
, "## cm wh vidiځim: %s\n", 
msg
);

939 
time_t
 
outCut
 = 
	`mktime
(&
tc
);

940 
cڋxt
.
vidiTime
 = 
outCut
;

947 
time_t
 
nA
 = 
da
.
	`gEndEyCtifiP
()->
	`gNA
();

948 
time_t
 
nBefe
 = 
da
.
	`gEndEyCtifiP
()->
	`gNBefe
();

950 
tm
 *
t
;

952 i(
da
.
	`isAuthSigtu
())

963 i(
nBefe
 > 
nowTime
)

965 
	`WLogW
("Author certificate isxpired.otBeforeime is greaterhan system-time.");

967 
t
 = 
	`loime
(&
nowTime
);

968 
	`WLogD
("Syem'cuY: %d", (
t
->
tm_yr
 + 1900));

969 
	`WLogD
("Syem'cumth : %d", (
t
->
tm_m
 + 1));

970 
	`WLogD
("Syem'cuday : %d", (
t
->
tm_mday
));

972 
t
 = 
	`loime
(&
nBefe
);

973 
	`WLogD
("Auth ctifi'nBefܐY: %d", (
t
->
tm_yr
 + 1900));

974 
	`WLogD
("Auth ctifi'nBefܐmth : %d", (
t
->
tm_m
 + 1));

975 
	`WLogD
("Auth ctifi'nBefܐday : %d", (
t
->
tm_mday
));

977 
cڋxt
.
vidiTime
 = 
nBefe
 + 
TIMET_DAY
;

979 
t
 = 
	`loime
(&
cڋxt
.
vidiTime
);

980 
	`WLogD
("Modifd cuY: %d", (
t
->
tm_yr
 + 1900));

981 
	`WLogD
("Modifd cunBefܐmth : %d", (
t
->
tm_m
 + 1));

982 
	`WLogD
("Modifd cunBefܐday : %d", (
t
->
tm_mday
));

986 i(!
da
.
	`isAuthSigtu
())

988 i(
XmlSec
::
NO_ERROR
 !
XmlSecSgt
::
	`In
().
	`vide
(&
cڋxt
)) {

989 
	`WLogW
("Installation break - invalidackage!");

990  
SigtuVid
::
SIGNATURE_INVALID
;

993 
da
.
	`tRen
(
cڋxt
.
nS
);

995 i(!
	`checkObjeRens
(
da
)) {

996  
SigtuVid
::
SIGNATURE_INVALID
;

999 
RenVid
 
	`feVid
(
widgCڋPh
);

1000 i(
RenVid
::
NO_ERROR
 !
feVid
.
	`checkRens
(
da
)) {

1001 
	`WLogW
("Invalidackage - fileeferences broken");

1002  
SigtuVid
::
SIGNATURE_INVALID
;

1006 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


1011 i(!
m_comnModeEbd
 && !
da
.
	`isAuthSigtu
()) {

1012 
CtifiCi
 
cl
;

1013 
cl
.
	`ld
(
s܋dCtifiLi
);

1015 i(!
cl
.
	`st
()) {

1016 
	`WLogD
("Collection doesot contain chain!");

1017  
SigtuVid
::
SIGNATURE_INVALID
;

1020 
CtifiVifr
 
	`vifit
(
m_ocEb
, 
m_lEb
);

1021 
VifitiStus
 
su
 = 
vifit
.
	`check
(
cl
);

1023 i(
su
 =
VERIFICATION_STATUS_REVOKED
) {

1024  
SigtuVid
::
SIGNATURE_REVOKED
;

1027 i(
su
 =
VERIFICATION_STATUS_UNKNOWN
 ||

1028 
su
 =
VERIFICATION_STATUS_ERROR
)

1030 #ifde
_OCSP_POLICY_DISREGARD_UNKNOWN_OR_ERROR_CERTS_


1031 
diegd
 = 
ue
;

1037 i(
diegd
) {

1038 
	`WLogW
("Signature is disregard. RootCA isot member of Tizen.");

1039  
SigtuVid
::
SIGNATURE_DISREGARD
;

1041  
SigtuVid
::
SIGNATURE_VERIFIED
;

1042 
	}
}

1046 
	gSigtuVid
::
	$SigtuVid
(

1047 
ATy
 
pTy
,

1048 
bo
 
ocEb
,

1049 
bo
 
lEb
,

1050 
bo
 
comnMode
)

1051 : 
	$m_im
(0)

1053 
	`WLogD
"pTy :%d", 
pTy
 );

1055 if(
pTy
 =
TIZEN
)

1057 
m_im
 = 
w
 
	`ImTizSigtuVid
(
ocEb
,
lEb
,
comnMode
);

1059 if(
pTy
 =
WAC20
)

1061 
m_im
 = 
w
 
	`ImWacSigtuVid
(
ocEb
,
lEb
,
comnMode
);

1063 
	}
}

1065 
	gSigtuVid
::~
	$SigtuVid
() {

1066 
de
 
m_im
;

1067 
	}
}

1069 
	gSigtuVid
::
Resu
 
SigtuVid
::
	$check
(

1070 
SigtuDa
 &
da
,

1071 cڡ 
d
::
rg
 &
widgCڋPh
)

1073  
m_im
->
	`check
(
da
, 
widgCڋPh
);

1074 
	}
}

1076 
	gSigtuVid
::
Resu
 
SigtuVid
::
checkLi
(

1077 
SigtuDa
 &
da
,

1078 cڡ 
d
::
rg
 &
widgCڋPh
,

1079 cڡ 
d
::
li
<d::
rg
>& 
uriLi
)

1081  
m_im
->
checkLi
(
da
, 
widgCڋPh
, 
uriLi
);

	@vcore/src/vcore/SignatureValidator.h

22 #ide
_VALIDATION_CORE_SIGNATUREVALIDATOR_H_


23 
	#_VALIDATION_CORE_SIGNATUREVALIDATOR_H_


	)

25 #ide
LOG_TAG


26 #unde
LOG_TAG


27 
	#LOG_TAG
 "OSP"

	)

30 
	~<rg
>

32 
	~<vce/SigtuDa.h
>

34 
mea
 
	gVidiCe
 {

36 as
	cSigtuVid
 {

37 
	gpublic
:

38 
ass
 
ImSigtuVid
;

40 
	eATy


42 
	gTIZEN
,

43 
	gWAC20


46 
	eResu


48 
	gSIGNATURE_VALID
,

49 
	gSIGNATURE_INVALID
,

50 
	gSIGNATURE_VERIFIED
,

51 
	gSIGNATURE_DISREGARD
,

52 
	gSIGNATURE_REVOKED
,

53 
	gSIGNATURE_INVALID_CERT_CHAIN
,

54 
	gSIGNATURE_INVALID_DISTRIBUTOR_CERT
,

55 
	gSIGNATURE_INVALID_SDK_DEFAULT_AUTHOR_CERT
,

56 
	gSIGNATURE_IN_DISTRIBUTOR_CASE_AUTHOR_CERT
,

57 
	gSIGNATURE_INVALID_CERT_TIME
,

58 
	gSIGNATURE_NO_DEVICE_PROFILE
,

59 
	gSIGNATURE_INVALID_DEVICE_UNIQUE_ID
,

60 
	gSIGNATURE_INVALID_NO_HASH_FILE
,

61 
	gSIGNATURE_INVALID_HASH_SIGNATURE


64 
SigtuVid
(
de
;

65 
SigtuVid
(cڡ SigtuVid &
de
;

66 cڡ 
	gSigtuVid
 &
	gݔ
=(cڡ 
SigtuVid
 &
de
;

68 
exic
 
SigtuVid
(

69 
ATy
 
pTy
,

70 
bo
 
ocEb
,

71 
bo
 
lEb
,

72 
bo
 
comnMode
);

74 
	gvtu
 ~
SigtuVid
();

76 
Resu
 
check
(

77 
SigtuDa
 &
da
,

78 cڡ 
d
::
rg
 &
widgCڋPh
);

80 
Resu
 
checkLi
(

81 
SigtuDa
 &
da
,

82 cڡ 
d
::
rg
 &
widgCڋPh
,

83 cڡ 
d
::
li
<d::
rg
>& 
uriLi
);

85 
	give
:

86 
ImSigtuVid
 *
m_im
;

	@vcore/src/vcore/SoupMessageSendBase.cpp

22 
	~<vce/SoupMesgeSdBa.h
>

24 
	~<d/as.h
>

25 
	~<d/fܗch.h
>

26 
	~<d/log/w_log.h
>

28 
mea
 
	gSoupW
 {

30 
	gSoupMesgeSdBa
::
SoupMesgeSdBa
()

31 : 
m_us
(
STATUS_IDLE
)

32 , 
m_timeout
(30)

33 , 
m_yCou
(5)

36 
	gSoupMesgeSdBa
::~
SoupMesgeSdBa
(){

37 
As
(
m_us
 =
STATUS_IDLE
);

40 
	gSoupMesgeSdBa
::
tHd
(cڡ 
d
::
rg
 &
ݔty
, cڡ std::rg &
vue
){

41 
As
(
m_us
 =
STATUS_IDLE
);

42 
	gm_hdM
[
ݔty
] = 
vue
;

45 
	gSoupMesgeSdBa
::
tHo
(cڡ 
d
::
rg
 &
ho
){

46 
As
(
m_us
 =
STATUS_IDLE
);

47 
	gm_ho
 = 
ho
;

50 
	gSoupMesgeSdBa
::
tReque
(cڡ 
d
::
rg
 &
cڋTy
, cڡ 
MesgeBufr
 &
mesge
){

51 
As
(
m_us
 =
STATUS_IDLE
);

52 
	gm_queTy
 = 
cڋTy
;

53 
	gm_queBufr
 = 
mesge
;

56 
	gSoupMesgeSdBa
::
MesgeBufr
 
SoupMesgeSdBa
::
gReڣ
() const {

57 
As
(
m_us
 =
STATUS_IDLE
);

58  
	gm_ڣBufr
;

61 
	gSoupMesgeSdBa
::
tTimeout
(
cds
) {

62 
As
(
m_us
 =
STATUS_IDLE
);

63 
As
(
cds
 >= 0);

64 
	gm_timeout
 = 
cds
;

67 
	gSoupMesgeSdBa
::
tRry
(
y
) {

68 
As
(
m_us
 =
STATUS_IDLE
);

69 
As
(
y
 >= 0);

70 
	gm_yCou
 = 
y
 + 1;

74 
SoupMesge
* 
	gSoupMesgeSdBa
::
Reque
(){

75 
SoupMesge
 *
mesge
;

77 
WLogI
("Soumesgwbndo: %s", 
m_ho
.
c_r
());

79 i(!
	gm_queBufr
.
emy
()) {

80 
	gmesge
 = 
soup_mesge_w
("POST", 
m_ho
.
c_r
());

82 
	gmesge
 = 
soup_mesge_w
("GET", 
m_ho
.
c_r
());

85 i(!
	gmesge
) {

86 
WLogE
("Error creatingequest!");

90 
FOREACH
(

, 
m_hdM
){

91 
soup_mesge_hds_nd
(
mesge
->
que_hds
,

92 

->
f
.
c_r
(),

93 

->
cd
.
c_r
());

96 i(!
	gm_queBufr
.
emy
()) {

97 
soup_mesge_t_hp_vsi
(
mesge
, 
SOUP_HTTP_1_0
);

98 
soup_mesge_t_que
(
mesge
,

99 
m_queTy
.
c_r
(),

100 
SOUP_MEMORY_COPY
,

101 &
m_queBufr
[0],

102 
m_queBufr
.
size
());

105  
	gmesge
;

	@vcore/src/vcore/SoupMessageSendBase.h

22 #ide
_SRC_VALIDATION_CORE_SOUP_MESSAGE_SEND_BASE_H_


23 
	#_SRC_VALIDATION_CORE_SOUP_MESSAGE_SEND_BASE_H_


	)

25 
	~<m
>

26 
	~<ve
>

27 
	~<rg
>

29 
	~<libsoup/soup.h
>

31 
mea
 
	gSoupW
 {

33 as
	cSoupMesgeSdBa
 {

34 
	gpublic
:

36 
d
::
	tve
<> 
	tMesgeBufr
;

37 
	gd
::
	tm
<
	td
::
	trg
,d::rg> 
	tHdM
;

39 
	eRequeStus
 {

40 
	gREQUEST_STATUS_OK
,

41 
	gREQUEST_STATUS_CONNECTION_ERROR


44 
SoupMesgeSdBa
();

46 
	gvtu
 ~
SoupMesgeSdBa
();

54 
tHd
(cڡ 
d
::
rg
 &
ݔty
,

55 cڡ 
d
::
rg
 &
vue
);

62 
tHo
(cڡ 
d
::
rg
 &
ho
);

70 
tReque
(cڡ 
d
::
rg
 &
cڋTy
,

71 cڡ 
MesgeBufr
 &
mesge
);

78 
tTimeout
(
cds
);

86 
tRry
(
y
);

91 
MesgeBufr
 
gReڣ
() const;

93 
	geed
:

95 
SoupMesge
* 
Reque
();

97 
	eStus
 {

98 
	gSTATUS_IDLE
,

99 
	gSTATUS_SEND_SYNC
,

100 
	gSTATUS_SEND_ASYNC


103 
Stus
 
	gm_us
;

105 
	gm_timeout
;

106 
	gm_yCou
;

108 
	gd
::
rg
 
m_ho
;

109 
	gd
::
rg
 
m_queTy
;

110 
MesgeBufr
 
	gm_queBufr
;

111 
MesgeBufr
 
	gm_ڣBufr
;

112 
HdM
 
	gm_hdM
;

	@vcore/src/vcore/SoupMessageSendSync.cpp

22 
	~<vce/SoupMesgeSdSync.h
>

24 
	~<memy
>

25 
	~<funiڮ
>

27 
	~<vcf.h
>

29 
	~<d/log/w_log.h
>

31 
mea
 
	gSoupW
 {

33 
	gSoupMesgeSdBa
::
RequeStus
 
SoupMesgeSdSync
::
ndSync
()

35 
As
(
m_us
 =
STATUS_IDLE
);

36 
	gm_us
 = 
STATUS_SEND_SYNC
;

38 
ScedGMaCڋxt
 
cڋxt
(
g_ma_cڋxt_w
());

40 
	gd
::
unique_r
<,d::
funi
<(*)> >

41 
oxy
(
vcf_g_r
(
VCONFKEY_NETWORK_PROXY
), 

);

43 
	gd
::
unique_r
 <
SoupURI
, std::
funi
<(SoupURI*)> >

44 
oxyURI
(
soup_uri_w
 (
oxy
.
g
()), 
soup_uri_
);

46 
WLogD
("Proxy: %Proxyddr: %s", (*)
oxy
.
g
(),roxy.get());

48 
	gyCou
 = 0;ryCou < 
	gm_yCou
; ++ryCount){

49 
WLogD
("Try(%dtdowd %s", 
yCou
, 
m_ho
.
c_r
());

51 
ScedSoupSessi
 
ssi
(
soup_ssi_async_w_wh_tis
(

52 
SOUP_SESSION_ASYNC_CONTEXT
,

53 &*
cڋxt
,

54 
SOUP_SESSION_TIMEOUT
,

55 
m_timeout
,

56 
SOUP_SESSION_PROXY_URI
,

57 
oxyURI
.
g
(),

58 
NULL
));

60 
ScedSoupMesge
 
	gmsg
;

62 
	gmsg
.
Ret
(
Reque
());

64 i(!
	gmsg
) {

65 
WLogE
("Unableo send HTTPequest.");

66 
	gm_us
 = 
STATUS_IDLE
;

67  
	gREQUEST_STATUS_CONNECTION_ERROR
;

69 
soup_ssi_nd_mesge
(&*
ssi
, &*
msg
);

73 i(
	gmsg
->
	gus_code
 =
SOUP_STATUS_OK
) {

74 
m_ڣBufr
.
size
(
msg
->
ڣ_body
->
ngth
);

75 
memy
(&
m_ڣBufr
[0],

76 
msg
->
ڣ_body
->
da
,

77 
msg
->
ڣ_body
->
ngth
);

79 
	gm_us
 = 
STATUS_IDLE
;

80  
	gREQUEST_STATUS_OK
;

82 
WLogW
("Soued wh cod[%d] mesg[%s]", 
msg
->
us_code
, msg->
ڣ_body
->
da
);

86 
	gm_us
 = 
STATUS_IDLE
;

87  
	gREQUEST_STATUS_CONNECTION_ERROR
;

	@vcore/src/vcore/SoupMessageSendSync.h

22 #ide
_VALIDATION_CORE_SOUP_MESSAGE_SEND_SYNC_H_


23 
	#_VALIDATION_CORE_SOUP_MESSAGE_SEND_SYNC_H_


	)

25 
	~<vce/SoupMesgeSdBa.h
>

27 
	~<vce/sced_gpor.h
>

29 
mea
 
	gSoupW
 {

31 as
	cSoupMesgeSdSync
 : 
public
 
SoupMesgeSdBa
 {

32 
public
:

33 
RequeStus
 
ndSync
();

34 
	geed
:

35 
WRT
::
	tScedGPor
<
	tSoupMesge
> 
	tScedSoupMesge
;

36 
	gWRT
::
	tScedGPor
<
	tSoupSessi
> 
	tScedSoupSessi
;

37 
	gWRT
::
	tScedGPor
<
	tGMaCڋxt
> 
	tScedGMaCڋxt
;

	@vcore/src/vcore/TimeConversion.cpp

16 
	~<vce/TimeCvsi.h
>

18 
	~<rg.h
>

20 
	~<d/log/w_log.h
>

21 
	~<d/as.h
>

23 
mea
 
	gVidiCe
 {

25 
a1TimeToTimeT
(
ASN1_TIME
 *
t
, 
time_t
 *
s
)

27 
tm
 
	gtm
;

28 
	gofft
;

30 (*
	gs
) = 0;

31 i(!
ASN1_TIME_check
(
t
)) {

35 
memt
(&
tm
, 0, (tm));

37 
	#g2
(
p
(()[0] - '0'* 10 + (p)[1] - '0')

	)

38 i(
	gt
->
	gty
 =
V_ASN1_UTCTIME
) {

39 
As
(
t
->
ngth
 > 12);

42 
	gtm
.
	gtm_yr
 = 
g2
(
t
->
da
);

43 i(
	gtm
.
	gtm_yr
 < 50) {

44 
	gtm
.
	gtm_yr
 += 100;

46 
	gtm
.
	gtm_m
 = 
g2
(
t
->
da
 + 2) - 1;

47 
	gtm
.
	gtm_mday
 = 
g2
(
t
->
da
 + 4);

48 
	gtm
.
	gtm_hour
 = 
g2
(
t
->
da
 + 6);

49 
	gtm
.
	gtm_m
 = 
g2
(
t
->
da
 + 8);

50 
	gtm
.
	gtm_c
 = 
g2
(
t
->
da
 + 10);

51 i(
	gt
->
	gda
[12] == 'Z') {

52 
offt
 = 0;

54 
As
(
t
->
ngth
 > 16);

56 
	gofft
 = 
g2
(
t
->
da
 + 13) * 60 + g2(t->data + 15);

57 i(
	gt
->
	gda
[12] == '-') {

58 
offt
 = -offset;

61 
	gtm
.
	gtm_isd
 = -1;

63 
As
(
t
->
ngth
 > 14);

65 
	gtm
.
	gtm_yr
 = 
g2
(
t
->
da
) * 100 + g2(t->data + 2);

66 
	gtm
.
	gtm_m
 = 
g2
(
t
->
da
 + 4) - 1;

67 
	gtm
.
	gtm_mday
 = 
g2
(
t
->
da
 + 6);

68 
	gtm
.
	gtm_hour
 = 
g2
(
t
->
da
 + 8);

69 
	gtm
.
	gtm_m
 = 
g2
(
t
->
da
 + 10);

70 
	gtm
.
	gtm_c
 = 
g2
(
t
->
da
 + 12);

71 i(
	gt
->
	gda
[14] == 'Z') {

72 
offt
 = 0;

74 
As
(
t
->
ngth
 > 18);

76 
	gofft
 = 
g2
(
t
->
da
 + 15) * 60 + g2(t->data + 17);

77 i(
	gt
->
	gda
[14] == '-') {

78 
offt
 = -offset;

81 
	gtm
.
	gtm_isd
 = -1;

83 #unde
g2


84 (*
	gs

timegm
(&
tm
- 
offt
 * 60;

88 
a1GizedTimeToTimeT
(
ASN1_GENERALIZEDTIME
 *
tm
, 
time_t
 *
s
)

97 cڡ 
	gDATE_BUFFER_LENGTH
 = 15;

99 i(
	gNULL
 =
s
 || 
NULL
 =
tm
) {

100 
WLogE
("NULLointer");

104 i(
	gDATE_BUFFER_LENGTH
 !
tm
->
ngth
 || 
NULL
 =tm->
da
) {

105 
WLogE
("Invalid ASN1_GENERALIZEDTIME");

109 
tm
 
	gtime_s
;

110 i(
ssnf
 ((*)
tm
->
da
,

112 &
time_s
.
tm_yr
,

113 &
time_s
.
tm_m
,

114 &
time_s
.
tm_mday
,

115 &
time_s
.
tm_hour
,

116 &
time_s
.
tm_m
,

117 &
time_s
.
tm_c
) < 6)

119 
WLogE
("Couldotxtractime data from ASN1_GENERALIZEDTIME");

123 
	gtime_s
.
	gtm_yr
 -= 1900;

124 
	gtime_s
.
	gtm_m
 -= 1;

125 
	gtime_s
.
	gtm_isd
 = 0;

126 
	gtime_s
.
	gtm_gmtoff
 = 0;

127 
	gtime_s
.
	gtm_ze
 = 
NULL
;

129 *
	gs
 = 
mktime
(&
time_s
);

	@vcore/src/vcore/TimeConversion.h

22 #ide
_VALIDATION_CORE_TIMECONVERSION_H_


23 
	#_VALIDATION_CORE_TIMECONVERSION_H_


	)

25 
	~<ime
>

27 
	~<ݒs/x509.h
>

29 
mea
 
	gVidiCe
 {

31 
a1TimeToTimeT
(
ASN1_TIME
 *
t
, 
time_t
 *
s
);

33 
a1GizedTimeToTimeT
(
ASN1_GENERALIZEDTIME
 *
tm
,

34 
time_t
 *
s
);

	@vcore/src/vcore/VCore.cpp

22 
	~<vce/VCePrive.h
>

23 
	~<vce/Cfig.h
>

24 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


25 
	~<vce/Daba.h
>

26 
	~<daba_checksum_vce.h
>

28 
	~<ݒs/s.h
>

29 
	~<glib.h
>

30 
	~<glib-obje.h
>

32 
	~<d/as.h
>

33 
	~<d/log/w_log.h
>

35 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


36 
	gmea
 {

37 
	gVceDPL
::
DB
::
ThadDabaSut
 *
thadI
 = 
NULL
;

41 
mea
 
	gVidiCe
 {

43 
AachToThadRO
()

45 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


46 
As
(
thadI
);

47 
bo
 
	gcheck
 = 
ue
;

48 
	gthadI
->
AachToThad
(

49 
VceDPL
::
DB
::
SqlCi
::
Fg
::
RO
);

52 i(
	gcheck
) {

53 
	gcheck
 = 
l
;

54 
As
(
ThadI
().
CheckTabExi
(
DB_CHECKSUM_STR
) &&

60 
AachToThadRW
()

62 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


63 
As
(
thadI
);

64 
bo
 
	gcheck
 = 
ue
;

65 
	gthadI
->
AachToThad
(

66 
VceDPL
::
DB
::
SqlCi
::
Fg
::
RW
);

69 i(
	gcheck
) {

70 
	gcheck
 = 
l
;

71 
As
(
ThadI
().
CheckTabExi
(
DB_CHECKSUM_STR
) &&

77 
DachFromThad
(){

78 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


79 
As
(
thadI
);

80 
	gthadI
->
DachFromThad
();

83 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


84 
	gVceDPL
::
DB
::
ThadDabaSut
& 
ThadI
() {

85 
As
(
thadI
);

86  *
	gthadI
;

90 
VCeIn
()

92 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


93 i(
	gthadI
) {

94 
WLogD
("Already Initialized");

95  
	gue
;

98 
	gthadI
 = 
w
 
VceDPL
::
DB
::
ThadDabaSut
(

99 
CERTSVC_VCORE_DB
,

100 
VceDPL
::
DB
::
SqlCi
::
Fg
::
ULu
);

103 
SSL_libry_
();

105 
	gCfig
 &
	gglobCfig
 = 
CfigSgt
::
In
();

107 
	gglobCfig
.
tXMLCfigPh
(
d
::
rg
(
FINGERPRINT_LIST_PATH
));

108 
	gglobCfig
.
tXMLSchemaPh
(
d
::
rg
(
FINGERPRINT_LIST_SCHEMA_PATH
));

111 
VCeDe
()

113 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


114 
As
(
thadI
 && "Not initialized orlready deinitialized");

115 
de
 
	gthadI
;

116 
	gthadI
 = 
NULL
;

	@vcore/src/vcore/VCore.h

22 #ide
_VCORE_SRC_VCORE_VCORE_H_


23 
	#_VCORE_SRC_VCORE_VCORE_H_


	)

25 
	~<rg
>

27 
mea
 
	gVidiCe
 {

34 
VCeIn
();

39 
VCeDe
();

50 
AachToThadRO
();

51 
AachToThadRW
();

52 
DachFromThad
();

	@vcore/src/vcore/VCorePrivate.h

22 #ide
_VCORE_SRC_VCORE_VCOREPRIVATE_H_


23 
	#_VCORE_SRC_VCORE_VCOREPRIVATE_H_


	)

25 
	~<rg
>

26 
	~<VCe.h
>

27 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


28 
	~<daba_checksum_vce.h
>

29 
	~<d/db/thad_daba_sut.h
>

32 
mea
 
	gVidiCe
 {

33 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


34 
	gVceDPL
::
DB
::
ThadDabaSut
& 
ThadI
();

	@vcore/src/vcore/ValidatorCommon.h

22 #ide
_VALIDATORCOMMON_H_


23 
	#_VALIDATORCOMMON_H_


	)

25 
	~<li
>

26 
	~<t
>

27 
	~<rg
>

29 
mea
 
	gVidiCe
 {

34 
	gme
 <
tyme
 
	gT
>

35 
	sVidCeUnivlFe
 {};

38 
	#VC_DECLARE_DELETER
(
ty
, 
funi
) \

39 
me
 <> \

40 
VidCeUnivlFe
 <
ty
> { \

41 
	`univl_
(
ty
 *
r
){ \

42 i(
r
) { \

43 
	`funi
(
r
); } \

45 };

	)

47 
	gme
 <
tyme
 
	gT
>

48 as
	cAutoP


50 
	gpublic
:

51 
AutoP
(
T
 *
r
) :

52 
m_da
(
r
)

56 
AutoP
(cڡ AutoP<
T
> &
cd
)

58 
m_da
 = 
cd
.m_data;

59 
	gcd
.
	gm_da
 = 0;

62 
	gAutoP
 & 
	gݔ
=(cڡ 
AutoP
 &
cd
)

64 i(
this
 !&
cd
) {

65 
VidCeUnivlFe
<
T
> 
d
;

66 
	gd
.
univl_
(
m_da
);

67 
	gm_da
 = 
cd
.
m_da
;

68 
	gcd
.
	gm_da
 = 0;

70  *
	gthis
;

76 
T
* 
	gݔ
->()

78  
	gm_da
;

81 ~
AutoP
()

83 
	gVidCeUnivlFe
<
	gT
> 
	gd
;

84 
	gd
.
univl_
(
m_da
);

90 
T
* 
g
()

92  
	gm_da
;

95 
	give
:

96 
mub
 
T
 *
m_da
;

	@vcore/src/vcore/ValidatorFactories.cpp

22 
	~<vce/VidFaܛs.h
>

24 
	~<vce/Ctifi.h
>

25 
	~<vce/CtifiCfigRd.h
>

26 
	~<vce/Cfig.h
>

27 
	~<d/log/w_log.h
>

29 
	~<rg
>

31 
mea
 
	gVidiCe
 {

33 cڡ 
	gCtifiIdtifr
& 
CtifiIdtifr
()

35 
CtifiIdtifr
 
	gifiIdtifr
;

36 
bo
 
	glized
 = 
l
;

37 i(!
	glized
) {

38 
CtifiCfigRd
 
	gad
;

39 
	gd
::
rg
 
fe
 =

40 
CfigSgt
::
In
().
gXMLCfigPh
();

41 
WLogD
("Fwh fgli is: %s", 
fe
.
c_r
());

42 
	gd
::
rg
 
schema
 =

43 
CfigSgt
::
In
().
gXMLSchemaPh
();

44 
WLogD
("Fwh fgli schemis: %s", 
schema
.
c_r
());

45 
	gad
.
lize
(
fe
, 
schema
);

46 
	gad
.
ad
(
ifiIdtifr
);

48 
	glized
 = 
ue
;

50  
	gifiIdtifr
;

	@vcore/src/vcore/ValidatorFactories.h

22 #ide
_WRT_ENGINE_SRC_INSTALLER_CORE_VALIDATION_CORE_VALIDATORFACTORY_H_


23 
	#_WRT_ENGINE_SRC_INSTALLER_CORE_VALIDATION_CORE_VALIDATORFACTORY_H_


	)

25 
	~<CtifiIdtifr.h
>

27 
mea
 
	gVidiCe
 {

33 cڡ 
	gCtifiIdtifr
& 
CtifiIdtifr
();

	@vcore/src/vcore/VerificationStatus.cpp

22 
	~<vce/VifitiStus.h
>

24 
mea
 
	gVidiCe
 {

26 
	gVifitiStusS
::
VifitiStusS
()

27 : 
m_vdiM
(0)

30 
VifitiStusS
::
add
(
VifitiStus
 
us
) {

31 
m_vdiM
 |
us
;

34 
bo
 
	gVifitiStusS
::
cڏs
(
VifitiStus
 
us
) const {

35  
m_vdiM
 & 
us
;

38 
bo
 
	gVifitiStusS
::
isEmy
() const {

39  0 =
m_vdiM
;

42 
	gVifitiStusS
::
ݔ
+=(cڡ 
VifitiStusS
 &
cd
) {

43 
m_vdiM
 |
cd
.m_verdictMap;

46 
	gVifitiStusS
::
t
() {

47 
m_vdiM
 = 0;

50 
VifitiStus
 
	gVifitiStusS
::
cvtToStus
() const

52 i(
m_vdiM
 & 
VERIFICATION_STATUS_REVOKED
) {

53  
VERIFICATION_STATUS_REVOKED
;

56 i(
	gm_vdiM
 & 
	gVERIFICATION_STATUS_VERIFICATION_ERROR
) {

57  
	gVERIFICATION_STATUS_VERIFICATION_ERROR
;

60 i(
	gm_vdiM
 & 
	gVERIFICATION_STATUS_ERROR
) {

61  
	gVERIFICATION_STATUS_ERROR
;

64 i(
	gm_vdiM
 & 
	gVERIFICATION_STATUS_UNKNOWN
) {

65  
	gVERIFICATION_STATUS_UNKNOWN
;

68 i(
	gm_vdiM
 & 
	gVERIFICATION_STATUS_CONNECTION_FAILED
) {

69  
	gVERIFICATION_STATUS_CONNECTION_FAILED
;

72 i(
	gm_vdiM
 & 
	gVERIFICATION_STATUS_NOT_SUPPORT
) {

73  
	gVERIFICATION_STATUS_NOT_SUPPORT
;

76 i(
	gm_vdiM
 & 
	gVERIFICATION_STATUS_GOOD
) {

77  
	gVERIFICATION_STATUS_GOOD
;

80  
	gVERIFICATION_STATUS_ERROR
;

	@vcore/src/vcore/VerificationStatus.h

22 #ide
_VALIDATION_CORE_VERIFICATION_STATUS_H_


23 
	#_VALIDATION_CORE_VERIFICATION_STATUS_H_


	)

25 
mea
 
	gVidiCe
 {

26 
	eVifitiStus


32 
	gVERIFICATION_STATUS_GOOD
 = 1,

41 
	gVERIFICATION_STATUS_REVOKED
 = 1 << 1,

50 
	gVERIFICATION_STATUS_UNKNOWN
 = 1 << 2,

54 
	gVERIFICATION_STATUS_VERIFICATION_ERROR
 = 1 << 3,

58 
	gVERIFICATION_STATUS_NOT_SUPPORT
 = 1 << 4,

62 
	gVERIFICATION_STATUS_CONNECTION_FAILED
 = 1 << 5,

65 
	gVERIFICATION_STATUS_ERROR
 = 1 << 6

68 as
	cVifitiStusS


70 
	gpublic
:

71 
VifitiStusS
();

73 
add
(
VifitiStus
 
us
);

75 
bo
 
cڏs
(
VifitiStus
 
us
) const;

77 
bo
 
isEmy
() const;

79 
	gݔ
+=(cڡ 
VifitiStusS
 &
cd
);

81 
t
();

83 
VifitiStus
 
cvtToStus
() const;

85 
	give
:

86 
m_vdiM
;

90 
	eWidgVifitiStus


94 
	gWIDGET_VERIFICATION_STATUS_GOOD
,

96 
	gWIDGET_VERIFICATION_STATUS_REVOKED
,

	@vcore/src/vcore/WacOrigin.cpp

22 
	~"WacOrig.h
"

24 
	~<gܙhm
>

25 
	~<y.h
>

26 
	~<id.h
>

28 
	~<<d/log/log.h
>>

30 
	~<i.h
>

31 
	~"VidComm.h
"

33 
	gmea
 {

34 cڡ 
	gd
::
rg
 
SCHEME_HTTP
 = "http";

35 cڡ 
	gd
::
rg
 
SCHEME_HTTPS
 = "https";

36 cڡ 
	gPORT_HTTP
 = 80;

37 cڡ 
	gPORT_HTTPS
 = 443;

40 
mea
 
	gVidiCe
 {

41 
VC_DECLARE_DELETER
(
i_ru
, 
i_deroy
)

43 
	gWacOrig
::
WacOrig
(cڡ 
d
::
rg
 &
u
) :

44 
m_pt
(0),

45 
m_rFaed
(
l
)

47 
r
(
u
.
c_r
());

50 
	gWacOrig
::
WacOrig
(cڡ *
u
) :

51 
m_pt
(0),

52 
m_rFaed
(
l
)

54 
r
(
u
);

57 
bo
 
	gWacOrig
::
ݔ
==(cڡ 
WacOrig
 &
cd
) const

59 i(
m_rFaed
 || 
cd
.m_parseFailed) {

60  
l
;

63  (
	gm_scheme
 =
cd
.
m_scheme
) &&

64 (
m_ho
 =
cd
.m_host) &&

65 (
m_pt
 =
cd
.m_port);

68 
	gWacOrig
::
r
(cڡ *
u
)

75 
AutoP
<
i_ru
> 
i
(
i_r
(
u
));

76 i(!
	gi
.
g
()) {

77 
	gm_rFaed
 = 
ue
;

81 i(
	gi
->
	gscheme
) {

82 
	gm_scheme
 = 
i
->
scheme
;

84 
	gm_rFaed
 = 
ue
;

94 
	gd
::
sfm
(
m_scheme
.
beg
(), m_scheme.
d
(), m_scheme.beg(), 
tow
);

97 i((
	gm_scheme
 !
SCHEME_HTTP
&& (
m_scheme
 !
SCHEME_HTTPS
)) {

98 
m_rFaed
 = 
ue
;

105 i(
	gi
->
	gho
) {

106 
	gm_ho
 = 
i
->
ho
;

108 
	gm_rFaed
 = 
ue
;

113 *
	gouut
 = 
NULL
;

114 i(
	gIDNA_SUCCESS
 !=

115 
id_to_ascii_lz
(
m_ho
.
c_r
(), &
ouut
, 
IDNA_USE_STD3_ASCII_RULES
)) {

116 
WLogE
("libidnrror");

117 
	gm_rFaed
 = 
ue
;

118 

(
ouut
);

121 
	gm_ho
 = 
ouut
;

122 

(
ouut
);

125 
	gd
::
sfm
(
m_ho
.
beg
(), m_ho.
d
(), m_ho.beg(), ::
tow
);

128 i(
	gi
->
	gpt
) {

129 
	gm_pt
 = 
i
->
pt
;

131 
tPt
();

138 
	gWacOrig
::
tPt
()

140 i(
SCHEME_HTTP
 =
m_scheme
) {

141 
m_pt
 = 
PORT_HTTP
;

143 } i(
	gSCHEME_HTTPS
 =
m_scheme
) {

144 
m_pt
 = 
PORT_HTTPS
;

147 
WLogD
("Schem%in su܈by WAC2.0 ", 
m_scheme
.
c_r
());

148 
	gm_rFaed
 = 
ue
;

	@vcore/src/vcore/WacOrigin.h

25 #ide
_WRT_ENGINE_SRC_INSTALLER_CORE_VALIDATION_CORE_HTML5ORIGIN_H_


26 
	#_WRT_ENGINE_SRC_INSTALLER_CORE_VALIDATION_CORE_HTML5ORIGIN_H_


	)

28 
	~<rg
>

30 
mea
 
	gVidiCe
 {

31 as
	cWacOrig


33 
	gpublic
:

35 
WacOrig
(cڡ 
d
::
rg
 &
u
);

36 
WacOrig
(cڡ *
u
);

38 
bo
 
	gݔ
!=(cڡ 
WacOrig
 &
cd
) const

40  !(
ݔ
==(
cd
));

43 
bo
 
	gݔ
==(cڡ 
WacOrig
 &
cd
) const;

45 
	give
:

46 
r
(cڡ *
u
);

47 
tPt
();

49 
	gd
::
rg
 
m_scheme
;

50 
	gd
::
rg
 
m_ho
;

51 
	gm_pt
;

52 
bo
 
	gm_rFaed
;

	@vcore/src/vcore/WrtSignatureValidator.cpp

22 
	~<vce/WSigtuVid.h
>

24 
	~<vce/CtifiVifr.h
>

25 
	~<vce/Ctifi.h
>

26 
	~<vce/OCSPCtMgrUt.h
>

27 
	~<vce/RenVid.h
>

28 
	~<vce/VidFaܛs.h
>

29 
	~<vce/XmlcAdr.h
>

31 
	~<d/log/w_log.h
>

33 
	gmea
 {

34 cڡ 
time_t
 
	gTIMET_DAY
 = 60 * 60 * 24;

36 cڡ 
	gd
::
rg
 
TOKEN_ROLE_AUTHOR_URI
 =

38 cڡ 
	gd
::
rg
 
TOKEN_ROLE_DISTRIBUTOR_URI
 =

40 cڡ 
	gd
::
rg
 
TOKEN_PROFILE_URI
 =

45 
tm
 
	$_ASN1_GTimeT
(
ASN1_TIME
* 
time
)

47 
tm
 
t
;

48 cڡ * 
r
 = (cڡ *
time
->
da
;

49 
size_t
 
i
 = 0;

51 
	`memt
(&
t
, 0, (t));

53 i(
time
->
ty
 =
V_ASN1_UTCTIME
)

55 
t
.
tm_yr
 = (
r
[
i
] - '0') * 10 + (str[i+1] - '0');

56 
i
 += 2;

57 i(
t
.
tm_yr
 < 70)

58 
t
.
tm_yr
 += 100;

60 i(
time
->
ty
 =
V_ASN1_GENERALIZEDTIME
)

62 
t
.
tm_yr
 =

63 (
r
[
i
] - '0') * 1000

64 + (
r
[
i
+1] - '0') * 100

65 + (
r
[
i
+2] - '0') * 10

66 + (
r
[
i
+3] - '0');

67 
i
 += 4;

68 
t
.
tm_yr
 -= 1900;

70 
t
.
tm_m
 = ((
r
[
i
] - '0') * 10 + (str[i+1] - '0')) - 1;

71 
t
.
tm_mday
 = (
r
[
i
+2] - '0') * 10 + (str[i+3] - '0');

72 
t
.
tm_hour
 = (
r
[
i
+4] - '0') * 10 + (str[i+5] - '0');

73 
t
.
tm_m
 = (
r
[
i
+6] - '0') * 10 + (str[i+7] - '0');

74 
t
.
tm_c
 = (
r
[
i
+8] - '0') * 10 + (str[i+9] - '0');

77  
t
;

78 
	}
}

81 
mea
 
	gVidiCe
 {

83 as
	cWSigtuVid
::
Im
 {

84 
public
:

85 
vtu
 
WSigtuVid
::
Resu
 
check
(

86 
SigtuDa
 &
da
,

87 cڡ 
d
::
rg
 &
widgCڋPh
) = 0;

89 
exic
 
Im
(
bo
 
ocEb
,

90 
bo
 
lEb
,

91 
bo
 
comnMode
)

92 : 
m_comnModeEbd
(
comnMode
)

94 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


95 
m_ocEb
 = 
ocEb
;

96 
	gm_lEb
 = 
lEb
;

98 (
	gocEb
;

99 (
	glEb
;

103 
	gvtu
 ~
Im
() {}

105 
bo
 
checkReURI
(cڡ 
SigtuDa
 &
da
) {

106 
	gd
::
rg
 
reURI
 = 
da
.
gReURI
();

108 i(
	greURI
.
emy
()) {

109 
WLogW
("URIttribute in Roleag couldn't bempty.");

110  
	gl
;

113 i(
	greURI
 !
TOKEN_ROLE_AUTHOR_URI
 && 
da
.
isAuthSigtu
()) {

114 
WLogW
("URIttribute in Roleag doesot "

116  
	gl
;

119 i(
	greURI
 !
TOKEN_ROLE_DISTRIBUTOR_URI
 && !
da
.
isAuthSigtu
()) {

120 
WLogW
("URIttribute in Roleag doesot "

122  
	gl
;

124  
	gue
;

127 
bo
 
checkProfeURI
(cڡ 
SigtuDa
 &
da
) {

128 i(
	gTOKEN_PROFILE_URI
 !
da
.
gProfeURI
()) {

129 
WLogW
("Profg cڏunsu܋d vu URIribu (%s).", (
da
.
gProfeURI
()).
c_r
());

130  
	gl
;

132  
	gue
;

135 
bo
 
checkObjeRens
(cڡ 
SigtuDa
 &
da
) {

136 
ObjeLi
 
	gobjeLi
 = 
da
.
gObjeLi
();

137 
	gObjeLi
::
cڡ_
 

;

138 
	g
 = 
objeLi
.
beg
(); i!objeLi.
d
(); ++iter) {

139 i(!
	gda
.
cڏObjeRen
(*

)) {

140 
WLogW
("Sigtu d۠n cڏen f obje %s", (*

).
c_r
());

141  
	gl
;

144  
	gue
;

146 
	geed
:

147 
bo
 
m_comnModeEbd
;

148 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


149 
bo
 
	gm_ocEb
;

150 
bo
 
	gm_lEb
;

155 as
	cImTiz
 : 
public
 
WSigtuVid
::
Im
 {

156 
public
:

157 
WSigtuVid
::
Resu
 
check
(
SigtuDa
 &
da
,

158 cڡ 
d
::
rg
 &
widgCڋPh
);

160 
exic
 
ImTiz
(
bo
 
ocEb
,

161 
bo
 
lEb
,

162 
bo
 
comnMode
)

163 : 
Im
(
ocEb
, 
lEb
, 
comnMode
)

166 
	gvtu
 ~
ImTiz
() {}

169 
	gWSigtuVid
::
Resu
 
ImTiz
::
	$check
(

170 
SigtuDa
 &
da
,

171 cڡ 
d
::
rg
 &
widgCڋPh
)

173 
bo
 
diegd
 = 
l
;

175 i(!
	`checkReURI
(
da
)) {

176  
WSigtuVid
::
SIGNATURE_INVALID
;

179 i(!
	`checkProfeURI
(
da
)) {

180  
WSigtuVid
::
SIGNATURE_INVALID
;

185 
CtifiCi
 
ci
;

186 
ci
.
	`ld
(
da
.
	`gCtLi
());

189 i(!
ci
.
	`st
()) {

190 
	`WLogW
("Certificates doot form valid chain.");

191  
WSigtuVid
::
SIGNATURE_INVALID_CERT_CHAIN
;

195 i(
ci
.
	`emy
()) {

196 
	`WLogW
("Certificateist in signature ismpty.");

197  
WSigtuVid
::
SIGNATURE_INVALID_CERT_CHAIN
;

200 
CtifiLi
 
s܋dCtifiLi
 = 
ci
.
	`gCha
();

204 
s܋dCtifiLi
 =

205 
OCSPCtMgrUt
::
	`comeCtifiCha
(
s܋dCtifiLi
);

207 
CtifiP
 
ro
 = 
s܋dCtifiLi
.
	`back
();

210 
CtSteId
::
S
 
eIdS
 = 
	`CtifiIdtifr
().
	`fd
(
ro
);

212 
	`WLogD
("Iro ctifi from TIZEN_DEVELOPER doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
));

213 
	`WLogD
("Iro ctifi from TIZEN_TEST doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_TEST
));

214 
	`WLogD
("Iro ctifi from TIZEN_VERIFY doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_VERIFY
));

215 
	`WLogD
("Iro ctifi from TIZEN_PUBLIC doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
));

216 
	`WLogD
("Iro ctifi from TIZEN_PARTNER doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PARTNER
));

217 
	`WLogD
("Iro ctifi from TIZEN_PLATFORM doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PLATFORM
));

218 
	`WLogD
("Visibyev ipubli: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
));

219 
	`WLogD
("Visibyev iø: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PARTNER
));

220 
	`WLogD
("Visibyev ifm : %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PLATFORM
));

222 i(
da
.
	`isAuthSigtu
())

224 i(!
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
))

226 
	`WLogW
("author-signature.xml has got unrecognized Root CA "

228 
diegd
 = 
ue
;

233 i(
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
))

235 
	`WLogW
("distributor hasuthorevel siganture! Signature will be disregarded.");

236  
WSigtuVid
::
SIGNATURE_IN_DISTRIBUTOR_CASE_AUTHOR_CERT
;

238 
	`WLogD
("sigtufm%s", 
da
.
	`gSigtuFeName
().
	`c_r
());

241 i(
da
.
	`gSigtuNumb
() == 1)

243 i(
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
|| steIdS.cڏs(CtSteId::
VIS_PARTNER
|| steIdS.cڏs(CtSteId::
VIS_PLATFORM
))

245 
	`WLogD
("Root CA for signature1.xml is correct.");

249 
	`WLogW
("signature1.xml has got unrecognized Root CA "

251 
diegd
 = 
ue
;

256 
da
.
	`tStageTy
(
eIdS
);

257 
da
.
	`tS܋dCtifiLi
(
s܋dCtifiLi
);

261 
XmlSec
::
XmlSecCڋxt
 
cڋxt
;

262 
cڋxt
.
sigtuFe
 = 
da
.
	`gSigtuFeName
();

263 
cڋxt
.
ifiP
 = 
ro
;

268 i(!(
ro
->
	`isSigdBy
(root))) {

269 
	`WLogW
("Root CA certificateot found. Chain is incomplete.");

275 
time_t
 
nowTime
 = 
	`time
(
NULL
);

276 
	#CHECK_TIME


	)

277 #ifde
CHECK_TIME


279 
ASN1_TIME
* 
nATime
 = 
da
.
	`gEndEyCtifiP
()->
	`gNATime
();

280 
ASN1_TIME
* 
nBefeTime
 = 
da
.
	`gEndEyCtifiP
()->
	`gNBefeTime
();

282 i(
	`X509_cmp_time
(
nBefeTime
, &
nowTime
> 0 || X509_cmp_time(
nATime
, &nowTime) < 0)

284 
tm
 *
t
;

285 
tm
 

, 
tb
, 
tc
;

286 
msg
[1024];

288 
t
 = 
	`loime
(&
nowTime
);

289 i(!
t
)

290  
WSigtuVid
::
SIGNATURE_INVALID_CERT_TIME
;

292 
	`memt
(&
tc
, 0, (tc));

294 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
t
->
tm_yr
 + 1900,->
tm_m
 + 1,t->
tm_mday
 );

295 
	`WLogD
("## Syem'cutTim: %s", 
msg
);

296 
	`rtf
(
dr
, "## Syem'cutTim: %s\n", 
msg
);

298 
tb
 = 
	`_ASN1_GTimeT
(
nBefeTime
);

299 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tb
.
tm_yr
 + 1900,b.
tm_m
 + 1,tb.
tm_mday
 );

300 
	`WLogD
("## ctifi'nBefeTim: %s", 
msg
);

301 
	`rtf
(
dr
, "## ctifi'nBefeTim: %s\n", 
msg
);

303 

 = 
	`_ASN1_GTimeT
(
nATime
);

304 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 

.
tm_yr
 + 1900,a.
tm_m
 + 1,.
tm_mday
 );

305 
	`WLogD
("## ctifi'nATim: %s", 
msg
);

306 
	`rtf
(
dr
, "## ctifi'nATim: %s\n", 
msg
);

308 i(
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_TEST
|| steIdS.cڏs(CtSteId::
TIZEN_VERIFY
))

310 
	`WLogD
("## TIZEN_VERIFY : check certificate Time : FALSE");

311 
	`rtf
(
dr
, "## TIZEN_VERIFY : check certificate Time : FALSE\n");

312  
WSigtuVid
::
SIGNATURE_INVALID_CERT_TIME
;

315 
yr
 = (

.
tm_yr
 - 
tb
.tm_year) / 4;

317 if(
yr
 == 0)

319 
tc
.
tm_yr
 = 
tb
.tm_year;

320 
tc
.
tm_m
 = 
tb
.tm_mon + 1;

321 
tc
.
tm_mday
 = 
tb
.tm_mday;

323 if(
tc
.
tm_m
 == 12)

325 
tc
.
tm_yr
 = 

.tm_year;

326 
tc
.
tm_m
 = 

.tm_mon - 1;

327 
tc
.
tm_mday
 = 

.tm_mday;

329 if(
tc
.
tm_m
 < 0)

331 
tc
.
tm_yr
 = 

.tm_year;

332 
tc
.
tm_m
 = 

.tm_mon;

333 
tc
.
tm_mday
 = 

.tm_mday -1;

335 if(
tc
.
tm_mday
 == 0)

337 
tc
.
tm_yr
 = 
tb
.tm_year;

338 
tc
.
tm_m
 = 
tb
.tm_mon;

339 
tc
.
tm_mday
 = 
tb
.tm_mday +1;

345 
tc
.
tm_yr
 = 
tb
.tm_y+ 
yr
;

346 
tc
.
tm_m
 = (
tb
.tm_m + 

.tm_mon )/2;

347 
tc
.
tm_mday
 = (
tb
.tm_mday + 

.tm_mday)/2;

350 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tc
.
tm_yr
 + 1900,c.
tm_m
 + 1,tc.
tm_mday
 );

351 
	`WLogD
("## cm wh vidiځim: %s", 
msg
);

352 
	`rtf
(
dr
, "## cm wh vidiځim: %s\n", 
msg
);

354 
time_t
 
outCut
 = 
	`mktime
(&
tc
);

355 
cڋxt
.
vidiTime
 = 
outCut
;

357 
	`rtf
(
dr
, "## cmoutCutim: %ld\n", 
outCut
);

365 
time_t
 
nA
 = 
da
.
	`gEndEyCtifiP
()->
	`gNA
();

366 
time_t
 
nBefe
 = 
da
.
	`gEndEyCtifiP
()->
	`gNBefe
();

368 
tm
 *
t
;

370 i(
da
.
	`isAuthSigtu
())

381 i(
nBefe
 > 
nowTime
)

383 
	`WLogW
("Author certificate isxpired.otBeforeime is greaterhan system-time.");

385 
t
 = 
	`loime
(&
nowTime
);

386 
	`WLogD
("Syem'cuY: %d", (
t
->
tm_yr
 + 1900));

387 
	`WLogD
("Syem'cumth : %d", (
t
->
tm_m
 + 1));

388 
	`WLogD
("Syem'cuday : %d", (
t
->
tm_mday
));

390 
t
 = 
	`loime
(&
nBefe
);

391 
	`WLogD
("Auth ctifi'nBefܐY: %d", (
t
->
tm_yr
 + 1900));

392 
	`WLogD
("Auth ctifi'nBefܐmth : %d", (
t
->
tm_m
 + 1));

393 
	`WLogD
("Auth ctifi'nBefܐday : %d", (
t
->
tm_mday
));

395 
cڋxt
.
vidiTime
 = 
nBefe
 + 
TIMET_DAY
;

397 
t
 = 
	`loime
(&
cڋxt
.
vidiTime
);

398 
	`WLogD
("Modifd cuY: %d", (
t
->
tm_yr
 + 1900));

399 
	`WLogD
("Modifd cunBefܐmth : %d", (
t
->
tm_m
 + 1));

400 
	`WLogD
("Modifd cunBefܐday : %d", (
t
->
tm_mday
));

408 i(!
da
.
	`isAuthSigtu
())

410 i(
XmlSec
::
NO_ERROR
 !
XmlSecSgt
::
	`In
().
	`vide
(&
cڋxt
)) {

411 
	`WLogW
("Installation break - invalidackage!");

412  
WSigtuVid
::
SIGNATURE_INVALID_HASH_SIGNATURE
;

415 
da
.
	`tRen
(
cڋxt
.
nS
);

417 i(!
	`checkObjeRens
(
da
)) {

418 
	`WLogW
("Failedo check Object References");

419  
WSigtuVid
::
SIGNATURE_INVALID_HASH_SIGNATURE
;

422 
RenVid
 
	`feVid
(
widgCڋPh
);

423 i(
RenVid
::
NO_ERROR
 !
feVid
.
	`checkRens
(
da
)) {

424 
	`WLogW
("Invalidackage - fileeferences broken");

425  
WSigtuVid
::
SIGNATURE_INVALID_NO_HASH_FILE
;

429 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


434 i(!
m_comnModeEbd
 && !
da
.
	`isAuthSigtu
()) {

435 
CtifiCi
 
cl
;

436 
cl
.
	`ld
(
s܋dCtifiLi
);

438 i(!
cl
.
	`st
()) {

439 
	`WLogD
("Collection doesot contain chain!");

440  
WSigtuVid
::
SIGNATURE_INVALID_CERT_CHAIN
;

443 
CtifiVifr
 
	`vifit
(
m_ocEb
, 
m_lEb
);

444 
VifitiStus
 
su
 = 
vifit
.
	`check
(
cl
);

446 i(
su
 =
VERIFICATION_STATUS_REVOKED
) {

447  
WSigtuVid
::
SIGNATURE_REVOKED
;

450 i(
su
 =
VERIFICATION_STATUS_UNKNOWN
 ||

451 
su
 =
VERIFICATION_STATUS_ERROR
)

453 #ifde
_OCSP_POLICY_DISREGARD_UNKNOWN_OR_ERROR_CERTS_


454 
diegd
 = 
ue
;

460 i(
diegd
) {

461 
	`WLogW
("Signature is disregard. RootCA isot member of Tizen");

462  
WSigtuVid
::
SIGNATURE_INVALID_DISTRIBUTOR_CERT
;

464  
WSigtuVid
::
SIGNATURE_VERIFIED
;

465 
	}
}

467 as
	cImWac
 : 
public
 
WSigtuVid
::
Im


469 
public
:

470 
WSigtuVid
::
Resu
 
check
(
SigtuDa
 &
da
,

471 cڡ 
d
::
rg
 &
widgCڋPh
);

473 
exic
 
ImWac
(
bo
 
ocEb
,

474 
bo
 
lEb
,

475 
bo
 
comnMode
)

476 : 
Im
(
ocEb
, 
lEb
, 
comnMode
)

479 
	gvtu
 ~
ImWac
() {}

482 
	gWSigtuVid
::
Resu
 
ImWac
::
	$check
(

483 
SigtuDa
 &
da
,

484 cڡ 
d
::
rg
 &
widgCڋPh
)

486 
bo
 
diegd
 = 
l
;

488 i(!
	`checkReURI
(
da
)) {

489  
WSigtuVid
::
SIGNATURE_INVALID
;

492 i(!
	`checkProfeURI
(
da
)) {

493  
WSigtuVid
::
SIGNATURE_INVALID
;

498 
CtifiCi
 
ci
;

499 
ci
.
	`ld
(
da
.
	`gCtLi
());

502 i(!
ci
.
	`st
()) {

503 
	`WLogW
("Certificates doot form valid chain.");

504  
WSigtuVid
::
SIGNATURE_INVALID
;

508 i(
ci
.
	`emy
()) {

509 
	`WLogW
("Certificateist in signature ismpty.");

510  
WSigtuVid
::
SIGNATURE_INVALID
;

513 
CtifiLi
 
s܋dCtifiLi
 = 
ci
.
	`gCha
();

517 
s܋dCtifiLi
 =

518 
OCSPCtMgrUt
::
	`comeCtifiCha
(
s܋dCtifiLi
);

520 
CtifiP
 
ro
 = 
s܋dCtifiLi
.
	`back
();

523 
CtSteId
::
S
 
eIdS
 = 
	`CtifiIdtifr
().
	`fd
(
ro
);

525 
	`WLogD
("Iro ctifi from TIZEN_DEVELOPER doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
));

526 
	`WLogD
("Iro ctifi from TIZEN_TEST doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_TEST
));

527 
	`WLogD
("Iro ctifi from TIZEN_VERIFY doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_VERIFY
));

528 
	`WLogD
("Iro ctifi from TIZEN_PUBLIC doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
));

529 
	`WLogD
("Iro ctifi from TIZEN_PARTNER doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PARTNER
));

530 
	`WLogD
("Iro ctifi from TIZEN_PLATFORM doma: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PLATFORM
));

532 
	`WLogD
("Visibyev ipubli: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
));

533 
	`WLogD
("Visibyev iø: %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PARTNER
));

534 
	`WLogD
("Visibyev ifm : %d", 
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PLATFORM
));

536 i(
da
.
	`isAuthSigtu
())

538 i(!
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
))

540 
	`WLogW
("author-signature.xml has got unrecognized Root CA "

542 
diegd
 = 
ue
;

547 i(
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_DEVELOPER
))

549 
	`WLogW
("distributor hasuthorevel siganture! Signature will be disregarded.");

550  
WSigtuVid
::
SIGNATURE_INVALID
;

552 
	`WLogD
("sigtufm%s", 
da
.
	`gSigtuFeName
().
	`c_r
());

554 i(
da
.
	`gSigtuNumb
() == 1)

556 i(
eIdS
.
	`cڏs
(
CtSteId
::
VIS_PUBLIC
|| steIdS.cڏs(CtSteId::
VIS_PARTNER
|| steIdS.cڏs(CtSteId::
VIS_PLATFORM
))

558 
	`WLogD
("Root CA for signature1.xml is correct.");

562 
	`WLogW
("signature1.xml has got unrecognized Root CA "

564 
diegd
 = 
ue
;

569 
da
.
	`tStageTy
(
eIdS
);

570 
da
.
	`tS܋dCtifiLi
(
s܋dCtifiLi
);

574 
XmlSec
::
XmlSecCڋxt
 
cڋxt
;

575 
cڋxt
.
sigtuFe
 = 
da
.
	`gSigtuFeName
();

576 
cڋxt
.
ifiP
 = 
ro
;

581 i(!(
ro
->
	`isSigdBy
(root))) {

582 
	`WLogW
("Root CA certificateot found. Chain is incomplete.");

586 
time_t
 
nowTime
 = 
	`time
(
NULL
);

589 
	#CHECK_TIME


	)

590 #ifde
CHECK_TIME


592 
ASN1_TIME
* 
nATime
 = 
da
.
	`gEndEyCtifiP
()->
	`gNATime
();

593 
ASN1_TIME
* 
nBefeTime
 = 
da
.
	`gEndEyCtifiP
()->
	`gNBefeTime
();

595 i(
	`X509_cmp_time
(
nBefeTime
, &
nowTime
> 0 || X509_cmp_time(
nATime
, &nowTime) < 0)

597 
tm
 *
t
;

598 
tm
 

, 
tb
, 
tc
;

599 
msg
[1024];

601 
t
 = 
	`loime
(&
nowTime
);

602 i(!
t
)

603  
WSigtuVid
::
SIGNATURE_INVALID_CERT_TIME
;

605 
	`memt
(&
tc
, 0, (tc));

607 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
t
->
tm_yr
 + 1900,->
tm_m
 + 1,t->
tm_mday
 );

608 
	`WLogD
("## Syem'cutTim: %s", 
msg
);

609 
	`rtf
(
dr
, "## Syem'cutTim: %s\n", 
msg
);

611 
tb
 = 
	`_ASN1_GTimeT
(
nBefeTime
);

612 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tb
.
tm_yr
 + 1900,b.
tm_m
 + 1,tb.
tm_mday
 );

613 
	`WLogD
("## ctifi'nBefeTim: %s", 
msg
);

614 
	`rtf
(
dr
, "## ctifi'nBefeTim: %s\n", 
msg
);

616 

 = 
	`_ASN1_GTimeT
(
nATime
);

617 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 

.
tm_yr
 + 1900,a.
tm_m
 + 1,.
tm_mday
 );

618 
	`WLogD
("## ctifi'nATim: %s", 
msg
);

619 
	`rtf
(
dr
, "## ctifi'nATim: %s\n", 
msg
);

621 i(
eIdS
.
	`cڏs
(
CtSteId
::
TIZEN_VERIFY
))

623 
	`WLogD
("## TIZEN_VERIFY : check certificate Time : FALSE");

624 
	`rtf
(
dr
, "## TIZEN_VERIFY : check certificate Time : FALSE\n");

625  
WSigtuVid
::
SIGNATURE_INVALID
;

628 
yr
 = (

.
tm_yr
 - 
tb
.tm_year) / 4;

630 if(
yr
 == 0)

632 
tc
.
tm_yr
 = 
tb
.tm_year;

633 
tc
.
tm_m
 = 
tb
.tm_mon + 1;

634 
tc
.
tm_mday
 = 
tb
.tm_mday;

636 if(
tc
.
tm_m
 == 12)

638 
tc
.
tm_yr
 = 

.tm_year;

639 
tc
.
tm_m
 = 

.tm_mon - 1;

640 
tc
.
tm_mday
 = 

.tm_mday;

642 if(
tc
.
tm_m
 < 0)

644 
tc
.
tm_yr
 = 

.tm_year;

645 
tc
.
tm_m
 = 

.tm_mon;

646 
tc
.
tm_mday
 = 

.tm_mday -1;

648 if(
tc
.
tm_mday
 == 0)

650 
tc
.
tm_yr
 = 
tb
.tm_year;

651 
tc
.
tm_m
 = 
tb
.tm_mon;

652 
tc
.
tm_mday
 = 
tb
.tm_mday +1;

658 
tc
.
tm_yr
 = 
tb
.tm_y+ 
yr
;

659 
tc
.
tm_m
 = (
tb
.tm_m + 

.tm_mon )/2;

660 
tc
.
tm_mday
 = (
tb
.tm_mday + 

.tm_mday)/2;

663 
	`tf
(
msg
, (msg), "Yr: %d, mth: %d, day : %d", 
tc
.
tm_yr
 + 1900,c.
tm_m
 + 1,tc.
tm_mday
 );

664 
	`WLogD
("## cm wh vidiځim: %s", 
msg
);

665 
	`rtf
(
dr
, "## cm wh vidiځim: %s\n", 
msg
);

667 
time_t
 
outCut
 = 
	`mktime
(&
tc
);

669 
	`rtf
(
dr
, "## cmoutCutim: %ld\n", 
outCut
);

671 
cڋxt
.
vidiTime
 = 
outCut
;

678 
time_t
 
nA
 = 
da
.
	`gEndEyCtifiP
()->
	`gNA
();

679 
time_t
 
nBefe
 = 
da
.
	`gEndEyCtifiP
()->
	`gNBefe
();

681 
tm
 *
t
;

683 i(
da
.
	`isAuthSigtu
())

694 i(
nBefe
 > 
nowTime
)

696 
	`WLogW
("Author certificate isxpired.otBeforeime is greaterhan system-time.");

698 
t
 = 
	`loime
(&
nowTime
);

699 
	`WLogD
("Syem'cuY: %d", (
t
->
tm_yr
 + 1900));

700 
	`WLogD
("Syem'cumth : %d", (
t
->
tm_m
 + 1));

701 
	`WLogD
("Syem'cuday : %d", (
t
->
tm_mday
));

703 
t
 = 
	`loime
(&
nBefe
);

704 
	`WLogD
("Auth ctifi'nBefܐY: %d", (
t
->
tm_yr
 + 1900));

705 
	`WLogD
("Auth ctifi'nBefܐmth : %d", (
t
->
tm_m
 + 1));

706 
	`WLogD
("Auth ctifi'nBefܐday : %d", (
t
->
tm_mday
));

708 
cڋxt
.
vidiTime
 = 
nBefe
 + 
TIMET_DAY
;

710 
t
 = 
	`loime
(&
cڋxt
.
vidiTime
);

711 
	`WLogD
("Modifd cuY: %d", (
t
->
tm_yr
 + 1900));

712 
	`WLogD
("Modifd cunBefܐmth : %d", (
t
->
tm_m
 + 1));

713 
	`WLogD
("Modifd cunBefܐday : %d", (
t
->
tm_mday
));

718 i(!
da
.
	`isAuthSigtu
())

720 i(
XmlSec
::
NO_ERROR
 !
XmlSecSgt
::
	`In
().
	`vide
(&
cڋxt
)) {

721 
	`WLogW
("Installation break - invalidackage!");

722  
WSigtuVid
::
SIGNATURE_INVALID
;

725 
da
.
	`tRen
(
cڋxt
.
nS
);

727 i(!
	`checkObjeRens
(
da
)) {

728  
WSigtuVid
::
SIGNATURE_INVALID
;

731 
RenVid
 
	`feVid
(
widgCڋPh
);

732 i(
RenVid
::
NO_ERROR
 !
feVid
.
	`checkRens
(
da
)) {

733 
	`WLogW
("Invalidackage - fileeferences broken");

734  
WSigtuVid
::
SIGNATURE_INVALID
;

738 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


743 i(!
m_comnModeEbd
 && !
da
.
	`isAuthSigtu
()) {

744 
CtifiCi
 
cl
;

745 
cl
.
	`ld
(
s܋dCtifiLi
);

747 i(!
cl
.
	`st
()) {

748 
	`WLogD
("Collection doesot contain chain!");

749  
WSigtuVid
::
SIGNATURE_INVALID
;

752 
CtifiVifr
 
	`vifit
(
m_ocEb
, 
m_lEb
);

753 
VifitiStus
 
su
 = 
vifit
.
	`check
(
cl
);

755 i(
su
 =
VERIFICATION_STATUS_REVOKED
) {

756  
WSigtuVid
::
SIGNATURE_REVOKED
;

759 i(
su
 =
VERIFICATION_STATUS_UNKNOWN
 ||

760 
su
 =
VERIFICATION_STATUS_ERROR
)

762 #ifde
_OCSP_POLICY_DISREGARD_UNKNOWN_OR_ERROR_CERTS_


763 
diegd
 = 
ue
;

769 i(
diegd
) {

770 
	`WLogW
("Signature is disregard. RootCA isot member of Tizen.");

771  
WSigtuVid
::
SIGNATURE_DISREGARD
;

773  
WSigtuVid
::
SIGNATURE_VERIFIED
;

774 
	}
}

778 
	gWSigtuVid
::
	$WSigtuVid
(

779 
ATy
 
pTy
,

780 
bo
 
ocEb
,

781 
bo
 
lEb
,

782 
bo
 
comnMode
)

783 : 
	$m_im
(0)

785 i(
pTy
 =
TIZEN
)

786 
m_im
 = 
w
 
	`ImTiz
(
ocEb
,
lEb
,
comnMode
);

788 
m_im
 = 
w
 
	`ImWac
(
ocEb
,
lEb
,
comnMode
);

789 
	}
}

791 
	gWSigtuVid
::~
	$WSigtuVid
()

793 
de
 
m_im
;

794 
	}
}

796 
	gWSigtuVid
::
Resu
 
WSigtuVid
::
	$check
(

797 
SigtuDa
 &
da
,

798 cڡ 
d
::
rg
 &
widgCڋPh
)

800  
m_im
->
	`check
(
da
, 
widgCڋPh
);

801 
	}
}

	@vcore/src/vcore/WrtSignatureValidator.h

22 #ide
_VALIDATION_CORE_TIZENSIGNATUREVALIDATOR_H_


23 
	#_VALIDATION_CORE_TIZENSIGNATUREVALIDATOR_H_


	)

25 
	~<rg
>

27 
	~<vce/SigtuDa.h
>

29 
mea
 
	gVidiCe
 {

31 as
	cWSigtuVid
 {

32 
	gpublic
:

34 
ass
 
Im
;

36 
	eATy


38 
	gTIZEN
,

39 
	gWAC20


42 
	eResu


44 
	gSIGNATURE_VALID
,

45 
	gSIGNATURE_INVALID
,

46 
	gSIGNATURE_VERIFIED
,

47 
	gSIGNATURE_DISREGARD
,

48 
	gSIGNATURE_REVOKED
,

49 
	gSIGNATURE_INVALID_CERT_CHAIN
,

50 
	gSIGNATURE_INVALID_DISTRIBUTOR_CERT
,

51 
	gSIGNATURE_INVALID_SDK_DEFAULT_AUTHOR_CERT
,

52 
	gSIGNATURE_IN_DISTRIBUTOR_CASE_AUTHOR_CERT
,

53 
	gSIGNATURE_INVALID_CERT_TIME
,

54 
	gSIGNATURE_NO_DEVICE_PROFILE
,

55 
	gSIGNATURE_INVALID_DEVICE_UNIQUE_ID
,

56 
	gSIGNATURE_INVALID_NO_HASH_FILE
,

57 
	gSIGNATURE_INVALID_HASH_SIGNATURE


60 
WSigtuVid
(
de
;

61 
WSigtuVid
(cڡ WSigtuVid &
de
;

62 cڡ 
	gWSigtuVid
 &
	gݔ
=(cڡ 
WSigtuVid
 &
de
;

64 
exic
 
WSigtuVid
(

65 
ATy
 
pTy
,

66 
bo
 
ocEb
,

67 
bo
 
lEb
,

68 
bo
 
comnMode
);

70 
	gvtu
 ~
WSigtuVid
();

72 
Resu
 
check
(

73 
SigtuDa
 &
da
,

74 cڡ 
d
::
rg
 &
widgCڋPh
);

76 
	give
:

77 
Im
 *
m_im
;

	@vcore/src/vcore/XmlsecAdapter.cpp

22 
	~<cdlib
>

23 
	~<crg
>

25 
	~<libxml/.h
>

26 
	~<libxml/xmlmemy.h
>

27 
	~<libxml/rr.h
>

29 #ide
XMLSEC_NO_XSLT


30 
	~<libxt/xt.h
>

33 
	~<xmlc/xmlc.h
>

34 
	~<xmlc/xmɻe.h
>

35 
	~<xmlc/xmldsig.h
>

36 
	~<xmlc/yo.h
>

37 
	~<xmlc/io.h
>

38 
	~<xmlc/keyfo.h
>

39 
	~<xmlc/rs.h
>

41 
	~<d/as.h
>

42 
	~<d/log/w_log.h
>

44 
	~<vce/XmlcAdr.h
>

46 
	~<vce/VidComm.h
>

48 
	~<d/sgt_im.h
>

49 
	$IMPLEMENT_SINGLETON
(
VidiCe
::
XmlSec
)

51 
mea
 {

53 
	sFeW
 {

54 
	`FeW
(*
gFe
, 
bo
 
gRd
)

55 : 
	`fe
(
gFe
)

56 , 
	`ad
(
gRd
)

58 *
fe
;

59 
bo
 
ad
;

62 
	}
}

64 
mea
 
	gVidiCe
 {

65 
VC_DECLARE_DELETER
(
xmlSecKeysMngr
, 
xmlSecKeysMngrDeroy
)

67 cڡ * 
	gDIGEST_MD5
 = "md5";

69 
	gd
::
rg
 
XmlSec
::
s_efixPh
;

71 
	gXmlSec
::
feMchClback
(cڡ *
fame
)

73 
d
::
rg
 
th
 = 
s_efixPh
 + 
fame
;

74  
xmlFeMch
(
th
.
c_r
());

77 * 
	gXmlSec
::
feOnClback
(cڡ *
fame
)

79 
d
::
rg
 
th
 = 
s_efixPh
 + 
fame
;

82  
w
 
FeW
(
xmlFeOn
(
th
.
c_r
()),
l
);

85 
	gXmlSec
::
feRdClback
(*
cڋxt
,

86 *
bufr
,

87 
n
)

89 
FeW
 *
	gfw
 = 
ic_
<FeW*>(
cڋxt
);

90 i(
	gfw
->
	gad
) {

93 
	gouut
 = 
xmlFeRd
(
fw
->
fe
, 
bufr
, 
n
);

94 i(
	gouut
 == 0) {

95 
fw
->
ad
 = 
ue
;

96 
xmlFeClo
(
fw
->
fe
);

98  
	gouut
;

101 
	gXmlSec
::
feCloClback
(*
cڋxt
)

104 
FeW
 *
fw
 = 
ic_
<FeW*>(
cڋxt
);

105 
	gouut
 = 0;

106 i(!(
	gfw
->
	gad
)) {

107 
	gouut
 = 
xmlFeClo
(
fw
->
fe
);

109 
de
 
	gfw
;

110  
	gouut
;

113 
	gXmlSec
::
feExaPfix
(
XmlSecCڋxt
 *
cڋxt
)

115 i(!(
cڋxt
->
wkgDey
.
emy
())) {

116 
s_efixPh
 = 
cڋxt
->
wkgDey
;

120 
	gs_efixPh
 = 
cڋxt
->
sigtuFe
;

121 
size_t
 
	gpos
 = 
s_efixPh
.
rfd
('/');

122 i(
	gpos
 =
d
::
rg
::
os
) {

123 
s_efixPh
.
r
();

125 
	gs_efixPh
.
a
(
pos
 + 1, 
d
::
rg
::
os
);

129 
LogDebugPrt
(cڡ * 
fe
, 
le
, cڡ * 
func
,

130 cڡ * 
rObje
, cڡ * 
rSubje
,

131 
as
, cڡ * 
msg
)

133 
	gtٮ
[1024];

134 
tf
(
tٮ
, ٮ), "[%s:%d][%s] : [%s] : [%s] : [%s]", 
fe
, 
le
, 
func
, 
rObje
, 
rSubje
, 
msg
);

136 if(
	gas
 != 256)

138 
rtf
(
dr
, "## [vidr]: %s\n", 
tٮ
);

139 
WLogE
(" %s", 
tٮ
);

143 
WLogD
(" %s", 
tٮ
);

147 
	gXmlSec
::
XmlSec
() :

148 
m_lized
(
l
),

149 
m_noHash
(
l
),

150 
m_lHash
(
l
),

151 
m_pLi
(
NULL
)

153 
LIBXML_TEST_VERSION


154 
	gxmlLdExtDtdDeuVue
 = 
XML_DETECT_IDS
 | 
XML_COMPLETE_ATTRS
;

155 
xmlSubuEsDeu
(1);

156 #ide
XMLSEC_NO_XSLT


157 
	gxmlIndtTeOuut
 = 1;

160 i(
xmlSecIn
() < 0) {

161 
WLogE
("Xmlsec initialization failed.");

162 
ThrowMsg
(
Exi
::
IlE
, "Xmlsec initialization failed.");

165 i(
xmlSecCheckVsi
() != 1) {

166 
xmlSecShutdown
();

167 
WLogE
("Loaded xmlsecibrary version isot compatible.");

168 
ThrowMsg
(
Exi
::
IlE
,

172 #ifde
XMLSEC_CRYPTO_DYNAMIC_LOADING


173 i(
xmlSecCryoDLLdLibry
(
BAD_CAST
 
XMLSEC_CRYPTO
) < 0) {

174 
xmlSecShutdown
();

175 
WLogE
(

179 
ThrowMsg
(
Exi
::
IlE
,

184 i(
xmlSecCryoAIn
(
NULL
) < 0) {

185 
xmlSecShutdown
();

186 
WLogE
("Crypto initialization failed.");

187 
ThrowMsg
(
Exi
::
IlE
, "Crypto initialization failed.");

190 i(
xmlSecCryoIn
() < 0) {

191 
xmlSecCryoAShutdown
();

192 
xmlSecShutdown
();

193 
WLogE
("Xmlsec-crypto initialization failed.");

194 
ThrowMsg
(
Exi
::
IlE
,

198 
	gm_lized
 = 
ue
;

201 
	gXmlSec
::
delize
()

203 
As
(
m_lized
);

206 
xmlSecCryoShutdown
();

209 
xmlSecCryoAShutdown
();

212 
xmlSecShutdown
();

215 #ide
XMLSEC_NO_XSLT


216 
xtC˪upGlobs
();

219 
	gs_efixPh
.
r
();

220 
	gm_lized
 = 
l
;

223 
	gXmlSec
::~
XmlSec
()

225 
m_noHash

l
;

226 
	gm_lHash
 = 
l
;

227 i(
	gm_lized
) {

228 
delize
();

232 
	gXmlSec
::
Resu
 
XmlSec
::
videFe
(
XmlSecCڋxt
 *
cڋxt
,

233 
xmlSecKeysMngrP
 
mngr
)

235 
xmlDocP
 
	gdoc
 = 
NULL
;

236 
xmlNodeP
 
	gnode
 = 
NULL
;

237 
xmlSecDSigCtxP
 
	gdsigCtx
 = 
NULL
;

238 
	gsize
, 
	gs
 = -1;

240 
feExaPfix
(
cڋxt
);

241 
WLogD
("Pfixh: %s", 
s_efixPh
.
c_r
());

243 
xmlSecIOC˪upClbacks
();

245 
xmlSecIORegiClbacks
(

246 
feMchClback
,

247 
feOnClback
,

248 
feRdClback
,

249 
feCloClback
);

252 
	gdoc
 = 
xmlPFe
(
cڋxt
->
sigtuFe
.
c_r
());

253 i((
	gdoc
 =
NULL
|| (
xmlDocGRoEmt
(
doc
) == NULL)) {

254 
WLogW
("Ubˁطr f%s", (
cڋxt
->
sigtuFe
).
c_r
());

255 
	gde
;

259 
	gnode
 = 
xmlSecFdNode
(
xmlDocGRoEmt
(

260 
doc
), 
xmlSecNodeSigtu
, 
xmlSecDSigNs
);

261 i(
	gnode
 =
NULL
) {

262 
WLogW
("Sodn found i%s", (
cڋxt
->
sigtuFe
).
c_r
());

263 
	gde
;

267 
	gdsigCtx
 = 
xmlSecDSigCtxCe
(
mngr
);

268 i(
	gdsigCtx
 =
NULL
) {

269 
WLogE
("Failedo create signature context.");

270 
	gde
;

273 i(
	gcڋxt
->
	glowBrokCha
) {

274 
	gdsigCtx
->
	gkeyInfoRdCtx
.
	gags
 |=

275 
XMLSEC_KEYINFO_FLAGS_ALLOW_BROKEN_CHAIN
;

278 i(
	gcڋxt
->
	gvidiTime
) {

279 
WLogD
("Setting validationime.");

280 
	gdsigCtx
->
	gkeyInfoRdCtx
.
	gsVifitiTime
 = 
cڋxt
->
vidiTime
;

283 if
	gm_noHash
 =
ue
 || 
m_lHash
 ==rue ) {

284 
WLogD
("SignatureEx start >> ");

285 if
	gm_pLi
 =
NULL
 ) {

286 
WLogW
("## [validate]: uriList doesotxist" );

287 
rtf
(
dr
, "## [validate]: uriList doesotxist\n");

288 
	gs
 = 
xmlSecDSigCtxVifyEx
(
dsigCtx
, 
node
, 1, 
NULL
);

290 
	gn
 = 0;

291 
	gi
 = 0;

293 if(
	gm_pLi
 =
NULL
)

295 
WLogW
("## [validate]: uriList doesotxist" );

296 
rtf
(
dr
, "## [validate]: uriList doesotxist\n");

297 
	gs
 = -1;

298 
	gde
;

301 
	gn
 = 
m_pLi
->
size
();

303 * 
	gpLi
[
n
 + 1];

304 
	gd
::
li
<
d
::
rg
>::
cڡ_
 
r
 = 
m_pLi
->
beg
();

305 
	gd
::
rg
 
tmpSg
;

306 * 
	guri
 = 
NULL
;

307 
	gn
;

309 ; 
	gr
 !
m_pLi
->
d
(); ++itr) {

310 
	gtmpSg
 = (*
r
);

311 
	guri
 = (*)
tmpSg
.
c_r
();

312 
	gn
 = 

(
uri
);

313 
	gpLi
[
i
] = (*)
mloc
(
n
 + 1);

314 
memy
(
pLi
[
i
], 
uri
, 
n
);

315 
	gpLi
[
i
][
n
] = '\0';

316 
rtf
(
dr
, "## [vide]: uriLi[%d] = %s\n", 
i
, 
pLi
[i]);

317 ++
	gi
;

319 
	gpLi
[
n
] = '\0';

321 
	gs
 = 
xmlSecDSigCtxVifyEx
(
dsigCtx
, 
node
, 0, (*)
pLi
);

322 
	gi
 = 0;

323 
	gpLi
[
i
] !
NULL
) {

324 

(
pLi
[
i
]);

325 ++
	gi
;

329 if(
	gs
 < 0) {

330 
WLogE
("SignatureEx verifyrror.");

331 
rtf
(
dr
, "## [validaterror]: SignatureEx verifyrror\n");

332 
	gs
 = -1;

333 
	gde
;

336 
WLogD
("Signature start >> ");

339 i(
xmlSecDSigCtxVify
(
dsigCtx
, 
node
) < 0) {

340 
WLogE
("Signature verifyrror.");

341 
rtf
(
dr
, "## [validaterror]: Signature verifyrror\n");

342 
	gs
 = -1;

343 
	gde
;

347 i(
	gdsigCtx
->
	gkeyInfoRdCtx
.
	gags2
 &

348 
	gXMLSEC_KEYINFO_ERROR_FLAGS_BROKEN_CHAIN
) {

349 
WLogW
("XMLSEC_KEYINFO_FLAGS_ALLOW_BROKEN_CHAIN was setorue!");

350 
WLogW
("Signature contains broken chain!");

351 
	gcڋxt
->
	grBrokCha
 = 
ue
;

355 i(
	gdsigCtx
->
	gus
 =
xmlSecDSigStusSuceded
) {

356 
WLogD
("Signature is OK");

357 
	gs
 = 0;

359 
WLogD
("Signature is INVALID");

360 
	gs
 = -1;

361 
	gde
;

364 i(
	gdsigCtx
->
	gc14nMhod
 && dsigCtx->c14nMhod->
	gid
 &&

365 
	gdsigCtx
->
	gc14nMhod
->
	gid
->
	gme
) {

369 
	gsize
 = 
xmlSecPLiGSize
(&(
dsigCtx
->
sigdInfoRens
));

370 
	gi
 = 0; i < 
	gsize
; ++i) {

371 
xmlSecDSigRenCtxP
 
	gdsigRefCtx
 =

372 (
xmlSecDSigRenCtxP
)
xmlSecPLiGIm
(&(
dsigCtx
->

373 
sigdInfoRens
),

374 
i
);

375 i(
	gdsigRefCtx
 && dsigRefCtx->
	guri
) {

376 i(
	gdsigRefCtx
->
	gdigeMhod
 && dsigRefCtx->digeMhod->
	gid
 &&

377 
	gdsigRefCtx
->
	gdigeMhod
->
	gid
->
	gme
) {

378 cڡ * 
	gpDige
 =

379 
t_
<cڡ *>(
dsigRefCtx
->
digeMhod
->
id


380 ->
me
);

381 
	gd
::
rg
 
rDige
(
pDige
);

383 i(
	grDige
 =
DIGEST_MD5
) {

384 
WLogW
("MD5 digest method used! Please use sha");

385 
	gs
 = -1;

389 
	gcڋxt
->
	gnS
.

(
d
::
rg
(
t_
<*>(

390 
dsigRefCtx
->
uri
)));

394 
	gde
:

395 
m_pLi
 = 
NULL
;

396 
	gm_noHash
 = 
l
;

397 
	gm_lHash
 = 
l
;

400 i(
	gdsigCtx
 !
NULL
) {

401 
xmlSecDSigCtxDeroy
(
dsigCtx
);

404 i(
	gdoc
 !
NULL
) {

405 
xmlFeDoc
(
doc
);

408 i(
	gs
) {

409  
	gERROR_INVALID_SIGNATURE
;

411  
	gNO_ERROR
;

414 
	gXmlSec
::
ldDERCtifiMemy
(
XmlSecCڋxt
 *
cڋxt
,

415 
xmlSecKeysMngrP
 
mngr
)

417 *
	gdCtifi
 = 
NULL
;

418 
	gsize
 = 
i2d_X509
(
cڋxt
->
ifiP
->
gX509
(), &
dCtifi
);

420 i(!
	gdCtifi
) {

421 
WLogE
("Failed during x509 conversiono der format.");

422 
ThrowMsg
(
Exi
::
IlE
,

426 i(
xmlSecCryoAKeysMngrCtLdMemy
(
mngr
,

427 
dCtifi
,

428 
size
,

429 
xmlSecKeyDaFmD
,

430 
xmlSecKeyDaTyTrued
) < 0) {

431 
OPENSSL_
(
dCtifi
);

432 
WLogE
("Failedooad der certificate from memory.");

433 
ThrowMsg
(
Exi
::
IlE
,

437 
OPENSSL_
(
dCtifi
);

440 
	gXmlSec
::
ldPEMCtifiFe
(
XmlSecCڋxt
 *
cڋxt
,

441 
xmlSecKeysMngrP
 
mngr
)

443 i(
xmlSecCryoAKeysMngrCtLd
(
mngr
,

444 
cڋxt
->
ifiPh
.
c_r
(),

445 
xmlSecKeyDaFmPem
,

446 
xmlSecKeyDaTyTrued
) < 0) {

447 
WLogE
("Failedooad PEM certificate from file.");

448 
ThrowMsg
(
Exi
::
IlE
,

453 
	gXmlSec
::
Resu
 
XmlSec
::
vide
(
XmlSecCڋxt
 *
cڋxt
)

455 
As
(
cڋxt
);

456 
As
(!(
cڋxt
->
sigtuFe
.
emy
()));

457 
As
(
cڋxt
->
ifiP
.
g
(|| !(cڋxt->
ifiPh
.
emy
()));

459 
xmlSecEsSClback
(
LogDebugPrt
);

461 i(!
	gm_lized
) {

462 
WLogE
("XmlSec isot initialized.");

463 
ThrowMsg
(
Exi
::
IlE
, "XmlSec isot initialized");

466 
	gAutoP
<
	gxmlSecKeysMngr
> 
mngr
(
xmlSecKeysMngrCe
());

468 i(!
	gmngr
.
g
()) {

469 
WLogE
("Failedo create keys manager.");

470 
ThrowMsg
(
Exi
::
IlE
, "Failedo create keys manager.");

473 i(
xmlSecCryoADeuKeysMngrIn
(
mngr
.
g
()) < 0) {

474 
WLogE
("Failedo initialize keys manager.");

475 
ThrowMsg
(
Exi
::
IlE
, "Failedo initialize keys manager.");

477 
	gcڋxt
->
	gnS
.
r
();

479 i(
	gcڋxt
->
	gifiP
.
g
()) {

480 
ldDERCtifiMemy
(
cڋxt
, 
mngr
.
g
());

483 i(!
	gcڋxt
->
	gifiPh
.
emy
()) {

484 
ldPEMCtifiFe
(
cڋxt
, 
mngr
.
g
());

487  
videFe
(
cڋxt
, 
mngr
.
g
());

490 
	gXmlSec
::
Resu
 
XmlSec
::
videNoHash
(
XmlSecCڋxt
 *
cڋxt
)

492 
xmlSecEsSClback
(
LogDebugPrt
);

494 
	gm_noHash
 = 
ue
;

495  
vide
(
cڋxt
);

498 
	gXmlSec
::
Resu
 
XmlSec
::
videPtlHash
(
XmlSecCڋxt
 *
cڋxt
)

500 
xmlSecEsSClback
(
LogDebugPrt
);

502 
	gm_lHash
 = 
ue
;

503  
vide
(
cڋxt
);

506 
	gXmlSec
::
Resu
 
XmlSec
::
tPtlHashLi
(cڡ 
d
::
li
<d::
rg
>& 
rgUri
)

508 
xmlSecEsSClback
(
LogDebugPrt
);

510 
	gm_pLi
 = (
d
::
li
<d::
rg
>*)&
rgUri
;

511  
	gNO_ERROR
;

	@vcore/src/vcore/XmlsecAdapter.h

22 #ide
_VALIDATION_CORE_XMLSECADAPTER_H_


23 
	#_VALIDATION_CORE_XMLSECADAPTER_H_


	)

25 
	~<xmlc/keysmngr.h
>

27 
	~<d/exi.h
>

28 
	~<d/ncyab.h
>

29 
	~<d/sgt.h
>

31 
	~<vce/Ctifi.h
>

32 
	~<vce/SigtuDa.h
>

34 
mea
 
	gVidiCe
 {

35 as
	cXmlSec
 : 
public
 
VceDPL
::
Ncyab


37 
public
:

39 
	sXmlSecCڋxt


42 
XmlSecCڋxt
() :

43 
vidiTime
(0),

44 
lowBrokCha
(
l
),

45 
rBrokCha
(
l
)

52 
	gd
::
rg
 
sigtuFe
;

58 
	gd
::
rg
 
wkgDey
;

62 
	gd
::
rg
 
ifiPh
;

66 
CtifiP
 
	gifiP
;

71 
time_t
 
	gvidiTime
;

78 
bo
 
	glowBrokCha
;

83 
bo
 
	grBrokCha
;

88 
RenS
 
	gnS
;

91 
	eResu


93 
	gNO_ERROR
,

94 
	gERROR_INVALID_SIGNATURE


97 as
	cExi


99 
	gpublic
:

100 
DECLARE_EXCEPTION_TYPE
(
VceDPL
::
Exi
, 
Ba
)

101 
DECLARE_EXCEPTION_TYPE
(
Ba
, 
IlE
)

107 
Resu
 
vide
(
XmlSecCڋxt
 *
cڋxt
);

108 
Resu
 
videNoHash
(
XmlSecCڋxt
 *
cڋxt
);

109 
Resu
 
videPtlHash
(
XmlSecCڋxt
 *
cڋxt
);

110 
Resu
 
tPtlHashLi
(cڡ 
d
::
li
<d::
rg
>& 
rgUri
);

112 
	geed
:

113 
XmlSec
();

114 ~
XmlSec
();

115 
	give
:

116 
delize
();

118 
ldDERCtifiMemy
(
XmlSecCڋxt
 *
cڋxt
,

119 
xmlSecKeysMngrP
 
mngr
);

120 
ldPEMCtifiFe
(
XmlSecCڋxt
 *
cڋxt
,

121 
xmlSecKeysMngrP
 
mngr
);

122 
Resu
 
videFe
(
XmlSecCڋxt
 *
cڋxt
,

123 
xmlSecKeysMngrP
 
mngr
);

125 
bo
 
	gm_lized
;

126 
bo
 
	gm_noHash
;

127 
bo
 
	gm_lHash
;

128 
	gd
::
li
<
d
::
rg
>* 
m_pLi
;

130 
	gd
::
rg
 
s_efixPh
;

131 
feMchClback
(cڡ *
fame
);

132 * 
feOnClback
(cڡ *
fame
);

133 
feRdClback
(*
cڋxt
,

134 *
bufr
,

135 
n
);

136 
feCloClback
(*
cڋxt
);

137 
feExaPfix
(
XmlSecCڋxt
 *
cڋxt
);

140 
	gVceDPL
::
	tSgt
<
	tXmlSec
> 
	tXmlSecSgt
;

	@vcore/src/vcore/api.cpp

23 
	~<unid.h
>

24 
	~<sys/tys.h
>

25 
	~<sys/.h
>

26 
	~<f.h
>

27 
	~<o.h
>

29 
	~<gܙhm
>

30 
	~<fam
>

31 
	~<m
>

32 
	~<memy
>

33 
	~<t
>

34 
	~<rg
>

35 
	~<ve
>

37 
	~<glib-obje.h
>

39 
	~<ݒs/m.h
>

40 
	~<ݒs/s.h
>

41 
	~<ݒs/x509v3.h
>

42 
	~<ݒs/pkcs12.h
>

43 
	~<ݒs/r.h
>

44 
	~<ݒs/sha.h
>

45 
	~<ݒs/evp.h
>

46 
	~<ݒs/bio.h
>

48 
	~<d/fܗch.h
>

49 
	~<d/log/w_log.h
>

51 
	~<-svc/c.h
>

52 
	~<-svc/c.h
>

53 
	~<-svc/kcs12.h
>

54 
	~<-svc/rimives.h
>

56 
	~<vce/Ba64.h
>

57 
	~<vce/Ctifi.h
>

58 
	~<vce/CtifiCi.h
>

59 
	~<vce/pkcs12.h
>

61 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


62 
	~<-svc/cl.h
>

63 
	~<-svc/coc.h
>

64 
	~<vce/OCSP.h
>

65 
	~<vce/CRL.h
>

66 
	~<vce/CRLCacheI.h
>

69 
	~<libxml/rr.h
>

70 
	~<libxml/.h
>

72 
	#START_CERT
 "-----BEGIN CERTIFICATE-----"

	)

73 
	#END_CERT
 "-----END CERTIFICATE-----"

	)

74 
	#START_TRUSTED
 "-----BEGIN TRUSTED CERTIFICATE-----"

	)

75 
	#END_TRUSTED
 "-----END TRUSTED CERTIFICATE-----"

	)

77 #ide
LOG_TAG


78 
	#LOG_TAG
 "CERT_SVC"

	)

81 
usg
 
mea
 
	gVidiCe
;

83 
	gmea
 {

85 
	gd
::
	tunique_r
<
	tCERT_CONTEXT
, 
	td
::
	tfuni
<(CERT_CONTEXT*)> > 
	tScedCtCtx
;

87 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


88 as
	cCRLCacheCAPI
 : 
public
 
CRLCacheI
 {

89 
public
:

90 
CRLCacheCAPI
(

91 
CtSvcCCacheWre
 
lWre
,

92 
CtSvcCCacheRd
 
lRd
,

93 
CtSvcCFe
 
lFe
,

94 *
urPam
)

95 : 
m_lWre
(
lWre
)

96 , 
m_lRd
(
lRd
)

97 , 
m_lFe
(
lFe
)

98 , 
m_urPam
(
urPam
)

101 
bo
 
gCRLReڣ
(
CRLCachedDa
 *
r
){

102 i(!
	gm_lRd
 || !
	gm_lFe
)

103  
	gl
;

105 *
	gbufr
;

106 
	gsize
;

108 
bo
 
	gsu
 = 
m_lRd
(

109 
r
->
diributi_pot
.
c_r
(),

110 &
bufr
,

111 &
size
,

112 &(
r
->
xt_upde_time
),

113 
m_urPam
);

115 i(
	gsu
) {

116 
	gr
->
	gl_body
.
r
();

117 
	gr
->
	gl_body
.
nd
(
bufr
, 
size
);

118 
m_lFe
(
bufr
, 
m_urPam
);

121  
	gsu
;

123 
tCRLReڣ
(
CRLCachedDa
 *
r
){

124 i(
	gm_lWre
) {

125 
m_lWre
(

126 
r
->
diributi_pot
.
c_r
(),

127 
r
->
l_body
.
c_r
(),

128 
r
->
l_body
.
size
(),

129 
r
->
xt_upde_time
,

130 
m_urPam
);

134 
	give
:

135 
CtSvcCCacheWre
 
m_lWre
;

136 
CtSvcCCacheRd
 
	gm_lRd
;

137 
CtSvcCFe
 
	gm_lFe
;

138 *
	gm_urPam
;

142 as
	cCtSvcInIm
 {

143 
	gpublic
:

144 
CtSvcInIm
()

145 : 
m_ifiCou
(0)

146 , 
m_idLiCou
(0)

147 , 
m_rgLiCou
(0)

148 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


149 , 
m_lWre
(
NULL
)

150 , 
m_lRd
(
NULL
)

151 , 
m_lFe
(
NULL
)

155 ~
CtSvcInIm
(){

156 
FOREACH
(

, 
m_lodSgS
) {

157 
	gde
[] *
	g
;

161 
le
 
t
(){

162 
	gm_ifiCou
 = 0;

163 
	gm_ifiM
.
r
();

164 
	gm_idLiCou
 = 0;

165 
	gm_idLiM
.
r
();

166 
	gm_rgLiCou
 = 0;

167 
	gm_rgLiM
.
r
();

169 
FOREACH
(

, 
m_lodSgS
) {

170 
	gde
[] *
	g
;

173 
	gm_lodSgS
.
r
();

176 
le
 
addCt
(cڡ 
CtifiP
 &

) {

177 
	gm_ifiM
[
m_ifiCou
] = 

;

178  
	gm_ifiCou
++;

181 
le
 
moveCt
(cڡ 
CtSvcCtifi
 &

) {

182 aut
	g
 = 
m_ifiM
.
fd
(

.
iveHdr
);

183 i(
	g
 !
m_ifiM
.
d
()) {

184 
m_ifiM
.
a
(

);

188 
le
 
gCtFromLi
(

189 cڡ 
CtSvcCtifiLi
 &
hdr
,

190 
posi
,

191 
CtSvcCtifi
 *
ifi
)

193 aut
	g
 = 
m_idLiM
.
fd
(
hdr
.
iveHdr
);

194 i(
	g
 =
m_idLiM
.
d
()) {

195  
CERTSVC_WRONG_ARGUMENT
;

197 i(
	gposi
 >
ic_
<>(

->
cd
.
size
())) {

198  
CERTSVC_WRONG_ARGUMENT
;

200 
	gifi
->
	giveIn
 = 
hdr
.
iveIn
;

201 
	gifi
->
	giveHdr
 = (

->
cd
)[
posi
];

202  
	gCERTSVC_SUCCESS
;

205 
le
 
gCtLiL
(cڡ 
CtSvcCtifiLi
 &
hdr
, *
n
) {

206 aut
	g
 = 
m_idLiM
.
fd
(
hdr
.
iveHdr
);

207 i(
	g
 =
m_idLiM
.
d
(|| !
n
) {

208  
CERTSVC_WRONG_ARGUMENT
;

210 *
	gn
 = (

->
cd
).
size
();

211  
	gCERTSVC_SUCCESS
;

214 
le
 
moveCtLi
(cڡ 
CtSvcCtifiLi
 &
hdr
) {

215 aut
	g
 = 
m_idLiM
.
fd
(
hdr
.
iveHdr
);

216 i(
	g
 !
m_idLiM
.
d
())

217 
m_idLiM
.
a
(

);

220 
le
 
isSigdBy
(cڡ 
CtSvcCtifi
 &
chd
,

221 cڡ 
CtSvcCtifi
 &

,

222 *
us
)

224 aut
	gc
 = 
m_ifiM
.
fd
(
chd
.
iveHdr
);

225 i(
	gc
 =
m_ifiM
.
d
()) {

226  
CERTSVC_WRONG_ARGUMENT
;

228 aut
	gp
 = 
m_ifiM
.
fd
(

.
iveHdr
);

229 i(
	gp
 =
m_ifiM
.
d
()) {

230  
CERTSVC_WRONG_ARGUMENT
;

233 i(
	gc
->
	gcd
->
isSigdBy
(
p
->
cd
)) {

234 *
	gus
 = 
CERTSVC_TRUE
;

236 *
	gus
 = 
CERTSVC_FALSE
;

238  
	gCERTSVC_SUCCESS
;

241 
le
 
gFld
(cڡ 
CtSvcCtifi
 &

,

242 
CtSvcCtifiFld
 
fld
,

243 
CtSvcSg
 *
bufr
)

245 aut
	g
 = 
m_ifiM
.
fd
(

.
iveHdr
);

246 i(
	g
 =
m_ifiM
.
d
()) {

247  
CERTSVC_WRONG_ARGUMENT
;

250 aut
	gP
 = 

->
cd
;

251 
	gd
::
rg
 
su
;

252 
	gfld
) {

253 
	gCERTSVC_SUBJECT
:

254 
su
 = 
P
->
gOLe
();

256 
	gCERTSVC_ISSUER
:

257 
su
 = 
P
->
gOLe
(
Ctifi
::
FIELD_ISSUER
);

259 
	gCERTSVC_SUBJECT_COMMON_NAME
:

260 
su
 = 
P
->
gCommName
();

262 
	gCERTSVC_SUBJECT_COUNTRY_NAME
:

263 
su
 = 
P
->
gCouryName
();

265 
	gCERTSVC_SUBJECT_STATE_NAME
:

266 
su
 = 
P
->
gSOrProvName
();

268 
	gCERTSVC_SUBJECT_ORGANIZATION_NAME
:

269 
su
 = 
P
->
gOrgiziName
();

271 
	gCERTSVC_SUBJECT_ORGANIZATION_UNIT_NAME
:

272 
su
 = 
P
->
gOrgiziڮUnName
();

274 
	gCERTSVC_SUBJECT_EMAIL_ADDRESS
:

275 
su
 = 
P
->
gEmaAdds
();

277 
	gCERTSVC_ISSUER_COMMON_NAME
:

278 
su
 = 
P
->
gCommName
(
Ctifi
::
FIELD_ISSUER
);

280 
	gCERTSVC_ISSUER_STATE_NAME
:

281 
su
 = 
P
->
gSOrProvName
(
Ctifi
::
FIELD_ISSUER
);

283 
	gCERTSVC_ISSUER_ORGANIZATION_NAME
:

284 
su
 = 
P
->
gOrgiziName
(
Ctifi
::
FIELD_ISSUER
);

286 
	gCERTSVC_ISSUER_ORGANIZATION_UNIT_NAME
:

287 
su
 = 
P
->
gOrgiziڮUnName
(
Ctifi
::
FIELD_ISSUER
);

289 
	gCERTSVC_VERSION
:

291 
d
::
rgam
 
am
;

292 
	gam
 << (
	gP
->
gVsi
()+1);

293 
	gsu
 = 
am
.
r
();

296 
	gCERTSVC_SERIAL_NUMBER
:

297 
su
 = 
P
->
gSlNumbSg
();

299 
	gCERTSVC_KEY_USAGE
:

300 
su
 = 
P
->
gKeyUgeSg
();

302 
	gCERTSVC_KEY
:

303 
su
 = 
P
->
gPublicKeySg
();

305 
	gCERTSVC_SIGNATURE_ALGORITHM
:

306 
su
 = 
P
->
gSigtuAlgܙhmSg
();

312 i(
	gsu
.
emy
()) {

313 
	gbufr
->
	giveHdr
 = 
NULL
;

314 
	gbufr
->
	giveLgth
 = 0;

315 
	gbufr
->
	giveIn
 = 

.
iveIn
;

316  
	gCERTSVC_SUCCESS
;

319 *
	gcrg
 = 
w
 [
su
.
size
()+1];

320 i(
	gcrg
 =
NULL
) {

321 
bufr
->
iveHdr
 = 
NULL
;

322 
	gbufr
->
	giveLgth
 = 0;

323 
	gbufr
->
	giveIn
 = 

.
iveIn
;

324  
	gCERTSVC_BAD_ALLOC
;

327 
y
(
crg
, 
su
.
c_r
(),esu.
size
()+1);

329 
	gbufr
->
	giveHdr
 = 
crg
;

330 
	gbufr
->
	giveLgth
 = 
su
.
size
();

331 
	gbufr
->
	giveIn
 = 

.
iveIn
;

333 
	gm_lodSgS
.

(
crg
);

335  
	gCERTSVC_SUCCESS
;

338 
le
 
gNA
(cڡ 
CtSvcCtifi
 &

,

339 
time_t
 *
time
)

341 aut
	g
 = 
m_ifiM
.
fd
(

.
iveHdr
);

342 i(
	g
 =
m_ifiM
.
d
()) {

343  
CERTSVC_WRONG_ARGUMENT
;

345 *
	gtime
 = 

->
cd
->
gNA
();

346  
	gCERTSVC_SUCCESS
;

349 
le
 
gNBefe
(cڡ 
CtSvcCtifi
 &

,

350 
time_t
 *
time
)

352 aut
	g
 = 
m_ifiM
.
fd
(

.
iveHdr
);

353 i(
	g
 =
m_ifiM
.
d
()) {

354  
CERTSVC_WRONG_ARGUMENT
;

356 *
	gtime
 = 

->
cd
->
gNBefe
();

357  
	gCERTSVC_SUCCESS
;

360 
le
 
isRoCA
(cڡ 
CtSvcCtifi
 &

, *
us
){

361 aut
	g
 = 
m_ifiM
.
fd
(

.
iveHdr
);

362 i(
	g
 =
m_ifiM
.
d
()) {

363  
CERTSVC_WRONG_ARGUMENT
;

365 i(
	g
->
	gcd
->
isRoCt
()) {

366 *
	gus
 = 
CERTSVC_TRUE
;

368 *
	gus
 = 
CERTSVC_FALSE
;

370  
	gCERTSVC_SUCCESS
;

373 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


374 
le
 
gC
(cڡ 
CtSvcCtifi
 &

, 
CtSvcSgLi
 *
hdr
){

375 aut
	g
 = 
m_ifiM
.
fd
(

.
iveHdr
);

376 i(
	g
 =
m_ifiM
.
d
()) {

377  
CERTSVC_WRONG_ARGUMENT
;

379 
	gposi
 = 
m_rgLiCou
++;

381 
	gd
::
li
<
d
::
rg
> 
mp
 = 

->
cd
->
gCUris
();

382 
	gd
::
cy
(
mp
.
beg
(),

383 
mp
.
d
(),

384 
back_
(
m_rgLiM
[
posi
]));

386 
	ghdr
->
	giveHdr
 = 
posi
;

387 
	ghdr
->
	giveIn
 = 

.
iveIn
;

389  
	gCERTSVC_SUCCESS
;

393 
le
 
gSgFromLi
(

394 cڡ 
CtSvcSgLi
 &
hdr
,

395 
posi
,

396 
CtSvcSg
 *
bufr
)

398 
	gbufr
->
	giveHdr
 = 
NULL
;

399 
	gbufr
->
	giveLgth
 = 0;

401 aut
	g
 = 
m_rgLiM
.
fd
(
hdr
.
iveHdr
);

402 i(
	g
 =
m_rgLiM
.
d
()) {

403  
CERTSVC_WRONG_ARGUMENT
;

405 i(
	gposi
 >()

->
cd
.
size
()) {

406  
CERTSVC_WRONG_ARGUMENT
;

408 cڡ 
	gd
::
rg
 &
da
 = 

->
cd
.

(
posi
);

409 
	gsize
 = 
da
.
size
();

410 *
	gcrg
 = 
w
 [
size
+1];

411 i(!
	gcrg
) {

412  
	gCERTSVC_FAIL
;

415 
y
(
crg
, 
da
.
c_r
(), da.
size
()+1);

417 
	gbufr
->
	giveHdr
 = 
crg
;

418 
	gbufr
->
	giveLgth
 = 
da
.
size
();

419 
	gbufr
->
	giveIn
 = 
hdr
.
iveIn
;

421 
	gm_lodSgS
.

(
crg
);

423  
	gCERTSVC_SUCCESS
;

426 
le
 
gSgLiL
(

427 cڡ 
CtSvcSgLi
 &
hdr
,

428 *
size
)

430 aut
	g
 = 
m_rgLiM
.
fd
(
hdr
.
iveHdr
);

431 i(
	g
 =
m_rgLiM
.
d
()) {

432  
CERTSVC_WRONG_ARGUMENT
;

434 *
	gsize
 = (

->
cd
.
size
();

435  
	gCERTSVC_SUCCESS
;

438 
le
 
moveSgLi
(cڡ 
CtSvcSgLi
 &
hdr
)

440 
	gm_rgLiM
.
a
(
m_rgLiM
.
fd
(
hdr
.
iveHdr
));

443 
le
 
moveSg
(cڡ 
CtSvcSg
 &
hdr
)

445 aut
	g
 = 
m_lodSgS
.
fd
(
hdr
.
iveHdr
);

446 i(
	g
 !
m_lodSgS
.
d
()) {

447 
de
[] *

;

448 
	gm_lodSgS
.
a
(

);

452 
le
 
ifiSrch
(

453 
CtSvcIn
 

,

454 
CtSvcCtifiFld
 
fld
,

455 cڡ *
vue
,

456 
CtSvcCtifiLi
 *
hdr
)

458 
	gsu
;

459 
ch_fld
 
	gfldId
 = 
SEARCH_FIELD_END
;

461 
	gfld
){

462 
	gCERTSVC_SUBJECT
:

463 
fldId
 = 
SUBJECT_STR
;

465 
	gCERTSVC_ISSUER
:

466 
fldId
 = 
ISSUER_STR
;

468 
	gCERTSVC_SUBJECT_COMMON_NAME
:

469 
fldId
 = 
SUBJECT_COMMONNAME
;

472 
WLogE
("Not implemented!");

473  
	gCERTSVC_WRONG_ARGUMENT
;

476 
ScedCtCtx
 
x
(
_svc__cڋxt_
(),

477 
_svc__cڋxt_f
);

479 i(
	gx
.
g
(=
NULL
) {

480 
WLogW
("Error in cert_svc_cert_context_init.");

481  
	gCERTSVC_FAIL
;

484 
WLogD
("Mch sg: %s", 
vue
);

485 
	gsu
 = 
_svc_ch_ifi
(
x
.
g
(), 
fldId
, 
cڡ_
<*>(
vue
));

486 
WLogD
("Search finished!");

488 i(
	gCERT_SVC_ERR_NO_ERROR
 !
su
) {

489 
WLogW
("Error during certificate search");

490  
	gCERTSVC_FAIL
;

493 
_svc_fame_li
 *
	gfeLi
 = 
x
.
g
()->
feNames
;

495 
	gliId
 = 
m_idLiCou
++;

496 
	gd
::
ve
<> &
li
 = 
m_idLiM
[
liId
];

497 
	ghdr
->
	giveHdr
 = 
liId
;

498 
	ghdr
->
	giveIn
 = 

;

500 ;
	gfeLi
 !
NULL
; feLi = 
feLi
->
xt
) {

501 
ScedCtCtx
 
x2
(
_svc__cڋxt_
(),

502 
_svc__cڋxt_f
);

503 i(
	gx2
.
g
(=
NULL
) {

504 
WLogW
("Error in cert_svc_cert_context_init.");

505  
	gCERTSVC_FAIL
;

509 i(
	gCERT_SVC_ERR_NO_ERROR
 !=

510 
_svc_ld_fe_to_cڋxt
(
x2
.
g
(), 
feLi
->
fame
))

512 
WLogW
("Error in cert_svc_load_file_to_context");

513  
	gCERTSVC_FAIL
;

515 
	gId
 = 
addCt
(
CtifiP
(
w
 
Ctifi
(*(
x2
.
g
()->
Buf
))));

516 
	gli
.
push_back
(
Id
);

518  
	gCERTSVC_SUCCESS
;

521 
le
 
stCi
(
CtSvcCtifi
 *
ifi_y
, 
size
) {

522 i(
	gsize
 < 2) {

523  
	gCERTSVC_WRONG_ARGUMENT
;

526 
	gi
=1; i<
	gsize
; ++i) {

527 i(
	gifi_y
[
i
-1].
	giveIn
.
	giveP


528 !
ifi_y
[
i
].
iveIn
.
iveP
)

530  
CERTSVC_WRONG_ARGUMENT
;

534 
CtifiLi
 
	gLi
;

535 
	gd
::
m
<
Ctifi
*,> 
	g
;

537 
	gi
=0; i<
	gsize
; ++i) {

538 
	gpos
 = 
ifi_y
[
i
].
iveHdr
;

539 aut
	g
 = 
m_ifiM
.
fd
(
pos
);

540 i(
	g
 =
m_ifiM
.
d
()) {

541  
CERTSVC_WRONG_ARGUMENT
;

543 
	g
[

->
cd
.
g
()] = 
pos
;

544 
	gLi
.
push_back
(

->
cd
);

547 
CtifiCi
 
	gci
;

548 
	gci
.
ld
(
Li
);

550 i(!
	gci
.
st
()) {

551  
	gCERTSVC_FAIL
;

554 aut
	gcha
 = 
ci
.
gCha
();

556 
	gi
=0;

557 aut
	g
 = 
cha
.
beg
(); i!cha.
d
(&& 
i
<
size
; ++, ++
	gi
) {

558 
	gifi_y
[
i
].
	giveHdr
 = 

[

->
g
()];

561  
	gCERTSVC_SUCCESS
;

564 
le
 
gX509Cy
(cڡ 
CtSvcCtifi
 &
ifi
, 
X509
** 

)

566 aut
	g
 = 
m_ifiM
.
fd
(
ifi
.
iveHdr
);

567 i(
	g
 =
m_ifiM
.
d
()) {

568  
CERTSVC_WRONG_ARGUMENT
;

570 *
	g
 = 
X509_dup
(

->
cd
->
gX509
());

571  
	gCERTSVC_SUCCESS
;

574 
le
 
veToFe
(cڡ 
CtSvcCtifi
 &
ifi
,

575 cڡ *
loti
)

577 aut
	g
 = 
m_ifiM
.
fd
(
ifi
.
iveHdr
);

578 i(
	g
 =
m_ifiM
.
d
()) {

579  
CERTSVC_WRONG_ARGUMENT
;

581 
FILE
 *
	gout
;

582 i(
	gNULL
 =(
out
 = 
fݒ
(
loti
, "w"))) {

583  
	gCERTSVC_FAIL
;

585 i(0 =
i2d_X509_
(
out
, 

->
cd
->
gX509
())) {

586 
fo
(
out
);

587  
	gCERTSVC_FAIL
;

589 
fo
(
out
);

590  
	gCERTSVC_SUCCESS
;

593 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


594 
le
 
ocCheck
(cڡ 
CtSvcCtifi
 *
cha
,

595 
cha_size
,

596 cڡ 
CtSvcCtifi
 *
ued
,

597 
ued_size
,

598 cڡ *
u
,

599 *
us
)

601 aut
	g
 = 
cha
[0].
iveIn
.
iveP
;

603 
	gi
=1; i<
	gcha_size
; ++i) {

604 i(
	g
 !
cha
[
i
].
iveIn
.
iveP
)

606  
CERTSVC_WRONG_ARGUMENT
;

609 
CtifiLi
 
	gchaLi
, 
	guedLi
;

611 
	gi
=0; i<
	gcha_size
; ++i) {

612 aut
	g
 = 
m_ifiM
.
fd
(
cha
[
i
].
iveHdr
);

613 i(
	g
 =
m_ifiM
.
d
()) {

614  
CERTSVC_WRONG_ARGUMENT
;

616 
	gchaLi
.
push_back
(

->
cd
);

619 
	gi
=0; i<
	gued_size
; ++i) {

620 i(
	g
 !
ued
[
i
].
iveIn
.
iveP
)

622  
CERTSVC_WRONG_ARGUMENT
;

626 
	gi
=0; i<
	gued_size
; ++i) {

627 aut
	g
 = 
m_ifiM
.
fd
(
ued
[
i
].
iveHdr
);

628 i(
	g
 =
m_ifiM
.
d
()) {

629  
CERTSVC_WRONG_ARGUMENT
;

631 
	guedLi
.
push_back
(

->
cd
);

634 
OCSP
 
	goc
;

637 
	goc
.
tTruedSte
(
uedLi
);

639 i(
	gu
) {

640 
	goc
.
tUDeuRed
(
ue
);

641 
	goc
.
tDeuRed
(
u
);

644 
CtifiCi
 
	gci
;

645 
	gci
.
ld
(
chaLi
);

646 i(!
	gci
.
st
()) {

647  
	gCERTSVC_WRONG_ARGUMENT
;

650 
	gchaLi
 = 
ci
.
gCha
();

652 
VifitiStusS
 
	gusS
 = 
oc
.
videCtifiLi
(
chaLi
);

654 
	gt
 = 0;

655 i(
	gusS
.
cڏs
(
VERIFICATION_STATUS_GOOD
)) {

656 
	gt
 |
CERTSVC_OCSP_GOOD
;

658 i(
	gusS
.
cڏs
(
VERIFICATION_STATUS_REVOKED
)) {

659 
	gt
 |
CERTSVC_OCSP_REVOKED
;

661 i(
	gusS
.
cڏs
(
VERIFICATION_STATUS_UNKNOWN
)) {

662 
	gt
 |
CERTSVC_OCSP_UNKNOWN
;

664 i(
	gusS
.
cڏs
(
VERIFICATION_STATUS_VERIFICATION_ERROR
)) {

665 
	gt
 |
CERTSVC_OCSP_VERIFICATION_ERROR
;

667 i(
	gusS
.
cڏs
(
VERIFICATION_STATUS_NOT_SUPPORT
)) {

668 
	gt
 |
CERTSVC_OCSP_NO_SUPPORT
;

670 i(
	gusS
.
cڏs
(
VERIFICATION_STATUS_CONNECTION_FAILED
)) {

671 
	gt
 |
CERTSVC_OCSP_CONNECTION_FAILED
;

673 i(
	gusS
.
cڏs
(
VERIFICATION_STATUS_ERROR
)) {

674 
	gt
 |
CERTSVC_OCSP_ERROR
;

677 *
	gus
 = 
t
;

678  
	gCERTSVC_SUCCESS
;

682 
le
 
vify
(

683 
CtSvcCtifi
 
ifi
,

684 
CtSvcSg
 &
mesge
,

685 
CtSvcSg
 &
sigtu
,

686 cڡ *
gܙhm
,

687 *
us
)

689 
	gsu
 = 
CERTSVC_FAIL
;

691 i(!
	gus
) {

692  
	gCERTSVC_WRONG_ARGUMENT
;

695 aut
	g
 = 
m_ifiM
.
fd
(
ifi
.
iveHdr
);

696 i(
	g
 =
m_ifiM
.
d
()) {

697  
CERTSVC_WRONG_ARGUMENT
;

700 
OnSSL_add_l_diges
();

702 
	gmp
;

703 
EVP_MD_CTX
* 
	gmdx
 = 
NULL
;

704 cڡ 
EVP_MD
 * 
	gmd
 = 
NULL
;

705 
X509
 *
	g
 = 

->
cd
->
gX509
();

706 
EVP_PKEY
 *
	gpkey
 = 
NULL
;

708 i(
	g
 =
NULL
) {

709 
r
;

712 
	gpkey
 = 
X509_g_pubkey
(

);

714 i(
	gpkey
 =
NULL
) {

715 
r
;

718 i(
	ggܙhm
 =
NULL
) {

719 
md
 = 
EVP_g_digebyobj
(

->
_fo
->
sigtu
->
gܙhm
);

721 
	gmd
 = 
EVP_g_digebyme
(
gܙhm
);

724 i(
	gmd
 =
NULL
) {

725 
su
 = 
CERTSVC_INVALID_ALGORITHM
;

726 
	gr
;

729 
	gmdx
 = 
EVP_MD_CTX_
();

731 i(
	gmdx
 =
NULL
) {

732 
r
;

735 i(
EVP_VifyIn_ex
(
mdx
, 
md
, 
NULL
) != 1) {

736 
r
;

739 i(
EVP_VifyUpde
(
mdx
, 
mesge
.
iveHdr
, mesge.
iveLgth
) != 1) {

740 
r
;

743 
	gmp
 = 
EVP_VifyF
(
mdx
,

744 
t_
<*>(
sigtu
.
iveHdr
),

745 
sigtu
.
iveLgth
,

746 
pkey
);

748 i(
	gmp
 == 0) {

749 *
us
 = 
CERTSVC_INVALID_SIGNATURE
;

750 
	gsu
 = 
CERTSVC_SUCCESS
;

751 } i(
	gmp
 == 1) {

752 *
us
 = 
CERTSVC_SUCCESS
;

753 
	gsu
 = 
CERTSVC_SUCCESS
;

756 
	gr
:

757 i(
mdx
 !
NULL
)

758 
EVP_MD_CTX_deroy
(
mdx
);

759 i(
	gpkey
 !
NULL
)

760 
EVP_PKEY_
(
pkey
);

761  
	gsu
;

764 
le
 
ba64Encode
(

765 cڡ 
CtSvcSg
 &
mesge
,

766 
CtSvcSg
 *
ba64
)

768 i(!
	gba64
) {

769  
	gCERTSVC_WRONG_ARGUMENT
;

771 
	gd
::
rg
 
fo
(
mesge
.
iveHdr
, mesge.
iveLgth
);

772 
Ba64Encod
 
	gba
;

773 
	gba
.
t
();

774 
	gba
.
nd
(
fo
);

775 
	gba
.
fize
();

776 
	gfo
 = 
ba
.
g
();

777 *
	gr
 = 
w
 [
fo
.
size
()+1];

778 if(
	gr
 =
NULL
) {

779  
CERTSVC_BAD_ALLOC
;

781 
memy
(
r
, 
fo
.
c_r
(), info.
size
()+1);

782 
	gm_lodSgS
.

(
r
);

783 
	gba64
->
	giveHdr
 = 
r
;

784 
	gba64
->
	giveLgth
 = 
fo
.
size
();

785 
	gba64
->
	giveIn
 = 
mesge
.
iveIn
;

786  
	gCERTSVC_SUCCESS
;

789 
ba64Decode
(

790 cڡ 
CtSvcSg
 &
ba64
,

791 
CtSvcSg
 *
mesge
)

793 i(!
	gmesge
) {

794  
	gCERTSVC_WRONG_ARGUMENT
;

796 
	gd
::
rg
 
fo
(
ba64
.
iveHdr
, ba64.
iveLgth
);

797 
Ba64Decod
 
	gba
;

798 
	gba
.
t
();

799 
	gba
.
nd
(
fo
);

800 i(!
	gba
.
fize
()) {

801  
	gCERTSVC_FAIL
;

803 
	gfo
 = 
ba
.
g
();

804 *
	gr
 = 
w
 [
fo
.
size
()+1];

805 if(
	gr
 =
NULL
) {

806  
CERTSVC_BAD_ALLOC
;

808 
memy
(
r
, 
fo
.
c_r
(), info.
size
()+1);

809 
	gm_lodSgS
.

(
r
);

810 
	gmesge
->
	giveHdr
 = 
r
;

811 
	gmesge
->
	giveLgth
 = 
fo
.
size
();

812 
	gmesge
->
	giveIn
 = 
ba64
.
iveIn
;

813  
	gCERTSVC_SUCCESS
;

816 
le
 
rgNew
(

817 
CtSvcIn
 &

,

818 cڡ *
r
,

819 
size
,

820 
CtSvcSg
 *
ouut
)

822 i(!
	gouut
 || 
	gsize
 < 0) {

823  
	gCERTSVC_WRONG_ARGUMENT
;

826 
	glocSize
 = 
size
;

828 i(
	glocSize
 =0 || 
r
[
locSize
-1] != 0)

829 
locSize
++;

831 *
	gr
 = 
w
 [
locSize
];

832 if(
	gr
 =
NULL
) {

833  
CERTSVC_BAD_ALLOC
;

835 
memy
(
r
, 
r
, 
size
);

836 
	gr
[
locSize
-1] = 0;

838 
	gouut
->
	giveHdr
 = 
r
;

839 
	gouut
->
	giveLgth
 = 
size
;

840 
	gouut
->
	giveIn
 = 

;

842 
	gm_lodSgS
.

(
r
);

844  
	gCERTSVC_SUCCESS
;

847 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


848 
le
 
tCRLFuni
(

849 
CtSvcCCacheWre
 
wreP
,

850 
CtSvcCCacheRd
 
adP
,

851 
CtSvcCFe
 
P
)

853 
	gm_lWre
 = 
wreP
;

854 
	gm_lRd
 = 
adP
;

855 
	gm_lFe
 = 
P
;

858 
le
 
lCheck
(

859 
CtSvcCtifi
 
ifi
,

860 
CtSvcCtifi
 *
uedSte
,

861 
eSize
,

862 
f
,

863 *
us
,

864 *
urPam
)

866 
	gi
=1; i<
	geSize
; ++i) {

867 i(
	gifi
.
	giveIn
.
	giveP


868 !
uedSte
[
i
].
iveIn
.
iveP
)

870  
CERTSVC_WRONG_ARGUMENT
;

874 
CRL
 
l
(
w
 
CRLCacheCAPI
(
m_lWre
, 
m_lRd
, 
m_lFe
, 
urPam
));

876 
	gi
=0; i<
	geSize
; ++i) {

877 aut
	g
 = 
m_ifiM
.
fd
(
uedSte
[
i
].
iveHdr
);

878 i(
	g
 =
m_ifiM
.
d
()) {

879  
CERTSVC_WRONG_ARGUMENT
;

881 
	gl
.
addToSte
(

->
cd
);

884 aut
	g
 = 
m_ifiM
.
fd
(
ifi
.
iveHdr
);

885 i(
	g
 =
m_ifiM
.
d
()) {

886  
CERTSVC_WRONG_ARGUMENT
;

888 i(
	g
->
	gcd
->
gCUris
().
emy
()) {

889 *
	gus
 = 
CERTSVC_CRL_NO_SUPPORT
;

890  
	gCERTSVC_SUCCESS
;

892 
	gl
.
updeLi
(

->
cd
, 
f
 ? 
CRL
::
UPDATE_ON_DEMAND
: CRL::
UPDATE_ON_EXPIRED
);

893 
	gCRL
::
RevotiStus
 

 = 
l
.
checkCtifi
(

->
cd
);

894 *
	gus
 = 0;

896 i(!
	g
.
	gisCRLVid
) {

897 *
	gus
 |
CERTSVC_CRL_VERIFICATION_ERROR
;

898  
	gCERTSVC_SUCCESS
;

901 i(
	g
.
	gisRevoked
) {

902 *
	gus
 |
CERTSVC_CRL_REVOKED
;

904 *
	gus
 |
CERTSVC_CRL_GOOD
;

907  
	gCERTSVC_SUCCESS
;

911 
le
 
ifiVify
(

912 
CtSvcCtifi
 
ifi
,

913 
CtSvcCtifi
 *
ued
,

914 
uedSize
,

915 
CtSvcCtifi
 *
urued
,

916 
uruedSize
,

917 
checkCaFg
,

918 *
us
)

920 i(!
	gued
 || !
	gus
) {

921  
	gCERTSVC_WRONG_ARGUMENT
;

923 aut
	g
 = 
m_ifiM
.
fd
(
ifi
.
iveHdr
);

924 i(
	g
 =
m_ifiM
.
d
()) {

925  
CERTSVC_WRONG_ARGUMENT
;

928 
X509
 *
	g
 = 

->
cd
->
gX509
();

929 
X509_STORE
 *
	ge
 = 
X509_STORE_w
();

930 
STACK_OF
(
X509
*
	gue
 = 
sk_X509_w_nu
();

932 
	gi
=0; i<
	guedSize
; ++i) {

933 aut
	g
 = 
m_ifiM
.
fd
(
ued
[
i
].
iveHdr
);

934 i(
	g
 =
m_ifiM
.
d
()) {

935 
X509_STORE_
(
e
);

936 
sk_X509_
(
ue
);

937  
	gCERTSVC_WRONG_ARGUMENT
;

939 
X509_STORE_add_
(
e
, 

->
cd
->
gX509
());

942 
	gi
=0; i<
	guruedSize
; ++i) {

943 aut
	g
 = 
m_ifiM
.
fd
(
urued
[
i
].
iveHdr
);

944 i(
	g
 =
m_ifiM
.
d
()) {

945 
X509_STORE_
(
e
);

946 
sk_X509_
(
ue
);

947  
	gCERTSVC_WRONG_ARGUMENT
;

949 i(
sk_X509_push
(
ue
, 

->
cd
->
gX509
()) == 0)

954 
X509_STORE_CTX
 
	gcڋxt
;

955 
X509_STORE_CTX_
(&
cڋxt
, 
e
, 

, 
ue
);

956 
	gsu
 = 
X509_vify_
(&
cڋxt
);

958 if(
	gsu
 =1 && 
checkCaFg
) {

959 
STACK_OF
(
X509
*
suCha
 = 
X509_STORE_CTX_g1_cha
(&
cڋxt
);

960 
X509
* 
	gtmpCt
 = 
NULL
;

961 
	gFgVidy
;

962 (
	gtmpCt
 = 
sk_X509_p
(
suCha
))) {

963 
FgVidy
 = 
X509_check_
(
tmpCt
);

964 if(
	gFgVidy
 !1 && (
tmpCt
 = 
sk_X509_p
(
suCha
)!
NULL
) {

965 
su
 = 0;

971 
X509_STORE_CTX_nup
(&
cڋxt
);

972 
X509_STORE_
(
e
);

973 
sk_X509_
(
ue
);

975 i(
	gsu
 == 1) {

976 *
us
 = 
CERTSVC_SUCCESS
;

978 *
	gus
 = 
CERTSVC_FAIL
;

980  
	gCERTSVC_SUCCESS
;

983 
gVisiby
(
CtSvcCtifi
 
ifi
, * 
visiby
)

985 
	gt
 = 
CERTSVC_FAIL
;

988 
xmlCh
 *
	gxmlPhDomaPtfm
 = (xmlChar*) "tizen-platform";

989 
xmlCh
 *
	gxmlPhDomaPublic
 = (xmlChar*) "tizen-public";

990 
xmlCh
 *
	gxmlPhDomaP
 = (xmlChar*) "tizen-partner";

991 
xmlCh
 *
	gxmlPhDomaDevݔ
 = (xmlChar*) "tizen-developer";

994 aut
	g
 = 
m_ifiM
.
fd
(
ifi
.
iveHdr
);

995 i(
	g
 =
m_ifiM
.
d
()) {

996  
CERTSVC_FAIL
;

998 
CtifiP
 
	gP
 = 

->
cd
;

1000 
	gd
::
rg
 
fgt
 = 
Ctifi
::
FgtToCHex
(
P
->
gFgt
(Ctifi::
FINGERPRINT_SHA1
));

1003 
xmlDocP
 
	gdoc
 = 
xmlPFe
(
FINGERPRINT_LIST_PATH
);

1004 i((
	gdoc
 =
NULL
|| (
xmlDocGRoEmt
(
doc
) == NULL))

1006 
WLogE
("Failedorase fingerprint_list.xml");

1007  
	gCERTSVC_IO_ERROR
;

1010 
xmlNodeP
 
	gcurP
 = 
xmlFEmtChd
(
xmlDocGRoEmt
(
doc
));

1011 if(
	gcurP
 =
NULL
)

1013 
WLogE
("Canot findoot");

1014 
	gt
 = 
CERTSVC_IO_ERROR
;

1015 
	gout
;

1018 
	gcurP
 !
NULL
)

1020 
xmlAr
* 

 = 
curP
->
ݔts
;

1021 if(!
	g
->
	gchdn
 || !->chdn->
	gcڋ
)

1023 
WLogE
("Failedo get fingerprints fromist");

1024 
	gt
 = 
CERTSVC_FAIL
;

1025 
	gout
;

1028 
xmlCh
* 
	grLev
 = 

->
chdn
->
cڋ
;

1029 
xmlNodeP
 
	gFpP
 = 
xmlFEmtChd
(
curP
);

1030 if(
	gFpP
 =
NULL
)

1032 
WLogE
("Couldot find fingerprint");

1033 
	gt
 = 
CERTSVC_FAIL
;

1034 
	gout
;

1037 
WLogD
("Rrvv : %s", 
rLev
);

1038 
	gFpP
)

1040 
xmlCh
 *
	gcڋ
 = 
xmlNodeGCڋ
(
FpP
);

1041 if(
xmlScmp
(
cڋ
, (
xmlCh
*)
fgt
.
c_r
()) == 0)

1043 
WLogD
("fg: %%s", 
cڋ
, 
rLev
);

1044 if(!
xmlScmp
(
rLev
, 
xmlPhDomaPtfm
))

1046 *
	gvisiby
 = 
CERTSVC_VISIBILITY_PLATFORM
;

1047 
	gt
 = 
CERTSVC_SUCCESS
;

1048 
	gout
;

1050 if(!
xmlScmp
(
rLev
, 
xmlPhDomaPublic
))

1052 *
	gvisiby
 = 
CERTSVC_VISIBILITY_PUBLIC
;

1053 
	gt
 = 
CERTSVC_SUCCESS
;

1054 
	gout
;

1056 if(!
xmlScmp
(
rLev
, 
xmlPhDomaP
))

1058 *
	gvisiby
 = 
CERTSVC_VISIBILITY_PARTNER
;

1059 
	gt
 = 
CERTSVC_SUCCESS
;

1060 
	gout
;

1062 if(!
xmlScmp
(
rLev
, 
xmlPhDomaDevݔ
))

1064 *
	gvisiby
 = 
CERTSVC_VISIBILITY_DEVELOPER
;

1065 
	gt
 = 
CERTSVC_SUCCESS
;

1066 
	gout
;

1069 
	gFpP
 = 
xmlNextEmtSiblg
(
FpP
);

1071 
	gcurP
 = 
xmlNextEmtSiblg
(
curP
);

1073 
xmlFeDoc
(
doc
);

1074  
	gCERTSVC_FAIL
;

1075 
	gout
:

1076 
xmlFeDoc
(
doc
);

1077  
	gt
;

1080 
le
 
pkcsNameIsUnique
(

1081 
CtSvcSg
 
pfxIdSg
,

1082 *
is_unique
)

1084 
gboޗn
 
	gexis
;

1085 
	gsu
 = 
c_svc_pkcs12_s_exis
(
pfxIdSg
.
iveHdr
, &
exis
);

1086 *
	gis_unique
 = !
exis
;

1087  
	gsu
;

1090 
le
 
pkcsImpt
(

1091 
CtSvcSg
 
th
,

1092 
CtSvcSg
 
ss
,

1093 
CtSvcSg
 
pfxIdSg
)

1095  
c_svc_pkcs12_impt
(
th
.
iveHdr
, 
ss
.iveHdr, 
pfxIdSg
.privateHandler);

1098 
le
 
pkcsNameIsUniqueInSte
(

1099 
CtSteTy
 
eTy
,

1100 
CtSvcSg
 
pfxIdSg
,

1101 *
is_unique
)

1103 
	gsu
 = 
c_svc_pkcs12_s_exis__e
(
eTy
, 
pfxIdSg
.
iveHdr
, 
is_unique
);

1104  
	gsu
;

1107 
le
 
gCtDaFromSte
(
CtSteTy
 
eTy
,

1108 
CtSvcSg
 
gme
,

1109 ** 
Bufr
,

1110 
size_t
* 
Size
)

1112  
c_svc_pkcs12_g_ifi_bufr_om_e
(
eTy
, 
gme
.
iveHdr
, 
Bufr
, 
Size
);

1115 
le
 
pkcsDeCtFromSte
(

1116 
CtSteTy
 
eTy
,

1117 
CtSvcSg
 
gme


1120  
c_svc_pkcs12_de_ifi_om_e
(
eTy
, 
gme
.
iveHdr
);

1123 
le
 
gPkcsIdLi
(

1124 
CtSvcIn
 &

,

1125 
CtSvcSgLi
 *
hdr
)

1127 
gch
 **
	gs
;

1128 
gsize
 
	gi
, 
	gls
;

1129 
	gd
::
ve
<
d
::
rg
> 
ouut
;

1130 
	gsu
;

1132 
	gsu
 = 
c_svc_pkcs12_s_ld
(&
s
, &
ls
);

1133 if(
	gsu
 !
CERTSVC_SUCCESS
)

1134  
su
;

1135 
	gi
 = 0; i < 
	gls
; i++)

1136 
	gouut
.
push_back
(
d
::
rg
(
s
[
i
]));

1137 
c_svc_pkcs12_s_
(
s
);

1139 
	gposi
 = 
m_rgLiCou
++;

1140 
	gm_rgLiM
[
posi
] = 
ouut
;

1142 
	ghdr
->
	giveHdr
 = 
posi
;

1143 
	ghdr
->
	giveIn
 = 

;

1144  
	gCERTSVC_SUCCESS
;

1147 
le
 
pkcsHasPasswd
(

1148 
CtSvcSg
 
fh
,

1149 *
has_sswd
)

1151  
c_svc_pkcs12_has_sswd
(
fh
.
iveHdr
, 
has_sswd
);

1154 
le
 
gPkcsPriveKey
(

1155 
CtSvcSg
 
pfxIdSg
,

1156 **
bufr
,

1157 
size_t
 *
size
)

1159  
c_svc_pkcs12_ive_key_ld
(
pfxIdSg
.
iveHdr
, 
bufr
, 
size
);

1162 
le
 
gPkcsCtifiLi
(

1163 
CtSvcIn
 &

,

1164 
CtSvcSg
 &
pfxIdSg
,

1165 
CtSvcCtifiLi
 *
hdr
)

1167 
gch
 **
	gs
;

1168 
gsize
 
	gi
, 
	gns
;

1169 
	gd
::
ve
<
CtifiP
> 
PVe
;

1170 
	gd
::
ve
<> 
liId
;

1171 
	gsu
;

1173 
	gsu
 = 
c_svc_pkcs12_ld_ifis
(
pfxIdSg
.
iveHdr
, &
s
, &
ns
);

1174 if(
	gsu
 !
CERTSVC_SUCCESS
)

1175  
su
;

1176 
	gi
 = 0; i < 
	gns
; i++) {

1177 
ScedCtCtx
 
cڋxt
(
_svc__cڋxt_
(), 
_svc__cڋxt_f
);

1178 if(
_svc_ld_fe_to_cڋxt
(
cڋxt
.
g
(), 
s
[
i
]!
CERT_SVC_ERR_NO_ERROR
) {

1179 
c_svc_pkcs12__ifis
(
s
);

1180  
	gCERTSVC_IO_ERROR
;

1183 
	gPVe
.
push_back
(
CtifiP
(
w
 
Ctifi
(*(
cڋxt
->
Buf
))));

1185 if(
	gns
 > 0)

1186 
c_svc_pkcs12__ifis
(
s
);

1188 
FOREACH
(

, 
PVe
) {

1189 
	gliId
.
push_back
(
addCt
(*

));

1192 
	gposi
 = 
m_idLiCou
++;

1193 
	gm_idLiM
[
posi
] = 
liId
;

1195 
	ghdr
->
	giveIn
 = 

;

1196 
	ghdr
->
	giveHdr
 = 
posi
;

1198  
	gsu
;

1201 
le
 
pkcsDe
(
CtSvcSg
 
pfxIdSg
)

1203  
c_svc_pkcs12_de
(
pfxIdSg
.
iveHdr
);

1206 
le
 
pkcsImptToSte
(

1207 
CtSteTy
 
eTy
,

1208 
CtSvcSg
 
th
,

1209 
CtSvcSg
 
ss
,

1210 
CtSvcSg
 
pfxIdSg
)

1212  
c_svc_pkcs12_impt_om_fe_to_e
(
eTy
, 
th
.
iveHdr
, 
ss
.iveHdr, 
pfxIdSg
.privateHandler);

1215 
le
 
pkcsGAlsNameFCtInSte
(
CtSteTy
 
eTy
,

1216 
CtSvcSg
 
gme
,

1217 **
s
)

1219  
c_svc_pkcs12_g_ifi_s_om_e
(
eTy
, 
gme
.
iveHdr
, 
s
);

1222 
le
 
pkcsSCtStusToSte
(
CtSteTy
 
eTy
,

1223 
is_ro_p
,

1224 
CtSvcSg
 
gme
,

1225 
CtStus
 
us
)

1227  
c_svc_pkcs12_t_ifi_us_to_e
(
eTy
, 
is_ro_p
, 
gme
.
iveHdr
, 
us
);

1230 
le
 
pkcsGCtStusFromSte
(

1231 
CtSteTy
 
eTy
,

1232 
CtSvcSg
 
gme
,

1233 *
us
)

1235  
c_svc_pkcs12_g_ifi_us_om_e
(
eTy
, 
gme
.
iveHdr
, 
us
);

1238 
le
 
gCtFromSte
(
CtSvcIn
 

,

1239 
CtSteTy
 
eTy
,

1240 *
gme
,

1241 
CtSvcCtifi
 *
ifi
)

1243  
svc_g_ifi
(

, 
eTy
, 
gme
, 
ifi
);

1246 
le
 
PkcsIdLiFromSte
(

1247 
CtSvcSteCtLi
** 
Li
)

1249  
c_svc_pkcs12__s_lded_om_e
(
Li
);

1252 
le
 
gPkcsIdLiFromSte
(

1253 
CtSteTy
 
eTy
,

1254 
is_ro_p
,

1255 
CtSvcSteCtLi
** 
Li
,

1256 * 
ngth
)

1258  
c_svc_pkcs12_g_ifi_li_om_e
(
eTy
, 
is_ro_p
, 
Li
, 
ngth
);

1261 
le
 
gPkcsIdEndUrLiFromSte
(

1262 
CtSteTy
 
eTy
,

1263 
CtSvcSteCtLi
** 
Li
,

1264 * 
ngth
)

1266  
c_svc_pkcs12_g_d_ur_ifi_li_om_e
(
eTy
, 
Li
, 
ngth
);

1269 
le
 
gPkcsIdRoLiFromSte
(

1270 
CtSteTy
 
eTy
,

1271 
CtSvcSteCtLi
** 
Li
,

1272 * 
ngth
)

1274  
c_svc_pkcs12_g_ro_ifi_li_om_e
(
eTy
, 
Li
, 
ngth
);

1277 
le
 
gPkcsPriveKeyFromSte
(

1278 
CtSteTy
 
eTy
,

1279 
CtSvcSg
 
gme
,

1280 **
Bufr
,

1281 
size_t
 *
Size
)

1283  
c_svc_pkcs12_ive_key_ld_om_e
(
eTy
, 
gme
.
iveHdr
, 
Bufr
, 
Size
);

1286 
le
 
gPkcsCtifiLiFromSte
(

1287 
CtSvcIn
 &

,

1288 
CtSteTy
 
eTy
,

1289 
CtSvcSg
 &
pfxIdSg
,

1290 
CtSvcCtifiLi
 *
hdr
)

1292 **
	gs
;

1293 
gsize
 
	gi
, 
	gns
;

1294 
	gd
::
ve
<
CtifiP
> 
PVe
;

1295 
	gd
::
ve
<> 
liId
;

1296 *
	gBufr
 = 
NULL
;

1297 
size_t
 
	gLgth
 = 0;

1298 
CtSvcSg
 
	gAls
;

1299 * 
	ghd
 = 
NULL
;

1300 * 
	ga
 = 
NULL
;

1301 cڡ * 
	ghdEnd
 = 
NULL
;

1302 cڡ * 
	gEnd
 = 
NULL
;

1303 
	gngth
 = 0;

1304 
	gsu
;

1306 
	gsu
 = 
c_svc_pkcs12_ld_ifis_om_e
(
eTy
, 
pfxIdSg
.
iveHdr
, &
s
, &
ns
);

1307 i(
	gsu
 !
CERTSVC_SUCCESS
) {

1308 
WLogE
("Unableooad certificates from store.");

1309  
	gsu
;

1312 
	gi
 = 0; i < 
	gns
; i++) {

1313 
	gAls
.
	giveHdr
 = 
s
[
i
];

1314 
	gAls
.
	giveLgth
 = 

(
s
[
i
]);

1315 
	gsu
 = 
svc_pkcs12_g_ifi_fo_om_e
(

, 
eTy
, 
Als
, &
Bufr
, &
Lgth
);

1316 i(
	gsu
 !
CERTSVC_SUCCESS
 || !
Bufr
) {

1317 
WLogE
("Failedo get certificate buffer.");

1318  
	gCERTSVC_FAIL
;

1321 
	ghd
 = 
rr
(
Bufr
, 
START_CERT
);

1322 
	ghdEnd
 = 
START_CERT
;

1323 i(!
	ghd
) {

1325 
	ghd
 = 
rr
(
Bufr
, 
START_TRUSTED
);

1326 
	ghdEnd
 = 
START_TRUSTED
;

1329 i(
	ghd
) {

1331 
	ga
 = 
rr
(
hd
, 
END_CERT
);

1332 
	gEnd
 = 
END_CERT
;

1335 i(!
	ga
) {

1337 
	ga
 = 
rr
(
hd
, 
END_TRUSTED
);

1338 
	gEnd
 = 
END_TRUSTED
;

1341 i(!
	ga
) {

1342 
WLogE
("Failedhe gethe certificate.");

1343  
	gCERTSVC_FAIL
;

1346 
	gngth
 = ((1 + 

(
hd
)- ((
hdEnd
+ sn(
End
) + 1));

1347 
	gd
::
rg
 
tmpBufr
(
Bufr
);

1348 
	gtmpBufr
 = 
tmpBufr
.
subr
(

(
hdEnd
),
ngth
);

1349 
	gd
::
rg
 
by
(
tmpBufr
.
c_r
(), 
ngth
);

1350 
	gCtifi
::
FmTy
 
fmTy
 = 
Ctifi
::
FORM_BASE64
;

1351 
	gPVe
.
push_back
(
CtifiP
(
w
 
Ctifi
(
by
, 
fmTy
)));

1352 

(
Bufr
);

1353 
	gBufr
 = 
NULL
;

1356 i(
	gns
 > 0)

1357 
c_svc_pkcs12__ifis
(
s
);

1359 
FOREACH
(

, 
PVe
) {

1360 
	gliId
.
push_back
(
addCt
(*

));

1363 
	gposi
 = 
m_idLiCou
++;

1364 
	gm_idLiM
[
posi
] = 
liId
;

1366 
	ghdr
->
	giveIn
 = 

;

1367 
	ghdr
->
	giveHdr
 = 
posi
;

1369  
	gsu
;

1372 
le
 
bo
 
checkVidSteTy
(
CtSteTy
 
eTy
)

1374 i(
	geTy
 >
VPN_STORE
 && 
eTy
 <
ALL_STORE
)

1375  
ue
;

1377  
	gl
;

1380 
	give
:

1381 
m_ifiCou
;

1382 
	gd
::
m
<, 
	gCtifiP
> 
	gm_ifiM
;

1384 
	gm_idLiCou
;

1385 
	gd
::
m
<, std::
ve
<> > 
m_idLiM
;

1387 
	gm_rgLiCou
;

1388 
	gd
::
m
<, std::
ve
<
d
::
rg
> > 
m_rgLiM
;

1390 
	gd
::
t
<*> 
m_lodSgS
;

1392 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


1393 
CtSvcCCacheWre
 
	gm_lWre
;

1394 
CtSvcCCacheRd
 
	gm_lRd
;

1395 
CtSvcCFe
 
	gm_lFe
;

1399 
le
 
CtSvcInIm
 *
	$im
(
CtSvcIn
 

) {

1400  
ic_
<
CtSvcInIm
*>(

.
iveP
);

1401 
	}
}

1405 
	$svc__w
(
CtSvcIn
 *

) {

1406 

 = 1;

1407 i(

) {

1408 
	`SSL_libry_
();

1409 
	`OnSSL_add_l_diges
();

1410 

 = 0;

1412 
y
 {

1413 

->
iveP
 =

1414 
t_
<*>(
w
 
CtSvcInIm
);

1415 i(

->
iveP
)

1416  
CERTSVC_SUCCESS
;

1417 } 
	`tch
 (
d
::
bad_loc
 &) {

1418  
CERTSVC_BAD_ALLOC
;

1419 } 
	`tch
 (...) {}

1420  
CERTSVC_FAIL
;

1421 
	}
}

1423 
	$svc__t
(
CtSvcIn
 

) {

1424 
	`im
(

)->
	`t
();

1425 
	}
}

1427 
	$svc__
(
CtSvcIn
 

) {

1428 
de
 
	`im
(

);

1429 
	}
}

1431 
	$svc_ifi_w_om_fe
(

1432 
CtSvcIn
 

,

1433 cڡ *
loti
,

1434 
CtSvcCtifi
 *
ifi
)

1436 
y
 {

1437 
ScedCtCtx
 
	`cڋxt
(
	`_svc__cڋxt_
(),

1438 
_svc__cڋxt_f
);

1440 
su
 = 
	`_svc_ld_fe_to_cڋxt
(
cڋxt
.
	`g
(), 
loti
);

1442 
su
) {

1443 
CERT_SVC_ERR_INVALID_PARAMETER
:  
CERTSVC_WRONG_ARGUMENT
;

1444 
CERT_SVC_ERR_INVALID_OPERATION
:  
CERTSVC_FAIL
;

1445 
CERT_SVC_ERR_MEMORY_ALLOCATION
:  
CERTSVC_BAD_ALLOC
;

1449 
CtifiP
 
	`
(
w
 
	`Ctifi
(*(
cڋxt
->
Buf
)));

1451 
ifi
->
iveIn
 = 

;

1452 
ifi
->
iveHdr
 = 
	`im
(

)->
	`addCt
(

);

1454  
CERTSVC_SUCCESS
;

1456 } 
	`tch
 (
d
::
bad_loc
 &) {

1457  
CERTSVC_BAD_ALLOC
;

1458 } 
	`tch
 (...) {}

1459  
CERTSVC_FAIL
;

1460 
	}
}

1462 
	$svc_ifi_w_om_memy
(

1463 
CtSvcIn
 

,

1464 cڡ *
memy
,

1465 
n
,

1466 
CtSvcCtifiFm
 
fm
,

1467 
CtSvcCtifi
 *
ifi
)

1469 
y
 {

1470 
Ctifi
::
FmTy
 
fmTy
;

1471 
d
::
rg
 
	`by
((*)
memy
, 
n
);

1473 i(
CERTSVC_FORM_DER
 =
fm
) {

1474 
fmTy
 = 
Ctifi
::
FORM_DER
;

1476 
fmTy
 = 
Ctifi
::
FORM_BASE64
;

1479 
CtifiP
 
	`
(
w
 
	`Ctifi
(
by
, 
fmTy
));

1481 
ifi
->
iveIn
 = 

;

1482 
ifi
->
iveHdr
 = 
	`im
(

)->
	`addCt
(

);

1483  
CERTSVC_SUCCESS
;

1484 } 
	`tch
 (
d
::
bad_loc
 &) {

1485  
CERTSVC_BAD_ALLOC
;

1486 } 
	`tch
 (...) {}

1487  
CERTSVC_FAIL
;

1488 
	}
}

1490 
	$svc_ifi_
(
CtSvcCtifi
 
ifi
)

1492 i(
ifi
.
iveHdr
 != 0)

1493 
	`im
(
ifi
.
iveIn
)->
	`moveCt
(certificate);

1494 
	}
}

1496 
	$svc_ifi_ve_fe
(

1497 
CtSvcCtifi
 
ifi
,

1498 cڡ *
loti
)

1500  
	`im
(
ifi
.
iveIn
)->
	`veToFe
(ifi, 
loti
);

1501 
	}
}

1503 
	$svc_ifi_ch
(

1504 
CtSvcIn
 

,

1505 
CtSvcCtifiFld
 
fld
,

1506 cڡ *
vue
,

1507 
CtSvcCtifiLi
 *
hdr
)

1509 
y
 {

1510  
	`im
(

)->
	`ifiSrch
(, 
fld
, 
vue
, 
hdr
);

1511 } 
	`tch
 (
d
::
bad_loc
 &) {

1512  
CERTSVC_BAD_ALLOC
;

1513 } 
	`tch
 (...) {}

1514  
CERTSVC_FAIL
;

1515 
	}
}

1517 
	$svc_ifi_li_g_e
(

1518 
CtSvcCtifiLi
 
hdr
,

1519 
posi
,

1520 
CtSvcCtifi
 *
ifi
)

1522  
	`im
(
hdr
.
iveIn
)->

1523 
	`gCtFromLi
(
hdr
,
posi
, 
ifi
);

1524 
	}
}

1526 
	$svc_ifi_li_g_ngth
(

1527 
CtSvcCtifiLi
 
hdr
,

1528 *
size
)

1530  
	`im
(
hdr
.
iveIn
)->
	`gCtLiL
(hdr, 
size
);

1531 
	}
}

1533 
	$svc_ifi_li_
(
CtSvcCtifiLi
 
hdr
)

1535 
	`im
(
hdr
.
iveIn
)->
	`moveCtLi
(handler);

1536 
	}
}

1538 
	$svc_ifi_is_sigd_by
(

1539 
CtSvcCtifi
 
chd
,

1540 
CtSvcCtifi
 

,

1541 *
us
)

1543 i(
chd
.
iveIn
.
iveP
 =

.privateInstance.privatePtr) {

1544  
	`im
(
chd
.
iveIn
)->
	`isSigdBy
(chd, 

, 
us
);

1546  
CERTSVC_WRONG_ARGUMENT
;

1547 
	}
}

1549 
	$svc_ifi_g_rg_fld
(

1550 
CtSvcCtifi
 
ifi
,

1551 
CtSvcCtifiFld
 
fld
,

1552 
CtSvcSg
 *
bufr
)

1554 
y
 {

1555  
	`im
(
ifi
.
iveIn
)->
	`gFld
(ifi, 
fld
, 
bufr
);

1556 } 
	`tch
 (
d
::
bad_loc
 &) {

1557  
CERTSVC_BAD_ALLOC
;

1558 } 
	`tch
 (...) {}

1559  
CERTSVC_FAIL
;

1560 
	}
}

1562 
	$svc_ifi_g_n_a
(

1563 
CtSvcCtifi
 
ifi
,

1564 
time_t
 *
su
)

1566 
y
 {

1567  
	`im
(
ifi
.
iveIn
)->
	`gNA
(ifi, 
su
);

1568 } 
	`tch
(...) {}

1569  
CERTSVC_FAIL
;

1570 
	}
}

1572 
	$svc_ifi_g_n_befe
(

1573 
CtSvcCtifi
 
ifi
,

1574 
time_t
 *
su
)

1576 
y
 {

1577  
	`im
(
ifi
.
iveIn
)->
	`gNBefe
(ifi, 
su
);

1578 } 
	`tch
(...) {}

1579  
CERTSVC_FAIL
;

1580 
	}
}

1582 
	$svc_ifi_is_ro_
(
CtSvcCtifi
 
ifi
, *
us
)

1584  
	`im
(
ifi
.
iveIn
)->
	`isRoCA
(ifi, 
us
);

1585 
	}
}

1587 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


1588 
	$svc_ifi_g_l_diributi_pots
(

1589 
CtSvcCtifi
 
ifi
,

1590 
CtSvcSgLi
 *
hdr
)

1592 
y
 {

1593  
	`im
(
ifi
.
iveIn
)->
	`gC
(ifi, 
hdr
);

1594 } 
	`tch
 (...) {}

1595  
CERTSVC_FAIL
;

1596 
	}
}

1599 
	$svc_rg_li_g_e
(

1600 
CtSvcSgLi
 
hdr
,

1601 
posi
,

1602 
CtSvcSg
 *
bufr
)

1604 
y
 {

1605  
	`im
(
hdr
.
iveIn
)->
	`gSgFromLi
(hdr, 
posi
, 
bufr
);

1606 } 
	`tch
 (
d
::
bad_loc
 &) {

1607  
CERTSVC_BAD_ALLOC
;

1608 } 
	`tch
 (...) {}

1609  
CERTSVC_FAIL
;

1610 
	}
}

1612 
	$svc_rg_li_g_ngth
(

1613 
CtSvcSgLi
 
hdr
,

1614 *
size
)

1616  
	`im
(
hdr
.
iveIn
)->
	`gSgLiL
(hdr, 
size
);

1617 
	}
}

1619 
	$svc_rg_li_
(
CtSvcSgLi
 
hdr
)

1621 i(
hdr
.
iveHdr
 != 0)

1623 
	`im
(
hdr
.
iveIn
)->
	`moveSgLi
(handler);

1624 
hdr
.
iveHdr
 = 0;

1626 
	}
}

1628 
	$svc_rg_
(
CtSvcSg
 
rg
)

1630 i(
rg
.
iveHdr
)

1631 
	`im
(
rg
.
iveIn
)->
	`moveSg
(string);

1632 
	}
}

1634 
	$svc_rg_to_crg
(

1635 
CtSvcSg
 
rg
,

1636 cڡ **
bufr
,

1637 *
n
)

1639 i(
bufr
) {

1640 *
bufr
 = 
rg
.
iveHdr
;

1642 i(
n
) {

1643 *
n
 = 
rg
.
iveLgth
;

1645 
	}
}

1647 
	$svc_ifi_cha_st
(

1648 
CtSvcCtifi
 *
ifi_y
,

1649 
size
)

1651 
y
 {

1652 i(!
ifi_y
) {

1653  
CERTSVC_WRONG_ARGUMENT
;

1655  
	`im
(
ifi_y
[0].
iveIn
)->

1656 
	`stCi
(
ifi_y
, 
size
);

1657 } 
	`tch
 (
d
::
bad_loc
 &) {

1658  
CERTSVC_BAD_ALLOC
;

1659 } 
	`tch
 (...) {}

1660  
CERTSVC_FAIL
;

1661 
	}
}

1663 
	$svc_ifi_dup_x509
(
CtSvcCtifi
 
ifi
, 
X509
 **

)

1665 
y
 {

1666  
	`im
(
ifi
.
iveIn
)->
	`gX509Cy
(ifi, 

);

1667 } 
	`tch
 (...) {}

1668  
CERTSVC_FAIL
;

1669 
	}
}

1671 
	$svc_ifi__x509
(
X509
 *
x509
)

1673 i(
x509
)

1674 
	`X509_
(
x509
);

1675 
	}
}

1677 
	$svc_pkcs12_dup_evp_pkey
(

1678 
CtSvcIn
 

,

1679 
CtSvcSg
 
s
,

1680 
EVP_PKEY
** 
pkey
)

1682 *
bufr
;

1683 
size_t
 
size
;

1685 
su
 = 
	`svc_pkcs12_ive_key_dup
(

1686 

,

1687 
s
,

1688 &
bufr
,

1689 &
size
);

1691 i(
su
 !
CERTSVC_SUCCESS
) {

1692 
	`WLogE
("Error in certsvc_pkcs12_private_key_dup");

1693  
su
;

1696 
BIO
 *
b
 = 
	`BIO_w
(
	`BIO_s_mem
());

1698 i(()
size
 !
	`BIO_wre
(
b
, 
bufr
, size)) {

1699 
	`WLogE
("Error in BIO_write");

1700 
	`BIO__l
(
b
);

1701 
	`svc_pkcs12_ive_key_
(
bufr
);

1702  
CERTSVC_FAIL
;

1705 
	`svc_pkcs12_ive_key_
(
bufr
);

1707 *
pkey
 = 
	`PEM_ad_bio_PriveKey
(
b
, 
NULL
, NULL, NULL);

1709 
	`BIO__l
(
b
);

1711 i(*
pkey
) {

1712  
CERTSVC_SUCCESS
;

1715 
	`WLogE
("Resu inu. Ons REASON codis: %d", 
	`ERR_GET_REASON
(
	`ERR_ek_ϡ_r
()));

1717  
CERTSVC_FAIL
;

1718 
	}
}

1720 
	$svc_pkcs12__evp_pkey
(
EVP_PKEY
* 
pkey
)

1722 
	`EVP_PKEY_
(
pkey
);

1723 
	}
}

1725 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


1726 
	$svc_oc_check
(

1727 
CtSvcCtifi
 *
cha
,

1728 
cha_size
,

1729 
CtSvcCtifi
 *
ued
,

1730 
ued_size
,

1731 cڡ *
u
,

1732 *
us
)

1734 
y
 {

1735 i(!
cha
 || !
ued
) {

1736  
CERTSVC_WRONG_ARGUMENT
;

1738  
	`im
(
cha
[0].
iveIn
)->

1739 
	`ocCheck
(
cha
,

1740 
cha_size
,

1741 
ued
,

1742 
ued_size
,

1743 
u
,

1744 
us
);

1745 } 
	`tch
 (
d
::
bad_loc
 &) {

1746  
CERTSVC_BAD_ALLOC
;

1747 } 
	`tch
 (...) {}

1748  
CERTSVC_FAIL
;

1749 
	}
}

1752 
	$svc_mesge_vify
(

1753 
CtSvcCtifi
 
ifi
,

1754 
CtSvcSg
 
mesge
,

1755 
CtSvcSg
 
sigtu
,

1756 cڡ *
gܙhm
,

1757 *
us
)

1759 
y
 {

1760  
	`im
(
ifi
.
iveIn
)->
	`vify
(

1761 
ifi
,

1762 
mesge
,

1763 
sigtu
,

1764 
gܙhm
,

1765 
us
);

1766 } 
	`tch
(...) {}

1767  
CERTSVC_FAIL
;

1768 
	}
}

1770 
	$svc_ba64_code
(
CtSvcSg
 
mesge
, CtSvcSg *
ba64
)

1772 
y
 {

1773  
	`im
(
mesge
.
iveIn
)->
	`ba64Encode
(mesge, 
ba64
);

1774 } 
	`tch
(...) {}

1775  
CERTSVC_FAIL
;

1776 
	}
}

1778 
	$svc_ba64_decode
(
CtSvcSg
 
ba64
, CtSvcSg *
mesge
)

1780 
y
 {

1781  
	`im
(
ba64
.
iveIn
)->
	`ba64Decode
(ba64, 
mesge
);

1782 } 
	`tch
(...) {}

1783  
CERTSVC_FAIL
;

1784 
	}
}

1786 
	$svc_rg_w
(

1787 
CtSvcIn
 

,

1788 cڡ *
u
,

1789 
size
,

1790 
CtSvcSg
 *
ouut
)

1792 
y
 {

1793  
	`im
(

)->
	`rgNew
(, 
u
, 
size
, 
ouut
);

1794 } 
	`tch
 (...) {}

1795  
CERTSVC_FAIL
;

1796 
	}
}

1798 
	$svc_rg_n_maged
(

1799 
CtSvcIn
 

,

1800 cڡ *
u
,

1801 
size
,

1802 
CtSvcSg
 *
ouut
)

1804 i(!
ouut
) {

1805  
CERTSVC_WRONG_ARGUMENT
;

1807 
ouut
->
iveHdr
 = 
cڡ_
<*>(
u
);

1808 
ouut
->
iveLgth
 = 
size
;

1809 
ouut
->
iveIn
 = 

;

1810  
CERTSVC_SUCCESS
;

1811 
	}
}

1813 #ifde
TIZEN_FEATURE_CERT_SVC_OCSP_CRL


1814 
	$svc_l_che_funis
(

1815 
CtSvcIn
 

,

1816 
CtSvcCCacheWre
 
wreP
,

1817 
CtSvcCCacheRd
 
adP
,

1818 
CtSvcCFe
 
P
)

1820 
	`im
(

)->
	`tCRLFuni
(
wreP
, 
adP
, 
P
);

1821 
	}
}

1823 
	$svc_l_check
(

1824 
CtSvcCtifi
 
ifi
,

1825 
CtSvcCtifi
 *
uedSte
,

1826 
eSize
,

1827 
f
,

1828 *
us
,

1829 *
urPam
)

1831 
y
 {

1832  
	`im
(
ifi
.
iveIn
)->
	`lCheck
(

1833 
ifi
,

1834 
uedSte
,

1835 
eSize
,

1836 
f
,

1837 
us
,

1838 
urPam
);

1839 } 
	`tch
 (...) {}

1840  
CERTSVC_FAIL
;

1841 
	}
}

1844 
	$svc_ifi_vify
(

1845 
CtSvcCtifi
 
ifi
,

1846 
CtSvcCtifi
 *
ued
,

1847 
uedSize
,

1848 
CtSvcCtifi
 *
urued
,

1849 
uruedSize
,

1850 *
us
)

1852 
y
 {

1853 
check_ag_l
 = 0;

1854  
	`im
(
ifi
.
iveIn
)->
	`ifiVify
(

1855 
ifi
,

1856 
ued
,

1857 
uedSize
,

1858 
urued
,

1859 
uruedSize
,

1860 
check_ag_l
,

1861 
us
);

1862 } 
	`tch
 (...) {}

1863  
CERTSVC_FAIL
;

1864 
	}
}

1866 
	$svc_ifi_vify_wh_ag
(

1867 
CtSvcCtifi
 
ifi
,

1868 
CtSvcCtifi
 *
ued
,

1869 
uedSize
,

1870 
CtSvcCtifi
 *
urued
,

1871 
uruedSize
,

1872 *
us
)

1874 
y
 {

1875 
check_ag_ue
 = 1;

1876  
	`im
(
ifi
.
iveIn
)->
	`ifiVify
(

1877 
ifi
,

1878 
ued
,

1879 
uedSize
,

1880 
urued
,

1881 
uruedSize
,

1882 
check_ag_ue
,

1883 
us
);

1884 } 
	`tch
 (...) {}

1885  
CERTSVC_FAIL
;

1886 
	}
}

1888 
	$svc_ifi_g_visiby
(
CtSvcCtifi
 
ifi
, * 
visiby
)

1890 
y
 {

1891  
	`im
(
ifi
.
iveIn
)->
	`gVisiby
(ifi, 
visiby
);

1892 } 
	`tch
 (...)

1894 
	`WLogE
("exception occur");

1896  
CERTSVC_FAIL
;

1897 
	}
}

1899 
	$svc_pkcs12_s_exis
(
CtSvcIn
 

,

1900 
CtSvcSg
 
pfxIdSg
,

1901 *
is_unique
)

1903 
y
 {

1904  
	`im
(

)->
	`pkcsNameIsUnique
(
pfxIdSg
, 
is_unique
);

1905 } 
	`tch
 (...) {}

1906  
CERTSVC_FAIL
;

1907 
	}
}

1909 
	$svc_pkcs12_impt_om_fe
(
CtSvcIn
 

,

1910 
CtSvcSg
 
th
,

1911 
CtSvcSg
 
sswd
,

1912 
CtSvcSg
 
pfxIdSg
)

1914 
y
 {

1915  
	`im
(

)->
	`pkcsImpt
(
th
, 
sswd
, 
pfxIdSg
);

1916 } 
	`tch
 (...) {}

1917  
CERTSVC_FAIL
;

1918 
	}
}

1920 
	$svc_g_ifi
(
CtSvcIn
 

,

1921 
CtSteTy
 
eTy
,

1922 *
gme
,

1923 
CtSvcCtifi
 *
ifi
)

1925 
su
 = 
CERTSVC_SUCCESS
;

1926 * 
Bufr
 = 
NULL
;

1927 
d
::
rg
 
feName
;

1928 
size_t
 
ngth
 = 0;

1929 
FILE
* 
_wre
 = 
NULL
;

1930 
BIO
* 
pBio
 = 
NULL
;

1931 
X509
* 
x509Su
 = 
NULL
;

1933 
y
 {

1934 
su
 = 
	`c_svc_pkcs12_g_ifi_bufr_om_e
(
eTy
, 
gme
, &
Bufr
, &
ngth
);

1935 i(
su
 !
CERTSVC_SUCCESS
) {

1936 
	`WLogE
("Failedo get certificate buffer from store.");

1937  
su
;

1940 
pBio
 = 
	`BIO_w
(
	`BIO_s_mem
());

1941 i(
pBio
 =
NULL
) {

1942 
	`WLogE
("Failedollocate memory.");

1943 
su
 = 
CERTSVC_BAD_ALLOC
;

1946 
ngth
 = 
	`BIO_wre
(
pBio
, (cڡ *
Bufr
,ength);

1947 i(
ngth
 < 1) {

1948 
	`WLogE
("Failedooad cert into bio.");

1949 
su
 = 
CERTSVC_BAD_ALLOC
;

1952 
x509Su
 = 
	`PEM_ad_bio_X509
(
pBio
, 
NULL
, 0, NULL);

1953 i(
x509Su
 !
NULL
) {

1954 
CtifiP
 
	`
(
w
 
	`Ctifi
(
x509Su
));

1955 
ifi
->
iveIn
 = 

;

1956 
ifi
->
iveHdr
 = 
	`im
(

)->
	`addCt
(

);

1957 i(
Bufr
!=
NULL

	`
(certBuffer);

1960 
feName
.
	`nd
(
CERTSVC_PKCS12_STORAGE_DIR
);

1961 
feName
.
	`nd
(
gme
);

1962 i(!(
_wre
 = 
	`fݒ
(
feName
.
	`c_r
(), "w"))) {

1963 
	`WLogE
("Faedݒhff wrg, [%s].", 
feName
.
	`c_r
());

1964 
su
 = 
CERTSVC_FAIL
;

1965 
r
;

1968 i(
	`fwre
(
Bufr
, (), (
size_t
)
ngth
, 
_wre
) != (size_t)length) {

1969 
	`WLogE
("Failo write certificate.");

1970 
su
 = 
CERTSVC_FAIL
;

1971 
r
;

1974 
	`fo
(
_wre
);

1975 
su
 = 
	`svc_ifi_w_om_fe
(

, 
feName
.
	`c_r
(), 
ifi
);

1976 i(
su
 !
CERTSVC_SUCCESS
) {

1977 
	`WLogE
("Failedo construct certificate from buffer.");

1978 
r
;

1980 
	`uƚk
(
feName
.
	`c_r
());

1982 
su
 = 
CERTSVC_SUCCESS
;

1983 } 
	`tch
 (
d
::
bad_loc
 &) {

1984  
CERTSVC_BAD_ALLOC
;

1985 } 
	`tch
 (...) {}

1987 
r
:

1988 i(
x509Su

	`X509_
(x509Struct);

1989 i(
pBio

	`BIO_
(pBio);

1990  
su
;

1991 
	}
}

1993 
	$svc_pkcs12_check_s_exis__e
(
CtSvcIn
 

,

1994 
CtSteTy
 
eTy
,

1995 
CtSvcSg
 
pfxIdSg
,

1996 *
is_unique
)

1998 i(
pfxIdSg
.
iveHdr
 =
NULL
 ||fxIdSg.
iveLgth
<=0) {

1999 
	`WLogE
("Invalid inputarameter.");

2000  
CERTSVC_WRONG_ARGUMENT
;

2003 
y
 {

2004 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2005 
	`WLogE
("Invalid inputarameter.");

2006  
CERTSVC_INVALID_STORE_TYPE
;

2009  
	`im
(

)->
	`pkcsNameIsUniqueInSte
(
eTy
, 
pfxIdSg
, 
is_unique
);

2010 } 
	`tch
 (...) {}

2011  
CERTSVC_FAIL
;

2012 
	}
}

2014 
	$svc_pkcs12__ifi_li_lded_om_e
(
CtSvcIn
 

,

2015 
CtSvcSteCtLi
** 
Li
)

2017 i(*
Li
 =
NULL
) {

2018 
	`WLogE
("Invalid inputarameter.");

2019  
CERTSVC_WRONG_ARGUMENT
;

2022 
y
 {

2023  
	`im
(

)->
	`PkcsIdLiFromSte
(
Li
);

2024 } 
	`tch
 (...) {}

2025  
CERTSVC_FAIL
;

2026 
	}
}

2028 
	$svc_pkcs12_g_ifi_li_om_e
(
CtSvcIn
 

,

2029 
CtSteTy
 
eTy
,

2030 
is_ro_p
,

2031 
CtSvcSteCtLi
** 
Li
,

2032 * 
ngth
)

2034 i(*
Li
 !
NULL
) {

2035 
	`WLogE
("Invalid inputarameter.");

2036  
CERTSVC_WRONG_ARGUMENT
;

2039 
y
 {

2040 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2041 
	`WLogE
("Invalid inputarameter.");

2042  
CERTSVC_INVALID_STORE_TYPE
;

2045  
	`im
(

)->
	`gPkcsIdLiFromSte
(
eTy
, 
is_ro_p
, 
Li
, 
ngth
);

2046 } 
	`tch
 (...) {}

2048  
CERTSVC_FAIL
;

2049 
	}
}

2051 
	$svc_pkcs12_g_d_ur_ifi_li_om_e
(
CtSvcIn
 

,

2052 
CtSteTy
 
eTy
,

2053 
CtSvcSteCtLi
** 
Li
,

2054 * 
ngth
)

2056 i(*
Li
 !
NULL
) {

2057 
	`WLogE
("Invalid inputarameter.");

2058  
CERTSVC_WRONG_ARGUMENT
;

2061 
y
 {

2062 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2063 
	`WLogE
("Invalid inputarameter.");

2064  
CERTSVC_INVALID_STORE_TYPE
;

2067  
	`im
(

)->
	`gPkcsIdEndUrLiFromSte
(
eTy
, 
Li
, 
ngth
);

2068 } 
	`tch
 (...) {}

2069  
CERTSVC_FAIL
;

2070 
	}
}

2072 
	$svc_pkcs12_g_ro_ifi_li_om_e
(
CtSvcIn
 

,

2073 
CtSteTy
 
eTy
,

2074 
CtSvcSteCtLi
** 
Li
,

2075 * 
ngth
)

2077 i(*
Li
 !
NULL
) {

2078 
	`WLogE
("Invalid inputarameter.");

2079  
CERTSVC_WRONG_ARGUMENT
;

2082 
y
 {

2083 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2084 
	`WLogE
("Invalid inputarameter.");

2085  
CERTSVC_INVALID_STORE_TYPE
;

2088  
	`im
(

)->
	`gPkcsIdRoLiFromSte
(
eTy
, 
Li
, 
ngth
);

2089 } 
	`tch
 (...) {}

2090  
CERTSVC_FAIL
;

2091 
	}
}

2093 
	$svc_pkcs12_g_ifi_fo_om_e
(
CtSvcIn
 

,

2094 
CtSteTy
 
eTy
,

2095 
CtSvcSg
 
gme
,

2096 ** 
Bufr
,

2097 
size_t
* 
Size
)

2099 i(*
Bufr
 !
NULL
) {

2100 
	`WLogE
("Invalid inputarameter.");

2101  
CERTSVC_WRONG_ARGUMENT
;

2104 
y
 {

2105 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2106 
	`WLogE
("Invalid inputarameter.");

2107  
CERTSVC_INVALID_STORE_TYPE
;

2110  
	`im
(

)->
	`gCtDaFromSte
(
eTy
, 
gme
, 
Bufr
, 
Size
);

2111 } 
	`tch
 (...) {}

2112  
CERTSVC_FAIL
;

2113 
	}
}

2115 
	$svc_pkcs12_de_ifi_om_e
(
CtSvcIn
 

,

2116 
CtSteTy
 
eTy
,

2117 
CtSvcSg
 
gme
)

2119 
y
 {

2120 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2121 
	`WLogE
("Invalid inputarameter.");

2122  
CERTSVC_INVALID_STORE_TYPE
;

2124  
	`im
(

)->
	`pkcsDeCtFromSte
(
eTy
, 
gme
);

2125 } 
	`tch
 (...) {}

2126  
CERTSVC_FAIL
;

2127 
	}
}

2129 
	$svc_pkcs12_impt_om_fe_to_e
(
CtSvcIn
 

,

2130 
CtSteTy
 
eTy
,

2131 
CtSvcSg
 
th
,

2132 
CtSvcSg
 
sswd
,

2133 
CtSvcSg
 
pfxIdSg
)

2135 
y
 {

2136 i(
th
.
iveHdr
 !
NULL
) {

2137 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2138 
	`WLogE
("Invalid inputarameter.");

2139  
CERTSVC_INVALID_STORE_TYPE
;

2141  
	`im
(

)->
	`pkcsImptToSte
(
eTy
, 
th
, 
sswd
, 
pfxIdSg
);

2144  
CERTSVC_FAIL
;

2145 } 
	`tch
 (...) {}

2146  
CERTSVC_FAIL
;

2147 
	}
}

2149 
	$svc_pkcs12_g_s_me_f_ifi__e
(
CtSvcIn
 

,

2150 
CtSteTy
 
eTy
,

2151 
CtSvcSg
 
gme
,

2152 **
s
)

2154 i(
gme
.
iveHdr
 =
NULL
 || gme.
iveLgth
<=0) {

2155 
	`WLogE
("Invalid inputarameter.");

2156  
CERTSVC_WRONG_ARGUMENT
;

2159 
y
 {

2160 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2161 
	`WLogE
("Invalid inputarameter.");

2162  
CERTSVC_INVALID_STORE_TYPE
;

2164  
	`im
(

)->
	`pkcsGAlsNameFCtInSte
(
eTy
, 
gme
, 
s
);

2165 } 
	`tch
 (...) {}

2166  
CERTSVC_FAIL
;

2167 
	}
}

2169 
	$svc_pkcs12_t_ifi_us_to_e
(
CtSvcIn
 

,

2170 
CtSteTy
 
eTy
,

2171 
is_ro_p
,

2172 
CtSvcSg
 
gme
,

2173 
CtStus
 
us
)

2175 
y
 {

2176 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2177 
	`WLogE
("Invalid inputarameter.");

2178  
CERTSVC_INVALID_STORE_TYPE
;

2180  
	`im
(

)->
	`pkcsSCtStusToSte
(
eTy
, 
is_ro_p
, 
gme
, 
us
);

2181 } 
	`tch
 (...) {}

2182  
CERTSVC_FAIL
;

2183 
	}
}

2185 
	$svc_pkcs12_g_ifi_us_om_e
(

2186 
CtSvcIn
 

,

2187 
CtSteTy
 
eTy
,

2188 
CtSvcSg
 
gme
,

2189 *
us
)

2191 
y
 {

2192 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2193 
	`WLogE
("Invalid inputarameter.");

2194  
CERTSVC_INVALID_STORE_TYPE
;

2196  
	`im
(

)->
	`pkcsGCtStusFromSte
(
eTy
, 
gme
, 
us
);

2197 } 
	`tch
 (...) {}

2198  
CERTSVC_FAIL
;

2199 
	}
}

2201 
	$svc_pkcs12_g_ifi_om_e
(
CtSvcIn
 

,

2202 
CtSteTy
 
eTy
,

2203 *
gme
,

2204 
CtSvcCtifi
 *
ifi
)

2206 
y
 {

2207 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2208 
	`WLogE
("Invalid inputarameter.");

2209  
CERTSVC_INVALID_STORE_TYPE
;

2211  
	`im
(

)->
	`gCtFromSte
(, 
eTy
, 
gme
, 
ifi
);

2212 } 
	`tch
 (...) {}

2213  
CERTSVC_FAIL
;

2214 
	}
}

2216 
	$svc_pkcs12_ld_ifi_li_om_e
(

2217 
CtSvcIn
 

,

2218 
CtSteTy
 
eTy
,

2219 
CtSvcSg
 
pfxIdSg
,

2220 
CtSvcCtifiLi
 *
ifiLi
)

2222 
y
 {

2223 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2224 
	`WLogE
("Invalid inputarameter.");

2225  
CERTSVC_INVALID_STORE_TYPE
;

2227  
	`im
(

)->
	`gPkcsCtifiLiFromSte
(, 
eTy
, 
pfxIdSg
, 
ifiLi
);

2228 } 
	`tch
 (...) {}

2229  
CERTSVC_FAIL
;

2230 
	}
}

2232 
	$svc_pkcs12_ive_key_dup_om_e
(

2233 
CtSvcIn
 

,

2234 
CtSteTy
 
eTy
,

2235 
CtSvcSg
 
gme
,

2236 **
Bufr
,

2237 
size_t
 *
Size
)

2239 
y
 {

2240 i(!
	`im
(

)->
	`checkVidSteTy
(
eTy
)) {

2241 
	`WLogE
("Invalid inputarameter.");

2242  
CERTSVC_INVALID_STORE_TYPE
;

2244  
	`im
(

)->
	`gPkcsPriveKeyFromSte
(
eTy
, 
gme
, 
Bufr
, 
Size
);

2245 } 
	`tch
 (...) {}

2246  
CERTSVC_FAIL
;

2247 
	}
}

2249 
	$svc_pkcs12_dup_evp_pkey_om_e
(

2250 
CtSvcIn
 

,

2251 
CtSteTy
 
eTy
,

2252 
CtSvcSg
 
gme
,

2253 
EVP_PKEY
** 
pkey
)

2255 *
bufr
 = 
NULL
;

2256 
size_t
 
size
;

2258 
su
 = 
	`svc_pkcs12_ive_key_dup_om_e
(

, 
eTy
, 
gme
, &
bufr
, &
size
);

2259 i(
su
 !
CERTSVC_SUCCESS
) {

2260 
	`WLogE
("Error in certsvc_pkcs12_private_key_dup");

2261  
su
;

2264 
BIO
 *
b
 = 
	`BIO_w
(
	`BIO_s_mem
());

2265 i(()
size
 !
	`BIO_wre
(
b
, 
bufr
, size)) {

2266 
	`WLogE
("Error in BIO_write");

2267 
	`BIO__l
(
b
);

2268 
	`svc_pkcs12_ive_key_
(
bufr
);

2269  
CERTSVC_FAIL
;

2272 
	`svc_pkcs12_ive_key_
(
bufr
);

2273 *
pkey
 = 
	`PEM_ad_bio_PriveKey
(
b
, 
NULL
, NULL, NULL);

2274 
	`BIO__l
(
b
);

2275 i(*
pkey
)

2276  
CERTSVC_SUCCESS
;

2278 
	`WLogE
("Resu inu. Ons REASON codis: %d", 
	`ERR_GET_REASON
(
	`ERR_ek_ϡ_r
()));

2279  
CERTSVC_FAIL
;

2280 
	}
}

2282 
	$svc_pkcs12_g_id_li
(

2283 
CtSvcIn
 

,

2284 
CtSvcSgLi
 *
pfxIdSgLi
)

2286 
y
 {

2287  
	`im
(

)->
	`gPkcsIdLi
(

2288 

,

2289 
pfxIdSgLi
);

2290 } 
	`tch
 (...) {}

2291  
CERTSVC_FAIL
;

2292 
	}
}

2294 
	$svc_pkcs12_has_sswd
(

2295 
CtSvcIn
 

,

2296 
CtSvcSg
 
fh
,

2297 *
has_sswd
)

2299 
y
 {

2300  
	`im
(

)->
	`pkcsHasPasswd
(

2301 
fh
,

2302 
has_sswd
);

2303 } 
	`tch
 (...) {}

2304  
CERTSVC_FAIL
;

2305 
	}
}

2307 
	$svc_pkcs12_ld_ifi_li
(

2308 
CtSvcIn
 

,

2309 
CtSvcSg
 
pfxIdSg
,

2310 
CtSvcCtifiLi
 *
ifiLi
)

2312 
y
 {

2313  
	`im
(

)->
	`gPkcsCtifiLi
(

2314 

,

2315 
pfxIdSg
,

2316 
ifiLi
);

2317 } 
	`tch
 (...) {}

2318  
CERTSVC_FAIL
;

2319 
	}
}

2321 
	$svc_pkcs12_ive_key_dup
(

2322 
CtSvcIn
 

,

2323 
CtSvcSg
 
pfxIdSg
,

2324 **
bufr
,

2325 
size_t
 *
size
)

2327 
y
 {

2328  
	`im
(

)->
	`gPkcsPriveKey
(
pfxIdSg
, 
bufr
, 
size
);

2329 } 
	`tch
 (...) {}

2330  
CERTSVC_FAIL
;

2331 
	}
}

2333 
	$svc_pkcs12_ive_key_
(

2334 *
bufr
)

2336 
	`
(
bufr
);

2337 
	}
}

2339 
	$svc_pkcs12_de
(

2340 
CtSvcIn
 

,

2341 
CtSvcSg
 
pfxIdSg
)

2343 
y
 {

2344  
	`im
(

)->
	`pkcsDe
(
pfxIdSg
);

2345 } 
	`tch
 (...) {}

2346  
CERTSVC_FAIL
;

2347 
	}
}

	@vcore/src/vcore/cert-svc-client.c

24 
	~<sys/.h
>

25 
	~<sys/un.h
>

26 
	~<sys/tys.h
>

27 
	~<sys/sock.h
>

28 
	~<o.h
>

29 
	~<rg.h
>

30 
	~<dlib.h
>

31 
	~<unid.h
>

33 
	~<-rvi-debug.h
>

35 
	~<-svc-.h
>

37 
	$lize_s_da
(
VceReڣDa
 *
pDa
)

39 
	`memt
(
pDa
->
daBlock
, 0, 
VCORE_MAX_RECV_DATA_SIZE
);

40 
	`memt
(
pDa
->
comm_me
, 0, 
VCORE_MAX_FILENAME_SIZE
 * 2 + 1);

41 
pDa
->
daBlockL
 = 0;

42 
pDa
->
Stus
 = 0;

43 
pDa
->
su
 = 0;

44 
pDa
->
Li
 = 
NULL
;

45 
pDa
->
Cou
 = 0;

46 
pDa
->
BlockLi
 = 
NULL
;

47 
pDa
->
BlockCou
 = 0;

48 
	}
}

50 
	$lize_q_da
(
VceRequeDa
 *
pDa
)

52 
	`memt
(
pDa
->
gme
, 0, 
VCORE_MAX_FILENAME_SIZE
+1);

53 
	`memt
(
pDa
->
comm_me
, 0, 
VCORE_MAX_FILENAME_SIZE
+1);

54 
	`memt
(
pDa
->
ive_key_gme
, 0, 
VCORE_MAX_FILENAME_SIZE
+1);

55 
	`memt
(
pDa
->
assocd_gme
, 0, 
VCORE_MAX_FILENAME_SIZE
+1);

56 
	`memt
(
pDa
->
daBlock
, 0, 
VCORE_MAX_SEND_DATA_SIZE
);

57 
pDa
->
Stus
 = 0;

58 
pDa
->
eTy
 = -1;

59 
pDa
->
qTy
 = -1;

60 
pDa
->
daBlockL
 = -1;

61 
pDa
->
is_ro_p
 = -1;

62 
	}
}

64 
	$_cv_fixed_nghth
(
sockfd
, *
buff
, 
ngth
)

66 
offt
 = 0;

67 
mag
 = 
ngth
;

68 
ad_n
 = 0;

69 
mag
 > 0) {

70 
ad_n
 = 
	`cv
(
sockfd
, 
buff
 + 
offt
, 
mag
, 0);

71 if(
ad_n
 <= 0)

72  
offt
;

73 
mag
 -
ad_n
;

74 
offt
 +
ad_n
;

76  
offt
;

77 
	}
}

79 
VceRequeDa
* 
	$t_que_da
(

80 
qTy
,

81 
CtSteTy
 
eTy
,

82 
is_ro_p
,

83 cڡ *
pGroupName
,

84 cڡ *
comm_me
,

85 cڡ *
ive_key_gme
,

86 cڡ *
assocd_gme
,

87 cڡ *
pDa
,

88 
size_t
 
daL
,

89 
CtTy
 
Ty
,

90 
Stus
)

92 
VceRequeDa
* 
pReqDa
 = (VceRequeDa*)
	`mloc
((VcoreRequestData));

93 i(!
pReqDa
) {

94 
	`LOGE
("Failedo malloc VcoreRequestData");

95  
NULL
;

97 
	`lize_q_da
(
pReqDa
);

99 
pReqDa
->
qTy
 =eqType;

100 
pReqDa
->
eTy
 = (
CtSteTy
) storeType;

101 
pReqDa
->
daBlockL
 = 
daL
;

102 
pReqDa
->
Ty
 = certType;

103 
pReqDa
->
Stus
 = certStatus;

104 
pReqDa
->
is_ro_p
 = is_root_app;

106 i(
pGroupName
) {

107 i(
	`
(
pGroupName
> 
VCORE_MAX_FILENAME_SIZE
) {

108 
	`LOGE
("The dataame isooong");

109 
	`
(
pReqDa
);

110  
NULL
;

112 
	`y
(
pReqDa
->
gme
, 
pGroupName
, 
VCORE_MAX_FILENAME_SIZE
);

113 
pReqDa
->
gme
[
	`
(
pGroupName
)] = '\0';

116 i(
comm_me
) {

117 i(
	`
(
comm_me
> 
VCORE_MAX_FILENAME_SIZE
) {

118 
	`LOGE
("Theength ofheath specified isooong");

119 
	`
(
pReqDa
);

120  
NULL
;

122 
	`y
(
pReqDa
->
comm_me
, comm_me, 
VCORE_MAX_FILENAME_SIZE
);

123 
pReqDa
->
comm_me
[
	`
(common_name)] = '\0';

126 i(
ive_key_gme
) {

127 i(
	`
(
ive_key_gme
> 
VCORE_MAX_FILENAME_SIZE
) {

128 
	`LOGE
("Therivate key gname isooong");

129 
	`
(
pReqDa
);

130  
NULL
;

132 
	`y
(
pReqDa
->
ive_key_gme
,rive_key_gme, 
VCORE_MAX_FILENAME_SIZE
);

133 
pReqDa
->
ive_key_gme
[
	`
(private_key_gname)] = '\0';

136 i(
assocd_gme
) {

137 i(
	`
(
assocd_gme
> 
VCORE_MAX_FILENAME_SIZE
) {

138 
	`LOGE
("Thessociated gname isooong");

139 
	`
(
pReqDa
);

140  
NULL
;

142 
	`y
(
pReqDa
->
assocd_gme
,ssocd_gme, 
VCORE_MAX_FILENAME_SIZE
);

143 
pReqDa
->
assocd_gme
[
	`
(associated_gname)] = '\0';

146 i(
daL
 !0 && 
pDa
 !
NULL
) {

147 i(
daL
 > 
VCORE_MAX_SEND_DATA_SIZE
) {

148 
	`LOGE
("Thdngth itolg [%d]", 
daL
);

149 
	`
(
pReqDa
);

150  
NULL
;

152 
	`memy
(
pReqDa
->
daBlock
, 
pDa
, 
daL
);

154  
pReqDa
;

155 
	}
}

158 
VceReڣDa
 
	$_svc__comm
(
VceRequeDa
* 
pClDa
) {

160 
sockfd
 = 0;

161 
L
 = 0;

162 
mpSockL
 = 0;

163 
ad_n
 = 0;

164 
i
 = 0;

165 
sockaddr_un
 
addr
;

166 
VceReڣDa
 
cvDa
;

167 
	`lize_s_da
(&
cvDa
);

169 i((
sockfd
 = 
	`sock
(
AF_UNIX
, 
SOCK_STREAM
, 0)) < 0) {

170 
	`LOGE
("Error in function socket()..");

171 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

172 
E_ex
;

175 
mpSockL
 = 
	`
(
VCORE_SOCK_PATH
);

176 
	`bzo
(&
addr
, (clientaddr));

177 
addr
.
sun_my
 = 
AF_UNIX
;

178 
	`y
(
addr
.
sun_th
, 
VCORE_SOCK_PATH
, 
mpSockL
);

179 
addr
.
sun_th
[
mpSockL
] = '\0';

180 
L
 = (
addr
);

182 
timev
 
timeout
;

183 
timeout
.
tv_c
 = 10;

184 
timeout
.
tv_uc
 = 0;

186 i(
	`tsockt
 (
sockfd
, 
SOL_SOCKET
, 
SO_RCVTIMEO
, (*)&
timeout
, (timeout)) < 0) {

187 
	`LOGE
("Error in Set SO_RCVTIMEO Socket Option");

188 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

189 
E_o_ex
;

192 i(
	`tsockt
 (
sockfd
, 
SOL_SOCKET
, 
SO_SNDTIMEO
, (*)&
timeout
, (timeout)) < 0) {

193 
	`LOGE
("Error in Set SO_SNDTIMEO Socket Option");

194 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

195 
E_o_ex
;

198 i(
	`c
(
sockfd
, (
sockaddr
*)&
addr
, 
L
) < 0) {

199 
	`LOGE
("Error in function connect()..");

200 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

201 
E_o_ex
;

204 i(
	`wre
(
sockfd
, (*)
pClDa
, (
VceRequeDa
)) < 0) {

205 
	`LOGE
("Error in function write()..");

206 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

207 
E_o_ex
;

210 
ad_n
 = 
	`_cv_fixed_nghth
(
sockfd
, (*)&
cvDa
, (recvData));

211 i(
ad_n
 < 0) {

212 
	`LOGE
("Error in functionead()..");

213 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

214 
E_o_ex
;

217 if(
cvDa
.
Cou
 > 0) {

218 
cvDa
.
Li
 = (
VceCtReڣDa
 *
	`mloc
ecvDa.
Cou
 * (VcoreCertResponseData));

219 i(!
cvDa
.
Li
) {

220 
	`LOGE
("Failedollocate memory");

221 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

222 
E_o_ex
;

224 
	`memt
(
cvDa
.
Li
, 0x00,ecvDa.
Cou
 * (
VceCtReڣDa
));

225 
i
=0; i<
cvDa
.
Cou
; i++) {

226 
ad_n
 = 
	`_cv_fixed_nghth
(
sockfd
, (*)(
cvDa
.
Li
 + 
i
), (
VceCtReڣDa
));

227 i(
ad_n
 < 0) {

228 
	`LOGE
("Error in functionead()..");

229 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

230 
E_o_ex
;

235 if(
cvDa
.
BlockCou
 > 0) {

236 
cvDa
.
BlockLi
 = (
ReڣCtBlock
 *
	`mloc
ecvDa.
BlockCou
 * (ResponseCertBlock));

237 i(!
cvDa
.
BlockLi
) {

238 
	`LOGE
("Failedollocate memory");

239 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

240 
E_o_ex
;

242 
	`memt
(
cvDa
.
BlockLi
, 0x00,ecvDa.
BlockCou
 * (
ReڣCtBlock
));

243 
i
=0; i<
cvDa
.
BlockCou
; i++) {

244 
ad_n
 = 
	`_cv_fixed_nghth
(
sockfd
, (*)(
cvDa
.
BlockLi
 + 
i
), (
ReڣCtBlock
));

245 i(
ad_n
 < 0) {

246 
	`LOGE
("Error in functionead()..");

247 
cvDa
.
su
 = 
VCORE_SOCKET_ERROR
;

248 
E_o_ex
;

253 
E_o_ex
:

254 
	`o
(
sockfd
);

255 i(
cvDa
.
su
 =
VCORE_SOCKET_ERROR
) {

256 
	`
(
cvDa
.
Li
);

257 
cvDa
.
Li
 = 
NULL
;

258 
cvDa
.
Cou
 = 0;

260 
	`
(
cvDa
.
BlockLi
);

261 
cvDa
.
BlockLi
 = 
NULL
;

262 
cvDa
.
BlockCou
 = 0;

265 
E_ex
:

266  
cvDa
;

267 
	}
}

269 
	$vce__l_ifi_to_e
(

270 
CtSteTy
 
eTy
,

271 cڡ *
gme
,

272 cڡ *
comm_me
,

273 cڡ *
ive_key_gme
,

274 cڡ *
assocd_gme
,

275 cڡ *
Da
,

276 
size_t
 
Size
,

277 
CtTy
 
Ty
)

279 
VceRequeDa
* 
pSdDa
 = 
NULL
;

280 
VceReڣDa
 
cvDa
;

281 
	`lize_s_da
(&
cvDa
);

283 i(!
gme
 && !
Da
) {

284 
	`LOGE
("Invalid inputrgument.");

285  
CERTSVC_WRONG_ARGUMENT
;

288 
pSdDa
 = 
	`t_que_da
(

289 
CERTSVC_INSTALL_CERTIFICATE
,

290 
eTy
,

291 
DISABLED
,

292 
gme
,

293 
comm_me
,

294 
ive_key_gme
,

295 
assocd_gme
,

296 
Da
,

297 
Size
,

298 
Ty
, 0);

299 i(
pSdDa
 =
NULL
) {

300 
	`LOGE
("Failedo setequest data");

301  
CERTSVC_WRONG_ARGUMENT
;

304 
cvDa
 = 
	`_svc__comm
(
pSdDa
);

305 
	`
(
pSdDa
);

306  
cvDa
.
su
;

307 
	}
}

309 
	$vce__t_ifi_us_to_e
(
CtSteTy
 
eTy
, 
is_ro_p
, cڡ * 
gme
, 
CtStus
 
us
) {

311 
VceRequeDa
* 
pSdDa
 = 
NULL
;

312 
VceReڣDa
 
cvDa
;

313 
	`lize_s_da
(&
cvDa
);

315 i(
gme
 =
NULL
) {

316 
	`LOGE
("Invalid inputarameter.");

317  
CERTSVC_WRONG_ARGUMENT
;

320 
pSdDa
 = 
	`t_que_da
(
CERTSVC_SET_CERTIFICATE_STATUS
, 
eTy
, 
is_ro_p
, 
gme
, 
NULL
, NULL, NULL, NULL, 0, 0, 
us
);

321 i(
pSdDa
 =
NULL
) {

322 
	`LOGE
("Failedo setequest data");

323  
CERTSVC_WRONG_ARGUMENT
;

326 
cvDa
 = 
	`_svc__comm
(
pSdDa
);

327 
	`
(
pSdDa
);

329  
cvDa
.
su
;

330 
	}
}

332 
	$vce__g_ifi_us_om_e
(
CtSteTy
 
eTy
, cڡ * 
gme
, *
us
) {

334 
VceRequeDa
* 
pSdDa
 = 
NULL
;

335 
VceReڣDa
 
cvDa
;

336 
	`lize_s_da
(&
cvDa
);

338 i(
gme
 =
NULL
) {

339 
	`LOGE
("Invalid inputarameter.");

340  
CERTSVC_WRONG_ARGUMENT
;

343 
pSdDa
 = 
	`t_que_da
(
CERTSVC_GET_CERTIFICATE_STATUS
, 
eTy
, 
DISABLED
, 
gme
, 
NULL
, NULL, NULL, NULL, 0, 0, 0);

344 i(
pSdDa
 =
NULL
) {

345 
	`LOGE
("Failedo setequest data");

346  
CERTSVC_WRONG_ARGUMENT
;

349 
cvDa
 = 
	`_svc__comm
(
pSdDa
);

350 
	`
(
pSdDa
);

351 *
us
 = 
cvDa
.
Stus
;

352  
cvDa
.
su
;

353 
	}
}

355 
	$vce__check_s_exi__e
(
CtSteTy
 
eTy
, cڡ * 
s
, *
us
) {

357 
VceRequeDa
* 
pSdDa
 = 
NULL
;

358 
VceReڣDa
 
cvDa
;

359 
	`lize_s_da
(&
cvDa
);

361 i(
s
 =
NULL
) {

362 
	`LOGE
("Invalid inputarameter.");

363  
CERTSVC_WRONG_ARGUMENT
;

366 
pSdDa
 = 
	`t_que_da
(
CERTSVC_CHECK_ALIAS_EXISTS
, 
eTy
, 
DISABLED
,
s
, 
NULL
, NULL, NULL, NULL, 0, 0, 0);

367 i(
pSdDa
 =
NULL
) {

368 
	`LOGE
("Failedo setequest data");

369  
CERTSVC_WRONG_ARGUMENT
;

372 
cvDa
 = 
	`_svc__comm
(
pSdDa
);

373 
	`
(
pSdDa
);

374 *
us
 = 
cvDa
.
Stus
;

375  
cvDa
.
su
;

376 
	}
}

378 
	$vce__g_ifi_om_e
(
CtSteTy
 
eTy
, cڡ * 
gme
, ** 
Da
, 
size_t
* 
Size
, 
CtTy
 
Ty
) {

380 * 
outDa
 = 
NULL
;

381 
VceRequeDa
* 
pSdDa
 = 
NULL
;

382 
VceReڣDa
 
cvDa
;

384 i(!
gme
 || !
Da
 || !
Size
) {

385 
	`LOGE
("Invalid inputrgument.");

386  
CERTSVC_WRONG_ARGUMENT
;

389 
	`lize_s_da
(&
cvDa
);

391 i(
eTy
 =
SYSTEM_STORE
)

392 
pSdDa
 = 
	`t_que_da
(
CERTSVC_EXTRACT_SYSTEM_CERT
, 
eTy
, 
DISABLED
, 
gme
, 
NULL
, NULL, NULL, NULL, 0, 
Ty
, 0);

394 
pSdDa
 = 
	`t_que_da
(
CERTSVC_EXTRACT_CERT
, 
eTy
, 
DISABLED
, 
gme
, 
NULL
, NULL, NULL, NULL, 0, 
Ty
, 0);

396 i(
pSdDa
 =
NULL
) {

397 
	`LOGE
("Failedo setequest data.");

398  
CERTSVC_WRONG_ARGUMENT
;

401 
cvDa
 = 
	`_svc__comm
(
pSdDa
);

402 i(
cvDa
.
su
 < 0) {

403 
	`LOGE
("Ar occued from sv sidr[%d]", 
cvDa
.
su
);

404 
	`
(
pSdDa
);

405  
cvDa
.
su
;

407 
	`
(
pSdDa
);

409 i(
cvDa
.
daBlockL
 > 0 &&ecvDa.daBlockL <
VCORE_MAX_RECV_DATA_SIZE
) {

410 
outDa
 = (*)
	`mloc
(
cvDa
.
daBlockL
 + 1);

411 
	`memt
(
outDa
, 0x00, 
cvDa
.
daBlockL
 +1);

412 
	`memy
(
outDa
, 
cvDa
.
daBlock
,ecvDa.
daBlockL
);

413 *
Da
 = 
outDa
;

414 *
Size
 = 
cvDa
.
daBlockL
;

417 
	`LOGE
("vcDngth iwrg : %d", 
cvDa
.
daBlockL
);

418  
CERTSVC_WRONG_ARGUMENT
;

421  
cvDa
.
su
;

422 
	}
}

424 
	$vce__de_ifi_om_e
(
CtSteTy
 
eTy
, cڡ * 
gme
) {

426 
VceRequeDa
* 
pSdDa
 = 
NULL
;

427 
VceReڣDa
 
cvDa
;

428 
	`lize_s_da
(&
cvDa
);

430 i(
gme
 =
NULL
) {

431 
	`LOGE
("Invalid inputarameter.");

432  
CERTSVC_WRONG_ARGUMENT
;

435 
pSdDa
 = 
	`t_que_da
(
CERTSVC_DELETE_CERT
, 
eTy
, 
DISABLED
, 
gme
, 
NULL
, NULL, NULL, NULL, 0, 0, 0);

436 i(
pSdDa
 =
NULL
) {

437 
	`LOGE
("Failedo setequest data");

438  
CERTSVC_WRONG_ARGUMENT
;

441 
cvDa
 = 
	`_svc__comm
(
pSdDa
);

442 
	`
(
pSdDa
);

443  
cvDa
.
su
;

444 
	}
}

446 
	$_vce__g_ifi_li_om_e
(
qTy
, 
CtSteTy
 
eTy
, 
is_ro_p
,

447 
CtSvcSteCtLi
** 
Li
, * 
ngth
)

449 
VceRequeDa
* 
pSdDa
 = 
NULL
;

450 
VceReڣDa
 
cvDa
;

451 
CtSvcSteCtLi
* 
cu
 = 
NULL
;

452 
CtSvcSteCtLi
* 
ev
 = 
NULL
;

453 
VceCtReڣDa
* 

 = 
NULL
;

454 
tm
 = 0;

455 
i
=0;

456 
	`lize_s_da
(&
cvDa
);

459 
pSdDa
 = 
	`t_que_da
(
qTy
, 
eTy
, 
is_ro_p
, 
NULL
, NULL, NULL, NULL, NULL, 0, 0, 0);

460 i(
pSdDa
 =
NULL
) {

461 
	`LOGE
("Failedo setequest data");

462  
CERTSVC_WRONG_ARGUMENT
;

465 
cvDa
 = 
	`_svc__comm
(
pSdDa
);

467 if(
cvDa
.
Cou
 > 0) {

468 
i
=0; i<
cvDa
.
Cou
; i++) {

469 

 = 
cvDa
.
Li
 + 
i
 ;

470 
cu
 = (
CtSvcSteCtLi
*
	`mloc
((CertSvcStoreCertList));

471 
	`memt
(
cu
, 0x00, (
CtSvcSteCtLi
));

473 
tm
 = 
	`
(

->
gme
);

474 
cu
->
gme
 = (*
	`mloc
 ((* (
tm
+ 1));

475 
	`memt
(
cu
->
gme
, 0x00, 
tm
 + 1);

476 
	`memy
(
cu
->
gme
, 

->gme, 
tm
);

478 
tm
 = 
	`
(

->
t
);

479 
cu
->
t
 = (*
	`mloc
 ((* (
tm
+ 1));

480 
	`memt
(
cu
->
t
, 0x00, 
tm
 + 1);

481 
	`memy
(
cu
->
t
, 

->t, 
tm
);

483 
cu
->
us
 = 

->status;

484 
cu
->
eTy
 = 

->storeType;

486 if(
ev
 =
NULL
) {

487 *
Li
 = 
cu
;

489 
ev
->
xt
 = 
cu
;

491 
ev
 = 
cu
;

495 *
ngth
 = 
cvDa
.
Cou
;

497 
	`LOGI
("g_ifi_li_om_e:esu=%d", 
cvDa
.
su
);

498 if(
cvDa
.
Li
 !
NULL
)

499 
	`
(
cvDa
.
Li
);

500 
	`
(
pSdDa
);

501  
cvDa
.
su
;

502 
	}
}

504 
	$vce__g_ifi_li_om_e
(
CtSteTy
 
eTy
, 
is_ro_p
,

505 
CtSvcSteCtLi
** 
Li
, * 
ngth
)

507  
	`_vce__g_ifi_li_om_e
(
CERTSVC_GET_CERTIFICATE_LIST
, 
eTy
, 
is_ro_p
,

508 
Li
, 
ngth
);

509 
	}
}

511 
	$vce__g_ro_ifi_li_om_e
(
CtSteTy
 
eTy
,

512 
CtSvcSteCtLi
** 
Li
, * 
ngth
)

514  
	`_vce__g_ifi_li_om_e
(
CERTSVC_GET_ROOT_CERTIFICATE_LIST
, 
eTy
, 0,

515 
Li
, 
ngth
);

516 
	}
}

518 
	$vce__g_d_ur_ifi_li_om_e
(
CtSteTy
 
eTy
,

519 
CtSvcSteCtLi
** 
Li
, * 
ngth
)

521  
	`_vce__g_ifi_li_om_e
(
CERTSVC_GET_USER_CERTIFICATE_LIST
, 
eTy
, 0,

522 
Li
, 
ngth
);

523 
	}
}

525 
	$vce__g_ifi_s_om_e
(
CtSteTy
 
eTy
, cڡ *
gme
, **
s
)

527 
VceRequeDa
* 
pSdDa
 = 
NULL
;

528 
VceReڣDa
 
cvDa
;

529 
	`lize_s_da
(&
cvDa
);

531 i(
gme
 =
NULL
) {

532 
	`LOGE
("Invalid inputarameter.");

533  
CERTSVC_WRONG_ARGUMENT
;

536 
pSdDa
 = 
	`t_que_da
(
CERTSVC_GET_CERTIFICATE_ALIAS
, 
eTy
, 
DISABLED
, 
gme
, 
NULL
, NULL, NULL, NULL, 0, 0, 0);

537 i(
pSdDa
 =
NULL
) {

538 
	`LOGE
("Failedo setequest data");

539  
CERTSVC_WRONG_ARGUMENT
;

542 
cvDa
 = 
	`_svc__comm
(
pSdDa
);

544 *
s
 = 
	`dup
(
cvDa
.
comm_me
, (recvData.common_name));

545 
	`
(
pSdDa
);

546  
cvDa
.
su
;

547 
	}
}

549 
	$vce__ld_ifis_om_e
(
CtSteTy
 
eTy
, cڡ *
gme
, ***
s
, *
ns
)

551 
VceRequeDa
* 
pSdDa
 = 
NULL
;

552 
VceReڣDa
 
cvDa
;

553 
ReڣCtBlock
* 

 = 
NULL
;

554 
i
=0;

555 
	`lize_s_da
(&
cvDa
);

557 
pSdDa
 = 
	`t_que_da
(
CERTSVC_LOAD_CERTIFICATES
, 
eTy
, 
DISABLED
, 
gme
, 
NULL
, NULL, NULL, NULL, 0, 0, 0);

558 i(
pSdDa
 =
NULL
) {

559 
	`LOGE
("Failedo setequest data");

560  
CERTSVC_WRONG_ARGUMENT
;

563 
cvDa
 = 
	`_svc__comm
(
pSdDa
);

565 *
ns
 = 
cvDa
.
BlockCou
;

566 *
s
 = (**)
	`mloc
((
cvDa
.
BlockCou
+1) * (*));

567 (*
s
)[
cvDa
.
BlockCou
] = 
NULL
;

568 
	`LOGD
("vce__ld_ifis_om_e.esu=%d,s=%d", 
cvDa
.
su
, *
ns
);

569 if(
cvDa
.
BlockCou
 > 0) {

570 
i
=0; i<
cvDa
.
BlockCou
; i++) {

571 

 = 
cvDa
.
BlockLi
 + 
i
 ;

572 (*
s
)[
i
] = 
	`dup
(

->
daBlock
, ct->
daBlockL
);

573 
	`LOGD
("vce__ld_ifis_om_e. ct=%s", (*
s
)[
i
]);

577 if(
cvDa
.
BlockLi
 !
NULL
)

578 
	`
(
cvDa
.
BlockLi
);

579 
	`
(
pSdDa
);

580  
cvDa
.
su
;

582 
	}
}

	@vcore/src/vcore/cert-svc-client.h

23 #ide
CERT_SVC_CLIENT_H_


24 
	#CERT_SVC_CLIENT_H_


	)

26 
	~<-svc/.h
>

27 
	~<-svc/c.h
>

29 #ifde
__lulus


33 
	#VCORE_MAX_FILENAME_SIZE
 128

	)

34 
	#VCORE_MAX_RECV_DATA_SIZE
 8192

35 
	#VCORE_MAX_SEND_DATA_SIZE
 8192

36 
	#VCORE_MAX_GROUP_ID_SIZE
 32

	)

37 
	#VCORE_MAX_APPID_SIZE
 32

	)

38 
	#VCORE_MAX_PASSWORD_SIZE
 32

	)

39 
	#VCORE_SOCKET_ERROR
 (-0x01C10000)

40 
	#VCORE_SOCK_PATH
 "/tmp/CtSock"

	)

41 
	#VCORE_PKEY_TEMP_PATH
 "/tmp/tmpDa"

	)

44 
CERTSVC_EXTRACT_CERT
,

45 
CERTSVC_EXTRACT_SYSTEM_CERT
,

46 
CERTSVC_DELETE_CERT
,

47 
CERTSVC_INSTALL_CERTIFICATE
,

48 
CERTSVC_GET_CERTIFICATE_STATUS
,

49 
CERTSVC_SET_CERTIFICATE_STATUS
,

50 
CERTSVC_CHECK_ALIAS_EXISTS
,

51 
CERTSVC_GET_CERTIFICATE_LIST
,

52 
CERTSVC_GET_CERTIFICATE_ALIAS
,

53 
CERTSVC_GET_USER_CERTIFICATE_LIST
,

54 
CERTSVC_GET_ROOT_CERTIFICATE_LIST
,

55 
CERTSVC_LOAD_CERTIFICATES
,

56 } 
	tVceRequeTy
;

59 
VceRequeTy
 
qTy
;

60 
CtSteTy
 
eTy
;

61 
gme
[
VCORE_MAX_FILENAME_SIZE
 * 2 + 1];

62 
comm_me
[
VCORE_MAX_FILENAME_SIZE
 * 2 + 1];

63 
ive_key_gme
[
VCORE_MAX_FILENAME_SIZE
 * 2 + 1];

64 
assocd_gme
[
VCORE_MAX_FILENAME_SIZE
 * 2 + 1];

65 
daBlock
[
VCORE_MAX_SEND_DATA_SIZE
];

66 
size_t
 
daBlockL
;

67 
Stus
;

68 
is_ro_p
;

69 
CtTy
 
Ty
;

70 } 
	tVceRequeDa
;

73 
gme
[
VCORE_MAX_FILENAME_SIZE
 * 2 + 1];

74 
t
[
VCORE_MAX_FILENAME_SIZE
 * 2 + 1];

75 
us
;

76 
CtSteTy
 
eTy
;

77 } 
	tVceCtReڣDa
;

81 
daBlock
[
VCORE_MAX_RECV_DATA_SIZE
];

82 
size_t
 
daBlockL
;

83 } 
	tReڣCtBlock
;

86 
daBlock
[
VCORE_MAX_RECV_DATA_SIZE
];

87 
size_t
 
daBlockL
;

88 
Stus
;

89 
comm_me
[
VCORE_MAX_FILENAME_SIZE
* 2 + 1];

90 
su
;

91 
Cou
;

92 
VceCtReڣDa
* 
Li
;

93 
BlockCou
;

94 
ReڣCtBlock
* 
BlockLi
;

95 } 
	tVceReڣDa
;

99 
vce__t_ifi_us_to_e
(
CtSteTy
 
eTy
, 
is_ro_p
, cڡ * 
gme
, 
CtStus
 
us
);

100 
vce__g_ifi_us_om_e
(
CtSteTy
 
eTy
, cڡ * 
gme
, *
us
);

101 
vce__check_s_exi__e
(
CtSteTy
 
eTy
, cڡ * 
s
, *
us
);

102 
vce__l_ifi_to_e
(
CtSteTy
 
eTy
, cڡ *
gme
, cڡ *
comm_me
, cڡ *
ive_key_gme
, cڡ *
assocd_gme
, cڡ *
daBlock
, 
size_t
 
daBlockL
, 
CtTy
 
Ty
);

103 
vce__g_ifi_om_e
(
CtSteTy
 
eTy
, cڡ * 
gme
, ** 
Da
, 
size_t
* 
Size
, 
CtTy
 
Ty
);

104 
vce__de_ifi_om_e
(
CtSteTy
 
eTy
, cڡ * 
gme
);

105 
VceReڣDa
 
_svc__comm
(
VceRequeDa
* 
_da
);

106 
vce__g_ifi_li_om_e
(
CtSteTy
 
eTy
, 
is_ro_p
, 
CtSvcSteCtLi
** 
Li
, * 
ngth
);

107 
vce__g_ro_ifi_li_om_e
(
CtSteTy
 
eTy
, 
CtSvcSteCtLi
** 
Li
, * 
ngth
);

108 
vce__g_d_ur_ifi_li_om_e
(
CtSteTy
 
eTy
, 
CtSvcSteCtLi
** 
Li
, * 
ngth
);

109 
vce__g_ifi_s_om_e
(
CtSteTy
 
eTy
, cڡ *
gme
, **
s
);

110 
vce__ld_ifis_om_e
(
CtSteTy
 
eTy
, cڡ *
gme
, ***
s
, *
ns
);

112 #ifde
__lulus


	@vcore/src/vcore/exception.cpp

22 
	~<vce/exi.h
>

24 
	~<d/log/vce_log.h
>

26 
	~<ddef.h
>

27 
	~<cdio
>

29 
mea
 
	gVidiCe
 {

30 
Exi
* 
	gExi
::
m_ϡExi
 = 
NULL
;

31 
	gExi
::
m_exiCou
 = 0;

32 (*
	gExi
::
m_rmeHdr
)(
NULL
;

34 
LogUnhddExi
(cڡ 
d
::
rg
 &
r
)

37 
VceLogD
("%s", 
r
.
c_r
());

40 
LogUnhddExi
(cڡ 
d
::
rg
 &
r
,

41 cڡ *
fame
,

42 
le
,

43 cڡ *
funi
)

46 
VceLogE
("[%s:%d][%s]%s", 
fame
, 
le
, 
funi
, 
r
.
c_r
());

	@vcore/src/vcore/exception.h

22 #ide
VidiCe_EXCEPTION_H


23 
	#VidiCe_EXCEPTION_H


	)

25 
	~<rg
>

26 
	~<crg
>

27 
	~<cdio
>

28 
	~<exi
>

29 
	~<cdlib
>

30 
	~<sam
>

32 
mea
 
	gVidiCe
 {

33 
LogUnhddExi
(cڡ 
d
::
rg
 &
r
);

34 
LogUnhddExi
(cڡ 
d
::
rg
 &
r
,

35 cڡ *
fame
,

36 
le
,

37 cڡ *
funi
);

40 
mea
 
	gVidiCe
 {

41 as
	cExi
 {

42 
	give
:

43 
m_exiCou
;

44 
Exi
* 
	gm_ϡExi
;

45 (*
	gm_rmeHdr
)();

47 
AddRef
(
Exi
* 
exi
)

49 i(!
	gm_exiCou
) {

50 
	gm_rmeHdr
 = 
d
::
t_rme
(&
TmeHdr
);

53 ++
	gm_exiCou
;

54 
	gm_ϡExi
 = 
exi
;

57 
UnRef
(
Exi
* 
e
)

59 i(
	gm_ϡExi
 =
e
) {

60 
m_ϡExi
 = 
NULL
;

63 --
	gm_exiCou
;

65 i(!
	gm_exiCou
) {

66 
	gd
::
t_rme
(
m_rmeHdr
);

67 
	gm_rmeHdr
 = 
NULL
;

71 
TmeHdr
()

73 i(
	gm_ϡExi
 !
NULL
) {

74 
DiyKnownExi
(*
m_ϡExi
);

75 
abt
();

77 
DiyUnknownExi
();

78 
abt
();

82 
Exi
 *
	gm_as
;

83 
	gd
::
rg
 
m_th
;

84 
	gd
::
rg
 
m_funi
;

85 
	gm_le
;

87 
	geed
:

88 
d
::
rg
 
m_mesge
;

89 
	gd
::
rg
 
m_assName
;

91 
	gpublic
:

92 
d
::
rg
 
KnownExiToSg
(cڡ 
Exi
 &
e
)

94 
d
::
orgam
 
mesge
;

95 
	gmesge
 <<

97 
	gmesge
 << "\033[1;33mExceptionrace:\033[m\n\n";

98 
	gmesge
 << 
	ge
.
DumpToSg
();

99 
	gmesge
 << "\033[1;31m\n=== Willowbort ===\033[m\n";

101  
	gmesge
.
r
();

104 
	gd
::
rg
 
UnknownExiToSg
()

106 
d
::
orgam
 
mesge
;

107 
	gmesge
 <<

109 
	gmesge
 << "\033[1;31m\n=== Willowbort ===\033[m\n";

111  
	gmesge
.
r
();

114 
DiyKnownExi
(cڡ 
Exi
& 
e
)

116 
LogUnhddExi
(
KnownExiToSg
(
e
).
c_r
());

119 
DiyUnknownExi
()

121 
LogUnhddExi
(
UnknownExiToSg
().
c_r
());

124 
Exi
(cڡ Exi &
h
)

127 i(
	gh
.
	gm_as
 !
NULL
) {

128 
m_as
 = 
w
 
Exi
(*
h
.m_reason);

130 
	gm_as
 = 
NULL
;

133 
	gm_mesge
 = 
h
.
m_mesge
;

134 
	gm_th
 = 
h
.
m_th
;

135 
	gm_funi
 = 
h
.
m_funi
;

136 
	gm_le
 = 
h
.
m_le
;

138 
	gm_assName
 = 
h
.
m_assName
;

140 
AddRef
(
this
);

143 cڡ 
	gExi
 &
	gݔ
 =(cڡ 
Exi
 &
h
)

145 i(
this
 =&
h
) {

146  *
this
;

150 i(
	gh
.
	gm_as
 !
NULL
) {

151 
m_as
 = 
w
 
Exi
(*
h
.m_reason);

153 
	gm_as
 = 
NULL
;

156 
	gm_mesge
 = 
h
.
m_mesge
;

157 
	gm_th
 = 
h
.
m_th
;

158 
	gm_funi
 = 
h
.
m_funi
;

159 
	gm_le
 = 
h
.
m_le
;

161 
	gm_assName
 = 
h
.
m_assName
;

163 
AddRef
(
this
);

165  *
	gthis
;

168 
Exi
(cڡ *
th
,

169 cڡ *
funi
,

170 
le
,

171 cڡ 
d
::
rg
 &
mesge
) :

172 
m_as
(
NULL
),

173 
m_th
(
th
),

174 
m_funi
(
funi
),

175 
m_le
(
le
),

176 
m_mesge
(
mesge
)

178 
AddRef
(
this
);

181 
Exi
(cڡ *
th
,

182 cڡ *
funi
,

183 
le
,

184 cڡ 
Exi
 &
as
,

185 cڡ 
d
::
rg
 &
mesge
) :

186 
m_as
(
w
 
Exi
(
as
)),

187 
m_th
(
th
),

188 
m_funi
(
funi
),

189 
m_le
(
le
),

190 
m_mesge
(
mesge
)

192 
AddRef
(
this
);

195 
	gvtu
 ~
Exi
(
throw
()

197 i(
	gm_as
 !
NULL
) {

198 
de
 
m_as
;

199 
	gm_as
 = 
NULL
;

202 
UnRef
(
this
);

205 
Dump
() const

208 i(
	gm_as
 !
NULL
) {

209 
m_as
->
Dump
();

213 cڡ *
	gfe
 = 
rchr
(
m_th
.
c_r
(), '/');

215 i(
	gfe
 =
NULL
) {

216 
fe
 = 
m_th
.
c_r
();

218 ++
	gfe
;

221 
tf
("\033[0;36m[%s:%i]\033[m %s() \033[4;35m%s\033[m: %s\033[m\n",

222 
fe
, 
m_le
,

223 
m_funi
.
c_r
(),

224 
m_assName
.
c_r
(),

225 
m_mesge
.
emy
(? "<EMPTY>" : m_mesge.
c_r
());

228 
	gd
::
rg
 
DumpToSg
() const

230 
d
::
rg
 
t
;

231 i(
	gm_as
 !
NULL
) {

232 
t
 = 
m_as
->
DumpToSg
();

235 cڡ *
	gfe
 = 
rchr
(
m_th
.
c_r
(), '/');

237 i(
	gfe
 =
NULL
) {

238 
fe
 = 
m_th
.
c_r
();

240 ++
	gfe
;

243 
	gbuf
[1024];

244 
tf
(
buf
,

245 (
buf
),

247 
fe
,

248 
m_le
,

249 
m_funi
.
c_r
(),

250 
m_assName
.
c_r
(),

251 
m_mesge
.
emy
(? "<EMPTY>" : m_mesge.
c_r
());

253 
	gbuf
[(
buf
) - 1] = '\n';

254 
	gt
 +
buf
;

256  
	gt
;

259 
Exi
 *
GRs
() const

261  
	gm_as
;

264 
	gd
::
rg
 
GPh
() const

266  
m_th
;

269 
	gd
::
rg
 
GFuni
() const

271  
m_funi
;

274 
GLe
() const

276  
	gm_le
;

279 
	gd
::
rg
 
GMesge
() const

281  
m_mesge
;

284 
	gd
::
rg
 
GCssName
() const

286  
m_assName
;

291 
	#VceTry
 
y


	)

293 
	#VceThrow
(
CssName
) \

294 
throw
 
	`CssName
(
__FILE__
, 
__FUNCTION__
, 
__LINE__
)

	)

296 
	#VceThrowMsg
(
CssName
, 
Mesge
) \

299 
d
::
orgam
 
dLogggSm
; \

300 
dLogggSm
 << 
Mesge
; \

301 
throw
 
	`CssName
(
__FILE__
, 
__FUNCTION__
, 
__LINE__
, 
dLogggSm
.
	`r
()); \

302 } 0)

	)

304 
	#VceReThrow
(
CssName
) \

305 
throw
 
	`CssName
(
__FILE__
, 
__FUNCTION__
, 
__LINE__
, 
_thrown_exi
)

	)

307 
	#VceReThrowMsg
(
CssName
, 
Mesge
) \

308 
throw
 
	`CssName
(
__FILE__
, \

309 
__FUNCTION__
, \

310 
__LINE__
, \

311 
_thrown_exi
, \

312 
Mesge
)

	)

314 
	#VceCch
(
CssName
) \

315 
	`tch
 (cڡ 
CssName
 &
_thrown_exi
)

	)

317 
	#VCORE_DECLARE_EXCEPTION_TYPE
(
BaCss
, 
Css
) \

318 as
	cCss
 : 
public
 
BaCss
 { \

319 
public
: \

320 
	`Css
(cڡ *
th
, \

321 cڡ *
funi
, \

322 
le
, \

323 cڡ 
d
::
rg
 & 
mesge
 = std::
	`rg
()) \

324 : 
	$BaCss
(
th
, 
funi
, 
le
, 
mesge
) { \

326 
BaCss
::
m_assName
 = #Class; \

329 
	`Css
(cڡ *
th
, \

330 cڡ *
funi
, \

331 
le
, \

332 cڡ 
VidiCe
::
Exi
 & 
as
, \

333 cڡ 
d
::
rg
 & 
mesge
 = std::
	`rg
()) \

334 : 
	$BaCss
(
th
, 
funi
, 
le
, 
as
, 
mesge
) { \

335 
BaCss
::
m_assName
 = #Class; \

336 
	}
} \

337 };

	)

339 
	#VCORE_UNHANDLED_EXCEPTION_HANDLER_BEGIN
 
y


	)

341 
	#VCORE_UNHANDLED_EXCEPTION_HANDLER_END
 \

342 
	`tch
 (cڡ 
VidiCe
::
Exi
 &
exi
) \

344 
d
::
orgam
 
msg
; \

345 
msg
 << 
VidiCe
::
Exi
::
	`KnownExiToSg
(
exi
); \

346 
VidiCe
::
	`LogUnhddExi
(
msg
.
	`r
(), \

347 
__FILE__
, \

348 
__LINE__
, \

349 
__FUNCTION__
); \

350 
	`abt
(); \

352 
	`tch
 (
d
::
exi
& 
e
) \

354 
d
::
orgam
 
msg
; \

355 
msg
 << 
e
.
	`wh
(); \

356 
msg
 << "\n"; \

357 
msg
 << 
VidiCe
::
Exi
::
	`UnknownExiToSg
(); \

358 
VidiCe
::
	`LogUnhddExi
(
msg
.
	`r
(), \

359 
__FILE__
, \

360 
__LINE__
, \

361 
__FUNCTION__
); \

362 
	`abt
(); \

364 
	`tch
 (...) \

366 
d
::
orgam
 
msg
; \

367 
msg
 << 
VidiCe
::
Exi
::
	`UnknownExiToSg
(); \

368 
VidiCe
::
	`LogUnhddExi
(
msg
.
	`r
(), \

369 
__FILE__
, \

370 
__LINE__
, \

371 
__FUNCTION__
); \

372 
	`abt
(); \

373 }

	)

375 
mea
 
	gVidiCe
 {

376 
mea
 
	gCommExi
 {

384 
VCORE_DECLARE_EXCEPTION_TYPE
(
Exi
, 
IlE
)

	@vcore/src/vcore/pkcs12.cpp

22 
	~<unid.h
>

23 
	~<f.h
>

24 
	~<o.h
>

25 
	~<rg.h
>

26 
	~<dt.h
>

27 
	~<sys/tys.h
>

28 
	~<sys/.h
>

29 
	~<ݒs/r.h
>

30 
	~<ݒs/pkcs12.h
>

31 
	~<ݒs/sha.h
>

32 
	~<ݒs/x509.h
>

33 
	~<ݒs/m.h
>

34 
	~<db-ut.h
>

36 
	~<ss_mag.h
>

38 
	~<-rvi.h
>

39 
	~<-rvi-ut.h
>

40 
	~<-rvi-debug.h
>

41 
	~<-svc/.h
>

42 
	~<-svc-.h
>

44 
	~<vce/uts.h
>

45 
	~<pkcs12.h
>

47 
	#SYSCALL
(

((=-1&& (
o
 =
EINTR
))

	)

49 
	#START_CERT
 "-----BEGIN CERTIFICATE-----"

	)

50 
	#END_CERT
 "-----END CERTIFICATE-----"

	)

51 
	#START_TRUSTED
 "-----BEGIN TRUSTED CERTIFICATE-----"

	)

52 
	#END_TRUSTED
 "-----END TRUSTED CERTIFICATE-----"

	)

53 
	#START_KEY
 "-----BEGIN PRIVATE KEY-----"

	)

54 
	#END_KEY
 "-----END PRIVATE KEY-----"

	)

56 
	#CERTSVC_PKCS12_STORAGE_FILE
 "age"

	)

58 
	#CERTSVC_PKCS12_STORAGE_PATH
 
CERTSVC_PKCS12_STORAGE_DIR
 "/" 
CERTSVC_PKCS12_STORAGE_FILE


	)

60 
	#MAX_BUFFER_SIZE
 16;

	)

61 
	#_CERT_SVC_VERIFY_PKCS12


	)

63 cڡ 
	gCERTSVC_PKCS12_STORAGE_KEY_PKEY
[] = "pkey";

64 cڡ 
	gCERTSVC_PKCS12_STORAGE_KEY_CERTS
[] = "certs";

65 cڡ 
gch
 
	gCERTSVC_PKCS12_STORAGE_SEPARATOR
 = ';';

66 cڡ 
	gCERTSVC_PKCS12_UNIX_GROUP
[] = "secure-storage::pkcs12";

68 
sqle3
 *
	g_e_db
 = 
NULL
;

70 
gboޗn
 
	$keyfe_check
(cڡ *
thme
) {

71 
su
;

72 if(
	`acss
(
thme
, 
F_OK
 | 
R_OK
 | 
W_OK
) == 0)

73  
TRUE
;

74 
	`SYSCALL
(
su
 = 
	`t
(
thme
, 
S_IRUSR
 | 
S_IWUSR
));

75 i(
su
 != -1) {

76 
su
 = 
	`o
(result);

77 if(
su
 == -1)

78 
	`SLOGD
("Faedo,n: %d", 
o
);

79  
TRUE
;

81  
FALSE
;

83 
	}
}

85 
GKeyFe
 *
	$keyfe_ld
(cڡ *
thme
) {

86 
GKeyFe
 *
keyfe
;

87 
GE
 *
r
;

89 if(!
	`keyfe_check
(
thme
))

90  
NULL
;

91 
keyfe
 = 
	`g_key_fe_w
();

92 
r
 = 
NULL
;

93 if(!
	`g_key_fe_ld_om_fe
(
keyfe
, 
thme
, 
G_KEY_FILE_KEEP_COMMENTS
, &
r
)) {

94 
	`g_key_fe_
(
keyfe
);

95  
NULL
;

97  
keyfe
;

98 
	}
}

100 
	$ge_ndom_fh
(**
fh
) {

101 
g
;

102 
t64_t
 
ndom
;

103 
SHA_CTX
 
x
;

104 
d
[
SHA_DIGEST_LENGTH
];

105 
su
;

107 if(!
fh
)

108  
CERTSVC_WRONG_ARGUMENT
;

110 
	`SYSCALL
(
g
 = 
	`ݒ
("/dev/undom", 
O_RDONLY
));

111 if(
g
 == -1)

112  
CERTSVC_FAIL
;

113 
	`SYSCALL
(
su
 = 
	`ad
(
g
, &
ndom
, (random)));

114 if(
su
 == -1) {

115 
	`SYSCALL
(
	`o
(
g
));

116  
CERTSVC_FAIL
;

118 
	`SYSCALL
(
su
 = 
	`o
(
g
));

119 if(
su
 == -1)

120  
CERTSVC_FAIL
;

122 
	`SHA1_In
(&
x
);

123 
	`SHA1_Upde
(&
x
, &
ndom
, (random));

124 
	`SHA1_F
(
d
, &
x
);

126 
su
 = 
	`artf
(
fh
, "%s/" \

129 
CERTSVC_PKCS12_STORAGE_DIR
,

130 
d
[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9],

131 
d
[10], d[11], d[12], d[13], d[14], d[15], d[16], d[17], d[18], d[19]);

132  (
su
 !-1? 
CERTSVC_SUCCESS
 : 
CERTSVC_BAD_ALLOC
;

133 
	}
}

135 
	$unique_fame
(**
fh
, 
gboޗn
 
wh_cu_age
) {

136 
l
 = 0x00U;

137 
su
;

138 
ssm_fe_fo_t
 
sfi
;

139 
exis
 = 1;

141 ; 
l
 < 0xFFU; ++trial) {

142 
su
 = 
	`ge_ndom_fh
(
fh
);

143 if(
su
 !
CERTSVC_SUCCESS
)

144  
su
;

146 
exis
 = (
	`acss
(*
fh
, 
F_OK
) == 0);

148 i(
wh_cu_age
)

149 
exis
 |(
	`ssm_gfo
(*
fh
, &
sfi
, 
SSM_FLAG_DATA
, 
CERTSVC_PKCS12_UNIX_GROUP
) == 0);

152 if(!
exis
)

153  
CERTSVC_SUCCESS
;

155 
	`
(*
fh
);

158  
CERTSVC_FAIL
;

159 
	}
}

161 *
	$be_fame
(*
fh
) {

162 *
ed
;

163 if(!
fh
)

164  
NULL
;

165 
ed
 = 
	`chr
(
fh
, '/');

166 if(!
ed
)

167  
NULL
;

168  *(++
ed
?d : 
NULL
;

169 
	}
}

171 
	$ad_om_fe
(cڡ *
feName
, **
Bufr
, *
ngth
) {

173 
su
 = 
CERTSVC_SUCCESS
;

174 
FILE
 *
_out
 = 
NULL
;

175 
Lgth
 = 0;

176 

 

;

178 i(
	`
(
feName
, &

) == -1) {

179 
	`SLOGE
("Certificate doesotxist in disable folder.");

180 
su
 = 
CERTSVC_FAIL
;

181 
r
;

184 i(!(
_out
 = 
	`fݒ
(
feName
, "rb"))) {

185 
	`SLOGE
("Faݒ ff܄dg, [%s].", 
feName
);

186 
su
 = 
CERTSVC_FAIL
;

187 
r
;

190 
	`fek
(
_out
, 0L, 
SEEK_END
);

191 
Lgth
 = 
	`l
(
_out
);

192 i(
Lgth
 < 1) {

193 
	`SLOGE
("Failo get certificateength.");

194 
su
 = 
CERT_SVC_ERR_FILE_IO
;

195 
r
;

198 *
Bufr
 = (*)
	`mloc
((* (()
Lgth
 + 1));

199 i(*
Bufr
 =
NULL
) {

200 
	`SLOGE
("Failollocate memory");

201 
su
 = 
CERTSVC_BAD_ALLOC
;

202 
r
;

205 
	`memt
(*
Bufr
, 0x00, 
Lgth
+1);

206 
	`wd
 (
_out
);

207 i(
	`d
(*
Bufr
, (), (
size_t
)
Lgth
, 
_out
) != (size_t)certLength) {

208 
	`SLOGE
("Faػad fe, [%s]", 
feName
);

209 
su
 = 
CERTSVC_IO_ERROR
;

210 
r
;

212 *
ngth
 = 
Lgth
;

214 
r
:

215 i(
_out
 !
NULL
) {

216 
	`fo
(
_out
);

217 
_out
 = 
NULL
;

219  
su
;

220 
	}
}

222 
	$ݒ_db
(
sqle3
 **
db_hd
, cڡ *
db_th
) {

224 
su
 = -1;

225 
sqle3
 *
hd
;

227 i(
	`acss
(
db_th
, 
F_OK
) == 0) {

228 
su
 = 
	`db_ut_ݒ
(
db_th
, &
hd
, 0);

229 i(
su
 !
SQLITE_OK
) {

230 
	`SLOGE
("cdb [%s] faed!", 
db_th
);

231  
CERTSVC_FAIL
;

233 *
db_hd
 = 
hd
;

234  
CERTSVC_SUCCESS
;

236 
	`SLOGD
("%DB d۠nكxis. Ce!!", 
db_th
);

238 
su
 = 
	`db_ut_ݒ
(
db_th
, &
hd
, 0);

239 i(
su
 !
SQLITE_OK
) {

240 
	`SLOGE
("cdb [%s] faed!", 
db_th
);

241  
CERTSVC_FAIL
;

243 *
db_hd
 = 
hd
;

244  
CERTSVC_SUCCESS
;

245 
	}
}

247 
	$lize_db
() {

249 
su
 = 
CERTSVC_SUCCESS
;

250 i(
_e_db
 =
NULL
) {

251 
su
 = 
	`ݒ_db
(&
_e_db
, 
CERTSVC_SYSTEM_STORE_DB
);

252 i(
su
 !
CERTSVC_SUCCESS
)

253 
	`SLOGE
("Certsvc store DB creation failed");

255  
su
;

256 
	}
}

258 
	$execu__quy
(*
quy
, 
sqle3_mt
 **
mt
) {

260 
su
 = 
CERTSVC_SUCCESS
;

261 
sqle3_mt
 *
mts
 = 
NULL
;

263 i(
_e_db
 !
NULL
) {

264 
	`sqle3_o
(
_e_db
);

265 
_e_db
 = 
NULL
;

268 
su
 = 
	`lize_db
();

269 i(
su
 !
CERTSVC_SUCCESS
) {

270 
	`SLOGE
("Failedo initialise database.");

271 
su
 = 
CERTSVC_IO_ERROR
;

272 
r
;

275 
su
 = 
	`sqle3_e_v2
(
_e_db
, 
quy
, 
	`
(quy), &
mts
, 
NULL
);

276 i(
su
 !
SQLITE_OK
) {

277 
	`SLOGE
("sqle3_e_v2 faed [%s].", 
quy
);

278 
su
 = 
CERTSVC_FAIL
;

279 
r
;

282 *
mt
 = 
mts
;

283 
su
 = 
CERTSVC_SUCCESS
;

285 
r
:

286  
su
;

287 
	}
}

289 
	$c_svc_pkcs12_t_ifi_us_to_e
(
CtSteTy
 
eTy
, 
is_ro_p
, * 
gme
, 
CtStus
 
us
) {

291  
	`vce__t_ifi_us_to_e
(
eTy
, 
is_ro_p
, 
gme
, 
us
);

292 
	}
}

294 
	$c_svc_pkcs12_g_ifi_bufr_om_e
(
CtSteTy
 
eTy
, * 
gme
, ** 
Bufr
, 
size_t
* 
Size
) {

296  
	`vce__g_ifi_om_e
(
eTy
, 
gme
, 
Bufr
, 
Size
, 
PEM_CRT
);

297 
	}
}

299 
	$c_svc_pkcs12_g_ifi_us_om_e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
gme
, *
us
) {

301  
	`vce__g_ifi_us_om_e
(
eTy
, 
gme
, 
us
);

302 
	}
}

304 
	$c_svc_pkcs12_s_exis__e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
s
, 
gboޗn
 *
exis
) {

306  
	`vce__check_s_exi__e
(
eTy
, 
s
, 
exis
);

307 
	}
}

309 
	$c_svc_pkcs12_ive_key_ld_om_e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
gme
, **
Bufr
, 
size_t
 *
Size
) {

311  
	`vce__g_ifi_om_e
(
eTy
, 
gme
, 
Bufr
, 
Size
, (
CtTy
)
P12_PKEY
);

312 
	}
}

314 
	$c_svc_pkcs12_de_ifi_om_e
(
CtSteTy
 
eTy
, cڡ * 
gme
) {

316 
su
 = 
CERTSVC_SUCCESS
;

318 
su
 = 
	`vce__de_ifi_om_e
(
eTy
, 
gme
);

319 if(
su
 =
CERTSVC_SUCCESS
)

320 
	`SLOG
(
LOG_INFO
, "MDM_LOG_USER", "Object=certificate, AccessType=Uninstall, Result=Succeed");

322 
	`SLOG
(
LOG_INFO
, "MDM_LOG_USER", "Object=certificate, AccessType=Uninstall, Result=Failed");

324  
su
;

325 
	}
}

327 
	$c_svc_pkcs12_g_ifi_s_om_e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
gme
, **
s
) {

329  
	`vce__g_ifi_s_om_e
(
eTy
, 
gme
, 
s
);

330 
	}
}

332 
	$c_svc_pkcs12_ld_ifis_om_e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
gme
, gch ***
s
, 
gsize
 *
ns
) {

333  
	`vce__ld_ifis_om_e
(
eTy
, 
gme
, (***)
s
, (*)
ns
);

334 
	}
}

336 
	$c_svc_pkcs12__s_lded_om_e
(
CtSvcSteCtLi
** 
Li
) {

337 
su
 = 
CERTSVC_SUCCESS
;

338 
CtSvcSteCtLi
* 
tmpNode
 = 
NULL
;

340 *
Li
!=
NULL
) {

341 
tmpNode
 = *
Li
;

342 if(
tmpNode
->
t
 !
NULL
{ 
	`
(tmpNode->title); }

343 if(
tmpNode
->
gme
 !
NULL
{ 
	`
(tmpNode->gname); }

344 (*
Li
(*Li)->
xt
;

345 
	`
(
tmpNode
);

348 i(
_e_db
 !
NULL
) {

349 
	`sqle3_o
(
_e_db
);

350 
_e_db
 = 
NULL
;

352 
Li
 = 
NULL
;

353  
su
;

354 
	}
}

356 
	$c_svc_pkcs12_g_ro_ifi_li_om_e
(
CtSteTy
 
eTy
, 
CtSvcSteCtLi
** 
Li
, * 
ngth
) {

357  
	`vce__g_ro_ifi_li_om_e
(
eTy
, 
Li
, 
ngth
);

358 
	}
}

360 
	$c_svc_pkcs12_g_d_ur_ifi_li_om_e
(
CtSteTy
 
eTy
, 
CtSvcSteCtLi
** 
Li
, * 
ngth
) {

361  
	`vce__g_d_ur_ifi_li_om_e
(
eTy
, 
Li
, 
ngth
);

362 
	}
}

364 
	$c_svc_pkcs12_g_ifi_li_om_e
(
CtSteTy
 
eTy
, 
is_ro_p
, 
CtSvcSteCtLi
** 
Li
, * 
ngth
) {

365  
	`vce__g_ifi_li_om_e
(
eTy
, 
is_ro_p
, 
Li
, 
ngth
);

366 
	}
}

368 
l_m_fe_fm_to_e
(
CtSteTy
 
eTy
, cڡ * 
Bufr
, 
Lgth
, \

369 cڡ 
gch
 *
s
, cڡ * 
th
, *
ive_key_gme
, gch *
assocd_gme
, 
CtTy
 
decideCt
) {

371 
	gsu
 = 
CERTSVC_SUCCESS
;

372 
	gadCou
 = 0;

373 * 
	gfeName
 = 
NULL
;

374 * 
	gcommName
 = 
NULL
;

375 *
	gunique
 = 
NULL
;

376 
BIO
* 
	gpBio
 = 
NULL
;

377 
X509
* 
	gx509Su
 = 
NULL
;

378 

 
	gdST
;

380 i(!
	gBufr
 || !
	gLgth
) {

381 
SLOGE
("Invalidrgument. certBuffer is input cert.");

382  
	gCERTSVC_WRONG_ARGUMENT
;

385 i(
	gdecideCt
 =
PEM_CRT
) {

386 
su
 = 
unique_fame
(&
unique
, 
FALSE
);

387 i(
	gsu
 !
CERTSVC_SUCCESS
) {

388 
SLOGE
("Failo generate unique filename.");

389  
	gsu
;

393 
	gunique
 = (*)
th
;

395 i(
	gunique
 =
NULL
) {

396 
SLOGE
("Failedo get unique fileame.");

397  
	gsu
;

401 i(

(
th
, &
dST
) != -1) {

402 
su
 = 
g_comm_me
(
th
, 
NULL
, &
commName
);

403 i(
	gsu
 !
CERTSVC_SUCCESS
) {

404 
pBio
 = 
BIO_w
(
BIO_s_mem
());

405 i(
	gpBio
 =
NULL
) {

406 
SLOGE
("Failedollocate memory.");

407 
	gsu
 = 
CERTSVC_BAD_ALLOC
;

408 
	gr
;

411 
	gadCou
 = 
BIO_wre
(
pBio
, (cڡ *
Bufr
, 
Lgth
);

412 i(
	gadCou
 < 1) {

413 
SLOGE
("Failedooad cert into bio.");

414 
	gsu
 = 
CERTSVC_BAD_ALLOC
;

415 
	gr
;

418 
	gx509Su
 = 
PEM_ad_bio_X509
(
pBio
, 
NULL
, 0, NULL);

419 i(
	gx509Su
 =
NULL
) {

420 
SLOGE
("Failedo create x509 structure.");

421 
	gsu
 = 
CERTSVC_IO_ERROR
;

422 
	gr
;

425 
	gsu
 = 
g_comm_me
(
NULL
, 
x509Su
, &
commName
);

426 i(
	gsu
 !
CERTSVC_SUCCESS
) {

427 
SLOGE
("CommonName is NULL");

428 
	gsu
 = 
CERTSVC_FAIL
;

429 
	gr
;

435 
	gfeName
 = 
be_fame
(
unique
);

436 i((
	gdecideCt
 =
P12_END_USER
&& (
ive_key_gme
 !
NULL
))

437 
su
 = 
vce__l_ifi_to_e
(
eTy
, 
feName
, 
s
, 
ive_key_gme
, feName, 
Bufr
, 
Lgth
, 
decideCt
);

438 i((
	gdecideCt
 =
P12_TRUSTED
|| (
decideCt
 =
P12_INTERMEDIATE
))

439 
su
 = 
vce__l_ifi_to_e
(
eTy
, 
feName
, 
commName
, 
NULL
, 
assocd_gme
, 
Bufr
, 
Lgth
, 
decideCt
);

441 
	gsu
 = 
vce__l_ifi_to_e
(
eTy
, 
feName
, 
commName
, 
NULL
, feName, 
Bufr
, 
Lgth
, 
decideCt
);

443 i(
	gsu
 !
CERTSVC_SUCCESS
) {

444 
SLOGE
("Faedؚ ctifi.esu[%d]", 
su
);

445 
	gsu
 = 
CERTSVC_FAIL
;

446 
	gr
;

449 
SLOGD
("Successodd certificate in store.");

451 
	gr
:

452 i(
commName
)

453 

(
commName
);

454  
	gsu
;

457 
	$l_t_fe
(

458 cڡ *
th
,

459 
CtSteTy
 
eTy
,

460 cڡ 
gch
 *
s
,

461 *
ive_key_gme
,

462 
gch
 *
assocd_gme
,

463 
CtTy
 
decideCt
)

465 
su
 = 
CERTSVC_SUCCESS
;

466 
feSize
 = 0;

467 
Lgth
 = 0;

468 cڡ * 
hd
 = 
NULL
;

469 cڡ * 
a
 = 
NULL
;

470 * 
feCڋ
 = 
NULL
;

471 cڡ * 
tmpBufr
 = 
NULL
;

472 * 
Bufr
 = 
NULL
;

473 cڡ * 
End
 = 
NULL
;

475 i(
	`ad_om_fe
(
th
, &
feCڋ
, &
feSize
)!=
CERTSVC_SUCCESS
)

477 
	`SLOGE
("Faedػadhfe. [%s]",
th
);

478 
su
 = 
CERTSVC_IO_ERROR
;

479 
r
;

482 
tmpBufr
 = 
feCڋ
;

483 i(
decideCt
 =
PEM_CRT
)

484 
hd
 = 
	`rr
(
tmpBufr
, 
START_CERT
);

485 i(
decideCt
 =
P12_END_USER
)

486 
hd
 = 
	`rr
(
tmpBufr
, 
START_CERT
);

487 i((
decideCt
 =
P12_TRUSTED
)||(decideC=
P12_INTERMEDIATE
))

488 
hd
 = 
	`rr
(
tmpBufr
, 
START_TRUSTED
);

490 
	`SLOGE
("Invalid cert.");

491 
su
 = 
CERTSVC_IO_ERROR
;

492 
r
;

495 i(
hd
 !
NULL
) {

497 i(
decideCt
 =
PEM_CRT
) {

498 
a
 = 
	`rr
(
hd
, 
END_CERT
);

499 
End
 = 
END_CERT
;

501 i(
decideCt
 =
P12_END_USER
) {

502 
a
 = 
	`rr
(
hd
, 
END_CERT
);

503 
End
 = 
END_CERT
;

505 i((
decideCt
 =
P12_TRUSTED
)||(decideC=
P12_INTERMEDIATE
)) {

506 
a
 = 
	`rr
(
hd
, 
END_TRUSTED
);

507 
End
 = 
END_TRUSTED
;

510 
	`SLOGE
("Invalid certificateassed.");

511 
su
 = 
CERTSVC_IO_ERROR
;

512 
r
;

515 i(
a
 !
NULL
) {

516 
tmpBufr
 = 
a
;

517 
Lgth
 = (()(
a
 - 
hd
+ 
	`
(
End
));

518 
Bufr
 = (*
	`mloc
((* (
Lgth
+2));

519 i(
Bufr
 =
NULL
) {

520 
su
 = 
CERTSVC_BAD_ALLOC
;

521 
	`SLOGE
("Failollocate memory.");

522 
r
;

525 
	`memt
(
Bufr
, 0x00, 
Lgth
+2);

526 
	`memy
(
Bufr
, 
hd
, 
Lgth
);

527 
Bufr
[
Lgth
] = '\0';

529 
su
 = 
	`l_m_fe_fm_to_e
(
eTy
, 
Bufr
, 
Lgth
, 
s
, \

530 
th
, 
ive_key_gme
, 
assocd_gme
, 
decideCt
);

531 i(
su
 !
CERTSVC_SUCCESS
) {

532 
su
 = 
CERTSVC_FAIL
;

533 
	`SLOGE
("Faؚifi[%s]", 
th
);

538 
	`SLOGE
("Invalid fileypeassed.");

539 
su
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

542 
r
:

543 i(
Bufr
)

544 
	`
(
Bufr
);

545 i(
feCڋ
)

546 
	`
(
feCڋ
);

547  
su
;

548 
	}
}

550 
	$hd_t_m_fe_ti
(
CtSteTy
 
eTy
, cڡ *
th
, cڡ 
gch
 *
s
) {

552 
su
 = 
CERTSVC_SUCCESS
;

554 i((
	`rr
(
th
, ".t")!
NULL
 || (strstr(path, ".pem")) != NULL) {

555 
	`SLOGD
("certificatextention is .crt/.pem file");

560 
su
 = 
	`l_t_fe
(
th
, 
eTy
, 
s
, 
NULL
, NULL, 
PEM_CRT
);

561 i(
su
 !
CERTSVC_SUCCESS
) {

562 
	`SLOGE
("Failedo installhe certificate.");

563 
su
 = 
CERTSVC_FAIL
;

564 
r
;

568 
	`SLOGE
("Invalid certificateassed.");

569 
su
 = 
CERTSVC_FAIL
;

570 
r
;

572 
	`SLOGD
("Successo installhe certificate.");

574 
r
:

575  
su
;

576 
	}
}

578 
vify__das
(
X509
** 

, 
STACK_OF
(X509**
v
) {

580 
	gsu
 = 
CERTSVC_SUCCESS
;

581 * 
	gpSubje
 = 
NULL
;

582 * 
	gpIssuName
 = 
NULL
;

583 
X509_STORE_CTX
 *
	g_x
 = 
NULL
;

584 
X509_STORE
 *
	g_e
 = 
NULL
;

585 
	gs
 = 0;

587 #ifde
_CERT_SVC_VERIFY_PKCS12


588 i(*
	gv
 =
NULL
) {

589 
pSubje
 = 
X509_NAME_ږe
((*

)->
_fo
->
subje
, 
NULL
, 0);

590 i(!
	gpSubje
) {

591 
SLOGE
("Failedo get subjectame");

592 
	gsu
 = 
CERTSVC_FAIL
;

593 
	g_memy
;

596 
	gpIssuName
 = 
X509_NAME_ږe
((*

)->
_fo
->
issu
, 
NULL
, 0);

597 i(!
	gpIssuName
) {

598 
SLOGE
("Failedo get issuerame");

599 
	gsu
 = 
CERTSVC_FAIL
;

600 
	g_memy
;

603 i(
rcmp
((cڡ *)
pSubje
, (cڡ *)
pIssuName
) == 0) {

605 
EVP_PKEY
* 
pKey
 = 
NULL
;

606 
	gpKey
 = 
X509_g_pubkey
(*

);

607 i(!
	gpKey
) {

608 
SLOGE
("Failedo getublic key");

609 
	gsu
 = 
CERTSVC_FAIL
;

610 
	g_memy
;

613 i(
X509_vify
(*

, 
pKey
) <= 0) {

614 
SLOGE
("P12 verification failed");

615 
EVP_PKEY_
(
pKey
);

616 
	gsu
 = 
CERTSVC_FAIL
;

617 
	g_memy
;

619 
SLOGD
("P12 verification Success");

620 
EVP_PKEY_
(
pKey
);

623 
	g_e
 = 
X509_STORE_w
();

624 i(!
	g_e
) {

625 
SLOGE
("Memoryllocation failed");

626 
	gsu
 = 
CERTSVC_FAIL
;

627 
	g_memy
;

630 
	gs
 = 
X509_STORE_ld_lotis
(
_e
, 
NULL
, "/opt/etc/ssl/certs/");

631 i(
	gs
 != 1) {

632 
SLOGE
("P12oad certificate store failed");

633 
X509_STORE_
(
_e
);

634 
	gsu
 = 
CERTSVC_FAIL
;

635 
	g_memy
;

638 
	gs
 = 
X509_STORE_t_deu_ths
(
_e
);

639 i(
	gs
 != 1) {

640 
SLOGE
("P12oad certificate storeath failed");

641 
X509_STORE_
(
_e
);

642 
	gsu
 = 
CERTSVC_FAIL
;

643 
	g_memy
;

647 
	g_x
 = 
X509_STORE_CTX_w
();

648 i(
	g_x
 =
NULL
) {

649 
SLOGE
("Memoryllocation failed");

650 
	gsu
 = 
CERTSVC_FAIL
;

651 
	g_memy
;

655 i(!
X509_STORE_CTX_
(
_x
, 
_e
, *

, 
NULL
)) {

656 
SLOGE
("Memoryllocation failed");

657 
	gsu
 = 
CERTSVC_FAIL
;

658 
	g_memy
;

661 #ifde
P12_VERIFICATION_NEEDED


662 
	gs
 = 
X509_vify_
(
_x
);

663 i(
	gs
 != 1) {

664 
SLOGE
("P12 verification failed");

665 
	gsu
 = 
CERTSVC_FAIL
;

666 
	g_memy
;

668 
SLOGD
("P12 verification Success");

672 i(*
	gv
 !
NULL
) {

674 
_e
 = 
X509_STORE_w
();

675 i(!
	g_e
) {

676 
SLOGE
("Memoryllocation failed");

677 
	gsu
 = 
CERTSVC_FAIL
;

678 
	g_memy
;

681 
	gs
 = 
X509_STORE_ld_lotis
(
_e
, 
NULL
, 
CERTSVC_SSL_CERTS_DIR
);

682 i(
	gs
 != 1) {

683 
SLOGE
("P12oad certificate store failed");

684 
	gsu
 = 
CERTSVC_FAIL
;

685 
	g_memy
;

688 
	gs
 = 
X509_STORE_t_deu_ths
(
_e
);

689 i(
	gs
 != 1) {

690 
SLOGE
("P12oad certificateath failed");

691 
	gsu
 = 
CERTSVC_FAIL
;

692 
	g_memy
;

696 
	g_x
 = 
X509_STORE_CTX_w
();

697 i(
	g_x
 =
NULL
) {

698 
SLOGE
("Memoryllocation failed");

699 
	gsu
 = 
CERTSVC_FAIL
;

700 
	g_memy
;

704 i(!
X509_STORE_CTX_
(
_x
, 
_e
, *

, 
NULL
)) {

705 
SLOGE
("Memoryllocation failed");

706 
	gsu
 = 
CERTSVC_FAIL
;

707 
	g_memy
;

710 
X509_STORE_CTX_ued_ack
(
_x
, *
v
);

711 #ifde
P12_VERIFICATION_NEEDED


712 
	gs
 = 
X509_vify_
(
_x
);

713 i(
	gs
 != 1) {

714 
SLOGE
("P12 verification failed");

715 
	gsu
 = 
CERTSVC_FAIL
;

716 
	g_memy
;

718 
SLOGD
("P12 verification Success");

723 
	g_memy
:

724 i(
pSubje
 !
NULL
{ 

(pSubject); }

725 i(
	gpIssuName
 !
NULL
{ 

(
pIssuName
); }

726 i(
	g_e
 !
NULL
{ 
X509_STORE_
(
_e
); }

727 i(
	g_x
{ 
X509_STORE_CTX_
(
_x
); }

728  
	gsu
;

731 
	$c_svc_pkcs12_impt_om_fe_to_e
(
CtSteTy
 
eTys
, cڡ *
th
, cڡ *
sswd
, cڡ 
gch
 *
s
) {

733 
su
 = 
CERTSVC_SUCCESS
;

734 
adL
 = 0;

735 
tmpL
 = 0;

736 
nis
 = 0, 
i
 = 0, 
n
 = 0, 
ns
 = 0, 
wr_s
;

737 
CtSteTy
 
eTy
 = 
NONE_STORE
;

738 
FILE
* 
am
 = 
NULL
;

739 
PKCS12
* 
cڏ
 = 
NULL
;

740 
EVP_PKEY
* 
key
 = 
NULL
;

741 
X509
* 

 = 
NULL
;

742 
	`STACK_OF
(
X509
*
v
 = 
NULL
;

743 
gch
* 
be
 = 
NULL
;

744 
gch
* 
pkvue
 = 
NULL
;

745 
gch
** 
cvuev
 = 
NULL
;

746 
gch
 **
s
 = 
NULL
;

747 * 
tmpPkVue
 = 
NULL
;

748 * 
unique
 = 
NULL
;

749 
feBufr
[4096] = {0,};

750 
loCou
 = 0;

751 
CtTy
 
decideCt
 = 
INVALID_DATA
;

752 
gboޗn
 
exis
 = 
FALSE
;

754 i((!
s
|| (
	`
ls< 1|| (!
th
) || (strlen(path) < 1)) {

755 
	`SLOGE
("Invalid inputarameter.");

756 
	`SLOG
(
LOG_INFO
, "MDM_LOG_USER", "Object=certificate, AccessType=Install, Result=Failed");

757  
CERTSVC_WRONG_ARGUMENT
;

762 i(
loCou
 =(
MAX_STORE_ENUMS
-1)) ;

765 i(((1 << 
loCou
& 
eTys
=
SYSTEM_STORE
) {

766 
	`SLOGE
("Nه vid stܐty inlg ctifi, stܐtyasd [%d].", (1 << 
loCou
));

767 
	`SLOG
(
LOG_INFO
, "MDM_LOG_USER", "Object=certificate, AccessType=Install, Result=Failed");

768  
CERTSVC_INVALID_STORE_TYPE
;

772 i((1 << 
loCou
& 
eTys
) {

773 
eTy
 = 
NONE_STORE
;

774 
eTy
 = (
CtSteTy
(1 << 
loCou
);

775 
	`SLOGD
("Prossg stܐty : [%s]", (
eTy
 =
VPN_STORE
)? "VPN" : (eTy =
WIFI_STORE
)? "WIFI" : "EMAIL");

778 
su
 = 
	`c_svc_pkcs12_s_exis__e
(
eTy
, 
s
, &
exis
);

779 i(
su
 !
CERTSVC_SUCCESS
) {

780 
	`SLOGE
("Failureoccess database.");

781 
su
 = 
CERTSVC_FAIL
;

782 
r
;

785 i(
exis
!=
CERTSVC_TRUE
) {

786 
	`SLOGE
("Alexi iܐ[%s].", (
eTy
 =
VPN_STORE
)? "VPN" : (eTy =
WIFI_STORE
)? "WIFI" : "EMAIL");

787 
su
 = 
CERTSVC_DUPLICATED_ALIAS
;

788 
r
;

793 i(
sswd
 =
NULL
 && ((
	`rr
(
th
, ".pfx") == NULL) || (strstr(path, ".p12")))) {

794 
su
 = 
	`hd_t_m_fe_ti
(
eTy
, 
th
, 
s
);

795 i(
su
 !
CERTSVC_SUCCESS
) {

796 
	`SLOGE
("Failedo install PEM/CRT fileo store.");

797 
su
 = 
CERTSVC_FAIL
;

799 
loCou
++;

804 i((
am
 = 
	`fݒ
(
th
, "rb")=
NULL
) {

805 
	`SLOGE
("Ubˁݒhff܄dg [%s].", 
th
);

806 
su
 = 
CERTSVC_IO_ERROR
;

807 
r
;

810 i(
cڏ
 =
NULL
) {

811 
cڏ
 = 
	`d2i_PKCS12_
(
am
, 
NULL
);

812 
	`fo
(
am
);

813 i(
cڏ
 =
NULL
) {

814 
	`SLOGE
("Failedoarsehe input fileassed.");

815 
su
 = 
CERTSVC_FAIL
;

816 
r
;

821 i(
key
==
NULL
 && 

==NULL && 
v
==NULL) {

822 
su
 = 
	`PKCS12_r
(
cڏ
, 
sswd
, &
key
, &

, &
v
);

823 
	`PKCS12_
(
cڏ
);

824 i(
su
 =
CERTSVC_FAIL
) {

825 
	`SLOGE
("Failedoarsehe fileassed.");

826 
su
 = 
CERTSVC_FAIL
;

827 
r
;

830 
su
 = 
	`vify__das
(&

, &
v
);

831 i(
su
 =
CERTSVC_FAIL
) {

832 
	`SLOGE
("Failedo verify12 certificate.");

833 
r
;

837 
nis
 = 0;

838 
nis
 = 
v
 ? 
	`sk_X509_num
(certv) : 0;

839 i(
cvuev
 !
NULL
) {

840 
i
 = 0; i < 
n
; i++)

841 
	`g_
(
cvuev
[
i
]);

842 i(
cvuev

	`
(cvaluev);

843 
cvuev
 = 
NULL
;

846 
n
 = 0;

847 
cvuev
 = (
gch
 **)
	`oc
(1 + 
nis
, (gchar *));

848 i(
unique
 !
NULL
{ 
	`
(unique); unique = NULL; }

849 
su
 = 
	`unique_fame
(&
unique
, 
FALSE
);

850 i(
su
 !
CERTSVC_SUCCESS
 || !
unique
) {

851 
	`SLOGE
("Unique filename generation failed.");

852 
r
;

855 i((
am
 = 
	`fݒ
(
unique
, "w+")=
NULL
) {

856 
	`SLOGE
("Ubˁݒhff wrg [%s].",
unique
);

857 
su
 = 
CERTSVC_IO_ERROR
;

858 
r
;

861 
su
 = 
	`PEM_wre_PriveKey
(
am
, 
key
, 
NULL
, NULL, 0, NULL, NULL);

862 i(
su
 == 0) {

863 
	`SLOGE
("Writingherivate key contents failed.");

864 
su
 = 
CERTSVC_FAIL
;

865 
	`fo
(
am
);

866 
r
;

869 
	`fek
(
am
, 0, 
SEEK_SET
);

870 
	`memt
(
feBufr
, 0, (()*4096));

871 
adL
=0;

872 
adL
 = 
	`d
(
feBufr
, (), 4096, 
am
);

873 
	`fo
(
am
);

874 i(
adL
 <= 0){

875 
	`SLOGE
("Failedoead key file");

876 
su
 = 
CERTSVC_FAIL
;

877 
r
;

880 
be
 = 
	`be_fame
(
unique
);

881 i(
be
) {

882 
pkvue
 = 
	`g_rdup
(
be
);

883 
tmpL
 = 
	`
((cڡ *)
pkvue
);

884 
tmpPkVue
 = (*)
	`mloc
((* (
tmpL
 + 1));

885 
	`memt
(
tmpPkVue
, 0x00, 
tmpL
+1);

886 
	`memy
(
tmpPkVue
, 
pkvue
, 
tmpL
);

889 
decideCt
 = 
P12_PKEY
;

890 
su
 = 
	`vce__l_ifi_to_e
(
eTy
, 
tmpPkVue
, 
NULL
, NULL, NULL, 
feBufr
, 
adL
, 
decideCt
);

891 i(
su
 !
CERTSVC_SUCCESS
) {

892 
	`SLOGD
("Failedo storeherivate key contents.");

893 
su
 = 
CERTSVC_FAIL
;

894 
r
;

897 
	`uƚk
(
unique
);

898 i(
unique
!=
NULL
{ 
	`
(unique); unique=NULL; }

899 
su
 = 
	`unique_fame
(&
unique
, 
FALSE
);

900 i(
su
 !
CERTSVC_SUCCESS
 || !
unique
) {

901 
	`SLOGE
("Unique filename generation failed.");

902 
r
;

905 i((
am
 = 
	`fݒ
(
unique
, "w")=
NULL
) {

906 
	`SLOGE
("Ubˁݒhff wrg [%s].", 
unique
);

907 
su
 = 
CERTSVC_IO_ERROR
;

908 
r
;

911 
su
 = 
	`PEM_wre_X509
(
am
, 

);

912 
	`fo
(
am
);

913 i(
su
 == 0) {

914 
	`SLOGE
("Failedo write contentso file.");

915 
su
 = 
CERTSVC_FAIL
;

916 
r
;

919 
be
 = 
	`be_fame
(
unique
);

920 i(
be
)

921 
cvuev
[
n
++] = 
	`g_rdup
(
be
);

923 
wr_s
 = -1;

924 
decideCt
 = 
P12_END_USER
;

925 
wr_s
 = 
	`l_t_fe
(
unique
, 
eTy
, 
s
, 
tmpPkVue
, 
NULL
, 
decideCt
);

926 i(
wr_s
 !
CERTSVC_SUCCESS
) {

927 
su
 = 
CERTSVC_FAIL
;

928 
	`SLOGE
("Failedo installhend user certificate.");

929 
r
;

932 
	`uƚk
(
unique
);

933 
i
=
nis
; i>0; i--) {

934 
su
 = 
	`unique_fame
(&
unique
, 
FALSE
);

935 i(
su
 !
CERTSVC_SUCCESS
 || !
unique
) {

936 
	`SLOGE
("Unique filename generation failed.");

937 
r
;

940 i((
am
 = 
	`fݒ
(
unique
, "w")=
NULL
) {

941 
su
 = 
CERTSVC_IO_ERROR
;

942 
	`SLOGE
("Unableo openhe file for writing.");

943 
r
;

946 
su
 = 
	`PEM_wre_X509_AUX
(
am
, 
	`sk_X509_vue
(
v
, 
i
-1));

947 
	`fo
(
am
);

948 i(
su
 == 0) {

949 
su
 = 
CERTSVC_FAIL
;

950 
	`SLOGE
("Unableoxtracthe certificates.");

951 
r
;

954 
wr_s
 = -1;

955 i(
i
==
nis
)

956 
decideCt
 = 
P12_INTERMEDIATE
;

958 
decideCt
 = 
P12_TRUSTED
;

959 
wr_s
 = 
	`l_t_fe
(
unique
, 
eTy
, 
s
, 
NULL
, 
cvuev
[0], 
decideCt
);

960 i(
wr_s
 !
CERTSVC_SUCCESS
) {

961 
su
 = 
CERTSVC_FAIL
;

962 
r
;

965 
	`uƚk
(
unique
);

966 
be
 = 
	`be_fame
(
unique
);

967 i(
be
)

968 
cvuev
[
n
++] = 
	`g_rdup
(
be
);

971 
loCou
++;

974 
r
:

977 i(
su
 !
CERTSVC_SUCCESS
) {

978 
	`SLOG
(
LOG_INFO
, "MDM_LOG_USER", "Object=certificate, AccessType=Install, Result=Failed");

979 i(
nis
 > 0) {

980 
nis
 = 0; 
i
 = 0;

983 i(
	`c_svc_pkcs12_ld_ifis_om_e
(
eTy
, 
cvuev
[0], &
s
, (
gsize
 *)&
ns
!
CERTSVC_SUCCESS
) {

984 
	`SLOGE
("Unableooad certificates from store.");

985  
su
;

988 
i
=0; i<
ns
; i++) {

989 i(
s
[
i
] !
NULL
) {

990 
	`SLOGD
("ftd: %s",
s
[
i
]);

991 
	`c_svc_pkcs12_de_ifi_om_e
(
eTy
, (*)
s
[
i
]);

995 i(
s
[
i
] !
NULL
) {

996 
i
=0; i<
ns
; i++)

997 
	`g_
(
s
[
i
]);

1002 
	`SLOG
(
LOG_INFO
, "MDM_LOG_USER", "Object=certificate, AccessType=Install, Result=Succeed");

1004 i(
key
 !
NULL

	`EVP_PKEY_
(key);

1005 i(

 !
NULL

	`X509_
(cert);

1006 i(
v
 !
NULL

	`sk_X509_
(certv);

1007 i(
pkvue
 !
NULL

	`
(pkvalue);

1008 i(
tmpPkVue
 !
NULL

	`
(tmpPkValue);

1009 i(
unique
 !
NULL

	`
(unique);

1010  
su
;

1011 
	}
}

1014 
	$c_svc_pkcs12_s_exis
(cڡ 
gch
 *
s
, 
gboޗn
 *
exis
) {

1015 
GKeyFe
 *
keyfe
;

1017 if(
exis
 =
NULL
)

1018  
CERTSVC_WRONG_ARGUMENT
;

1019 
keyfe
 = 
	`keyfe_ld
(
CERTSVC_PKCS12_STORAGE_PATH
);

1020 if(!
keyfe
)

1021  
CERTSVC_IO_ERROR
;

1022 *
exis
 = 
	`g_key_fe_has_group
(
keyfe
, 
s
);

1023 
	`g_key_fe_
(
keyfe
);

1024  
CERTSVC_SUCCESS
;

1025 
	}
}

1027 
	$c_svc_pkcs12_impt
(cڡ *
th
, cڡ *
sswd
, cڡ 
gch
 *
s
) {

1028 
exis
;

1029 
FILE
 *
am
;

1030 
PKCS12
 *
cڏ
;

1031 
EVP_PKEY
 *
key
;

1032 
X509
 *

;

1033 
	`STACK_OF
(
X509
*
v
;

1034 
nis
;

1035 *
unique
;

1036 
su
 = 0;

1037 

 

;

1038 
wr_s
;

1039 
GKeyFe
 *
keyfe
;

1040 
gch
 *
be
;

1041 
gch
 *
pkvue
;

1042 
gch
 **
cvuev
;

1043 
gsize
 
i
, 
n
;

1044 
gch
 *
da
;

1045 
gsize
 
ngth
;

1046 
adL
 = 0;

1047 
feBufr
[4096] = {0,};

1049 
v
 = 
NULL
;

1050 
pkvue
 = 
NULL
;

1051 if(!
s
 || 
	`
(alias) < 1)

1052  
CERTSVC_WRONG_ARGUMENT
;

1053 
su
 = 
	`c_svc_pkcs12_s_exis
(
s
, &
exis
);

1054 if(
su
 !
CERTSVC_SUCCESS
)

1055  
su
;

1056 if(
exis
 =
TRUE
)

1057  
CERTSVC_DUPLICATED_ALIAS
;

1059 
keyfe
 = 
	`keyfe_ld
(
CERTSVC_PKCS12_STORAGE_PATH
);

1060 if(!
keyfe
)

1061  
CERTSVC_IO_ERROR
;

1062 if(
	`
(
CERTSVC_PKCS12_STORAGE_PATH
, &

) == -1) {

1063 if(
	`mkd
(
CERTSVC_PKCS12_STORAGE_PATH
, 
S_IRWXU
 | 
S_IRWXG
 | 
S_IRWXO
) == -1) {

1064 
su
 = 
CERTSVC_FAIL
;

1065 
_keyfe
;

1069 if((
am
 = 
	`fݒ
(
th
, "rb")=
NULL
) {

1070 
su
 = 
CERTSVC_IO_ERROR
;

1071 
_keyfe
;

1073 
cڏ
 = 
	`d2i_PKCS12_
(
am
, 
NULL
);

1074 
	`fo
(
am
);

1075 if(
cڏ
 =
NULL
) {

1076 
su
 = 
CERTSVC_FAIL
;

1077 
_keyfe
;

1081 
su
 = 
	`PKCS12_r
(
cڏ
, 
sswd
, &
key
, &

, &
v
);

1082 
	`PKCS12_
(
cڏ
);

1083 i(
su
 == 0)

1085 
	`SLOGD
("Failedoarse PKCS12");

1086 
su
 = 
CERTSVC_FAIL
;

1087 
_keyfe
;

1090 
su
 = 
	`vify__das
(&

, &
v
);

1091 i(
su
 =
CERTSVC_FAIL
)

1093 
	`SLOGE
("Failedoarsehe fileassed.");

1094 
_keyfe
;

1097 
nis
 = 
v
 ? 
	`sk_X509_num
(certv) : 0;

1098 
cvuev
 = (
gch
 **)
	`oc
(1 + 
nis
, (gchar *));

1099 
n
 = 0;

1101 
su
 = 
	`unique_fame
(&
unique
, 
TRUE
);

1102 if(
su
 !
CERTSVC_SUCCESS
)

1103 
n__cha_d_pkey
;

1104 if((
am
 = 
	`fݒ
(
unique
, "w+")=
NULL
) {

1105 
	`
(
unique
);

1106 
su
 = 
CERTSVC_IO_ERROR
;

1107 
n__cha_d_pkey
;

1109 
su
 = 
	`PEM_wre_PriveKey
(
am
, 
key
, 
NULL
, NULL, 0, NULL, NULL);

1110 if(
su
 == 0) {

1111 
su
 = 
CERTSVC_FAIL
;

1112 
	`fo
(
am
);

1113 
	`
(
unique
);

1114 
n__cha_d_pkey
;

1117 
	`fek
(
am
, 0, 
SEEK_SET
);

1119 
adL
 = 
	`d
(
feBufr
, (), 4096, 
am
);

1120 
	`fo
(
am
);

1121 if(
adL
 <= 0){

1122 
	`
(
unique
);

1123 
su
 = 
CERTSVC_FAIL
;

1124 
	`SLOGE
("failedoead key file");

1125 
n__cha_d_pkey
;

1128 
wr_s
 = 
	`ssm_wre_fe
(
unique
, 
SSM_FLAG_DATA
, 
CERTSVC_PKCS12_UNIX_GROUP
);

1129 if(
wr_s
 <= 0) {

1130 
	`
(
unique
);

1131 
su
 = 
CERTSVC_FAIL
;

1132 
	`SLOGE
("ssm_wre_fed : %d", 
wr_s
);

1133 
n__cha_d_pkey
;

1135 
	`uƚk
(
unique
);

1137 
be
 = 
	`be_fame
(
unique
);

1138 if(
be
) {

1139 
pkvue
 = 
	`g_rdup
(
be
);

1140 
	`g_key_fe_t_rg
(
keyfe
, 
s
, 
CERTSVC_PKCS12_STORAGE_KEY_PKEY
, 
pkvue
);

1142 
	`
(
unique
);

1143 
su
 = 
	`unique_fame
(&
unique
, 
TRUE
);

1144 if(
su
 !
CERTSVC_SUCCESS
)

1145 
n__cha_d_pkey
;

1146 if((
am
 = 
	`fݒ
(
unique
, "w")=
NULL
) {

1147 
	`
(
unique
);

1148 
su
 = 
CERTSVC_IO_ERROR
;

1149 
n__cha_d_pkey
;

1151 
su
 = 
	`PEM_wre_X509
(
am
, 

);

1152 
	`fo
(
am
);

1153 if(
su
 == 0) {

1154 
su
 = 
CERTSVC_FAIL
;

1155 
n__cha_d_pkey
;

1157 
be
 = 
	`be_fame
(
unique
);

1158 if(
be
)

1159 
cvuev
[
n
++] = 
	`g_rdup
(
be
);

1160 
	`
(
unique
);

1161 
i
 = 0; i < ()
nis
; i++) {

1162 
su
 = 
	`unique_fame
(&
unique
, 
TRUE
);

1163 if(
su
 !
CERTSVC_SUCCESS
)

1164 
n__cha_d_pkey
;

1165 if((
am
 = 
	`fݒ
(
unique
, "w")=
NULL
) {

1166 
	`
(
unique
);

1167 
su
 = 
CERTSVC_IO_ERROR
;

1168 
n__cha_d_pkey
;

1170 
su
 = 
	`PEM_wre_X509_AUX
(
am
, 
	`sk_X509_vue
(
v
, 
i
));

1171 
	`fo
(
am
);

1172 if(
su
 == 0) {

1173 
su
 = 
CERTSVC_FAIL
;

1174 
n__cha_d_pkey
;

1176 
be
 = 
	`be_fame
(
unique
);

1177 if(
be
)

1178 
cvuev
[
n
++] = 
	`g_rdup
(
be
);

1179 
	`
(
unique
);

1181 
	`g_key_fe_t_li_t
(
keyfe
, 
CERTSVC_PKCS12_STORAGE_SEPARATOR
);

1182 
	`g_key_fe_t_rg_li
(
keyfe
, 
s
, 
CERTSVC_PKCS12_STORAGE_KEY_CERTS
, (cڡ 
gch
 * cڡ *)
cvuev
, 
n
);

1183 
da
 = 
	`g_key_fe_to_da
(
keyfe
, &
ngth
, 
NULL
);

1184 if(
da
 =
NULL
) {

1185 
su
 = 
CERTSVC_BAD_ALLOC
;

1186 
n__cha_d_pkey
;

1188 if(!
	`g_fe_t_cڋs
(
CERTSVC_PKCS12_STORAGE_PATH
, 
da
, 
ngth
, 
NULL
)) {

1189 
su
 = 
CERTSVC_IO_ERROR
;

1190 
_da
;

1192 
su
 = 
CERTSVC_SUCCESS
;

1194 
	`SLOGD
("%s, %s)", 
th
, 
sswd
);

1196 
_da
:

1197 
	`g_
(
da
);

1199 
n__cha_d_pkey
:

1200 
	`EVP_PKEY_
(
key
);

1201 
	`X509_
(

);

1202 
	`sk_X509_
(
v
);

1203 
	`
(
pkvue
);

1204 
i
 = 0; i < 
n
; i++) {

1205 
	`g_
(
cvuev
[
i
]);

1207 
	`
(
cvuev
);

1208 
_keyfe
:

1209 
	`g_key_fe_
(
keyfe
);

1210  
su
;

1211 
	}
}

1213 
	$c_svc_pkcs12_s_ld
(
gch
 ***
s
, 
gsize
 *
ls
) {

1214 
GKeyFe
 *
keyfe
;

1216 
keyfe
 = 
	`keyfe_ld
(
CERTSVC_PKCS12_STORAGE_PATH
);

1217 if(!
keyfe
)

1218  
CERTSVC_IO_ERROR
;

1219 *
s
 = 
	`g_key_fe_g_groups
(
keyfe
, 
ls
);

1220 
	`g_key_fe_
(
keyfe
);

1221  
CERTSVC_SUCCESS
;

1222 
	}
}

1224 
	$c_svc_pkcs12_s_
(
gch
 **
s
) {

1225 
	`g_rv
(
s
);

1226 
	}
}

1228 
	$c_svc_pkcs12_has_sswd
(cڡ *
fh
, 
gboޗn
 *
sswded
) {

1229 
FILE
 *
am
;

1230 
EVP_PKEY
 *
pkey
;

1231 
X509
 *

;

1232 
PKCS12
 *
cڏ
;

1233 
su
;

1235 if(
sswded
 =
NULL
)

1236  
CERTSVC_WRONG_ARGUMENT
;

1237 if((
am
 = 
	`fݒ
(
fh
, "rb")=
NULL
)

1238  
CERTSVC_IO_ERROR
;

1239 
cڏ
 = 
	`d2i_PKCS12_
(
am
, 
NULL
);

1240 
	`fo
(
am
);

1241 if(
cڏ
 =
NULL
)

1242  
CERTSVC_FAIL
;

1243 
su
 = 
	`PKCS12_r
(
cڏ
, 
NULL
, &
pkey
, &

, NULL);

1244 
	`PKCS12_
(
cڏ
);

1245 if(
su
 == 1) {

1246 
	`EVP_PKEY_
(
pkey
);

1247 
	`X509_
(

);

1248 *
sswded
 = 
FALSE
;

1249  
CERTSVC_SUCCESS
;

1252 if(
	`ERR_GET_REASON
(
	`ERR_ek_ϡ_r
()=
PKCS12_R_MAC_VERIFY_FAILURE
) {

1253 *
sswded
 = 
TRUE
;

1254  
CERTSVC_SUCCESS
;

1257  
CERTSVC_FAIL
;

1259 
	}
}

1261 
	$c_svc_pkcs12_ld_ifis
(cڡ 
gch
 *
s
, gch ***
s
, 
gsize
 *
ns
) {

1262 
GKeyFe
 *
keyfe
;

1263 
gch
 **
bev
;

1264 
gsize
 
i
;

1265 
keyfe
 = 
	`keyfe_ld
(
CERTSVC_PKCS12_STORAGE_PATH
);

1266 if(!
keyfe
)

1267  
CERTSVC_IO_ERROR
;

1268 
	`g_key_fe_t_li_t
(
keyfe
, 
CERTSVC_PKCS12_STORAGE_SEPARATOR
);

1269 
bev
 = 
	`g_key_fe_g_rg_li
(
keyfe
, 
s
, 
CERTSVC_PKCS12_STORAGE_KEY_CERTS
, 
ns
, 
NULL
);

1270 if(
bev
 =
NULL
) {

1271 *
ns
 = 0;

1272 
_keyfe
;

1274 *
s
 = (
gch
 **)
	`g_mloc
((*
ns
 + 1) * (gchar *));

1275 
i
 = 0; i < *
ns
; i++)

1276 (*
s
)[
i
] = 
	`g_rdup_tf
("%s/%s", 
CERTSVC_PKCS12_STORAGE_DIR
, 
bev
[i]);

1277 (*
s
)[*
ns
] = 
NULL
;

1278 
	`g_rv
(
bev
);

1279 
_keyfe
:

1280 
	`g_key_fe_
(
keyfe
);

1281  
CERTSVC_SUCCESS
;

1282 
	}
}

1284 
	$c_svc_pkcs12__ifis
(
gch
 **
s
) {

1285 
gsize
 
i
 = 0;

1286 if(
s
 =
NULL
)

1288 
s
[
i
])

1289 
	`g_
(
s
[
i
++]);

1290 
	`g_
(
s
);

1291 
	}
}

1293 
	$c_svc_pkcs12_ive_key_ld
(cڡ 
gch
 *
s
, **
bufr
, 
gsize
 *
cou
) {

1294 
GKeyFe
 *
keyfe
;

1295 
gch
 *
pkey
;

1296 
GE
 *
r
;

1297 *
kp
;

1298 
su
;

1299 
ssm_fe_fo_t
 
sfi
;

1301 if(!
bufr
)

1302  
CERTSVC_WRONG_ARGUMENT
;

1303 
keyfe
 = 
	`keyfe_ld
(
CERTSVC_PKCS12_STORAGE_PATH
);

1304 if(!
keyfe
)

1305  
CERTSVC_IO_ERROR
;

1306 
r
 = 
NULL
;

1308 
su
 = 
CERTSVC_SUCCESS
;

1310 
pkey
 = 
	`g_key_fe_g_rg
(
keyfe
, 
s
, 
CERTSVC_PKCS12_STORAGE_KEY_PKEY
, &
r
);

1311 
	`g_key_fe_
(
keyfe
);

1313 if(
r
 &&->
code
 =
G_KEY_FILE_ERROR_KEY_NOT_FOUND
) {

1314 *
cou
 = 0;

1315  
CERTSVC_SUCCESS
;

1318 if(
r
)

1319  
CERTSVC_FAIL
;

1321 if(
	`artf
(&
kp
, "%s/%s", 
CERTSVC_PKCS12_STORAGE_DIR
, 
pkey
) == -1) {

1322 
kp
 = 
NULL
;

1323 
su
 = 
CERTSVC_BAD_ALLOC
;

1324 
out
;

1327 if(
	`ssm_gfo
(
kp
, &
sfi
, 
SSM_FLAG_DATA
, 
CERTSVC_PKCS12_UNIX_GROUP
) != 0) {

1329 
out
;

1332 if((*
bufr
 = (*)
	`mloc
(
sfi
.
igSize
))) {

1333 
su
 = 
CERTSVC_BAD_ALLOC
;

1334 
out
;

1337 if(
	`ssm_ad
(
kp
, *
bufr
, 
sfi
.
igSize
, 
cou
, 
SSM_FLAG_DATA
, 
CERTSVC_PKCS12_UNIX_GROUP
) != 0) {

1338 
	`c_svc_pkcs12_ive_key_
(*
bufr
);

1339 
su
 = 
CERTSVC_FAIL
;

1342 
out
:

1343 
	`
(
kp
);

1344 
	`g_
(
pkey
);

1346  
su
;

1347 
	}
}

1349 
	$c_svc_pkcs12_ive_key_
(*
bufr
) {

1350 
	`
(
bufr
);

1351 
	}
}

1353 
	$svc_ld_fe_to_bufr
(cڡ * 
fePh
, ** 
Buf
, * 
ngth
)

1355 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1356 
FILE
* 
_
 = 
NULL
;

1357 
feSize
 = 0;

1360 if((
t
 = 
	`_svc_g_fe_size
(
fePh
, &
feSize
)!
CERT_SVC_ERR_NO_ERROR
) {

1361 
	`SLOGE
("[ERR][%s] Fag fsize, [%s]", 
__func__
, 
fePh
);

1362  
CERT_SVC_ERR_FILE_IO
;

1365 if(!(
_
 = 
	`fݒ
(
fePh
, "rb"))) {

1366 
	`SLOGE
("[ERR][%s] Faݒ fe, [%s]", 
__func__
, 
fePh
);

1367  
CERT_SVC_ERR_FILE_IO
;

1370 if(!(*
Buf
 = (*)
	`mloc
((* ()(
feSize
 + 1)))) {

1371 
	`SLOGE
("[ERR][%s] Faخlo memy.", 
__func__
);

1372 
t
 = 
CERT_SVC_ERR_MEMORY_ALLOCATION
;

1373 
r
;

1375 
	`memt
(*
Buf
, 0x00, (
feSize
 + 1));

1376 if(
	`d
(*
Buf
, (), 
feSize
, 
_
) != fileSize) {

1377 
	`SLOGE
("[ERR][%s] Faػad fe, [%s]", 
__func__
, 
fePh
);

1378 
t
 = 
CERT_SVC_ERR_FILE_IO
;

1379 
r
;

1382 *
ngth
 = 
feSize
;

1384 
r
:

1385 if(
_
 !
NULL
)

1386 
	`fo
(
_
);

1387  
t
;

1388 
	}
}

1390 
	$c_svc_pkcs12_de
(cڡ 
gch
 *
s
) {

1391 
gch
 **
s
;

1392 
gsize
 
ns
;

1393 *
pkey
 = 
NULL
;

1394 *
kp
 = 
NULL
;

1395 
su
;

1396 
GKeyFe
 *
keyfe
 = 
NULL
;

1397 
gch
 *
da
;

1398 
gsize
 
i
, 
ngth
;

1400 
da
 = 
NULL
;

1401 
su
 = 
	`c_svc_pkcs12_ld_ifis
(
s
, &
s
, &
ns
);

1402 if(
su
 !
CERTSVC_SUCCESS
)

1403 
ld_ifis_ed
;

1404 
keyfe
 = 
	`keyfe_ld
(
CERTSVC_PKCS12_STORAGE_PATH
);

1405 if(!
keyfe
) {

1406 
su
 = 
CERTSVC_IO_ERROR
;

1407 
keyfe_ld_ed
;

1409 
pkey
 = 
	`g_key_fe_g_rg
(
keyfe
, 
s
, 
CERTSVC_PKCS12_STORAGE_KEY_PKEY
, 
NULL
);

1410 if(
	`g_key_fe_move_group
(
keyfe
, 
s
, 
NULL
)) {

1411 
da
 = 
	`g_key_fe_to_da
(
keyfe
, &
ngth
, 
NULL
);

1412 if(
da
 =
NULL
) {

1413 
su
 = 
CERTSVC_BAD_ALLOC
;

1414 
keyfe_
;

1416 if(!
	`g_fe_t_cڋs
(
CERTSVC_PKCS12_STORAGE_PATH
, 
da
, 
ngth
, 
NULL
)) {

1417 
su
 = 
CERTSVC_IO_ERROR
;

1418 
da_
;

1422 
i
 = 0; i < 
ns
; i++)

1424 
	`uƚk
(
s
[
i
]);

1426 if(
pkey
 !
NULL
) {

1427 if(
	`artf
(&
kp
, "%s/%s", 
CERTSVC_PKCS12_STORAGE_DIR
, 
pkey
) == -1) {

1428 
su
 = 
CERTSVC_BAD_ALLOC
;

1429 
da_
;

1431 
	`ssm_de_fe
(
kp
, 
SSM_FLAG_DATA
, 
CERTSVC_PKCS12_UNIX_GROUP
);

1432 
	`
(
kp
);

1434 
da_
:

1435 
	`g_
(
da
);

1436 
keyfe_
:

1437 
	`g_key_fe_
(
keyfe
);

1438 
keyfe_ld_ed
:

1439 if(
ns
 != 0)

1440 
	`c_svc_pkcs12__ifis
(
s
);

1441 
ld_ifis_ed
:

1442  
su
;

1443 
	}
}

1446 
	$_svc_g_fe_size
(cڡ * 
fh
, * 
ngth
)

1448 
t
 = 
CERT_SVC_ERR_NO_ERROR
;

1449 
FILE
* 
_
 = 
NULL
;

1451 if(!(
_
 = 
	`fݒ
(
fh
, "r"))) {

1452 
	`SLOGE
("[ERR][%s] Faݒ fe, [%s]", 
__func__
, 
fh
);

1453 
t
 = 
CERT_SVC_ERR_FILE_IO
;

1454 
r
;

1457 
	`fek
(
_
, 0L, 
SEEK_END
);

1458 (*
ngth

	`l
(
_
);

1460 
r
:

1461 if(
_
 !
NULL
)

1462 
	`fo
(
_
);

1464  
t
;

1465 
	}
}

	@vcore/src/vcore/pkcs12.h

22 #ide
_PKCS12_H_


23 
	#_PKCS12_H_


	)

25 
	~<glib.h
>

26 
	~<-svc/c.h
>

28 #ifde
__lulus


39 
c_svc_pkcs12_s_exis
(cڡ 
gch
 *
s
, 
gboޗn
 *
exis
);

49 
c_svc_pkcs12_impt
(cڡ *
th
, cڡ *
sswd
, cڡ 
gch
 *
s
);

60 
c_svc_pkcs12_impt_om_fe_to_e
(
CtSteTy
 
eTy
, cڡ *
th
, cڡ *
sswd
, cڡ 
gch
 *
s
);

74 
c_svc_pkcs12_g_ifi_li_om_e
(
CtSteTy
 
eTy
, 
is_ro_p
, 
CtSvcSteCtLi
** 
Li
, * 
ngth
);

86 
c_svc_pkcs12_t_ifi_us_to_e
(
CtSteTy
 
eTy
, 
is_ro_p
, * 
gme
, 
CtStus
 
us
);

96 
c_svc_pkcs12_g_ifi_us_om_e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
gme
, *
us
);

107 
c_svc_pkcs12_g_ifi_bufr_om_e
(
CtSteTy
 
eTy
, * 
gme
, ** 
Bufr
, 
size_t
* 
Size
);

116 
c_svc_pkcs12_de_ifi_om_e
(
CtSteTy
 
eTy
, cڡ * 
gme
);

125 
c_svc_pkcs12__s_lded_om_e
(
CtSvcSteCtLi
** 
Li
);

135 
c_svc_pkcs12_s_exis__e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
s
, 
gboޗn
 *
exis
);

146 
c_svc_pkcs12_ld_ifis_om_e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
gme
, gch ***
s
, 
gsize
 *
ns
);

156 
c_svc_pkcs12_ive_key_ld_om_e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
gme
, **
pkey
, 
gsize
 *
cou
);

166 
c_svc_pkcs12_g_ifi_s_om_e
(
CtSteTy
 
eTy
, cڡ 
gch
 *
gme
, **
s
);

178 
c_svc_pkcs12_g_d_ur_ifi_li_om_e
(
CtSteTy
 
eTy
, 
CtSvcSteCtLi
** 
Li
, * 
ngth
);

190 
c_svc_pkcs12_g_ro_ifi_li_om_e
(
CtSteTy
 
eTy
, 
CtSvcSteCtLi
** 
Li
, * 
ngth
);

199 
c_svc_pkcs12_s_ld
(
gch
 ***
s
, 
gsize
 *
ls
);

207 
c_svc_pkcs12_s_
(
gch
 **
s
);

216 
c_svc_pkcs12_has_sswd
(cڡ *
fh
, 
gboޗn
 *
sswded
);

226 
c_svc_pkcs12_ld_ifis
(cڡ 
gch
 *
s
, gch ***
ifis
, 
gsize
 *
nifis
);

235 
c_svc_pkcs12__ifis
(
gch
 **
s
);

245 
c_svc_pkcs12_ive_key_ld
(cڡ 
gch
 *
s
, **
pkey
, 
gsize
 *
cou
);

253 
c_svc_pkcs12_ive_key_
(*
bufr
);

261 
c_svc_pkcs12_de
(cڡ 
gch
 *
s
);

272 
svc_ld_fe_to_bufr
(cڡ * 
fePh
, ** 
Buf
, * 
ngth
);

281 
_svc_g_fe_size
(cڡ * 
fh
, * 
ngth
);

283 #ifde
__lulus


	@vcore/src/vcore/scoped_gpointer.h

22 #ide
WRT_ENGINE_SRC_COMMON_SCOPED_GPOINTER_H


23 
	#WRT_ENGINE_SRC_COMMON_SCOPED_GPOINTER_H


	)

25 
	~<cddef
>

26 
	~<glib-obje.h
>

28 
	~<d/sced_sour.h
>

29 
	~<d/as.h
>

31 
mea
 
	gWRT
 {

32 
	sScedGPorPicy


34 
gpor
 
	tTy
;

35 
Ty
 
NuVue
()

37  
	gNULL
;

39 
Deroy
(
Ty
 
por
)

41 i(
	gpor
 !
NULL
) {

42 
g_obje_uef
(
por
);

47 
	gme
 <
tyme
 
	gCss
>

48 
ass
 
	gScedGPor
 : 
public
 
VceDPL
::
ScedResour
<
ScedGPorPicy
>

50 
ScedGPorPicy
 
	tPicy
;

51 
	gVceDPL
::
	tScedResour
<
	tPicy
> 
	tBaTy
;

53 
	gpublic
:

54 
exic
 
ScedGPor
(
tyme
 
Picy
::
Ty
 
por
 =

55 
Picy
::
NuVue
()) :

56 
BaTy
(
por
)

60 
Css
 *
ݔ
->(cڡ 
throw
()

62 
As
(
this
->
m_vue
 !
Picy
::
NuVue
() &&

64  
	gic_
<
	gCss
 *>(
	gthis
->
	gm_vue
);

67 
	gCss
 & 
	gݔ
 *(cڡ 
throw
()

69 
As
(
this
->
m_vue
 !
Picy
::
NuVue
() &&

71  *
	gic_
<
	gCss
 *>(
	gthis
->
	gm_vue
);

	@vcore/src/vcore/utils.c

1 
	~<-rvi.h
>

2 
	~<-rvi-debug.h
>

3 
	~<-svc/.h
>

5 
	~<dio.h
>

6 
	~<dlib.h
>

7 
	~<rg.h
>

9 
	~"uts.h
"

11 
	$_cy_fld
(cڡ *

, **
out
)

13 
size_t
 
_n
 = 
	`
((cڡ *)(

));

15 *
out
 = (*)
	`mloc
((* (
_n
 + 1));

16 i(!(*
out
)) {

17 
	`LOGE
("Failedollocate memory.");

21 
	`memy
(*
out
, 

, 
_n
 + 1);

22 
	}
}

24 *
	$g_come_th
(cڡ *
r1
, cڡ *
r2
)

26 
size_t
 
r1_n
 = 
	`
(
r1
);

27 *
su
 = 
NULL
;

28 
as_su
;

30 i(
r1
[
r1_n
 - 1] != '/')

31 
as_su
 = 
	`artf
(&
su
, "%s/%s", 
r1
, 
r2
);

33 
as_su
 = 
	`artf
(&
su
, "%s%s", 
r1
, 
r2
);

35 i(
as_su
 < 0)

36  
NULL
;

38  
su
;

39 
	}
}

42 
	$g_comm_me
(cڡ *
th
, 
x509_
 *
x509Su
, **
commName
)

44 
su
 = 
CERTSVC_SUCCESS
;

45 cڡ * 
da
 = 
NULL
;

46 
CERT_CONTEXT
* 
cڋxt
 = 
NULL
;

47 *
_commName
 = 
NULL
;

48 *
tmpSubjeS
 = 
NULL
;

49 
_svc_me_d_da
 *
FldDa
 = 
NULL
;

51 i(!
th
 && !
x509Su
) {

52 
	`LOGE
("Invalid inputarameter.");

53  
CERTSVC_WRONG_ARGUMENT
;

57 i(!
x509Su
) {

58 
cڋxt
 = 
	`_svc__cڋxt_
();

59 i(!
cڋxt
) {

60 
	`LOGE
("Failedollocate memory.");

61  
CERTSVC_BAD_ALLOC
;

64 
su
 = 
	`_svc_ld_fe_to_cڋxt
(
cڋxt
, 
th
);

65 i(
su
 !
CERT_SVC_ERR_NO_ERROR
) {

66 
	`LOGE
("Failedooad file into context.");

67 
su
 = 
CERTSVC_FAIL
;

68 
r
;

71 i(!
cڋxt
->
Buf
 || !cڋxt->Buf->
da
) {

72 
	`LOGE
("Empty certificate buffer.");

73 
su
 = 
CERTSVC_FAIL
;

74 
r
;

77 
da
 = 
cڋxt
->
Buf
->data;

78 
	`d2i_X509
(&
x509Su
, &
da
, 
cڋxt
->
Buf
->
size
);

80 i(!
x509Su
) {

81 
	`LOGE
("[ERR][%s] Facڡru X509 suu.", 
__func__
);

82 
su
 = 
CERT_SVC_ERR_INVALID_CERTIFICATE
;

83 
r
;

88 
tmpSubjeS
 = (*)
	`X509_NAME_ږe
((
x509Su
->
_fo
->
subje
), 
NULL
, 0);

89 i(!
tmpSubjeS
) {

90 
	`LOGE
("[ERR][%s] Faطr ctifi.", 
__func__
);

91 
su
 = 
CERTSVC_FAIL
;

92 
r
;

95 
FldDa
 = (
_svc_me_d_da
 *)
	`mloc
((cert_svc_name_fld_data));

96 i(!
FldDa
) {

97 
	`LOGE
("Failedollocate memory.");

98 
su
 = 
CERTSVC_BAD_ALLOC
;

99 
r
;

102 
FldDa
->
commName
 = 
NULL
;

103 
FldDa
->
giziName
 = 
NULL
;

104 
FldDa
->
giziUnName
 = 
NULL
;

105 
FldDa
->
emaAddss
 = 
NULL
;

107 
su
 = 
	`_svc_ut_r_me_d_da
(
tmpSubjeS
, 
FldDa
);

108 i(
su
 !
CERT_SVC_ERR_NO_ERROR
) {

109 
	`LOGE
("[ERR][%s] Faطr ct_svc_me_d_da.", 
__func__
);

110 
su
 = 
CERTSVC_FAIL
;

111 
r
;

114 
su
 = 
CERTSVC_SUCCESS
;

116 i(
FldDa
->
commName
)

117 
	`_cy_fld
(
FldDa
->
commName
, &
_commName
);

118 i(
FldDa
->
giziName
)

119 
	`_cy_fld
(
FldDa
->
giziName
, &
_commName
);

120 i(
FldDa
->
giziUnName
)

121 
	`_cy_fld
(
FldDa
->
giziUnName
, &
_commName
);

122 i(
FldDa
->
emaAddss
)

123 
	`_cy_fld
(
FldDa
->
emaAddss
, &
_commName
);

125 i(!
_commName
) {

126 
	`LOGE
("Failedo get commoname");

127 
su
 = 
CERTSVC_FAIL
;

128 
r
;

131 *
commName
 = (*)
_commName
;

132 
	`LOGD
("Sucstg commڂamf܁. commme[%s]", *
commName
);

134 
r
:

135 i(
x509Su
)

136 
	`X509_
(
x509Su
);

138 i(
cڋxt
)

139 
	`_svc__cڋxt_f
(
cڋxt
);

141 i(
tmpSubjeS
)

142 
	`OPENSSL_
(
tmpSubjeS
);

144 i(
FldDa
) {

145 
	`
(
FldDa
->
couryName
);

146 
	`
(
FldDa
->
lolyName
);

147 
	`
(
FldDa
->
eOrProvName
);

148 
	`
(
FldDa
->
giziName
);

149 
	`
(
FldDa
->
giziUnName
);

150 
	`
(
FldDa
->
commName
);

151 
	`
(
FldDa
->
emaAddss
);

152 
	`
(
FldDa
);

155  
su
;

156 
	}
}

	@vcore/src/vcore/utils.h

1 #agm



3 
	~<ݒs/x509.h
>

5 #ifde
__lulus


9 *
g_come_th
(cڡ *
r1
, cڡ *
r2
);

10 
g_comm_me
(cڡ *
th
, 
x509_
 *
x509Su
, **
commName
);

12 #ifde
__lulus


	@/usr/include/ctype.h

22 #idef 
_CTYPE_H


23 
	#_CTYPE_H
 1

	)

25 
	~<us.h
>

26 
	~<bs/tys.h
>

28 
	g__BEGIN_DECLS


30 #ide
_ISb


39 
	~<dn.h
>

40 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


41 
	#_ISb
(
b
(1 << (b))

	)

43 
	#_ISb
(
b
((b< 8 ? ((1 << (b)<< 8: ((1 << (b)>> 8))

	)

48 
	m_ISu
 = 
_ISb
 (0),

49 
	m_ISlow
 = 
_ISb
 (1),

50 
	m_ISpha
 = 
_ISb
 (2),

51 
	m_ISdig
 = 
_ISb
 (3),

52 
	m_ISxdig
 = 
_ISb
 (4),

53 
	m_ISa
 = 
_ISb
 (5),

54 
	m_ISt
 = 
_ISb
 (6),

55 
	m_ISgph
 = 
_ISb
 (7),

56 
	m_ISbnk
 = 
_ISb
 (8),

57 
	m_ISl
 = 
_ISb
 (9),

58 
	m_ISpun
 = 
_ISb
 (10),

59 
	m_ISnum
 = 
_ISb
 (11)

79 cڡ **
	$__y_b_loc
 ()

80 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

81 cڡ 
__t32_t
 **
	$__y_tow_loc
 ()

82 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

83 cڡ 
__t32_t
 **
	$__y_tou_loc
 ()

84 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

87 #ide
__lulus


88 
	#__isy
(
c
, 
ty
) \

89 ((*
	`__y_b_loc
 ())[((
c
)] & (
ty
)

	)

90 #i
defed
 
__USE_EXTERN_INLINES


91 
	#__isy_f
(
ty
) \

92 
__ex_le
 \

93 
is
##
	`ty
 (
__c

__THROW
 \

95  (*
	`__y_b_loc
 ())[((
__c
)] & (
_IS
##
ty
; \

96 
	}

	)
}

99 
	#__iscii
(
c
(((c& ~0x7f=0

	)

100 
	#__tscii
(
c
((c& 0x7f

	)

102 
	#__exy
(
me

	`me
 (
__THROW


	)

104 
__BEGIN_NAMESPACE_STD


110 
__exy
 (
ium
);

111 
__exy
 (
iha
);

112 
__exy
 (
isl
);

113 
__exy
 (
isdig
);

114 
__exy
 (
iow
);

115 
__exy
 (
isgph
);

116 
__exy
 (
irt
);

117 
__exy
 (
iun
);

118 
__exy
 (
isa
);

119 
__exy
 (
isu
);

120 
__exy
 (
isxdig
);

124 
	$tow
 (
__c

__THROW
;

127 
	$tou
 (
__c

__THROW
;

129 
__END_NAMESPACE_STD


133 #ifdef 
__USE_ISOC99


134 
__BEGIN_NAMESPACE_C99


136 
	`__exy
 (
isbnk
);

138 
__END_NAMESPACE_C99


141 #ifde
__USE_GNU


143 
	$isy
 (
__c
, 
__mask

__THROW
;

146 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


150 
	$iscii
 (
__c

__THROW
;

154 
	$tscii
 (
__c

__THROW
;

158 
	`__exy
 (
_tou
);

159 
	`__exy
 (
_tow
);

163 
	#__tobody
(
c
, 
f
, 
a
, 
gs
) \

164 (
__exnsi__
 \

165 ({ 
__s
; \

166 i( (
c
) > 1) \

168 i(
	`__but_cڡt_p
 (
c
)) \

170 
__c
 = (
c
); \

171 
__s
 = 
__c
 < -128 || __> 255 ? __: (
a
)[__c]; \

174 
__s
 = 
f
 
gs
; \

177 
__s
 = (
a
)[((
c
)]; \

178 
__s
; 
	}
}))

	)

180 #i!
defed
 
__NO_CTYPE


181 #ifde
__isy_f


182 
	$__isy_f
 (
num
)

183 
	$__isy_f
 (
pha
)

184 
	$__isy_f
 (
l
)

185 
	$__isy_f
 (
dig
)

186 
	$__isy_f
 (
low
)

187 
	$__isy_f
 (
gph
)

188 
	$__isy_f
 (
t
)

189 
	$__isy_f
 (
pun
)

190 
	$__isy_f
 (
a
)

191 
	$__isy_f
 (
u
)

192 
	$__isy_f
 (
xdig
)

193 #ifde
__USE_ISOC99


194 
	$__isy_f
 (
bnk
)

196 #i
defed
 
__isy


197 
	#ium
(
c

	`__isy
((c), 
_ISnum
)

	)

198 
	#iha
(
c

	`__isy
((c), 
_ISpha
)

	)

199 
	#isl
(
c

	`__isy
((c), 
_ISl
)

	)

200 
	#isdig
(
c

	`__isy
((c), 
_ISdig
)

	)

201 
	#iow
(
c

	`__isy
((c), 
_ISlow
)

	)

202 
	#isgph
(
c

	`__isy
((c), 
_ISgph
)

	)

203 
	#irt
(
c

	`__isy
((c), 
_ISt
)

	)

204 
	#iun
(
c

	`__isy
((c), 
_ISpun
)

	)

205 
	#isa
(
c

	`__isy
((c), 
_ISa
)

	)

206 
	#isu
(
c

	`__isy
((c), 
_ISu
)

	)

207 
	#isxdig
(
c

	`__isy
((c), 
_ISxdig
)

	)

208 #ifde
__USE_ISOC99


209 
	#isbnk
(
c

	`__isy
((c), 
_ISbnk
)

	)

213 #ifde
__USE_EXTERN_INLINES


214 
__ex_le
 

215 
	`__NTH
 (
	$tow
 (
__c
))

217  
__c
 >-128 && __< 256 ? (*
	`__y_tow_loc
 ())[__c] : __c;

218 
	}
}

220 
__ex_le
 

221 
__NTH
 (
	$tou
 (
__c
))

223  
__c
 >-128 && __< 256 ? (*
	`__y_tou_loc
 ())[__c] : __c;

224 
	}
}

227 #i
__GNUC__
 >2 && 
defed
 
__OPTIMIZE__
 && !defed 
__lulus


228 
	#tow
(
c

	`__tobody
 (c, 
tow
, *
	`__y_tow_loc
 (), (c))

	)

229 
	#tou
(
c

	`__tobody
 (c, 
tou
, *
	`__y_tou_loc
 (), (c))

	)

232 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


233 
	#iscii
(
c

	`__iscii
 (c)

	)

234 
	#tscii
(
c

	`__tscii
 (c)

	)

236 
	#_tow
(
c
(((*
	`__y_tow_loc
 ())[((c)])

	)

237 
	#_tou
(
c
(((*
	`__y_tou_loc
 ())[((c)])

	)

243 #ifde
__USE_XOPEN2K8


257 
	~<xlo.h
>

261 
	#__isy_l
(
c
, 
ty
, 
lo
) \

262 ((
lo
)->
__y_b
[((
c
)] & (
ty
)

	)

264 
	#__exy_l
(
me
) \

265 
	`me
 (, 
__lo_t

__THROW


	)

271 
__exy_l
 (
ium_l
);

272 
__exy_l
 (
iha_l
);

273 
__exy_l
 (
isl_l
);

274 
__exy_l
 (
isdig_l
);

275 
__exy_l
 (
iow_l
);

276 
__exy_l
 (
isgph_l
);

277 
__exy_l
 (
irt_l
);

278 
__exy_l
 (
iun_l
);

279 
__exy_l
 (
isa_l
);

280 
__exy_l
 (
isu_l
);

281 
__exy_l
 (
isxdig_l
);

283 
__exy_l
 (
isbnk_l
);

287 
	$__tow_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

288 
	$tow_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

291 
	$__tou_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

292 
	$tou_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

294 #i
__GNUC__
 >2 && 
defed
 
__OPTIMIZE__
 && !defed 
__lulus


295 
	#__tow_l
(
c
, 
lo
) \

296 
	`__tobody
 (
c
, 
__tow_l
, (
lo
)->
__y_tow
, (c,o))

	)

297 
	#__tou_l
(
c
, 
lo
) \

298 
	`__tobody
 (
c
, 
__tou_l
, (
lo
)->
__y_tou
, (c,o))

	)

299 
	#tow_l
(
c
, 
lo

	`__tow_l
 ((c), (lo))

	)

300 
	#tou_l
(
c
, 
lo

	`__tou_l
 ((c), (lo))

	)

304 #ide
__NO_CTYPE


305 
	#__ium_l
(
c
,
l

	`__isy_l
((c), 
_ISnum
, (l))

	)

306 
	#__iha_l
(
c
,
l

	`__isy_l
((c), 
_ISpha
, (l))

	)

307 
	#__isl_l
(
c
,
l

	`__isy_l
((c), 
_ISl
, (l))

	)

308 
	#__isdig_l
(
c
,
l

	`__isy_l
((c), 
_ISdig
, (l))

	)

309 
	#__iow_l
(
c
,
l

	`__isy_l
((c), 
_ISlow
, (l))

	)

310 
	#__isgph_l
(
c
,
l

	`__isy_l
((c), 
_ISgph
, (l))

	)

311 
	#__irt_l
(
c
,
l

	`__isy_l
((c), 
_ISt
, (l))

	)

312 
	#__iun_l
(
c
,
l

	`__isy_l
((c), 
_ISpun
, (l))

	)

313 
	#__isa_l
(
c
,
l

	`__isy_l
((c), 
_ISa
, (l))

	)

314 
	#__isu_l
(
c
,
l

	`__isy_l
((c), 
_ISu
, (l))

	)

315 
	#__isxdig_l
(
c
,
l

	`__isy_l
((c), 
_ISxdig
, (l))

	)

317 
	#__isbnk_l
(
c
,
l

	`__isy_l
((c), 
_ISbnk
, (l))

	)

319 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC


320 
	#__iscii_l
(
c
,
l
(), 
	`__iscii
 (c))

	)

321 
	#__tscii_l
(
c
,
l
(), 
	`__tscii
 (c))

	)

324 
	#ium_l
(
c
,
l

	`__ium_l
 ((c), (l))

	)

325 
	#iha_l
(
c
,
l

	`__iha_l
 ((c), (l))

	)

326 
	#isl_l
(
c
,
l

	`__isl_l
 ((c), (l))

	)

327 
	#isdig_l
(
c
,
l

	`__isdig_l
 ((c), (l))

	)

328 
	#iow_l
(
c
,
l

	`__iow_l
 ((c), (l))

	)

329 
	#isgph_l
(
c
,
l

	`__isgph_l
 ((c), (l))

	)

330 
	#irt_l
(
c
,
l

	`__irt_l
 ((c), (l))

	)

331 
	#iun_l
(
c
,
l

	`__iun_l
 ((c), (l))

	)

332 
	#isa_l
(
c
,
l

	`__isa_l
 ((c), (l))

	)

333 
	#isu_l
(
c
,
l

	`__isu_l
 ((c), (l))

	)

334 
	#isxdig_l
(
c
,
l

	`__isxdig_l
 ((c), (l))

	)

336 
	#isbnk_l
(
c
,
l

	`__isbnk_l
 ((c), (l))

	)

338 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC


339 
	#iscii_l
(
c
,
l

	`__iscii_l
 ((c), (l))

	)

340 
	#tscii_l
(
c
,
l

	`__tscii_l
 ((c), (l))

	)

347 
__END_DECLS


	@/usr/include/dirent.h

22 #idef 
_DIRENT_H


23 
	#_DIRENT_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


29 
	~<bs/tys.h
>

31 #ifde
__USE_XOPEN


32 #ide
__o_t_defed


33 #ide
__USE_FILE_OFFSET64


34 
__o_t
 
	to_t
;

36 
__o64_t
 
	to_t
;

38 
	#__o_t_defed


	)

40 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__o64_t_defed


41 
__o64_t
 
	to64_t
;

42 
	#__o64_t_defed


	)

61 
	~<bs/dt.h
>

63 #i(
defed
 
__USE_BSD
 || defed 
__USE_MISC
&& !defed 
d_fo


64 
	#d_o
 
d_fo


	)

81 #ifde
_DIRENT_HAVE_D_NAMLEN


82 
	#_D_EXACT_NAMLEN
(
d
((d)->
d_mn
)

	)

83 
	#_D_ALLOC_NAMLEN
(
d
(
	`_D_EXACT_NAMLEN
 (d+ 1)

	)

85 
	#_D_EXACT_NAMLEN
(
d
(
	`
 ((d)->
d_me
))

	)

86 #ifde
_DIRENT_HAVE_D_RECLEN


87 
	#_D_ALLOC_NAMLEN
(
d
(((*(d+ (d)->
d_
- &(d)->
d_me
[0])

	)

89 
	#_D_ALLOC_NAMLEN
(
d
( (d)->
d_me
 > 1 ?  (d)->d_name : \

90 
	`_D_EXACT_NAMLEN
 (
d
+ 1)

	)

95 #ifde
__USE_BSD


99 
	mDT_UNKNOWN
 = 0,

100 
	#DT_UNKNOWN
 
DT_UNKNOWN


	)

101 
	mDT_FIFO
 = 1,

102 
	#DT_FIFO
 
DT_FIFO


	)

103 
	mDT_CHR
 = 2,

104 
	#DT_CHR
 
DT_CHR


	)

105 
	mDT_DIR
 = 4,

106 
	#DT_DIR
 
DT_DIR


	)

107 
	mDT_BLK
 = 6,

108 
	#DT_BLK
 
DT_BLK


	)

109 
	mDT_REG
 = 8,

110 
	#DT_REG
 
DT_REG


	)

111 
	mDT_LNK
 = 10,

112 
	#DT_LNK
 
DT_LNK


	)

113 
	mDT_SOCK
 = 12,

114 
	#DT_SOCK
 
DT_SOCK


	)

115 
	mDT_WHT
 = 14

116 
	#DT_WHT
 
DT_WHT


	)

120 
	#IFTODT
(
mode
(((mode& 0170000>> 12)

	)

121 
	#DTTOIF
(
dty
((dty<< 12)

	)

127 
__dam
 
	tDIR
;

134 
DIR
 *
	$ݒd
 (cڡ *
__me

	`__nnu
 ((1));

136 #ifde
__USE_XOPEN2K8


141 
DIR
 *
	`fdݒd
 (
__fd
);

149 
	$od
 (
DIR
 *
__dp

	`__nnu
 ((1));

161 #ide
__USE_FILE_OFFSET64


162 
dt
 *
	$add
 (
DIR
 *
__dp

	`__nnu
 ((1));

164 #ifde
__REDIRECT


165 
dt
 *
	`__REDIRECT
 (
add
, (
DIR
 *
__dp
), 
add64
)

166 
	`__nnu
 ((1));

168 
	#add
 
add64


	)

172 #ifde
__USE_LARGEFILE64


173 
dt64
 *
	$add64
 (
DIR
 *
__dp

	`__nnu
 ((1));

176 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


182 #ide
__USE_FILE_OFFSET64


183 
	$add_r
 (
DIR
 *
__ri
 
__dp
,

184 
dt
 *
__ri
 
__y
,

185 
dt
 **
__ri
 
__su
)

186 
	`__nnu
 ((1, 2, 3));

188 #ifde
__REDIRECT


189 
	`__REDIRECT
 (
add_r
,

190 (
DIR
 *
__ri
 
__dp
,

191 
dt
 *
__ri
 
__y
,

192 
dt
 **
__ri
 
__su
),

193 
add64_r

	`__nnu
 ((1, 2, 3));

195 
	#add_r
 
add64_r


	)

199 #ifde
__USE_LARGEFILE64


200 
	$add64_r
 (
DIR
 *
__ri
 
__dp
,

201 
dt64
 *
__ri
 
__y
,

202 
dt64
 **
__ri
 
__su
)

203 
	`__nnu
 ((1, 2, 3));

208 
	$wdd
 (
DIR
 *
__dp

__THROW
 
	`__nnu
 ((1));

210 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


211 
	~<bs/tys.h
>

214 
	$ekd
 (
DIR
 *
__dp
, 
__pos

__THROW
 
	`__nnu
 ((1));

217 
	$d
 (
DIR
 *
__dp

__THROW
 
	`__nnu
 ((1));

220 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN2K8


223 
	$dfd
 (
DIR
 *
__dp

__THROW
 
	`__nnu
 ((1));

225 #i
defed
 
__OPTIMIZE__
 && defed 
_DIR_dfd


226 
	#dfd
(
dp

	`_DIR_dfd
 (dp)

	)

229 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC


230 #ide
MAXNAMLEN


232 
	~<bs/posix1_lim.h
>

235 #ifde
NAME_MAX


236 
	#MAXNAMLEN
 
NAME_MAX


	)

238 
	#MAXNAMLEN
 255

	)

243 
	#__ed_size_t


	)

244 
	~<ddef.h
>

253 #ide
__USE_FILE_OFFSET64


254 
	`snd
 (cڡ *
__ri
 
__d
,

255 
dt
 ***
__ri
 
__mi
,

256 (*
__
(cڡ 
dt
 *),

257 (*
__cmp
(cڡ 
dt
 **,

258 cڡ 
dt
 **))

259 
	`__nnu
 ((1, 2));

261 #ifde
__REDIRECT


262 
	`__REDIRECT
 (
snd
,

263 (cڡ *
__ri
 
__d
,

264 
dt
 ***
__ri
 
__mi
,

265 (*
__
(cڡ 
dt
 *),

266 (*
__cmp
(cڡ 
dt
 **,

267 cڡ 
dt
 **)),

268 
snd64

	`__nnu
 ((1, 2));

270 
	#snd
 
snd64


	)

274 #i
defed
 
__USE_GNU
 && defed 
__USE_LARGEFILE64


277 
	`snd64
 (cڡ *
__ri
 
__d
,

278 
dt64
 ***
__ri
 
__mi
,

279 (*
__
(cڡ 
dt64
 *),

280 (*
__cmp
(cڡ 
dt64
 **,

281 cڡ 
dt64
 **))

282 
	`__nnu
 ((1, 2));

285 #ifde
__USE_GNU


291 #ide
__USE_FILE_OFFSET64


292 
	`snd
 (
__dfd
, cڡ *
__ri
 
__d
,

293 
dt
 ***
__ri
 
__mi
,

294 (*
__
(cڡ 
dt
 *),

295 (*
__cmp
(cڡ 
dt
 **,

296 cڡ 
dt
 **))

297 
	`__nnu
 ((2, 3));

299 #ifde
__REDIRECT


300 
	`__REDIRECT
 (
snd
,

301 (
__dfd
, cڡ *
__ri
 
__d
,

302 
dt
 ***
__ri
 
__mi
,

303 (*
__
(cڡ 
dt
 *),

304 (*
__cmp
(cڡ 
dt
 **,

305 cڡ 
dt
 **)),

306 
snd64

	`__nnu
 ((2, 3));

308 
	#snd
 
snd64


	)

314 
	`snd64
 (
__dfd
, cڡ *
__ri
 
__d
,

315 
dt64
 ***
__ri
 
__mi
,

316 (*
__
(cڡ 
dt64
 *),

317 (*
__cmp
(cڡ 
dt64
 **,

318 cڡ 
dt64
 **))

319 
	`__nnu
 ((2, 3));

323 #ide
__USE_FILE_OFFSET64


324 
	$phast
 (cڡ 
dt
 **
__e1
,

325 cڡ 
dt
 **
__e2
)

326 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

328 #ifde
__REDIRECT


329 
	`__REDIRECT_NTH
 (
phast
,

330 (cڡ 
dt
 **
__e1
,

331 cڡ 
dt
 **
__e2
),

332 
phast64

__ibu_pu__
 
	`__nnu
 ((1, 2));

334 
	#phast
 
phast64


	)

338 #i
defed
 
__USE_GNU
 && defed 
__USE_LARGEFILE64


339 
	$phast64
 (cڡ 
dt64
 **
__e1
,

340 cڡ 
dt64
 **
__e2
)

341 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

346 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC


351 #ide
__USE_FILE_OFFSET64


352 
__ssize_t
 
	$gds
 (
__fd
, *
__ri
 
__buf
,

353 
size_t
 
__nbys
,

354 
__off_t
 *
__ri
 
__bap
)

355 
__THROW
 
	`__nnu
 ((2, 4));

357 #ifde
__REDIRECT


358 
__ssize_t
 
	`__REDIRECT_NTH
 (
gds
,

359 (
__fd
, *
__ri
 
__buf
,

360 
size_t
 
__nbys
,

361 
__off64_t
 *
__ri
 
__bap
),

362 
gds64

	`__nnu
 ((2, 4));

364 
	#gds
 
gds64


	)

368 #ifde
__USE_LARGEFILE64


369 
__ssize_t
 
	$gds64
 (
__fd
, *
__ri
 
__buf
,

370 
size_t
 
__nbys
,

371 
__off64_t
 *
__ri
 
__bap
)

372 
__THROW
 
	`__nnu
 ((2, 4));

376 #ifde
__USE_GNU


378 #ide
__USE_FILE_OFFSET64


379 
	$vsist
 (cڡ 
dt
 **
__e1
,

380 cڡ 
dt
 **
__e2
)

381 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

383 #ifde
__REDIRECT


384 
	`__REDIRECT_NTH
 (
vsist
,

385 (cڡ 
dt
 **
__e1
,

386 cڡ 
dt
 **
__e2
),

387 
vsist64
)

388 
__ibu_pu__
 
	`__nnu
 ((1, 2));

390 
	#vsist
 
vsist64


	)

394 #ifde
__USE_LARGEFILE64


395 
	$vsist64
 (cڡ 
dt64
 **
__e1
,

396 cڡ 
dt64
 **
__e2
)

397 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

401 
__END_DECLS


	@/usr/include/dlfcn.h

19 #idef 
_DLFCN_H


20 
	#_DLFCN_H
 1

	)

22 
	~<us.h
>

23 
	#__ed_size_t


	)

24 
	~<ddef.h
>

27 
	~<bs/dlf.h
>

30 #ifde
__USE_GNU


35 
	#RTLD_NEXT
 ((*-1l)

	)

40 
	#RTLD_DEFAULT
 ((*0)

	)

44 
	tLmid_t
;

47 
	#LM_ID_BASE
 0

	)

48 
	#LM_ID_NEWLM
 -1

	)

52 
__BEGIN_DECLS


56 *
	$dlݒ
 (cڡ *
__fe
, 
__mode

__THROWNL
;

60 
	$dlo
 (*
__hd

__THROWNL
 
	`__nnu
 ((1));

64 *
	$dlsym
 (*
__ri
 
__hd
,

65 cڡ *
__ri
 
__me

__THROW
 
	`__nnu
 ((2));

67 #ifde
__USE_GNU


69 *
	$dlmݒ
 (
Lmid_t
 
__nsid
, cڡ *
__fe
, 
__mode

__THROWNL
;

73 *
	$dlvsym
 (*
__ri
 
__hd
,

74 cڡ *
__ri
 
__me
,

75 cڡ *
__ri
 
__vsi
)

76 
__THROW
 
	`__nnu
 ((2, 3));

82 *
	$d˼
 (
__THROW
;

85 #ifde
__USE_GNU


90 cڡ *
dli_ame
;

91 *
dli_fba
;

92 cڡ *
dli_ame
;

93 *
dli_ddr
;

94 } 
	tDl_fo
;

98 
	$dddr
 (cڡ *
__addss
, 
Dl_fo
 *
__fo
)

99 
__THROW
 
	`__nnu
 ((2));

102 
	$dddr1
 (cڡ *
__addss
, 
Dl_fo
 *
__fo
,

103 **
__exa_fo
, 
__ags

__THROW
 
	`__nnu
 ((2));

111 
RTLD_DL_SYMENT
 = 1,

114 
RTLD_DL_LINKMAP
 = 2

123 
	$dlfo
 (*
__ri
 
__hd
,

124 
__que
, *
__ri
 
__g
)

125 
__THROW
 
	`__nnu
 ((1, 3));

131 
RTLD_DI_LMID
 = 1,

135 
RTLD_DI_LINKMAP
 = 2,

137 
RTLD_DI_CONFIGADDR
 = 3,

144 
RTLD_DI_SERINFO
 = 4,

145 
RTLD_DI_SERINFOSIZE
 = 5,

149 
RTLD_DI_ORIGIN
 = 6,

151 
RTLD_DI_PROFILENAME
 = 7,

152 
RTLD_DI_PROFILEOUT
 = 8,

157 
RTLD_DI_TLS_MODID
 = 9,

163 
RTLD_DI_TLS_DATA
 = 10,

165 
RTLD_DI_MAX
 = 10

173 *
dls_me
;

174 
dls_ags
;

175 } 
	tDl_h
;

181 
size_t
 
dls_size
;

182 
dls_t
;

183 
Dl_h
 
dls_h
[1];

184 } 
	tDl_rfo
;

188 
__END_DECLS


	@/usr/include/errno.h

22 #idef 
_ERRNO_H


26 #idef 
__ed_Emh


27 
	#_ERRNO_H
 1

	)

28 
	~<us.h
>

31 
	g__BEGIN_DECLS


35 
	~<bs/o.h
>

36 #unde
__ed_Emh


38 #ifdef 
_ERRNO_H


45 #idef 
o


46 
o
;

49 #ifde
__USE_GNU


54 *
ogm_voti_me
, *
ogm_voti_sht_me
;

58 
	g__END_DECLS


66 #i
defed
 
__USE_GNU
 || defed 
__ed_r_t


67 #ide
__r_t_defed


68 
	tr_t
;

69 
	#__r_t_defed
 1

	)

71 #unde
__ed_r_t


	@/usr/include/error.h

19 #ide
_ERROR_H


20 
	#_ERROR_H
 1

	)

22 
	~<us.h
>

25 
__BEGIN_DECLS


31 
	$r
 (
__us
, 
__um
, cڡ *
__fm
, ...)

32 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

34 
	$r__le
 (
__us
, 
__um
, cڡ *
__ame
,

35 
__lo
, cڡ *
__fm
, ...)

36 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 5, 6)));

41 (*
r_t_ogme
) ();

44 
r_mesge_cou
;

48 
r_e_r_le
;

51 #i
defed
 
__ex_ways_le
 && defed 
__va_g_ck


52 
	~<bs/r.h
>

55 
__END_DECLS


	@/usr/include/fcntl.h

22 #idef 
_FCNTL_H


23 
	#_FCNTL_H
 1

	)

25 
	~<us.h
>

28 
	g__BEGIN_DECLS


31 
	~<bs/tys.h
>

35 
	~<bs/f.h
>

40 #ide
__mode_t_defed


41 
__mode_t
 
	tmode_t
;

42 
	#__mode_t_defed


	)

45 #ide
__off_t_defed


46 #ide
__USE_FILE_OFFSET64


47 
__off_t
 
	toff_t
;

49 
__off64_t
 
	toff_t
;

51 
	#__off_t_defed


	)

54 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


55 
__off64_t
 
	toff64_t
;

56 
	#__off64_t_defed


	)

59 #ide
__pid_t_defed


60 
__pid_t
 
	tpid_t
;

61 
	#__pid_t_defed


	)

65 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


66 
	#__ed_timeec


	)

67 
	~<time.h
>

68 
	~<bs/.h
>

70 
	#S_IFMT
 
__S_IFMT


	)

71 
	#S_IFDIR
 
__S_IFDIR


	)

72 
	#S_IFCHR
 
__S_IFCHR


	)

73 
	#S_IFBLK
 
__S_IFBLK


	)

74 
	#S_IFREG
 
__S_IFREG


	)

75 #ifde
__S_IFIFO


76 
	#S_IFIFO
 
__S_IFIFO


	)

78 #ifde
__S_IFLNK


79 
	#S_IFLNK
 
__S_IFLNK


	)

81 #i(
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8
&& defed 
__S_IFSOCK


82 
	#S_IFSOCK
 
__S_IFSOCK


	)

87 
	#S_ISUID
 
__S_ISUID


	)

88 
	#S_ISGID
 
__S_ISGID


	)

90 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


92 
	#S_ISVTX
 
__S_ISVTX


	)

95 
	#S_IRUSR
 
__S_IREAD


	)

96 
	#S_IWUSR
 
__S_IWRITE


	)

97 
	#S_IXUSR
 
__S_IEXEC


	)

99 
	#S_IRWXU
 (
__S_IREAD
|
__S_IWRITE
|
__S_IEXEC
)

	)

101 
	#S_IRGRP
 (
S_IRUSR
 >> 3

	)

102 
	#S_IWGRP
 (
S_IWUSR
 >> 3

	)

103 
	#S_IXGRP
 (
S_IXUSR
 >> 3

	)

105 
	#S_IRWXG
 (
S_IRWXU
 >> 3)

	)

107 
	#S_IROTH
 (
S_IRGRP
 >> 3

	)

108 
	#S_IWOTH
 (
S_IWGRP
 >> 3

	)

109 
	#S_IXOTH
 (
S_IXGRP
 >> 3

	)

111 
	#S_IRWXO
 (
S_IRWXG
 >> 3)

	)

114 #ifdef 
__USE_MISC


115 #ide
R_OK


118 
	#R_OK
 4

	)

119 
	#W_OK
 2

	)

120 
	#X_OK
 1

	)

121 
	#F_OK
 0

	)

126 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


127 
	#SEEK_SET
 0

	)

128 
	#SEEK_CUR
 1

	)

129 
	#SEEK_END
 2

	)

137 
f
 (
__fd
, 
__cmd
, ...);

145 #ide
__USE_FILE_OFFSET64


146 
	$ݒ
 (cڡ *
__fe
, 
__oag
, ...
	`__nnu
 ((1));

148 #ifde
__REDIRECT


149 
	`__REDIRECT
 (
ݒ
, (cڡ *
__fe
, 
__oag
, ...), 
ݒ64
)

150 
	`__nnu
 ((1));

152 
	#ݒ
 
ݒ64


	)

155 #ifde
__USE_LARGEFILE64


156 
	$ݒ64
 (cڡ *
__fe
, 
__oag
, ...
	`__nnu
 ((1));

159 #ifde
__USE_ATFILE


169 #ide
__USE_FILE_OFFSET64


170 
	$ݒ
 (
__fd
, cڡ *
__fe
, 
__oag
, ...)

171 
	`__nnu
 ((2));

173 #ifde
__REDIRECT


174 
	`__REDIRECT
 (
ݒ
, (
__fd
, cڡ *
__fe
, 
__oag
,

175 ...), 
ݒ64

	`__nnu
 ((2));

177 
	#ݒ
 
ݒ64


	)

180 #ifde
__USE_LARGEFILE64


181 
	$ݒ64
 (
__fd
, cڡ *
__fe
, 
__oag
, ...)

182 
	`__nnu
 ((2));

191 #ide
__USE_FILE_OFFSET64


192 
	$t
 (cڡ *
__fe
, 
mode_t
 
__mode

	`__nnu
 ((1));

194 #ifde
__REDIRECT


195 
	`__REDIRECT
 (
t
, (cڡ *
__fe
, 
mode_t
 
__mode
),

196 
t64

	`__nnu
 ((1));

198 
	#t
 
t64


	)

201 #ifde
__USE_LARGEFILE64


202 
	$t64
 (cڡ *
__fe
, 
mode_t
 
__mode

	`__nnu
 ((1));

205 #i!
defed
 
F_LOCK
 && (defed 
__USE_MISC
 || (defed 
__USE_XOPEN_EXTENDED
 \

206 && !
defed
 
__USE_POSIX
))

215 
	#F_ULOCK
 0

	)

216 
	#F_LOCK
 1

	)

217 
	#F_TLOCK
 2

	)

218 
	#F_TEST
 3

	)

220 #ide
__USE_FILE_OFFSET64


221 
	`lockf
 (
__fd
, 
__cmd
, 
off_t
 
__n
);

223 #ifde
__REDIRECT


224 
	`__REDIRECT
 (
lockf
, (
__fd
, 
__cmd
, 
__off64_t
 
__n
), 
lockf64
);

226 
	#lockf
 
lockf64


	)

229 #ifde
__USE_LARGEFILE64


230 
	`lockf64
 (
__fd
, 
__cmd
, 
off64_t
 
__n
);

234 #ifde
__USE_XOPEN2K


237 #ide
__USE_FILE_OFFSET64


238 
	$posix_dvi
 (
__fd
, 
off_t
 
__offt
, off_
__n
,

239 
__advi

__THROW
;

241 #ifde
__REDIRECT_NTH


242 
	`__REDIRECT_NTH
 (
posix_dvi
, (
__fd
, 
__off64_t
 
__offt
,

243 
__off64_t
 
__n
, 
__advi
),

244 
posix_dvi64
);

246 
	#posix_dvi
 
posix_dvi64


	)

249 #ifde
__USE_LARGEFILE64


250 
	$posix_dvi64
 (
__fd
, 
off64_t
 
__offt
, off64_
__n
,

251 
__advi

__THROW
;

259 #ide
__USE_FILE_OFFSET64


260 
	`posix_o
 (
__fd
, 
off_t
 
__offt
, off_
__n
);

262 #ifde
__REDIRECT


263 
	`__REDIRECT
 (
posix_o
, (
__fd
, 
__off64_t
 
__offt
,

264 
__off64_t
 
__n
),

265 
posix_o64
);

267 
	#posix_o
 
posix_o64


	)

270 #ifde
__USE_LARGEFILE64


271 
	`posix_o64
 (
__fd
, 
off64_t
 
__offt
, off64_
__n
);

277 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi
 \

278 && 
defed
 
__va_g_ck_n


279 
	~<bs/f2.h
>

282 
__END_DECLS


	@/usr/include/fts.h

32 #idef 
_FTS_H


33 
	#_FTS_H
 1

	)

35 
	~<us.h
>

36 
	~<sys/tys.h
>

40 #ifde
__USE_FILE_OFFSET64


46 
_
 *
	ms_cur
;

47 
_
 *
	ms_chd
;

48 
_
 **
	ms_y
;

49 
dev_t
 
	ms_dev
;

50 *
	ms_th
;

51 
	ms_rfd
;

52 
	ms_thn
;

53 
	ms_nems
;

54 (*
	ms_comr
) (const *, const *);

56 
	#FTS_COMFOLLOW
 0x0001

	)

57 
	#FTS_LOGICAL
 0x0002

	)

58 
	#FTS_NOCHDIR
 0x0004

	)

59 
	#FTS_NOSTAT
 0x0008

	)

60 
	#FTS_PHYSICAL
 0x0010

	)

61 
	#FTS_SEEDOT
 0x0020

	)

62 
	#FTS_XDEV
 0x0040

	)

63 
	#FTS_WHITEOUT
 0x0080

	)

64 
	#FTS_OPTIONMASK
 0x00f

	)

66 
	#FTS_NAMEONLY
 0x0100

	)

67 
	#FTS_STOP
 0x0200

	)

68 
	ms_tis
;

69 } 
	tFTS
;

71 
	s_
 {

72 
_
 *
	ms_cye
;

73 
_
 *
	ms_
;

74 
_
 *
	ms_lk
;

75 
	ms_numb
;

76 *
	ms_por
;

77 *
	ms_ach
;

78 *
	ms_th
;

79 
	ms_o
;

80 
	ms_symfd
;

81 
u_sht
 
	ms_thn
;

82 
u_sht
 
	ms_m
;

84 
o_t
 
	ms_o
;

85 
dev_t
 
	ms_dev
;

86 
ƚk_t
 
	ms_ƚk
;

88 
	#FTS_ROOTPARENTLEVEL
 -1

	)

89 
	#FTS_ROOTLEVEL
 0

	)

90 
	ms_v
;

92 
	#FTS_D
 1

	)

93 
	#FTS_DC
 2

	)

94 
	#FTS_DEFAULT
 3

	)

95 
	#FTS_DNR
 4

	)

96 
	#FTS_DOT
 5

	)

97 
	#FTS_DP
 6

	)

98 
	#FTS_ERR
 7

	)

99 
	#FTS_F
 8

	)

100 
	#FTS_INIT
 9

	)

101 
	#FTS_NS
 10

	)

102 
	#FTS_NSOK
 11

	)

103 
	#FTS_SL
 12

	)

104 
	#FTS_SLNONE
 13

	)

105 
	#FTS_W
 14

	)

106 
u_sht
 
	ms_fo
;

108 
	#FTS_DONTCHDIR
 0x01

	)

109 
	#FTS_SYMFOLLOW
 0x02

	)

110 
u_sht
 
	ms_ags
;

112 
	#FTS_AGAIN
 1

	)

113 
	#FTS_FOLLOW
 2

	)

114 
	#FTS_NOINSTR
 3

	)

115 
	#FTS_SKIP
 4

	)

116 
u_sht
 
	ms_r
;

118 

 *
	ms_p
;

119 
	ms_me
[1];

120 } 
	tFTSENT
;

122 
__BEGIN_DECLS


123 
FTSENT
 *
s_chdn
 (
FTS
 *, );

124 
s_o
 (
FTS
 *);

125 
FTS
 *
s_ݒ
 (* const *, ,

126 (*)(cڡ 
FTSENT
 **, const FTSENT **));

127 
FTSENT
 *
	`s_ad
 (
FTS
 *);

128 
	$s_t
 (
FTS
 *, 
FTSENT
 *, 
__THROW
;

129 
__END_DECLS


	@/usr/include/iconv.h

18 #ide
_ICONV_H


19 
	#_ICONV_H
 1

	)

21 
	~<us.h
>

22 
	#__ed_size_t


	)

23 
	~<ddef.h
>

26 
__BEGIN_DECLS


29 *
	ticv_t
;

37 
icv_t
 
icv_ݒ
 (cڡ *
__tocode
, cڡ *
__omcode
);

42 
size_t
 
icv
 (
icv_t
 
__cd
, **
__ri
 
__buf
,

43 
size_t
 *
__ri
 
__bye
,

44 **
__ri
 
__outbuf
,

45 
size_t
 *
__ri
 
__outbye
);

51 
icv_o
 (
icv_t
 
__cd
);

53 
	g__END_DECLS


	@/usr/include/libgen.h

18 #ide
_LIBGEN_H


19 
	#_LIBGEN_H
 1

	)

21 
	~<us.h
>

23 
__BEGIN_DECLS


26 *
	$dme
 (*
__th

__THROW
;

34 *
	$__xpg_bame
 (*
__th

__THROW
;

35 
	#bame
 
__xpg_bame


	)

37 
__END_DECLS


	@/usr/include/limits.h

22 #ide
_LIBC_LIMITS_H_


23 
	#_LIBC_LIMITS_H_
 1

	)

25 
	~<us.h
>

31 
	#MB_LEN_MAX
 16

	)

36 #i!
defed
 
__GNUC__
 || __GNUC__ < 2

41 #ide
_LIMITS_H


42 
	#_LIMITS_H
 1

	)

44 
	~<bs/wdsize.h
>

53 
	#CHAR_BIT
 8

	)

56 
	#SCHAR_MIN
 (-128)

	)

57 
	#SCHAR_MAX
 127

	)

60 
	#UCHAR_MAX
 255

	)

63 #ifde
__CHAR_UNSIGNED__


64 
	#CHAR_MIN
 0

	)

65 
	#CHAR_MAX
 
UCHAR_MAX


	)

67 
	#CHAR_MIN
 
SCHAR_MIN


	)

68 
	#CHAR_MAX
 
SCHAR_MAX


	)

72 
	#SHRT_MIN
 (-32768)

	)

73 
	#SHRT_MAX
 32767

	)

76 
	#USHRT_MAX
 65535

	)

79 
	#INT_MIN
 (-
INT_MAX
 - 1)

	)

80 
	#INT_MAX
 2147483647

	)

83 
	#UINT_MAX
 4294967295U

	)

86 #i
__WORDSIZE
 == 64

87 
	#LONG_MAX
 9223372036854775807L

	)

89 
	#LONG_MAX
 2147483647L

	)

91 
	#LONG_MIN
 (-
LONG_MAX
 - 1L)

	)

94 #i
__WORDSIZE
 == 64

95 
	#ULONG_MAX
 18446744073709551615UL

	)

97 
	#ULONG_MAX
 4294967295UL

	)

100 #ifde
__USE_ISOC99


103 
	#LLONG_MAX
 9223372036854775807LL

	)

104 
	#LLONG_MIN
 (-
LLONG_MAX
 - 1LL)

	)

107 
	#ULLONG_MAX
 18446744073709551615ULL

	)

121 #i
defed
 
__GNUC__
 && !defed 
_GCC_LIMITS_H_


123 #ude_x<
lims
.
h
>

129 #i
defed
 
__USE_ISOC99
 && defed 
__GNUC__


130 #ide
LLONG_MIN


131 
	#LLONG_MIN
 (-
LLONG_MAX
-1)

	)

133 #ide
LLONG_MAX


134 
	#LLONG_MAX
 
__LONG_LONG_MAX__


	)

136 #ide
ULLONG_MAX


137 
	#ULLONG_MAX
 (
LLONG_MAX
 * 2ULL + 1)

	)

141 #ifdef 
__USE_POSIX


143 
	~<bs/posix1_lim.h
>

146 #ifdef 
__USE_POSIX2


147 
	~<bs/posix2_lim.h
>

150 #ifdef 
__USE_XOPEN


151 
	~<bs/xݒ_lim.h
>

	@/usr/include/malloc.h

19 #ide
_MALLOC_H


20 
	#_MALLOC_H
 1

	)

22 
	~<us.h
>

23 
	~<ddef.h
>

24 
	~<dio.h
>

26 #ifde
_LIBC


27 
	#__MALLOC_HOOK_VOLATILE


	)

28 
	#__MALLOC_DEPRECATED


	)

30 
	#__MALLOC_HOOK_VOLATILE
 vީe

	)

31 
	#__MALLOC_DEPRECATED
 
__ibu_dd__


	)

35 
__BEGIN_DECLS


38 *
	$mloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

41 *
	$oc
 (
size_t
 
__nmemb
, size_
__size
)

42 
__THROW
 
__ibu_mloc__
 
__wur
;

49 *
	$loc
 (*
__r
, 
size_t
 
__size
)

50 
__THROW
 
__ibu_wn_unud_su__
;

53 
	$
 (*
__r

__THROW
;

56 
	$c
 (*
__r

__THROW
;

59 *
	$memign
 (
size_t
 
__ignmt
, size_
__size
)

60 
__THROW
 
__ibu_mloc__
 
__wur
;

63 *
	$vloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

67 *
	$pvloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

71 *(*
__mece
(
rdiff_t
 
__size
);

74 *
	$__deu_mece
 (
rdiff_t
 
__size
)

75 
__THROW
 
__ibu_mloc__
;

79 
	smlfo


81 
a
;

82 
dblks
;

83 
smblks
;

84 
hblks
;

85 
hblkhd
;

86 
usmblks
;

87 
fsmblks
;

88 
udblks
;

89 
fdblks
;

90 
kpco
;

94 
mlfo
 
	$mlfo
 (
__THROW
;

97 #ide
M_MXFAST


98 
	#M_MXFAST
 1

	)

100 #ide
M_NLBLKS


101 
	#M_NLBLKS
 2

	)

103 #ide
M_GRAIN


104 
	#M_GRAIN
 3

	)

106 #ide
M_KEEP


107 
	#M_KEEP
 4

	)

111 
	#M_TRIM_THRESHOLD
 -1

	)

112 
	#M_TOP_PAD
 -2

	)

113 
	#M_MMAP_THRESHOLD
 -3

	)

114 
	#M_MMAP_MAX
 -4

	)

115 
	#M_CHECK_ACTION
 -5

	)

116 
	#M_PERTURB
 -6

	)

117 
	#M_ARENA_TEST
 -7

	)

118 
	#M_ARENA_MAX
 -8

	)

121 
	$mlt
 (
__m
, 
__v

__THROW
;

125 
	$mloc_im
 (
size_t
 
__d

__THROW
;

129 
size_t
 
	$mloc_ub_size
 (*
__r

__THROW
;

132 
	$mloc_s
 (
__THROW
;

135 
	$mloc_fo
 (
__tis
, 
FILE
 *
__

__THROW
;

138 *
	$mloc_g_e
 (
__THROW
;

142 
	$mloc_t_e
 (*
__r

__THROW
;

147 (*
__MALLOC_HOOK_VOLATILE
 
__mloc_lize_hook
) ()

148 
__MALLOC_DEPRECATED
;

150 (*
__MALLOC_HOOK_VOLATILE
 
___hook
(*
__r
,

152 
__MALLOC_DEPRECATED
;

153 *(*
__MALLOC_HOOK_VOLATILE
 
__mloc_hook
)(
size_t
 
__size
,

155 
__MALLOC_DEPRECATED
;

156 *(*
__MALLOC_HOOK_VOLATILE
 
__loc_hook
)(*
__r
,

157 
size_t
 
__size
,

159 
__MALLOC_DEPRECATED
;

160 *(*
__MALLOC_HOOK_VOLATILE
 
__memign_hook
)(
size_t
 
__ignmt
,

161 
size_t
 
__size
,

163 
__MALLOC_DEPRECATED
;

164 (*
__MALLOC_HOOK_VOLATILE
 
__a_mece_hook
) ();

167 
	$__mloc_check_
 (
__THROW
 
__MALLOC_DEPRECATED
;

170 
__END_DECLS


	@/usr/include/memory.h

22 #idef 
_MEMORY_H


23 
	#_MEMORY_H
 1

	)

25 
	~<us.h
>

28 #idef 
_STRING_H


29 
	~<rg.h
>

	@/usr/include/poll.h

1 
	~<sys/pl.h
>

	@/usr/include/pthread.h

18 #ide
_PTHREAD_H


19 
	#_PTHREAD_H
 1

	)

21 
	~<us.h
>

22 
	~<dn.h
>

23 
	~<sched.h
>

24 
	~<time.h
>

26 
	~<bs/hadtys.h
>

27 
	~<bs/tjmp.h
>

28 
	~<bs/wdsize.h
>

34 
	mPTHREAD_CREATE_JOINABLE
,

35 
	#PTHREAD_CREATE_JOINABLE
 
PTHREAD_CREATE_JOINABLE


	)

36 
	mPTHREAD_CREATE_DETACHED


37 
	#PTHREAD_CREATE_DETACHED
 
PTHREAD_CREATE_DETACHED


	)

44 
	mPTHREAD_MUTEX_TIMED_NP
,

45 
	mPTHREAD_MUTEX_RECURSIVE_NP
,

46 
	mPTHREAD_MUTEX_ERRORCHECK_NP
,

47 
	mPTHREAD_MUTEX_ADAPTIVE_NP


48 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


50 
	mPTHREAD_MUTEX_NORMAL
 = 
PTHREAD_MUTEX_TIMED_NP
,

51 
	mPTHREAD_MUTEX_RECURSIVE
 = 
PTHREAD_MUTEX_RECURSIVE_NP
,

52 
	mPTHREAD_MUTEX_ERRORCHECK
 = 
PTHREAD_MUTEX_ERRORCHECK_NP
,

53 
	mPTHREAD_MUTEX_DEFAULT
 = 
PTHREAD_MUTEX_NORMAL


55 #ifde
__USE_GNU


57 , 
	mPTHREAD_MUTEX_FAST_NP
 = 
PTHREAD_MUTEX_TIMED_NP


62 #ifde
__USE_XOPEN2K


66 
	mPTHREAD_MUTEX_STALLED
,

67 
	mPTHREAD_MUTEX_STALLED_NP
 = 
PTHREAD_MUTEX_STALLED
,

68 
	mPTHREAD_MUTEX_ROBUST
,

69 
	mPTHREAD_MUTEX_ROBUST_NP
 = 
PTHREAD_MUTEX_ROBUST


74 #i
defed
 
__USE_POSIX199506
 || defed 
__USE_UNIX98


78 
	mPTHREAD_PRIO_NONE
,

79 
	mPTHREAD_PRIO_INHERIT
,

80 
	mPTHREAD_PRIO_PROTECT


86 #i
__PTHREAD_MUTEX_HAVE_ELISION
 == 1

87 
	#__PTHREAD_SPINS
 0, 0

	)

88 #i
__PTHREAD_MUTEX_HAVE_ELISION
 == 2

89 
	#__PTHREAD_SPINS
 { 0, 0 }

	)

91 
	#__PTHREAD_SPINS
 0

	)

94 #ifde
__PTHREAD_MUTEX_HAVE_PREV


95 
	#PTHREAD_MUTEX_INITIALIZER
 \

96 { { 0, 0, 0, 0, 0, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

97 #ifde
__USE_GNU


98 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

99 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

100 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

101 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

102 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

103 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

104 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

105 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

109 
	#PTHREAD_MUTEX_INITIALIZER
 \

110 { { 0, 0, 0, 0, 0, { 
__PTHREAD_SPINS
 } } }

	)

111 #ifde
__USE_GNU


112 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

113 { { 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

114 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

115 { { 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

116 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

117 { { 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

124 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


127 
	mPTHREAD_RWLOCK_PREFER_READER_NP
,

128 
	mPTHREAD_RWLOCK_PREFER_WRITER_NP
,

129 
	mPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,

130 
	mPTHREAD_RWLOCK_DEFAULT_NP
 = 
PTHREAD_RWLOCK_PREFER_READER_NP


136 #ide
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


137 #i
__WORDSIZE
 == 64

138 
	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
 1

	)

143 
	#PTHREAD_RWLOCK_INITIALIZER
 \

144 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }

	)

145 #ifde
__USE_GNU


146 #ifde
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


147 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

149 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
 } }

	)

151 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


152 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

153 { { 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
, \

154 0, 0, 0, 0 } }

	)

156 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

157 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,\

158 0 } }

	)

168 
	mPTHREAD_INHERIT_SCHED
,

169 
	#PTHREAD_INHERIT_SCHED
 
PTHREAD_INHERIT_SCHED


	)

170 
	mPTHREAD_EXPLICIT_SCHED


171 
	#PTHREAD_EXPLICIT_SCHED
 
PTHREAD_EXPLICIT_SCHED


	)

178 
	mPTHREAD_SCOPE_SYSTEM
,

179 
	#PTHREAD_SCOPE_SYSTEM
 
PTHREAD_SCOPE_SYSTEM


	)

180 
	mPTHREAD_SCOPE_PROCESS


181 
	#PTHREAD_SCOPE_PROCESS
 
PTHREAD_SCOPE_PROCESS


	)

188 
	mPTHREAD_PROCESS_PRIVATE
,

189 
	#PTHREAD_PROCESS_PRIVATE
 
PTHREAD_PROCESS_PRIVATE


	)

190 
	mPTHREAD_PROCESS_SHARED


191 
	#PTHREAD_PROCESS_SHARED
 
PTHREAD_PROCESS_SHARED


	)

197 
	#PTHREAD_COND_INITIALIZER
 { { 0, 0, 0, 0, 0, (*0, 0, 0 } }

	)

201 
	s_had_nup_bufr


203 (*
	m__route
) (*);

204 *
	m__g
;

205 
	m__ny
;

206 
_had_nup_bufr
 *
	m__ev
;

212 
	mPTHREAD_CANCEL_ENABLE
,

213 
	#PTHREAD_CANCEL_ENABLE
 
PTHREAD_CANCEL_ENABLE


	)

214 
	mPTHREAD_CANCEL_DISABLE


215 
	#PTHREAD_CANCEL_DISABLE
 
PTHREAD_CANCEL_DISABLE


	)

219 
	mPTHREAD_CANCEL_DEFERRED
,

220 
	#PTHREAD_CANCEL_DEFERRED
 
PTHREAD_CANCEL_DEFERRED


	)

221 
	mPTHREAD_CANCEL_ASYNCHRONOUS


222 
	#PTHREAD_CANCEL_ASYNCHRONOUS
 
PTHREAD_CANCEL_ASYNCHRONOUS


	)

224 
	#PTHREAD_CANCELED
 ((*-1)

	)

228 
	#PTHREAD_ONCE_INIT
 0

	)

231 #ifde
__USE_XOPEN2K


235 
	#PTHREAD_BARRIER_SERIAL_THREAD
 -1

	)

239 
__BEGIN_DECLS


244 
had_
 (
had_t
 *
__ri
 
__wthad
,

245 cڡ 
had__t
 *
__ri
 
__
,

246 *(*
__t_route
) (*),

247 *
__ri
 
__g

__THROWNL
 
__nnu
 ((1, 3));

253 
	$had_ex
 (*
__tv

	`__ibu__
 ((
__nܑu__
));

261 
	`had_jo
 (
had_t
 
__th
, **
__thad_tu
);

263 #ifde
__USE_GNU


266 
	$had_yjo_
 (
had_t
 
__th
, **
__thad_tu

__THROW
;

274 
	`had_timedjo_
 (
had_t
 
__th
, **
__thad_tu
,

275 cڡ 
timeec
 *
__abime
);

282 
	$had_dach
 (
had_t
 
__th

__THROW
;

286 
had_t
 
	$had_lf
 (
__THROW
 
	`__ibu__
 ((
__cڡ__
));

289 
	$had_equ
 (
had_t
 
__thad1
,thad_
__thad2
)

290 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

298 
	$had__
 (
had__t
 *
__

__THROW
 
	`__nnu
 ((1));

301 
	$had__deroy
 (
had__t
 *
__
)

302 
__THROW
 
	`__nnu
 ((1));

305 
	$had__gdache
 (cڡ 
had__t
 *
__
,

306 *
__dache
)

307 
__THROW
 
	`__nnu
 ((1, 2));

310 
	$had__tdache
 (
had__t
 *
__
,

311 
__dache
)

312 
__THROW
 
	`__nnu
 ((1));

316 
	$had__ggudsize
 (cڡ 
had__t
 *
__
,

317 
size_t
 *
__gudsize
)

318 
__THROW
 
	`__nnu
 ((1, 2));

321 
	$had__tgudsize
 (
had__t
 *
__
,

322 
size_t
 
__gudsize
)

323 
__THROW
 
	`__nnu
 ((1));

327 
	$had__gschedm
 (cڡ 
had__t
 *
__ri
 
__
,

328 
sched_m
 *
__ri
 
__m
)

329 
__THROW
 
	`__nnu
 ((1, 2));

332 
	$had__tschedm
 (
had__t
 *
__ri
 
__
,

333 cڡ 
sched_m
 *
__ri


334 
__m

__THROW
 
	`__nnu
 ((1, 2));

337 
	$had__gschedpicy
 (cڡ 
had__t
 *
__ri


338 
__
, *
__ri
 
__picy
)

339 
__THROW
 
	`__nnu
 ((1, 2));

342 
	$had__tschedpicy
 (
had__t
 *
__
, 
__picy
)

343 
__THROW
 
	`__nnu
 ((1));

346 
	$had__ghsched
 (cڡ 
had__t
 *
__ri


347 
__
, *
__ri
 
__h
)

348 
__THROW
 
	`__nnu
 ((1, 2));

351 
	$had__thsched
 (
had__t
 *
__
,

352 
__h
)

353 
__THROW
 
	`__nnu
 ((1));

357 
	$had__gsce
 (cڡ 
had__t
 *
__ri
 
__
,

358 *
__ri
 
__sce
)

359 
__THROW
 
	`__nnu
 ((1, 2));

362 
	$had__tsce
 (
had__t
 *
__
, 
__sce
)

363 
__THROW
 
	`__nnu
 ((1));

366 
	$had__gackaddr
 (cڡ 
had__t
 *
__ri


367 
__
, **
__ri
 
__ackaddr
)

368 
__THROW
 
	`__nnu
 ((1, 2)
__ibu_dd__
;

374 
	$had__tackaddr
 (
had__t
 *
__
,

375 *
__ackaddr
)

376 
__THROW
 
	`__nnu
 ((1)
__ibu_dd__
;

379 
	$had__gacksize
 (cڡ 
had__t
 *
__ri


380 
__
, 
size_t
 *
__ri
 
__acksize
)

381 
__THROW
 
	`__nnu
 ((1, 2));

386 
	$had__tacksize
 (
had__t
 *
__
,

387 
size_t
 
__acksize
)

388 
__THROW
 
	`__nnu
 ((1));

390 #ifde
__USE_XOPEN2K


392 
	$had__gack
 (cڡ 
had__t
 *
__ri
 
__
,

393 **
__ri
 
__ackaddr
,

394 
size_t
 *
__ri
 
__acksize
)

395 
__THROW
 
	`__nnu
 ((1, 2, 3));

400 
	$had__tack
 (
had__t
 *
__
, *
__ackaddr
,

401 
size_t
 
__acksize

__THROW
 
	`__nnu
 ((1));

404 #ifde
__USE_GNU


407 
	$had__ffy_
 (
had__t
 *
__
,

408 
size_t
 
__utsize
,

409 cڡ 
u_t_t
 *
__ut
)

410 
__THROW
 
	`__nnu
 ((1, 3));

414 
	$had__gaffy_
 (cڡ 
had__t
 *
__
,

415 
size_t
 
__utsize
,

416 
u_t_t
 *
__ut
)

417 
__THROW
 
	`__nnu
 ((1, 3));

420 
	$had_g_deu_
 (
had__t
 *
__
)

421 
__THROW
 
	`__nnu
 ((1));

425 
	$had_r_deu_
 (cڡ 
had__t
 *
__
)

426 
__THROW
 
	`__nnu
 ((1));

431 
	$had_g_
 (
had_t
 
__th
, 
had__t
 *
__
)

432 
__THROW
 
	`__nnu
 ((2));

440 
	$had_tschedm
 (
had_t
 
__rg_thad
, 
__picy
,

441 cڡ 
sched_m
 *
__m
)

442 
__THROW
 
	`__nnu
 ((3));

445 
	$had_gschedm
 (
had_t
 
__rg_thad
,

446 *
__ri
 
__picy
,

447 
sched_m
 *
__ri
 
__m
)

448 
__THROW
 
	`__nnu
 ((2, 3));

451 
	$had_tschedio
 (
had_t
 
__rg_thad
, 
__io
)

452 
__THROW
;

455 #ifde
__USE_GNU


457 
	$had_gme_
 (
had_t
 
__rg_thad
, *
__buf
,

458 
size_t
 
__bu
)

459 
__THROW
 
	`__nnu
 ((2));

462 
	$had_ame_
 (
had_t
 
__rg_thad
, cڡ *
__me
)

463 
__THROW
 
	`__nnu
 ((2));

467 #ifde
__USE_UNIX98


469 
	$had_gccucy
 (
__THROW
;

472 
	$had_tccucy
 (
__v

__THROW
;

475 #ifde
__USE_GNU


480 
	$had_yld
 (
__THROW
;

485 
	$had_ffy_
 (
had_t
 
__th
, 
size_t
 
__utsize
,

486 cڡ 
u_t_t
 *
__ut
)

487 
__THROW
 
	`__nnu
 ((3));

490 
	$had_gaffy_
 (
had_t
 
__th
, 
size_t
 
__utsize
,

491 
u_t_t
 *
__ut
)

492 
__THROW
 
	`__nnu
 ((3));

505 
	`had_
 (
had__t
 *
___cڌ
,

506 (*
___route
()
	`__nnu
 ((1, 2));

517 
	`had_tnle
 (
__e
, *
__de
);

521 
	`had_tny
 (
__ty
, *
__dty
);

524 
	`had_nl
 (
had_t
 
__th
);

529 
	`had_nl
 ();

538 
__jmp_buf
 
__nl_jmp_buf
;

539 
__mask_was_ved
;

540 } 
__nl_jmp_buf
[1];

541 *
__d
[4];

542 } 
	t__had_unwd_buf_t
 
	t__ibu__
 ((
	t__igd__
));

545 #ide
__nup_f_ibu


546 
	#__nup_f_ibu


	)

551 
	s__had_nup_ame


553 (*
__nl_route
) (*);

554 *
__nl_g
;

555 
__do_
;

556 
__nl_ty
;

559 #i
defed
 
__GNUC__
 && defed 
__EXCEPTIONS


560 #ifde
__lulus


562 as
	c__had_nup_ass


564 (*
__nl_route
) (*);

565 *
__nl_g
;

566 
__do_
;

567 
__nl_ty
;

569 
public
:

570 
	`__had_nup_ass
 ((*
__f
(*), *
__g
)

571 : 
	`__nl_route
 (
__f
), 
	`__nl_g
 (
__g
), 
	$__do_
 (1) { }

572 ~
	$__had_nup_ass
 ({ i(
__do_

	`__nl_route
 (
__nl_g
); 
	}
}

573 
	$__tdo
 (
__wv
{ 
__do_
 = __wv; 
	}
}

574 
	$__der
 ({ 
	`had_tny
 (
PTHREAD_CANCEL_DEFERRED
,

575 &
__nl_ty
); 
	}
}

576 
	$__e
 (cڡ { 
	`had_tny
 (
__nl_ty
, 0); 
	}
}

586 
	#had_nup_push
(
route
, 
g
) \

588 
__had_nup_ass
 
	`__ame
 (
route
, 
g
)

	)

592 
	#had_nup_p
(
execu
) \

593 
__ame
.
	`__tdo
 (
execu
); \

594 } 0)

	)

596 #ifde
__USE_GNU


600 
	#had_nup_push_der_
(
route
, 
g
) \

602 
__had_nup_ass
 
	`__ame
 (
route
, 
g
); \

603 
__ame
.
	`__der
 ()

	)

608 
	#had_nup_p_e_
(
execu
) \

609 
__ame
.
	`__e
 (); \

610 
__ame
.
	`__tdo
 (
execu
); \

611 } 0)

	)

618 
__ex_le
 

619 
	$__had_nup_route
 (
__had_nup_ame
 *
__ame
)

621 i(
__ame
->
__do_
)

622 
__ame
->
	`__nl_route
 (__ame->
__nl_g
);

623 
	}
}

632 
	#had_nup_push
(
route
, 
g
) \

634 
__had_nup_ame
 
__ame
 \

635 
	`__ibu__
 ((
	`__nup__
 (
__had_nup_route
))) \

636 { .
__nl_route
 = (
route
), .
__nl_g
 = (
g
), \

637 .
__do_
 = 1 };

	)

641 
	#had_nup_p
(
execu
) \

642 
__ame
.
__do_
 = (
execu
); \

643 } 0)

	)

645 #ifde
__USE_GNU


649 
	#had_nup_push_der_
(
route
, 
g
) \

651 
__had_nup_ame
 
__ame
 \

652 
	`__ibu__
 ((
	`__nup__
 (
__had_nup_route
))) \

653 { .
__nl_route
 = (
route
), .
__nl_g
 = (
g
), \

654 .
__do_
 = 1 }; \

655 (
	`had_tny
 (
PTHREAD_CANCEL_DEFERRED
, \

656 &
__ame
.
__nl_ty
)

	)

661 
	#had_nup_p_e_
(
execu
) \

662 (
	`had_tny
 (
__ame
.
__nl_ty
, 
NULL
); \

663 
__ame
.
__do_
 = (
execu
); \

664 } 0)

	)

675 
	#had_nup_push
(
route
, 
g
) \

677 
__had_unwd_buf_t
 
__nl_buf
; \

678 (*
__nl_route
(*(
route
); \

679 *
__nl_g
 = (
g
); \

680 
__n_f_
 = 
	`__sigtjmp
 ((
__jmp_buf_g
 *) (*) \

681 
__nl_buf
.
__nl_jmp_buf
, 0); \

682 i(
	`__glibc_uiky
 (
__n_f_
)) \

684 
	`__nl_route
 (
__nl_g
); \

685 
	`__had_unwd_xt
 (&
__nl_buf
); \

689 
	`__had_gi_nl
 (&
__nl_buf
); \

690 d{

	)

691 
__had_gi_nl
 (
__had_unwd_buf_t
 *
__buf
)

692 
__nup_f_ibu
;

696 
	#had_nup_p
(
execu
) \

699 
	`__had_uegi_nl
 (&
__nl_buf
); \

700 i(
execu
) \

701 
	`__nl_route
 (
__nl_g
); \

702 } 0)

	)

703 
	$__had_uegi_nl
 (
__had_unwd_buf_t
 *
__buf
)

704 
__nup_f_ibu
;

706 #ifde
__USE_GNU


710 
	#had_nup_push_der_
(
route
, 
g
) \

712 
__had_unwd_buf_t
 
__nl_buf
; \

713 (*
__nl_route
(*(
route
); \

714 *
__nl_g
 = (
g
); \

715 
__n_f_
 = 
	`__sigtjmp
 ((
__jmp_buf_g
 *) (*) \

716 
__nl_buf
.
__nl_jmp_buf
, 0); \

717 i(
	`__glibc_uiky
 (
__n_f_
)) \

719 
	`__nl_route
 (
__nl_g
); \

720 
	`__had_unwd_xt
 (&
__nl_buf
); \

724 
	`__had_gi_nl_der
 (&
__nl_buf
); \

725 d{

	)

726 
	`__had_gi_nl_der
 (
__had_unwd_buf_t
 *
__buf
)

727 
__nup_f_ibu
;

732 
	#had_nup_p_e_
(
execu
) \

735 
	`__had_uegi_nl_e
 (&
__nl_buf
); \

736 i(
execu
) \

737 
	`__nl_route
 (
__nl_g
); \

738 
	}
} 0)

	)

739 
	$__had_uegi_nl_e
 (
__had_unwd_buf_t
 *
__buf
)

740 
__nup_f_ibu
;

744 
	$__had_unwd_xt
 (
__had_unwd_buf_t
 *
__buf
)

745 
__nup_f_ibu
 
	`__ibu__
 ((
__nܑu__
))

746 #ide
SHARED


747 
	`__ibu__
 ((
__wk__
))

753 
__jmp_buf_g
;

754 
	$__sigtjmp
 (
__jmp_buf_g
 *
__v
, 
__vemask

__THROWNL
;

760 
	$had_mux_
 (
had_mux_t
 *
__mux
,

761 cڡ 
had_mux_t
 *
__mux
)

762 
__THROW
 
	`__nnu
 ((1));

765 
	$had_mux_deroy
 (
had_mux_t
 *
__mux
)

766 
__THROW
 
	`__nnu
 ((1));

769 
	$had_mux_ylock
 (
had_mux_t
 *
__mux
)

770 
__THROWNL
 
	`__nnu
 ((1));

773 
	$had_mux_lock
 (
had_mux_t
 *
__mux
)

774 
__THROWNL
 
	`__nnu
 ((1));

776 #ifde
__USE_XOPEN2K


778 
	$had_mux_timedlock
 (
had_mux_t
 *
__ri
 
__mux
,

779 cڡ 
timeec
 *
__ri


780 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

784 
	$had_mux_uock
 (
had_mux_t
 *
__mux
)

785 
__THROWNL
 
	`__nnu
 ((1));

789 
	$had_mux_giog
 (cڡ 
had_mux_t
 *

790 
__ri
 
__mux
,

791 *
__ri
 
__iog
)

792 
__THROW
 
	`__nnu
 ((1, 2));

796 
	$had_mux_riog
 (
had_mux_t
 *
__ri
 
__mux
,

797 
__iog
,

798 *
__ri
 
__d_g
)

799 
__THROW
 
	`__nnu
 ((1, 3));

802 #ifde
__USE_XOPEN2K8


804 
	$had_mux_csit
 (
had_mux_t
 *
__mux
)

805 
__THROW
 
	`__nnu
 ((1));

806 #ifde
__USE_GNU


807 
	$had_mux_csit_
 (
had_mux_t
 *
__mux
)

808 
__THROW
 
	`__nnu
 ((1));

817 
	$had_mux_
 (
had_mux_t
 *
__
)

818 
__THROW
 
	`__nnu
 ((1));

821 
	$had_mux_deroy
 (
had_mux_t
 *
__
)

822 
__THROW
 
	`__nnu
 ((1));

825 
	$had_mux_gpshed
 (cڡ 
had_mux_t
 *

826 
__ri
 
__
,

827 *
__ri
 
__pshed
)

828 
__THROW
 
	`__nnu
 ((1, 2));

831 
	$had_mux_shed
 (
had_mux_t
 *
__
,

832 
__pshed
)

833 
__THROW
 
	`__nnu
 ((1));

835 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


837 
	$had_mux_gty
 (cڡ 
had_mux_t
 *
__ri


838 
__
, *
__ri
 
__kd
)

839 
__THROW
 
	`__nnu
 ((1, 2));

844 
	$had_mux_y
 (
had_mux_t
 *
__
, 
__kd
)

845 
__THROW
 
	`__nnu
 ((1));

849 
	$had_mux_goc
 (cڡ 
had_mux_t
 *

850 
__ri
 
__
,

851 *
__ri
 
__oc
)

852 
__THROW
 
	`__nnu
 ((1, 2));

856 
	$had_mux_roc
 (
had_mux_t
 *
__
,

857 
__oc
)

858 
__THROW
 
	`__nnu
 ((1));

861 
	$had_mux_giog
 (cڡ 
had_mux_t
 *

862 
__ri
 
__
,

863 *
__ri
 
__iog
)

864 
__THROW
 
	`__nnu
 ((1, 2));

867 
	$had_mux_riog
 (
had_mux_t
 *
__
,

868 
__iog
)

869 
__THROW
 
	`__nnu
 ((1));

871 #ifde
__USE_XOPEN2K


873 
	$had_mux_grobu
 (cڡ 
had_mux_t
 *
__
,

874 *
__robuss
)

875 
__THROW
 
	`__nnu
 ((1, 2));

876 #ifde
__USE_GNU


877 
	$had_mux_grobu_
 (cڡ 
had_mux_t
 *
__
,

878 *
__robuss
)

879 
__THROW
 
	`__nnu
 ((1, 2));

883 
	$had_mux_obu
 (
had_mux_t
 *
__
,

884 
__robuss
)

885 
__THROW
 
	`__nnu
 ((1));

886 #ifde
__USE_GNU


887 
	$had_mux_obu_
 (
had_mux_t
 *
__
,

888 
__robuss
)

889 
__THROW
 
	`__nnu
 ((1));

894 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


899 
	$had_rwlock_
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

900 cڡ 
had_rwlock_t
 *
__ri


901 
__

__THROW
 
	`__nnu
 ((1));

904 
	$had_rwlock_deroy
 (
had_rwlock_t
 *
__rwlock
)

905 
__THROW
 
	`__nnu
 ((1));

908 
	$had_rwlock_rdlock
 (
had_rwlock_t
 *
__rwlock
)

909 
__THROWNL
 
	`__nnu
 ((1));

912 
	$had_rwlock_yrdlock
 (
had_rwlock_t
 *
__rwlock
)

913 
__THROWNL
 
	`__nnu
 ((1));

915 #ifde
__USE_XOPEN2K


917 
	$had_rwlock_timedrdlock
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

918 cڡ 
timeec
 *
__ri


919 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

923 
	$had_rwlock_wock
 (
had_rwlock_t
 *
__rwlock
)

924 
__THROWNL
 
	`__nnu
 ((1));

927 
	$had_rwlock_ywock
 (
had_rwlock_t
 *
__rwlock
)

928 
__THROWNL
 
	`__nnu
 ((1));

930 #ifde
__USE_XOPEN2K


932 
	$had_rwlock_timedwock
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

933 cڡ 
timeec
 *
__ri


934 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

938 
	$had_rwlock_uock
 (
had_rwlock_t
 *
__rwlock
)

939 
__THROWNL
 
	`__nnu
 ((1));

945 
	$had_rwlock_
 (
had_rwlock_t
 *
__
)

946 
__THROW
 
	`__nnu
 ((1));

949 
	$had_rwlock_deroy
 (
had_rwlock_t
 *
__
)

950 
__THROW
 
	`__nnu
 ((1));

953 
	$had_rwlock_gpshed
 (cڡ 
had_rwlock_t
 *

954 
__ri
 
__
,

955 *
__ri
 
__pshed
)

956 
__THROW
 
	`__nnu
 ((1, 2));

959 
	$had_rwlock_shed
 (
had_rwlock_t
 *
__
,

960 
__pshed
)

961 
__THROW
 
	`__nnu
 ((1));

964 
	$had_rwlock_gkd_
 (cڡ 
had_rwlock_t
 *

965 
__ri
 
__
,

966 *
__ri
 
__ef
)

967 
__THROW
 
	`__nnu
 ((1, 2));

970 
	$had_rwlock_tkd_
 (
had_rwlock_t
 *
__
,

971 
__ef

__THROW
 
	`__nnu
 ((1));

979 
	$had_cd_
 (
had_cd_t
 *
__ri
 
__cd
,

980 cڡ 
had_cd_t
 *
__ri
 
__cd_
)

981 
__THROW
 
	`__nnu
 ((1));

984 
	$had_cd_deroy
 (
had_cd_t
 *
__cd
)

985 
__THROW
 
	`__nnu
 ((1));

988 
	$had_cd_sigl
 (
had_cd_t
 *
__cd
)

989 
__THROWNL
 
	`__nnu
 ((1));

992 
	$had_cd_brd
 (
had_cd_t
 *
__cd
)

993 
__THROWNL
 
	`__nnu
 ((1));

1000 
	$had_cd_wa
 (
had_cd_t
 *
__ri
 
__cd
,

1001 
had_mux_t
 *
__ri
 
__mux
)

1002 
	`__nnu
 ((1, 2));

1011 
	$had_cd_timedwa
 (
had_cd_t
 *
__ri
 
__cd
,

1012 
had_mux_t
 *
__ri
 
__mux
,

1013 cڡ 
timeec
 *
__ri
 
__abime
)

1014 
	`__nnu
 ((1, 2, 3));

1019 
	$had_cd_
 (
had_cd_t
 *
__
)

1020 
__THROW
 
	`__nnu
 ((1));

1023 
	$had_cd_deroy
 (
had_cd_t
 *
__
)

1024 
__THROW
 
	`__nnu
 ((1));

1027 
	$had_cd_gpshed
 (cڡ 
had_cd_t
 *

1028 
__ri
 
__
,

1029 *
__ri
 
__pshed
)

1030 
__THROW
 
	`__nnu
 ((1, 2));

1033 
	$had_cd_shed
 (
had_cd_t
 *
__
,

1034 
__pshed

__THROW
 
	`__nnu
 ((1));

1036 #ifde
__USE_XOPEN2K


1038 
	$had_cd_gock
 (cڡ 
had_cd_t
 *

1039 
__ri
 
__
,

1040 
__ockid_t
 *
__ri
 
__ock_id
)

1041 
__THROW
 
	`__nnu
 ((1, 2));

1044 
	$had_cd_tock
 (
had_cd_t
 *
__
,

1045 
__ockid_t
 
__ock_id
)

1046 
__THROW
 
	`__nnu
 ((1));

1050 #ifde
__USE_XOPEN2K


1055 
	$had__
 (
had_lock_t
 *
__lock
, 
__pshed
)

1056 
__THROW
 
	`__nnu
 ((1));

1059 
	$had__deroy
 (
had_lock_t
 *
__lock
)

1060 
__THROW
 
	`__nnu
 ((1));

1063 
	$had__lock
 (
had_lock_t
 *
__lock
)

1064 
__THROWNL
 
	`__nnu
 ((1));

1067 
	$had__ylock
 (
had_lock_t
 *
__lock
)

1068 
__THROWNL
 
	`__nnu
 ((1));

1071 
	$had__uock
 (
had_lock_t
 *
__lock
)

1072 
__THROWNL
 
	`__nnu
 ((1));

1079 
	$had_brr_
 (
had_brr_t
 *
__ri
 
__brr
,

1080 cڡ 
had_brr_t
 *
__ri


1081 
__
, 
__cou
)

1082 
__THROW
 
	`__nnu
 ((1));

1085 
	$had_brr_deroy
 (
had_brr_t
 *
__brr
)

1086 
__THROW
 
	`__nnu
 ((1));

1089 
	$had_brr_wa
 (
had_brr_t
 *
__brr
)

1090 
__THROWNL
 
	`__nnu
 ((1));

1094 
	$had_brr_
 (
had_brr_t
 *
__
)

1095 
__THROW
 
	`__nnu
 ((1));

1098 
	$had_brr_deroy
 (
had_brr_t
 *
__
)

1099 
__THROW
 
	`__nnu
 ((1));

1102 
	$had_brr_gpshed
 (cڡ 
had_brr_t
 *

1103 
__ri
 
__
,

1104 *
__ri
 
__pshed
)

1105 
__THROW
 
	`__nnu
 ((1, 2));

1108 
	$had_brr_shed
 (
had_brr_t
 *
__
,

1109 
__pshed
)

1110 
__THROW
 
	`__nnu
 ((1));

1122 
	`had_key_
 (
had_key_t
 *
__key
,

1123 (*
__der_funi
) (*))

1124 
__THROW
 
	`__nnu
 ((1));

1127 
	$had_key_de
 (
had_key_t
 
__key

__THROW
;

1130 *
	$had_gecific
 (
had_key_t
 
__key

__THROW
;

1133 
	$had_tecific
 (
had_key_t
 
__key
,

1134 cڡ *
__por

__THROW
 ;

1137 #ifde
__USE_XOPEN2K


1139 
	$had_guockid
 (
had_t
 
__thad_id
,

1140 
__ockid_t
 *
__ock_id
)

1141 
__THROW
 
	`__nnu
 ((2));

1156 
	`had_fk
 ((*
__e
) (),

1157 (*
__
) (),

1158 (*
__chd
()
__THROW
;

1161 #ifde
__USE_EXTERN_INLINES


1163 
__ex_le
 

1164 
	`__NTH
 (
	$had_equ
 (
had_t
 
__thad1
,thad_
__thad2
))

1166  
__thad1
 =
__thad2
;

1167 
	}
}

1170 
	g__END_DECLS


	@/usr/include/signal.h

22 #idef 
_SIGNAL_H


24 #i!
defed
 
__ed_sig_omic_t
 && !defed 
__ed_sigt_t


25 
	#_SIGNAL_H


	)

28 
	~<us.h
>

30 
	g__BEGIN_DECLS


32 
	~<bs/sigt.h
>

36 #i
defed
 
__ed_sig_omic_t
 || defed 
_SIGNAL_H


37 #ide
__sig_omic_t_defed


38 
	#__sig_omic_t_defed


	)

39 
__BEGIN_NAMESPACE_STD


40 
__sig_omic_t
 
	tsig_omic_t
;

41 
	g__END_NAMESPACE_STD


43 #unde
__ed_sig_omic_t


46 #i
defed
 
__ed_sigt_t
 || (defed 
_SIGNAL_H
 && defed 
__USE_POSIX
)

47 #ide
__sigt_t_defed


48 
	#__sigt_t_defed


	)

49 
__sigt_t
 
	tsigt_t
;

51 #unde
__ed_sigt_t


54 #ifde
_SIGNAL_H


56 
	~<bs/tys.h
>

57 
	~<bs/signum.h
>

59 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K


60 #ide
__pid_t_defed


61 
__pid_t
 
	tpid_t
;

62 
	#__pid_t_defed


	)

64 #ifde
__USE_XOPEN


66 #ide
__uid_t_defed


67 
__uid_t
 
	tuid_t
;

68 
	#__uid_t_defed


	)

72 #ifde
__USE_POSIX199309


74 
	#__ed_timeec


	)

75 
	~<time.h
>

78 #i
defed
 
__USE_POSIX199309
 || defed 
__USE_XOPEN_EXTENDED


80 
	~<bs/sigfo.h
>

85 (*
	t__sighdr_t
) ();

90 
__sighdr_t
 
	$__sysv_sigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

91 
__THROW
;

92 #ifde
__USE_GNU


93 
__sighdr_t
 
	$sysv_sigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

94 
__THROW
;

100 
__BEGIN_NAMESPACE_STD


101 #ifde
__USE_BSD


102 
__sighdr_t
 
	$sigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

103 
__THROW
;

106 #ifde
__REDIRECT_NTH


107 
__sighdr_t
 
	`__REDIRECT_NTH
 (
sigl
,

108 (
__sig
, 
__sighdr_t
 
__hdr
),

109 
__sysv_sigl
);

111 
	#sigl
 
__sysv_sigl


	)

114 
__END_NAMESPACE_STD


116 #ifde
__USE_XOPEN


119 
__sighdr_t
 
	$bsd_sigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

120 
__THROW
;

126 #ifde
__USE_POSIX


127 
	$kl
 (
__pid_t
 
__pid
, 
__sig

__THROW
;

130 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


134 
	$kg
 (
__pid_t
 
__pg
, 
__sig

__THROW
;

137 
__BEGIN_NAMESPACE_STD


139 
	$i
 (
__sig

__THROW
;

140 
__END_NAMESPACE_STD


142 #ifde
__USE_SVID


144 
__sighdr_t
 
	$ssigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

145 
__THROW
;

146 
	$gsigl
 (
__sig

__THROW
;

149 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN2K


151 
	`psigl
 (
__sig
, cڡ *
__s
);

154 #ifde
__USE_XOPEN2K


156 
	`psigfo
 (cڡ 
sigfo_t
 *
__pfo
, cڡ *
__s
);

167 
	`__sigu
 (
__sig__mask
, 
__is_sig
);

169 #ifde
__USE_XOPEN


170 #ifde
__GNUC__


171 
	$sigu
 (
__sig

	`__asm__
 ("__xpg_sigpause");

174 
	#sigu
(
sig

	`__sigu
 ((sig), 1)

	)

179 #ifde
__USE_BSD


186 
	#sigmask
(
sig

	`__sigmask
(sig)

	)

189 
	$sigblock
 (
__mask

__THROW
 
__ibu_dd__
;

192 
	$sigtmask
 (
__mask

__THROW
 
__ibu_dd__
;

195 
	$siggmask
 (
__THROW
 
__ibu_dd__
;

199 #ifde
__USE_MISC


200 
	#NSIG
 
_NSIG


	)

203 #ifde
__USE_GNU


204 
__sighdr_t
 
	tsighdr_t
;

208 #ifde
__USE_BSD


209 
__sighdr_t
 
	tsig_t
;

212 #ifde
__USE_POSIX


215 
	$sigemyt
 (
sigt_t
 *
__t

__THROW
 
	`__nnu
 ((1));

218 
	$sigflt
 (
sigt_t
 *
__t

__THROW
 
	`__nnu
 ((1));

221 
	$sigaddt
 (
sigt_t
 *
__t
, 
__signo

__THROW
 
	`__nnu
 ((1));

224 
	$sigdt
 (
sigt_t
 *
__t
, 
__signo

__THROW
 
	`__nnu
 ((1));

227 
	$sigismemb
 (cڡ 
sigt_t
 *
__t
, 
__signo
)

228 
__THROW
 
	`__nnu
 ((1));

230 #ifde
__USE_GNU


232 
	$sigimyt
 (cڡ 
sigt_t
 *
__t

__THROW
 
	`__nnu
 ((1));

235 
	$sigdt
 (
sigt_t
 *
__t
, cڡ sigt_*
__
,

236 cڡ 
sigt_t
 *
__right

__THROW
 
	`__nnu
 ((1, 2, 3));

239 
	$sigܣt
 (
sigt_t
 *
__t
, cڡ sigt_*
__
,

240 cڡ 
sigt_t
 *
__right

__THROW
 
	`__nnu
 ((1, 2, 3));

245 
	~<bs/sigai.h
>

248 
	$sigocmask
 (
__how
, cڡ 
sigt_t
 *
__ri
 
__t
,

249 
sigt_t
 *
__ri
 
__ot

__THROW
;

256 
	$sigsud
 (cڡ 
sigt_t
 *
__t

	`__nnu
 ((1));

259 
	$sigai
 (
__sig
, cڡ 
sigai
 *
__ri
 
__a
,

260 
sigai
 *
__ri
 
__

__THROW
;

263 
	$signdg
 (
sigt_t
 *
__t

__THROW
 
	`__nnu
 ((1));

270 
	$sigwa
 (cڡ 
sigt_t
 *
__ri
 
__t
, *__ri 
__sig
)

271 
	`__nnu
 ((1, 2));

273 #ifde
__USE_POSIX199309


278 
	$sigwafo
 (cڡ 
sigt_t
 *
__ri
 
__t
,

279 
sigfo_t
 *
__ri
 
__fo

	`__nnu
 ((1));

286 
	$sigtimedwa
 (cڡ 
sigt_t
 *
__ri
 
__t
,

287 
sigfo_t
 *
__ri
 
__fo
,

288 cڡ 
timeec
 *
__ri
 
__timeout
)

289 
	`__nnu
 ((1));

293 
	$sigqueue
 (
__pid_t
 
__pid
, 
__sig
, cڡ 
sigv
 
__v
)

294 
__THROW
;

299 #ifde
__USE_BSD


303 cڡ *cڡ 
_sys_sigli
[
_NSIG
];

304 cڡ *cڡ 
sys_sigli
[
_NSIG
];

307 
	ssigvec


309 
__sighdr_t
 
sv_hdr
;

310 
sv_mask
;

312 
sv_ags
;

313 
	#sv_ڡack
 
sv_ags


	)

317 
	#SV_ONSTACK
 (1 << 0)

	)

318 
	#SV_INTERRUPT
 (1 << 1)

	)

319 
	#SV_RESETHAND
 (1 << 2)

	)

327 
	$sigvec
 (
__sig
, cڡ 
sigvec
 *
__vec
,

328 
sigvec
 *
__ovec

__THROW
;

332 
	~<bs/sigcڋxt.h
>

335 
	$sigtu
 (
sigcڋxt
 *
__s

__THROW
;

340 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


341 
	#__ed_size_t


	)

342 
	~<ddef.h
>

347 
	$sigu
 (
__sig
, 
__u

__THROW
;

349 
	~<bs/sigack.h
>

350 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


352 
	~<sys/ucڋxt.h
>

358 
	$sigack
 (
sigack
 *
__ss
, sigack *
__oss
)

359 
__THROW
 
__ibu_dd__
;

363 
	$sigtack
 (cڡ 
sigtack
 *
__ri
 
__ss
,

364 
sigtack
 *
__ri
 
__oss

__THROW
;

368 #ifde
__USE_XOPEN_EXTENDED


372 
	$sighd
 (
__sig

__THROW
;

375 
	$sigl
 (
__sig

__THROW
;

378 
	$sigigne
 (
__sig

__THROW
;

381 
__sighdr_t
 
	$sigt
 (
__sig
, 
__sighdr_t
 
__di

__THROW
;

384 #i
defed
 
__USE_POSIX199506
 || defed 
__USE_UNIX98


387 
	~<bs/hadtys.h
>

388 
	~<bs/sigthad.h
>

395 
	$__libc_cut_sigm
 (
__THROW
;

397 
	$__libc_cut_sigmax
 (
__THROW
;

401 
__END_DECLS


	@/usr/include/stdint.h

22 #ide
_STDINT_H


23 
	#_STDINT_H
 1

	)

25 
	~<us.h
>

26 
	~<bs/wch.h
>

27 
	~<bs/wdsize.h
>

34 #ide
__t8_t_defed


35 
	#__t8_t_defed


	)

36 sigd 
	tt8_t
;

37 
	tt16_t
;

38 
	tt32_t
;

39 #i
__WORDSIZE
 == 64

40 
	tt64_t
;

42 
__exnsi__


43 
	tt64_t
;

48 
	tut8_t
;

49 
	tut16_t
;

50 #ide
__ut32_t_defed


51 
	tut32_t
;

52 
	#__ut32_t_defed


	)

54 #i
__WORDSIZE
 == 64

55 
	tut64_t
;

57 
__exnsi__


58 
	tut64_t
;

65 sigd 
	tt_a8_t
;

66 
	tt_a16_t
;

67 
	tt_a32_t
;

68 #i
__WORDSIZE
 == 64

69 
	tt_a64_t
;

71 
__exnsi__


72 
	tt_a64_t
;

76 
	tut_a8_t
;

77 
	tut_a16_t
;

78 
	tut_a32_t
;

79 #i
__WORDSIZE
 == 64

80 
	tut_a64_t
;

82 
__exnsi__


83 
	tut_a64_t
;

90 sigd 
	tt_8_t
;

91 #i
__WORDSIZE
 == 64

92 
	tt_16_t
;

93 
	tt_32_t
;

94 
	tt_64_t
;

96 
	tt_16_t
;

97 
	tt_32_t
;

98 
__exnsi__


99 
	tt_64_t
;

103 
	tut_8_t
;

104 #i
__WORDSIZE
 == 64

105 
	tut_16_t
;

106 
	tut_32_t
;

107 
	tut_64_t
;

109 
	tut_16_t
;

110 
	tut_32_t
;

111 
__exnsi__


112 
	tut_64_t
;

117 #i
__WORDSIZE
 == 64

118 #ide
___t_defed


119 
	t_t
;

120 
	#___t_defed


	)

122 
	tu_t
;

124 #ide
___t_defed


125 
	t_t
;

126 
	#___t_defed


	)

128 
	tu_t
;

133 #i
__WORDSIZE
 == 64

134 
	ttmax_t
;

135 
	tutmax_t
;

137 
__exnsi__


138 
	ttmax_t
;

139 
__exnsi__


140 
	tutmax_t
;

144 #i
__WORDSIZE
 == 64

145 
	#__INT64_C
(
c
## 
L


	)

146 
	#__UINT64_C
(
c
## 
UL


	)

148 
	#__INT64_C
(
c
## 
LL


	)

149 
	#__UINT64_C
(
c
## 
ULL


	)

155 
	#INT8_MIN
 (-128)

	)

156 
	#INT16_MIN
 (-32767-1)

	)

157 
	#INT32_MIN
 (-2147483647-1)

	)

158 
	#INT64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

160 
	#INT8_MAX
 (127)

	)

161 
	#INT16_MAX
 (32767)

	)

162 
	#INT32_MAX
 (2147483647)

	)

163 
	#INT64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

166 
	#UINT8_MAX
 (255)

	)

167 
	#UINT16_MAX
 (65535)

	)

168 
	#UINT32_MAX
 (4294967295U)

	)

169 
	#UINT64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

173 
	#INT_LEAST8_MIN
 (-128)

	)

174 
	#INT_LEAST16_MIN
 (-32767-1)

	)

175 
	#INT_LEAST32_MIN
 (-2147483647-1)

	)

176 
	#INT_LEAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

178 
	#INT_LEAST8_MAX
 (127)

	)

179 
	#INT_LEAST16_MAX
 (32767)

	)

180 
	#INT_LEAST32_MAX
 (2147483647)

	)

181 
	#INT_LEAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

184 
	#UINT_LEAST8_MAX
 (255)

	)

185 
	#UINT_LEAST16_MAX
 (65535)

	)

186 
	#UINT_LEAST32_MAX
 (4294967295U)

	)

187 
	#UINT_LEAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

191 
	#INT_FAST8_MIN
 (-128)

	)

192 #i
__WORDSIZE
 == 64

193 
	#INT_FAST16_MIN
 (-9223372036854775807L-1)

	)

194 
	#INT_FAST32_MIN
 (-9223372036854775807L-1)

	)

196 
	#INT_FAST16_MIN
 (-2147483647-1)

	)

197 
	#INT_FAST32_MIN
 (-2147483647-1)

	)

199 
	#INT_FAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

201 
	#INT_FAST8_MAX
 (127)

	)

202 #i
__WORDSIZE
 == 64

203 
	#INT_FAST16_MAX
 (9223372036854775807L)

	)

204 
	#INT_FAST32_MAX
 (9223372036854775807L)

	)

206 
	#INT_FAST16_MAX
 (2147483647)

	)

207 
	#INT_FAST32_MAX
 (2147483647)

	)

209 
	#INT_FAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

212 
	#UINT_FAST8_MAX
 (255)

	)

213 #i
__WORDSIZE
 == 64

214 
	#UINT_FAST16_MAX
 (18446744073709551615UL)

	)

215 
	#UINT_FAST32_MAX
 (18446744073709551615UL)

	)

217 
	#UINT_FAST16_MAX
 (4294967295U)

	)

218 
	#UINT_FAST32_MAX
 (4294967295U)

	)

220 
	#UINT_FAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

224 #i
__WORDSIZE
 == 64

225 
	#INTPTR_MIN
 (-9223372036854775807L-1)

	)

226 
	#INTPTR_MAX
 (9223372036854775807L)

	)

227 
	#UINTPTR_MAX
 (18446744073709551615UL)

	)

229 
	#INTPTR_MIN
 (-2147483647-1)

	)

230 
	#INTPTR_MAX
 (2147483647)

	)

231 
	#UINTPTR_MAX
 (4294967295U)

	)

236 
	#INTMAX_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

238 
	#INTMAX_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

241 
	#UINTMAX_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

247 #i
__WORDSIZE
 == 64

248 
	#PTRDIFF_MIN
 (-9223372036854775807L-1)

	)

249 
	#PTRDIFF_MAX
 (9223372036854775807L)

	)

251 
	#PTRDIFF_MIN
 (-2147483647-1)

	)

252 
	#PTRDIFF_MAX
 (2147483647)

	)

256 
	#SIG_ATOMIC_MIN
 (-2147483647-1)

	)

257 
	#SIG_ATOMIC_MAX
 (2147483647)

	)

260 #i
__WORDSIZE
 == 64

261 
	#SIZE_MAX
 (18446744073709551615UL)

	)

263 
	#SIZE_MAX
 (4294967295U)

	)

267 #ide
WCHAR_MIN


269 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

270 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

274 
	#WINT_MIN
 (0u)

	)

275 
	#WINT_MAX
 (4294967295u)

	)

278 
	#INT8_C
(
c

	)
c

279 
	#INT16_C
(
c

	)
c

280 
	#INT32_C
(
c

	)
c

281 #i
__WORDSIZE
 == 64

282 
	#INT64_C
(
c
## 
L


	)

284 
	#INT64_C
(
c
## 
LL


	)

288 
	#UINT8_C
(
c

	)
c

289 
	#UINT16_C
(
c

	)
c

290 
	#UINT32_C
(
c
## 
U


	)

291 #i
__WORDSIZE
 == 64

292 
	#UINT64_C
(
c
## 
UL


	)

294 
	#UINT64_C
(
c
## 
ULL


	)

298 #i
__WORDSIZE
 == 64

299 
	#INTMAX_C
(
c
## 
L


	)

300 
	#UINTMAX_C
(
c
## 
UL


	)

302 
	#INTMAX_C
(
c
## 
LL


	)

303 
	#UINTMAX_C
(
c
## 
ULL


	)

	@/usr/include/stdio.h

23 #ide
_STDIO_H


25 #i!
defed
 
__ed_FILE
 && !defed 
__ed___FILE


26 
	#_STDIO_H
 1

	)

27 
	~<us.h
>

29 
	g__BEGIN_DECLS


31 
	#__ed_size_t


	)

32 
	#__ed_NULL


	)

33 
	~<ddef.h
>

35 
	~<bs/tys.h
>

36 
	#__ed_FILE


	)

37 
	#__ed___FILE


	)

41 #i!
defed
 
__FILE_defed
 && defed 
__ed_FILE


44 
	g_IO_FILE
;

46 
__BEGIN_NAMESPACE_STD


48 
_IO_FILE
 
	tFILE
;

49 
	g__END_NAMESPACE_STD


50 #i
defed
 
__USE_LARGEFILE64
 || defed 
__USE_SVID
 || defed 
__USE_POSIX
 \

51 || 
defed
 
	g__USE_BSD
 || defed 
	g__USE_ISOC99
 || defed 
	g__USE_XOPEN
 \

52 || 
defed
 
__USE_POSIX2


53 
	$__USING_NAMESPACE_STD
(
FILE
)

56 
	#__FILE_defed
 1

	)

58 #unde
__ed_FILE


61 #i!
defed
 
____FILE_defed
 && defed 
__ed___FILE


64 
_IO_FILE
 
	t__FILE
;

66 
	#____FILE_defed
 1

	)

68 #unde
__ed___FILE


71 #ifdef 
_STDIO_H


72 
	#_STDIO_USES_IOSTREAM


	)

74 
	~<libio.h
>

76 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


77 #ifde
__GNUC__


78 #ide
_VA_LIST_DEFINED


79 
_G_va_li
 
	tva_li
;

80 
	#_VA_LIST_DEFINED


	)

83 
	~<dg.h
>

87 #ifde
__USE_XOPEN2K8


88 #ide
__off_t_defed


89 #ide
__USE_FILE_OFFSET64


90 
__off_t
 
	toff_t
;

92 
__off64_t
 
	toff_t
;

94 
	#__off_t_defed


	)

96 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


97 
__off64_t
 
	toff64_t
;

98 
	#__off64_t_defed


	)

101 #ide
__ssize_t_defed


102 
__ssize_t
 
	tssize_t
;

103 
	#__ssize_t_defed


	)

108 
__BEGIN_NAMESPACE_STD


109 #ide
__USE_FILE_OFFSET64


110 
_G_os_t
 
	tos_t
;

112 
_G_os64_t
 
	tos_t
;

114 
__END_NAMESPACE_STD


115 #ifde
__USE_LARGEFILE64


116 
_G_os64_t
 
	tos64_t
;

120 
	#_IOFBF
 0

	)

121 
	#_IOLBF
 1

	)

122 
	#_IONBF
 2

	)

126 #ide
BUFSIZ


127 
	#BUFSIZ
 
_IO_BUFSIZ


	)

133 #ide
EOF


134 
	#EOF
 (-1)

	)

140 
	#SEEK_SET
 0

	)

141 
	#SEEK_CUR
 1

	)

142 
	#SEEK_END
 2

	)

143 #ifde
__USE_GNU


144 
	#SEEK_DATA
 3

	)

145 
	#SEEK_HOLE
 4

	)

149 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


151 
	#P_tmpd
 "/tmp"

	)

164 
	~<bs/dio_lim.h
>

168 
_IO_FILE
 *
d
;

169 
_IO_FILE
 *
dout
;

170 
_IO_FILE
 *
dr
;

172 
	#d
 
d


	)

173 
	#dout
 
dout


	)

174 
	#dr
 
dr


	)

176 
__BEGIN_NAMESPACE_STD


178 
	$move
 (cڡ *
__fame

__THROW
;

180 
	$me
 (cڡ *
__d
, cڡ *
__w

__THROW
;

181 
__END_NAMESPACE_STD


183 #ifde
__USE_ATFILE


185 
	$mt
 (
__dfd
, cڡ *
__d
, 
__wfd
,

186 cڡ *
__w

__THROW
;

189 
__BEGIN_NAMESPACE_STD


194 #ide
__USE_FILE_OFFSET64


195 
FILE
 *
	$tmpfe
 (
__wur
;

197 #ifde
__REDIRECT


198 
FILE
 *
	`__REDIRECT
 (
tmpfe
, (), 
tmpfe64

__wur
;

200 
	#tmpfe
 
tmpfe64


	)

204 #ifde
__USE_LARGEFILE64


205 
FILE
 *
	$tmpfe64
 (
__wur
;

209 *
	$tmam
 (*
__s

__THROW
 
__wur
;

210 
__END_NAMESPACE_STD


212 #ifde
__USE_MISC


215 *
	$tmam_r
 (*
__s

__THROW
 
__wur
;

219 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


227 *
	$mam
 (cڡ *
__d
, cڡ *
__pfx
)

228 
__THROW
 
__ibu_mloc__
 
__wur
;

232 
__BEGIN_NAMESPACE_STD


237 
	`fo
 (
FILE
 *
__am
);

242 
	`fush
 (
FILE
 *
__am
);

243 
__END_NAMESPACE_STD


245 #ifde
__USE_MISC


252 
	`fush_uocked
 (
FILE
 *
__am
);

255 #ifde
__USE_GNU


262 
	`fol
 ();

266 
__BEGIN_NAMESPACE_STD


267 #ide
__USE_FILE_OFFSET64


272 
FILE
 *
	$fݒ
 (cڡ *
__ri
 
__fame
,

273 cڡ *
__ri
 
__modes

__wur
;

278 
FILE
 *
	$eݒ
 (cڡ *
__ri
 
__fame
,

279 cڡ *
__ri
 
__modes
,

280 
FILE
 *
__ri
 
__am

__wur
;

282 #ifde
__REDIRECT


283 
FILE
 *
	`__REDIRECT
 (
fݒ
, (cڡ *
__ri
 
__fame
,

284 cڡ *
__ri
 
__modes
), 
fݒ64
)

285 
__wur
;

286 
FILE
 *
	`__REDIRECT
 (
eݒ
, (cڡ *
__ri
 
__fame
,

287 cڡ *
__ri
 
__modes
,

288 
FILE
 *
__ri
 
__am
), 
eݒ64
)

289 
__wur
;

291 
	#fݒ
 
fݒ64


	)

292 
	#eݒ
 
eݒ64


	)

295 
__END_NAMESPACE_STD


296 #ifde
__USE_LARGEFILE64


297 
FILE
 *
	$fݒ64
 (cڡ *
__ri
 
__fame
,

298 cڡ *
__ri
 
__modes

__wur
;

299 
FILE
 *
	$eݒ64
 (cڡ *
__ri
 
__fame
,

300 cڡ *
__ri
 
__modes
,

301 
FILE
 *
__ri
 
__am

__wur
;

304 #ifdef 
__USE_POSIX


306 
FILE
 *
	$fdݒ
 (
__fd
, cڡ *
__modes

__THROW
 
__wur
;

309 #ifdef 
__USE_GNU


312 
FILE
 *
	$fݒcook
 (*
__ri
 
__magic_cook
,

313 cڡ *
__ri
 
__modes
,

314 
_IO_cook_io_funis_t
 
__io_funcs

__THROW
 
__wur
;

317 #ifde
__USE_XOPEN2K8


319 
FILE
 *
	$fmemݒ
 (*
__s
, 
size_t
 
__n
, cڡ *
__modes
)

320 
__THROW
 
__wur
;

325 
FILE
 *
	$ݒ_memam
 (**
__buoc
, 
size_t
 *
__sizoc

__THROW
 
__wur
;

329 
__BEGIN_NAMESPACE_STD


332 
	$tbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf

__THROW
;

336 
	$tvbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

337 
__modes
, 
size_t
 
__n

__THROW
;

338 
__END_NAMESPACE_STD


340 #ifdef 
__USE_BSD


343 
	$tbufr
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

344 
size_t
 
__size

__THROW
;

347 
	$ebuf
 (
FILE
 *
__am

__THROW
;

351 
__BEGIN_NAMESPACE_STD


356 
	`rtf
 (
FILE
 *
__ri
 
__am
,

357 cڡ *
__ri
 
__fm
, ...);

362 
	`tf
 (cڡ *
__ri
 
__fm
, ...);

364 
	$rtf
 (*
__ri
 
__s
,

365 cڡ *
__ri
 
__fm
, ...
__THROWNL
;

371 
	`vrtf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

372 
_G_va_li
 
__g
);

377 
	`vtf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
);

379 
	$vrtf
 (*
__ri
 
__s
, cڡ *__ri 
__fm
,

380 
_G_va_li
 
__g

__THROWNL
;

381 
__END_NAMESPACE_STD


383 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


384 
__BEGIN_NAMESPACE_C99


386 
	$tf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

387 cڡ *
__ri
 
__fm
, ...)

388 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

390 
	$vtf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

391 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

392 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

393 
__END_NAMESPACE_C99


396 #ifde
__USE_GNU


399 
	$vartf
 (**
__ri
 
__r
, cڡ *__ri 
__f
,

400 
_G_va_li
 
__g
)

401 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 0))
__wur
;

402 
	$__artf
 (**
__ri
 
__r
,

403 cڡ *
__ri
 
__fmt
, ...)

404 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

405 
	$artf
 (**
__ri
 
__r
,

406 cڡ *
__ri
 
__fmt
, ...)

407 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

410 #ifde
__USE_XOPEN2K8


412 
	$vdtf
 (
__fd
, cڡ *
__ri
 
__fmt
,

413 
_G_va_li
 
__g
)

414 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

415 
	$dtf
 (
__fd
, cڡ *
__ri
 
__fmt
, ...)

416 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

420 
__BEGIN_NAMESPACE_STD


425 
	$fsnf
 (
FILE
 *
__ri
 
__am
,

426 cڡ *
__ri
 
__fm
, ...
__wur
;

431 
	$snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

433 
	$ssnf
 (cڡ *
__ri
 
__s
,

434 cڡ *
__ri
 
__fm
, ...
__THROW
;

436 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

437 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

438 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

439 #ifde
__REDIRECT


443 
	`__REDIRECT
 (
fsnf
, (
FILE
 *
__ri
 
__am
,

444 cڡ *
__ri
 
__fm
, ...),

445 
__isoc99_fsnf

__wur
;

446 
	`__REDIRECT
 (
snf
, (cڡ *
__ri
 
__fm
, ...),

447 
__isoc99_snf

__wur
;

448 
	`__REDIRECT_NTH
 (
ssnf
, (cڡ *
__ri
 
__s
,

449 cڡ *
__ri
 
__fm
, ...),

450 
__isoc99_ssnf
);

452 
	$__isoc99_fsnf
 (
FILE
 *
__ri
 
__am
,

453 cڡ *
__ri
 
__fm
, ...
__wur
;

454 
	$__isoc99_snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

455 
	$__isoc99_ssnf
 (cڡ *
__ri
 
__s
,

456 cڡ *
__ri
 
__fm
, ...
__THROW
;

457 
	#fsnf
 
__isoc99_fsnf


	)

458 
	#snf
 
__isoc99_snf


	)

459 
	#ssnf
 
__isoc99_ssnf


	)

463 
__END_NAMESPACE_STD


465 #ifdef 
__USE_ISOC99


466 
__BEGIN_NAMESPACE_C99


471 
	$vfsnf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

472 
_G_va_li
 
__g
)

473 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

479 
	$vsnf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

480 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

483 
	$vssnf
 (cڡ *
__ri
 
__s
,

484 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

485 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

487 #i!
defed
 
__USE_GNU
 \

488 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

489 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

490 #ifde
__REDIRECT


494 
	`__REDIRECT
 (
vfsnf
,

495 (
FILE
 *
__ri
 
__s
,

496 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
),

497 
__isoc99_vfsnf
)

498 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

499 
	`__REDIRECT
 (
vsnf
, (cڡ *
__ri
 
__fm
,

500 
_G_va_li
 
__g
), 
__isoc99_vsnf
)

501 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

502 
	`__REDIRECT_NTH
 (
vssnf
,

503 (cڡ *
__ri
 
__s
,

504 cڡ *
__ri
 
__fm
,

505 
_G_va_li
 
__g
), 
__isoc99_vssnf
)

506 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

508 
	$__isoc99_vfsnf
 (
FILE
 *
__ri
 
__s
,

509 cڡ *
__ri
 
__fm
,

510 
_G_va_li
 
__g

__wur
;

511 
	$__isoc99_vsnf
 (cڡ *
__ri
 
__fm
,

512 
_G_va_li
 
__g

__wur
;

513 
	$__isoc99_vssnf
 (cڡ *
__ri
 
__s
,

514 cڡ *
__ri
 
__fm
,

515 
_G_va_li
 
__g

__THROW
;

516 
	#vfsnf
 
__isoc99_vfsnf


	)

517 
	#vsnf
 
__isoc99_vsnf


	)

518 
	#vssnf
 
__isoc99_vssnf


	)

522 
__END_NAMESPACE_C99


526 
__BEGIN_NAMESPACE_STD


531 
	`fgc
 (
FILE
 *
__am
);

532 
	`gc
 (
FILE
 *
__am
);

538 
	`gch
 ();

539 
__END_NAMESPACE_STD


543 
	#gc
(
_

	`_IO_gc
 (_)

	)

545 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


550 
	`gc_uocked
 (
FILE
 *
__am
);

551 
	`gch_uocked
 ();

554 #ifde
__USE_MISC


561 
	`fgc_uocked
 (
FILE
 *
__am
);

565 
__BEGIN_NAMESPACE_STD


573 
	`utc
 (
__c
, 
FILE
 *
__am
);

574 
	`putc
 (
__c
, 
FILE
 *
__am
);

580 
	`putch
 (
__c
);

581 
__END_NAMESPACE_STD


585 
	#putc
(
_ch
, 
_

	`_IO_putc
 (_ch, _)

	)

587 #ifde
__USE_MISC


594 
	`utc_uocked
 (
__c
, 
FILE
 *
__am
);

597 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


602 
	`putc_uocked
 (
__c
, 
FILE
 *
__am
);

603 
	`putch_uocked
 (
__c
);

607 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 \

608 || (
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
)

610 
	`gw
 (
FILE
 *
__am
);

613 
	`putw
 (
__w
, 
FILE
 *
__am
);

617 
__BEGIN_NAMESPACE_STD


622 *
	$fgs
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

623 
__wur
;

625 #i!
defed
 
__USE_ISOC11
 \

626 || (
defed
 
__lulus
 && __cplusplus <= 201103L)

638 *
	$gs
 (*
__s

__wur
 
__ibu_dd__
;

640 
__END_NAMESPACE_STD


642 #ifde
__USE_GNU


649 *
	$fgs_uocked
 (*
__ri
 
__s
, 
__n
,

650 
FILE
 *
__ri
 
__am

__wur
;

654 #ifdef 
__USE_XOPEN2K8


665 
_IO_ssize_t
 
	$__gdim
 (**
__ri
 
__l
,

666 
size_t
 *
__ri
 
__n
, 
__dim
,

667 
FILE
 *
__ri
 
__am

__wur
;

668 
_IO_ssize_t
 
	$gdim
 (**
__ri
 
__l
,

669 
size_t
 *
__ri
 
__n
, 
__dim
,

670 
FILE
 *
__ri
 
__am

__wur
;

678 
_IO_ssize_t
 
	$gle
 (**
__ri
 
__l
,

679 
size_t
 *
__ri
 
__n
,

680 
FILE
 *
__ri
 
__am

__wur
;

684 
__BEGIN_NAMESPACE_STD


689 
	`uts
 (cڡ *
__ri
 
__s
, 
FILE
 *__ri 
__am
);

695 
	`puts
 (cڡ *
__s
);

702 
	`ungc
 (
__c
, 
FILE
 *
__am
);

709 
size_t
 
	$d
 (*
__ri
 
__r
, 
size_t
 
__size
,

710 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

715 
size_t
 
	`fwre
 (cڡ *
__ri
 
__r
, size_
__size
,

716 
size_t
 
__n
, 
FILE
 *
__ri
 
__s
);

717 
__END_NAMESPACE_STD


719 #ifde
__USE_GNU


726 
	`uts_uocked
 (cڡ *
__ri
 
__s
,

727 
FILE
 *
__ri
 
__am
);

730 #ifde
__USE_MISC


737 
size_t
 
	$d_uocked
 (*
__ri
 
__r
, 
size_t
 
__size
,

738 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

739 
size_t
 
	`fwre_uocked
 (cڡ *
__ri
 
__r
, size_
__size
,

740 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
);

744 
__BEGIN_NAMESPACE_STD


749 
	`fek
 (
FILE
 *
__am
, 
__off
, 
__wh
);

754 
	$l
 (
FILE
 *
__am

__wur
;

759 
	`wd
 (
FILE
 *
__am
);

760 
__END_NAMESPACE_STD


767 #i
defed
 
__USE_LARGEFILE
 || defed 
__USE_XOPEN2K


768 #ide
__USE_FILE_OFFSET64


773 
	`feko
 (
FILE
 *
__am
, 
__off_t
 
__off
, 
__wh
);

778 
__off_t
 
	$lo
 (
FILE
 *
__am

__wur
;

780 #ifde
__REDIRECT


781 
	`__REDIRECT
 (
feko
,

782 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
),

783 
feko64
);

784 
__off64_t
 
	`__REDIRECT
 (
lo
, (
FILE
 *
__am
), 
lo64
);

786 
	#feko
 
feko64


	)

787 
	#lo
 
lo64


	)

792 
__BEGIN_NAMESPACE_STD


793 #ide
__USE_FILE_OFFSET64


798 
	`fgpos
 (
FILE
 *
__ri
 
__am
, 
os_t
 *__ri 
__pos
);

803 
	`fos
 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
);

805 #ifde
__REDIRECT


806 
	`__REDIRECT
 (
fgpos
, (
FILE
 *
__ri
 
__am
,

807 
os_t
 *
__ri
 
__pos
), 
fgpos64
);

808 
	`__REDIRECT
 (
fos
,

809 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
), 
fos64
);

811 
	#fgpos
 
fgpos64


	)

812 
	#fos
 
fos64


	)

815 
__END_NAMESPACE_STD


817 #ifde
__USE_LARGEFILE64


818 
	`feko64
 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
);

819 
__off64_t
 
	$lo64
 (
FILE
 *
__am

__wur
;

820 
	`fgpos64
 (
FILE
 *
__ri
 
__am
, 
os64_t
 *__ri 
__pos
);

821 
	`fos64
 (
FILE
 *
__am
, cڡ 
os64_t
 *
__pos
);

824 
__BEGIN_NAMESPACE_STD


826 
	$
 (
FILE
 *
__am

__THROW
;

828 
	$of
 (
FILE
 *
__am

__THROW
 
__wur
;

830 
	$
 (
FILE
 *
__am

__THROW
 
__wur
;

831 
__END_NAMESPACE_STD


833 #ifde
__USE_MISC


835 
	$_uocked
 (
FILE
 *
__am

__THROW
;

836 
	$of_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

837 
	$_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

841 
__BEGIN_NAMESPACE_STD


846 
	`
 (cڡ *
__s
);

847 
__END_NAMESPACE_STD


853 
	~<bs/sys_i.h
>

856 #ifdef 
__USE_POSIX


858 
	$fo
 (
FILE
 *
__am

__THROW
 
__wur
;

861 #ifde
__USE_MISC


863 
	$fo_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

867 #i(
defed
 
__USE_POSIX2
 || defed 
__USE_SVID
 || defed 
__USE_BSD
 || \

868 
defed
 
__USE_MISC
)

873 
FILE
 *
	$pݒ
 (cڡ *
__commd
, cڡ *
__modes

__wur
;

879 
	`po
 (
FILE
 *
__am
);

883 #ifdef 
__USE_POSIX


885 *
	$mid
 (*
__s

__THROW
;

889 #ifde
__USE_XOPEN


891 *
	`curid
 (*
__s
);

895 #ifdef 
__USE_GNU


896 
oback
;

899 
	$oback_tf
 (
oback
 *
__ri
 
__oback
,

900 cڡ *
__ri
 
__fm
, ...)

901 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

902 
	$oback_vtf
 (
oback
 *
__ri
 
__oback
,

903 cڡ *
__ri
 
__fm
,

904 
_G_va_li
 
__gs
)

905 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

909 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


913 
	$ockfe
 (
FILE
 *
__am

__THROW
;

917 
	$rylockfe
 (
FILE
 *
__am

__THROW
 
__wur
;

920 
	$fuockfe
 (
FILE
 *
__am

__THROW
;

923 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
 && !defed 
__USE_GNU


927 
	#__ed_gt


	)

928 
	~<gt.h
>

933 #ifde
__USE_EXTERN_INLINES


934 
	~<bs/dio.h
>

936 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ex_ways_le


937 
	~<bs/dio2.h
>

939 #ifde
__LDBL_COMPAT


940 
	~<bs/dio-ldbl.h
>

943 
__END_DECLS


	@/usr/include/stdlib.h

22 #idef 
_STDLIB_H


24 
	~<us.h
>

27 
	#__ed_size_t


	)

28 #ide
__ed_mloc_d_oc


29 
	#__ed_wch_t


	)

30 
	#__ed_NULL


	)

32 
	~<ddef.h
>

34 
	g__BEGIN_DECLS


36 #ide
__ed_mloc_d_oc


37 
	#_STDLIB_H
 1

	)

39 #i(
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8
&& !defed 
_SYS_WAIT_H


41 
	~<bs/waags.h
>

42 
	~<bs/waus.h
>

44 #ifde
__USE_BSD


49 #i
defed
 
__GNUC__
 && !defed 
__lulus


50 
	#__WAIT_INT
(
us
) \

51 (
	`__exnsi__
 (((uni { 
	`__tyof
(
us

__
; 
__i
; }) \

52 { .
__
 = (
us
}).
__i
))

	)

54 
	#__WAIT_INT
(
us
(*(*&(us))

	)

62 #i!
defed
 
__GNUC__
 || __GNUC__ < 2 || defed 
__lulus


63 
	#__WAIT_STATUS
 *

	)

64 
	#__WAIT_STATUS_DEFN
 *

	)

69 
wa
 *
	m__ur
;

70 *
	m__
;

71 } 
	t__WAIT_STATUS
 
	t__ibu__
 ((
	t__t_uni__
));

72 
	#__WAIT_STATUS_DEFN
 *

	)

77 
	#__WAIT_INT
(
us
(us)

	)

78 
	#__WAIT_STATUS
 *

	)

79 
	#__WAIT_STATUS_DEFN
 *

	)

84 
	#WEXITSTATUS
(
us

	`__WEXITSTATUS
 (
	`__WAIT_INT
 (us))

	)

85 
	#WTERMSIG
(
us

	`__WTERMSIG
 (
	`__WAIT_INT
 (us))

	)

86 
	#WSTOPSIG
(
us

	`__WSTOPSIG
 (
	`__WAIT_INT
 (us))

	)

87 
	#WIFEXITED
(
us

	`__WIFEXITED
 (
	`__WAIT_INT
 (us))

	)

88 
	#WIFSIGNALED
(
us

	`__WIFSIGNALED
 (
	`__WAIT_INT
 (us))

	)

89 
	#WIFSTOPPED
(
us

	`__WIFSTOPPED
 (
	`__WAIT_INT
 (us))

	)

90 #ifde
__WIFCONTINUED


91 
	#WIFCONTINUED
(
us

	`__WIFCONTINUED
 (
	`__WAIT_INT
 (us))

	)

95 
__BEGIN_NAMESPACE_STD


99 
	mqu
;

100 
	mm
;

101 } 
	tdiv_t
;

104 #ide
__ldiv_t_defed


107 
	mqu
;

108 
	mm
;

109 } 
	tldiv_t
;

110 
	#__ldiv_t_defed
 1

	)

112 
	g__END_NAMESPACE_STD


114 #i
defed
 
__USE_ISOC99
 && !defed 
__div_t_defed


115 
__BEGIN_NAMESPACE_C99


117 
__exnsi__
 struct

119 
	mqu
;

120 
	mm
;

121 } 
	tdiv_t
;

122 
	#__div_t_defed
 1

	)

123 
	g__END_NAMESPACE_C99


128 
	#RAND_MAX
 2147483647

	)

133 
	#EXIT_FAILURE
 1

	)

134 
	#EXIT_SUCCESS
 0

	)

138 
	#MB_CUR_MAX
 (
	`__y_g_mb_cur_max
 ())

	)

139 
size_t
 
	$__y_g_mb_cur_max
 (
__THROW
 
__wur
;

142 
__BEGIN_NAMESPACE_STD


144 
	$of
 (cڡ *
__Ō
)

145 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

147 
	$oi
 (cڡ *
__Ō
)

148 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

150 
	$
 (cڡ *
__Ō
)

151 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

152 
__END_NAMESPACE_STD


154 #i
defed
 
__USE_ISOC99
 || defed 
__USE_MISC


155 
__BEGIN_NAMESPACE_C99


157 
__exnsi__
 
	$l
 (cڡ *
__Ō
)

158 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

159 
__END_NAMESPACE_C99


162 
__BEGIN_NAMESPACE_STD


164 
	$od
 (cڡ *
__ri
 
__Ō
,

165 **
__ri
 
__dr
)

166 
__THROW
 
	`__nnu
 ((1));

167 
__END_NAMESPACE_STD


169 #ifdef 
__USE_ISOC99


170 
__BEGIN_NAMESPACE_C99


172 
	$of
 (cڡ *
__ri
 
__Ō
,

173 **
__ri
 
__dr

__THROW
 
	`__nnu
 ((1));

175 
	$d
 (cڡ *
__ri
 
__Ō
,

176 **
__ri
 
__dr
)

177 
__THROW
 
	`__nnu
 ((1));

178 
__END_NAMESPACE_C99


181 
__BEGIN_NAMESPACE_STD


183 
	$
 (cڡ *
__ri
 
__Ō
,

184 **
__ri
 
__dr
, 
__ba
)

185 
__THROW
 
	`__nnu
 ((1));

187 
	$oul
 (cڡ *
__ri
 
__Ō
,

188 **
__ri
 
__dr
, 
__ba
)

189 
__THROW
 
	`__nnu
 ((1));

190 
__END_NAMESPACE_STD


192 #ifde
__USE_BSD


194 
__exnsi__


195 
	$oq
 (cڡ *
__ri
 
__Ō
,

196 **
__ri
 
__dr
, 
__ba
)

197 
__THROW
 
	`__nnu
 ((1));

199 
__exnsi__


200 
	$ouq
 (cڡ *
__ri
 
__Ō
,

201 **
__ri
 
__dr
, 
__ba
)

202 
__THROW
 
	`__nnu
 ((1));

205 #i
defed
 
__USE_ISOC99
 || defed 
__USE_MISC


206 
__BEGIN_NAMESPACE_C99


208 
__exnsi__


209 
	$l
 (cڡ *
__ri
 
__Ō
,

210 **
__ri
 
__dr
, 
__ba
)

211 
__THROW
 
	`__nnu
 ((1));

213 
__exnsi__


214 
	$ou
 (cڡ *
__ri
 
__Ō
,

215 **
__ri
 
__dr
, 
__ba
)

216 
__THROW
 
	`__nnu
 ((1));

217 
__END_NAMESPACE_C99


221 #ifde
__USE_GNU


235 
	~<xlo.h
>

239 
	$_l
 (cڡ *
__ri
 
__Ō
,

240 **
__ri
 
__dr
, 
__ba
,

241 
__lo_t
 
__loc

__THROW
 
	`__nnu
 ((1, 4));

243 
	$oul_l
 (cڡ *
__ri
 
__Ō
,

244 **
__ri
 
__dr
,

245 
__ba
, 
__lo_t
 
__loc
)

246 
__THROW
 
	`__nnu
 ((1, 4));

248 
__exnsi__


249 
	$l_l
 (cڡ *
__ri
 
__Ō
,

250 **
__ri
 
__dr
, 
__ba
,

251 
__lo_t
 
__loc
)

252 
__THROW
 
	`__nnu
 ((1, 4));

254 
__exnsi__


255 
	$ou_l
 (cڡ *
__ri
 
__Ō
,

256 **
__ri
 
__dr
,

257 
__ba
, 
__lo_t
 
__loc
)

258 
__THROW
 
	`__nnu
 ((1, 4));

260 
	$od_l
 (cڡ *
__ri
 
__Ō
,

261 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

262 
__THROW
 
	`__nnu
 ((1, 3));

264 
	$of_l
 (cڡ *
__ri
 
__Ō
,

265 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

266 
__THROW
 
	`__nnu
 ((1, 3));

268 
	$d_l
 (cڡ *
__ri
 
__Ō
,

269 **
__ri
 
__dr
,

270 
__lo_t
 
__loc
)

271 
__THROW
 
	`__nnu
 ((1, 3));

275 #ifde
__USE_EXTERN_INLINES


276 
__BEGIN_NAMESPACE_STD


277 
__ex_le
 

278 
	`__NTH
 (
	$oi
 (cڡ *
__Ō
))

280  (
	`
 (
__Ō
, (**
NULL
, 10);

281 
	}
}

282 
__ex_le
 

283 
__NTH
 (
	$
 (cڡ *
__Ō
))

285  
	`
 (
__Ō
, (**
NULL
, 10);

286 
	}
}

287 
	g__END_NAMESPACE_STD


289 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


290 
__BEGIN_NAMESPACE_C99


291 
__exnsi__
 
__ex_le
 

292 
__NTH
 (
	$l
 (cڡ *
__Ō
))

294  
	`l
 (
__Ō
, (**
NULL
, 10);

295 
	}
}

296 
	g__END_NAMESPACE_C99


301 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN_EXTENDED


305 *
	$l64a
 (
__n

__THROW
 
__wur
;

308 
	$a64l
 (cڡ *
__s
)

309 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

313 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_BSD


314 
	~<sys/tys.h
>

321 
	$ndom
 (
__THROW
;

324 
	$dom
 (
__ed

__THROW
;

330 *
	$e
 (
__ed
, *
__ebuf
,

331 
size_t
 
__

__THROW
 
	`__nnu
 ((2));

335 *
	$te
 (*
__ebuf

__THROW
 
	`__nnu
 ((1));

338 #ifde
__USE_MISC


343 
	sndom_da


345 
t32_t
 *

;

346 
t32_t
 *

;

347 
t32_t
 *
e
;

348 
nd_ty
;

349 
nd_deg
;

350 
nd_p
;

351 
t32_t
 *
d_r
;

354 
	$ndom_r
 (
ndom_da
 *
__ri
 
__buf
,

355 
t32_t
 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

357 
	$dom_r
 (
__ed
, 
ndom_da
 *
__buf
)

358 
__THROW
 
	`__nnu
 ((2));

360 
	$e_r
 (
__ed
, *
__ri
 
__ebuf
,

361 
size_t
 
__
,

362 
ndom_da
 *
__ri
 
__buf
)

363 
__THROW
 
	`__nnu
 ((2, 4));

365 
	$te_r
 (*
__ri
 
__ebuf
,

366 
ndom_da
 *
__ri
 
__buf
)

367 
__THROW
 
	`__nnu
 ((1, 2));

372 
__BEGIN_NAMESPACE_STD


374 
	$nd
 (
__THROW
;

376 
	$d
 (
__ed

__THROW
;

377 
__END_NAMESPACE_STD


379 #ifde
__USE_POSIX


381 
	$nd_r
 (*
__ed

__THROW
;

385 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


389 
	$dnd48
 (
__THROW
;

390 
	$d48
 (
__xsubi
[3]
__THROW
 
	`__nnu
 ((1));

393 
	$̪d48
 (
__THROW
;

394 
	$Īd48
 (
__xsubi
[3])

395 
__THROW
 
	`__nnu
 ((1));

398 
	$mnd48
 (
__THROW
;

399 
	$jnd48
 (
__xsubi
[3])

400 
__THROW
 
	`__nnu
 ((1));

403 
	$d48
 (
__edv

__THROW
;

404 *
	$ed48
 (
__ed16v
[3])

405 
__THROW
 
	`__nnu
 ((1));

406 
	$lcg48
 (
__m
[7]
__THROW
 
	`__nnu
 ((1));

408 #ifde
__USE_MISC


412 
	sdnd48_da


414 
__x
[3];

415 
__d_x
[3];

416 
__c
;

417 
__
;

418 
__exnsi__
 
__a
;

423 
	$dnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

424 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

425 
	$d48_r
 (
__xsubi
[3],

426 
dnd48_da
 *
__ri
 
__bufr
,

427 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

430 
	$̪d48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

431 *
__ri
 
__su
)

432 
__THROW
 
	`__nnu
 ((1, 2));

433 
	$Īd48_r
 (
__xsubi
[3],

434 
dnd48_da
 *
__ri
 
__bufr
,

435 *
__ri
 
__su
)

436 
__THROW
 
	`__nnu
 ((1, 2));

439 
	$mnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

440 *
__ri
 
__su
)

441 
__THROW
 
	`__nnu
 ((1, 2));

442 
	$jnd48_r
 (
__xsubi
[3],

443 
dnd48_da
 *
__ri
 
__bufr
,

444 *
__ri
 
__su
)

445 
__THROW
 
	`__nnu
 ((1, 2));

448 
	$d48_r
 (
__edv
, 
dnd48_da
 *
__bufr
)

449 
__THROW
 
	`__nnu
 ((2));

451 
	$ed48_r
 (
__ed16v
[3],

452 
dnd48_da
 *
__bufr

__THROW
 
	`__nnu
 ((1, 2));

454 
	$lcg48_r
 (
__m
[7],

455 
dnd48_da
 *
__bufr
)

456 
__THROW
 
	`__nnu
 ((1, 2));

462 #ide
__mloc_d_oc_defed


463 
	#__mloc_d_oc_defed


	)

464 
__BEGIN_NAMESPACE_STD


466 *
	$mloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

468 *
	$oc
 (
size_t
 
__nmemb
, size_
__size
)

469 
__THROW
 
__ibu_mloc__
 
__wur
;

470 
__END_NAMESPACE_STD


473 #ide
__ed_mloc_d_oc


474 
__BEGIN_NAMESPACE_STD


480 *
	$loc
 (*
__r
, 
size_t
 
__size
)

481 
__THROW
 
__ibu_wn_unud_su__
;

483 
	$
 (*
__r

__THROW
;

484 
__END_NAMESPACE_STD


486 #ifdef 
__USE_MISC


488 
	$c
 (*
__r

__THROW
;

491 #i
defed
 
__USE_GNU
 || defed 
__USE_BSD
 || defed 
__USE_MISC


492 
	~<lo.h
>

495 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K
) \

496 || 
defed
 
__USE_BSD


498 *
	$vloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

501 #ifde
__USE_XOPEN2K


503 
	$posix_memign
 (**
__memr
, 
size_t
 
__ignmt
, size_
__size
)

504 
__THROW
 
	`__nnu
 ((1)
__wur
;

507 #ifde
__USE_ISOC11


509 *
	$igd_loc
 (
size_t
 
__ignmt
, size_
__size
)

510 
__THROW
 
__ibu_mloc__
 
	`__ibu_loc_size__
 ((2)
__wur
;

513 
__BEGIN_NAMESPACE_STD


515 
	$abt
 (
__THROW
 
	`__ibu__
 ((
__nܑu__
));

519 
	`ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

521 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


523 #ifde
__lulus


524 "C++" 
	`_quick_ex
 ((*
__func
) ())

525 
__THROW
 
	`__asm
 ("_quick_ex"
	`__nnu
 ((1));

527 
	`_quick_ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

530 
__END_NAMESPACE_STD


532 #ifdef 
__USE_MISC


535 
	`_ex
 ((*
__func
(
__us
, *
__g
), *__arg)

536 
__THROW
 
	`__nnu
 ((1));

539 
__BEGIN_NAMESPACE_STD


543 
	$ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

545 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


549 
	$quick_ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

551 
__END_NAMESPACE_STD


553 #ifde
__USE_ISOC99


554 
__BEGIN_NAMESPACE_C99


557 
	$_Ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

558 
__END_NAMESPACE_C99


562 
__BEGIN_NAMESPACE_STD


564 *
	$gv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

565 
__END_NAMESPACE_STD


567 #ifde
__USE_GNU


570 *
	$cu_gv
 (cڡ *
__me
)

571 
__THROW
 
	`__nnu
 ((1)
__wur
;

574 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


578 
	$punv
 (*
__rg

__THROW
 
	`__nnu
 ((1));

581 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K


584 
	$nv
 (cڡ *
__me
, cڡ *
__vue
, 
__a
)

585 
__THROW
 
	`__nnu
 ((2));

588 
	$unnv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1));

591 #ifdef 
__USE_MISC


595 
	$nv
 (
__THROW
;

599 #i
defed
 
__USE_MISC
 \

600 || (
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
)

606 *
	$mkmp
 (*
__me

__THROW
 
	`__nnu
 ((1));

609 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 \

610 || 
defed
 
__USE_XOPEN2K8


619 #ide
__USE_FILE_OFFSET64


620 
	$mkemp
 (*
__me

	`__nnu
 ((1)
__wur
;

622 #ifde
__REDIRECT


623 
	`__REDIRECT
 (
mkemp
, (*
__me
), 
mkemp64
)

624 
	`__nnu
 ((1)
__wur
;

626 
	#mkemp
 
mkemp64


	)

629 #ifde
__USE_LARGEFILE64


630 
	$mkemp64
 (*
__me

	`__nnu
 ((1)
__wur
;

634 #ifde
__USE_MISC


641 #ide
__USE_FILE_OFFSET64


642 
	$mkemps
 (*
__me
, 
__suffixn

	`__nnu
 ((1)
__wur
;

644 #ifde
__REDIRECT


645 
	`__REDIRECT
 (
mkemps
, (*
__me
, 
__suffixn
),

646 
mkemps64

	`__nnu
 ((1)
__wur
;

648 
	#mkemps
 
mkemps64


	)

651 #ifde
__USE_LARGEFILE64


652 
	$mkemps64
 (*
__me
, 
__suffixn
)

653 
	`__nnu
 ((1)
__wur
;

657 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K8


663 *
	$mkdmp
 (*
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

666 #ifde
__USE_GNU


673 #ide
__USE_FILE_OFFSET64


674 
	$mkoemp
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

676 #ifde
__REDIRECT


677 
	`__REDIRECT
 (
mkoemp
, (*
__me
, 
__ags
), 
mkoemp64
)

678 
	`__nnu
 ((1)
__wur
;

680 
	#mkoemp
 
mkoemp64


	)

683 #ifde
__USE_LARGEFILE64


684 
	$mkoemp64
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

693 #ide
__USE_FILE_OFFSET64


694 
	$mkoemps
 (*
__me
, 
__suffixn
, 
__ags
)

695 
	`__nnu
 ((1)
__wur
;

697 #ifde
__REDIRECT


698 
	`__REDIRECT
 (
mkoemps
, (*
__me
, 
__suffixn
,

699 
__ags
), 
mkoemps64
)

700 
	`__nnu
 ((1)
__wur
;

702 
	#mkoemps
 
mkoemps64


	)

705 #ifde
__USE_LARGEFILE64


706 
	$mkoemps64
 (*
__me
, 
__suffixn
, 
__ags
)

707 
	`__nnu
 ((1)
__wur
;

712 
__BEGIN_NAMESPACE_STD


717 
	$syem
 (cڡ *
__commd

__wur
;

718 
__END_NAMESPACE_STD


721 #ifdef 
__USE_GNU


724 *
	$nilize_fe_me
 (cڡ *
__me
)

725 
__THROW
 
	`__nnu
 ((1)
__wur
;

728 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


734 *
	$th
 (cڡ *
__ri
 
__me
,

735 *
__ri
 
__sved

__THROW
 
__wur
;

740 #ide
__COMPAR_FN_T


741 
	#__COMPAR_FN_T


	)

742 (*
	t__comr__t
) (const *, const *);

744 #ifdef 
__USE_GNU


745 
__comr__t
 
	tcomris__t
;

748 #ifde
__USE_GNU


749 (*
	t__comr_d__t
) (const *, const *, *);

752 
__BEGIN_NAMESPACE_STD


755 *
	$bch
 (cڡ *
__key
, cڡ *
__ba
,

756 
size_t
 
__nmemb
, size_
__size
, 
__comr__t
 
__comr
)

757 
	`__nnu
 ((1, 2, 5)
__wur
;

759 #ifde
__USE_EXTERN_INLINES


760 
	~<bs/dlib-bch.h
>

765 
	$qst
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

766 
__comr__t
 
__comr

	`__nnu
 ((1, 4));

767 #ifde
__USE_GNU


768 
	$qst_r
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

769 
__comr_d__t
 
__comr
, *
__g
)

770 
	`__nnu
 ((1, 4));

775 
	$abs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

776 
	$bs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

777 
__END_NAMESPACE_STD


779 #ifde
__USE_ISOC99


780 
__exnsi__
 
	$abs
 (
__x
)

781 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

785 
__BEGIN_NAMESPACE_STD


789 
div_t
 
	$div
 (
__num
, 
__dom
)

790 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

791 
ldiv_t
 
	$ldiv
 (
__num
, 
__dom
)

792 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

793 
__END_NAMESPACE_STD


795 #ifde
__USE_ISOC99


796 
__BEGIN_NAMESPACE_C99


797 
__exnsi__
 
div_t
 
	$div
 (
__num
,

798 
__dom
)

799 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

800 
__END_NAMESPACE_C99


804 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

805 || 
defed
 
__USE_SVID


812 *
	$ecvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

813 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

818 *
	$fcvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

819 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

824 *
	$gcvt
 (
__vue
, 
__ndig
, *
__buf
)

825 
__THROW
 
	`__nnu
 ((3)
__wur
;

828 #ifde
__USE_MISC


830 *
	$qecvt
 (
__vue
, 
__ndig
,

831 *
__ri
 
__det
, *__ri 
__sign
)

832 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

833 *
	$qfcvt
 (
__vue
, 
__ndig
,

834 *
__ri
 
__det
, *__ri 
__sign
)

835 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

836 *
	$qgcvt
 (
__vue
, 
__ndig
, *
__buf
)

837 
__THROW
 
	`__nnu
 ((3)
__wur
;

842 
	$ecvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

843 *
__ri
 
__sign
, *__ri 
__buf
,

844 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

845 
	$fcvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

846 *
__ri
 
__sign
, *__ri 
__buf
,

847 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

849 
	$qecvt_r
 (
__vue
, 
__ndig
,

850 *
__ri
 
__det
, *__ri 
__sign
,

851 *
__ri
 
__buf
, 
size_t
 
__n
)

852 
__THROW
 
	`__nnu
 ((3, 4, 5));

853 
	$qfcvt_r
 (
__vue
, 
__ndig
,

854 *
__ri
 
__det
, *__ri 
__sign
,

855 *
__ri
 
__buf
, 
size_t
 
__n
)

856 
__THROW
 
	`__nnu
 ((3, 4, 5));

860 
__BEGIN_NAMESPACE_STD


863 
	$mbn
 (cڡ *
__s
, 
size_t
 
__n

__THROW
;

866 
	$mbtowc
 (
wch_t
 *
__ri
 
__pwc
,

867 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

870 
	$womb
 (*
__s
, 
wch_t
 
__wch

__THROW
;

874 
size_t
 
	$mbowcs
 (
wch_t
 *
__ri
 
__pwcs
,

875 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

877 
size_t
 
	$wcombs
 (*
__ri
 
__s
,

878 cڡ 
wch_t
 *
__ri
 
__pwcs
, 
size_t
 
__n
)

879 
__THROW
;

880 
__END_NAMESPACE_STD


883 #ifde
__USE_SVID


888 
	$mch
 (cڡ *
__ڣ

__THROW
 
	`__nnu
 ((1)
__wur
;

892 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


899 
	$gsubt
 (**
__ri
 
__tip
,

900 *cڡ *
__ri
 
__toks
,

901 **
__ri
 
__vu
)

902 
__THROW
 
	`__nnu
 ((1, 2, 3)
__wur
;

906 #ifde
__USE_XOPEN


908 
	$tkey
 (cڡ *
__key

__THROW
 
	`__nnu
 ((1));

914 #ifde
__USE_XOPEN2KXSI


916 
	$posix_ݒ
 (
__oag

__wur
;

919 #ifde
__USE_XOPEN


924 
	$g
 (
__fd

__THROW
;

928 
	$uock
 (
__fd

__THROW
;

933 *
	$ame
 (
__fd

__THROW
 
__wur
;

936 #ifde
__USE_GNU


940 
	$ame_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
)

941 
__THROW
 
	`__nnu
 ((2));

944 
	`g
 ();

947 #ifde
__USE_BSD


951 
	$gldavg
 (
__ldavg
[], 
__m
)

952 
__THROW
 
	`__nnu
 ((1));

955 
	~<bs/dlib-t.h
>

958 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


959 
	~<bs/dlib.h
>

961 #ifde
__LDBL_COMPAT


962 
	~<bs/dlib-ldbl.h
>

966 #unde
__ed_mloc_d_oc


968 
__END_DECLS


	@/usr/include/string.h

22 #idef 
_STRING_H


23 
	#_STRING_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


30 
	#__ed_size_t


	)

31 
	#__ed_NULL


	)

32 
	~<ddef.h
>

39 #i
defed
 
__lulus
 && (__lulu>199711L || 
__GNUC_PREREQ
 (4, 4))

40 
	#__CORRECT_ISO_CPP_STRING_H_PROTO


	)

44 
__BEGIN_NAMESPACE_STD


46 *
	$memy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

47 
size_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

50 *
	$memmove
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

51 
__THROW
 
	`__nnu
 ((1, 2));

52 
__END_NAMESPACE_STD


57 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN


58 *
	$memcy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

59 
__c
, 
size_t
 
__n
)

60 
__THROW
 
	`__nnu
 ((1, 2));

64 
__BEGIN_NAMESPACE_STD


66 *
	$memt
 (*
__s
, 
__c
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

69 
	$memcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

70 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

73 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


76 *
	`memchr
 (*
__s
, 
__c
, 
size_t
 
__n
)

77 
__THROW
 
	`__asm
 ("memchr"
__ibu_pu__
 
	`__nnu
 ((1));

78 cڡ *
	`memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

79 
__THROW
 
	`__asm
 ("memchr"
__ibu_pu__
 
	`__nnu
 ((1));

81 #ifde
__OPTIMIZE__


82 
__ex_ways_le
 *

83 
	`memchr
 (*
__s
, 
__c
, 
size_t
 
__n

__THROW


85  
	`__but_memchr
 (
__s
, 
__c
, 
__n
);

88 
__ex_ways_le
 const *

89 
	`memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n

__THROW


91  
	`__but_memchr
 (
__s
, 
__c
, 
__n
);

94 
	}
}

96 *
	$memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

97 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

99 
__END_NAMESPACE_STD


101 #ifde
__USE_GNU


104 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


105 "C++" *
	$wmemchr
 (*
__s
, 
__c
)

106 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
 
	`__nnu
 ((1));

107 "C++" cڡ *
	$wmemchr
 (cڡ *
__s
, 
__c
)

108 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
 
	`__nnu
 ((1));

110 *
	$wmemchr
 (cڡ *
__s
, 
__c
)

111 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

115 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


116 "C++" *
	$memrchr
 (*
__s
, 
__c
, 
size_t
 
__n
)

117 
__THROW
 
	`__asm
 ("memrchr"
__ibu_pu__
 
	`__nnu
 ((1));

118 "C++" cڡ *
	$memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

119 
__THROW
 
	`__asm
 ("memrchr"
__ibu_pu__
 
	`__nnu
 ((1));

121 *
	$memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

122 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

127 
__BEGIN_NAMESPACE_STD


129 *
	$ry
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

130 
__THROW
 
	`__nnu
 ((1, 2));

132 *
	$y
 (*
__ri
 
__de
,

133 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

134 
__THROW
 
	`__nnu
 ((1, 2));

137 *
	$rt
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

138 
__THROW
 
	`__nnu
 ((1, 2));

140 *
	$t
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

141 
size_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

144 
	$rcmp
 (cڡ *
__s1
, cڡ *
__s2
)

145 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

147 
	$cmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

148 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

151 
	$rcl
 (cڡ *
__s1
, cڡ *
__s2
)

152 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

154 
size_t
 
	$rxm
 (*
__ri
 
__de
,

155 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

156 
__THROW
 
	`__nnu
 ((2));

157 
__END_NAMESPACE_STD


159 #ifde
__USE_XOPEN2K8


163 
	~<xlo.h
>

166 
	$rcl_l
 (cڡ *
__s1
, cڡ *
__s2
, 
__lo_t
 
__l
)

167 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 3));

169 
size_t
 
	$rxm_l
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
,

170 
__lo_t
 
__l

__THROW
 
	`__nnu
 ((2, 4));

173 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 \

174 || 
defed
 
__USE_XOPEN2K8


176 *
	$rdup
 (cڡ *
__s
)

177 
__THROW
 
__ibu_mloc__
 
	`__nnu
 ((1));

183 #i
defed
 
__USE_XOPEN2K8


184 *
	$dup
 (cڡ *
__rg
, 
size_t
 
__n
)

185 
__THROW
 
__ibu_mloc__
 
	`__nnu
 ((1));

188 #i
defed
 
__USE_GNU
 && defed 
__GNUC__


190 
	#rdu
(
s
) \

191 (
__exnsi__
 \

193 cڡ *
__d
 = (
s
); \

194 
size_t
 
__n
 = 
	`
 (
__d
) + 1; \

195 *
__w
 = (*
	`__but_lo
 (
__n
); \

196 (*
	`memy
 (
__w
, 
__d
, 
__n
); \

197 
	}
}))

	)

200 
	#du
(
s
, 
n
) \

201 (
__exnsi__
 \

203 cڡ *
__d
 = (
s
); \

204 
size_t
 
__n
 = 
	`n
 (
__d
, (
n
)); \

205 *
__w
 = (*
	`__but_lo
 (
__n
 + 1); \

206 
__w
[
__n
] = '\0'; \

207 (*
	`memy
 (
__w
, 
__d
, 
__n
); \

208 }))

	)

211 
	g__BEGIN_NAMESPACE_STD


213 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


216 *
rchr
 (*
__s
, 
__c
)

217 
__THROW
 
__asm
 ("rchr"
__ibu_pu__
 
__nnu
 ((1));

218 cڡ *
rchr
 (cڡ *
__s
, 
__c
)

219 
__THROW
 
__asm
 ("rchr"
__ibu_pu__
 
__nnu
 ((1));

221 #ifde
__OPTIMIZE__


222 
__ex_ways_le
 *

223 
rchr
 (*
__s
, 
__c

	g__THROW


225  
__but_rchr
 (
__s
, 
__c
);

228 
__ex_ways_le
 const *

229 
rchr
 (cڡ *
__s
, 
__c

	g__THROW


231  
__but_rchr
 (
__s
, 
__c
);

236 *
	$rchr
 (cڡ *
__s
, 
__c
)

237 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

240 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


243 *
	`chr
 (*
__s
, 
__c
)

244 
__THROW
 
	`__asm
 ("chr"
__ibu_pu__
 
	`__nnu
 ((1));

245 cڡ *
	`chr
 (cڡ *
__s
, 
__c
)

246 
__THROW
 
	`__asm
 ("chr"
__ibu_pu__
 
	`__nnu
 ((1));

248 #ifde
__OPTIMIZE__


249 
__ex_ways_le
 *

250 
	`chr
 (*
__s
, 
__c

__THROW


252  
	`__but_chr
 (
__s
, 
__c
);

255 
__ex_ways_le
 const *

256 
	`chr
 (cڡ *
__s
, 
__c

__THROW


258  
	`__but_chr
 (
__s
, 
__c
);

261 
	}
}

263 *
	$chr
 (cڡ *
__s
, 
__c
)

264 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

266 
__END_NAMESPACE_STD


268 #ifde
__USE_GNU


271 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


272 "C++" *
	$rchul
 (*
__s
, 
__c
)

273 
__THROW
 
	`__asm
 ("rchul"
__ibu_pu__
 
	`__nnu
 ((1));

274 "C++" cڡ *
	$rchul
 (cڡ *
__s
, 
__c
)

275 
__THROW
 
	`__asm
 ("rchul"
__ibu_pu__
 
	`__nnu
 ((1));

277 *
	$rchul
 (cڡ *
__s
, 
__c
)

278 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

282 
__BEGIN_NAMESPACE_STD


285 
size_t
 
	$rcn
 (cڡ *
__s
, cڡ *
__je
)

286 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

289 
size_t
 
	$rn
 (cڡ *
__s
, cڡ *
__ac
)

290 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

292 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


295 *
	`brk
 (*
__s
, cڡ *
__ac
)

296 
__THROW
 
	`__asm
 ("brk"
__ibu_pu__
 
	`__nnu
 ((1, 2));

297 cڡ *
	`brk
 (cڡ *
__s
, cڡ *
__ac
)

298 
__THROW
 
	`__asm
 ("brk"
__ibu_pu__
 
	`__nnu
 ((1, 2));

300 #ifde
__OPTIMIZE__


301 
__ex_ways_le
 *

302 
	`brk
 (*
__s
, cڡ *
__ac

__THROW


304  
	`__but_brk
 (
__s
, 
__ac
);

307 
__ex_ways_le
 const *

308 
	`brk
 (cڡ *
__s
, cڡ *
__ac

__THROW


310  
	`__but_brk
 (
__s
, 
__ac
);

313 
	}
}

315 *
	$brk
 (cڡ *
__s
, cڡ *
__ac
)

316 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

319 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


322 *
	`rr
 (*
__hayack
, cڡ *
__ed
)

323 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

324 cڡ *
	`rr
 (cڡ *
__hayack
, cڡ *
__ed
)

325 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

327 #ifde
__OPTIMIZE__


328 
__ex_ways_le
 *

329 
	`rr
 (*
__hayack
, cڡ *
__ed

__THROW


331  
	`__but_rr
 (
__hayack
, 
__ed
);

334 
__ex_ways_le
 const *

335 
	`rr
 (cڡ *
__hayack
, cڡ *
__ed

__THROW


337  
	`__but_rr
 (
__hayack
, 
__ed
);

340 
	}
}

342 *
	$rr
 (cڡ *
__hayack
, cڡ *
__ed
)

343 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

348 *
	$ok
 (*
__ri
 
__s
, cڡ *__ri 
__dim
)

349 
__THROW
 
	`__nnu
 ((2));

350 
__END_NAMESPACE_STD


354 *
	$__ok_r
 (*
__ri
 
__s
,

355 cڡ *
__ri
 
__dim
,

356 **
__ri
 
__ve_r
)

357 
__THROW
 
	`__nnu
 ((2, 3));

358 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


359 *
	$ok_r
 (*
__ri
 
__s
, cڡ *__ri 
__dim
,

360 **
__ri
 
__ve_r
)

361 
__THROW
 
	`__nnu
 ((2, 3));

364 #ifde
__USE_GNU


366 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


367 "C++" *
	$rr
 (*
__hayack
, cڡ *
__ed
)

368 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

369 "C++" cڡ *
	$rr
 (cڡ *
__hayack
,

370 cڡ *
__ed
)

371 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

373 *
	$rr
 (cڡ *
__hayack
, cڡ *
__ed
)

374 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

378 #ifde
__USE_GNU


382 *
	$memmem
 (cڡ *
__hayack
, 
size_t
 
__hayackn
,

383 cڡ *
__ed
, 
size_t
 
__edn
)

384 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 3));

388 *
	$__mempy
 (*
__ri
 
__de
,

389 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

390 
__THROW
 
	`__nnu
 ((1, 2));

391 *
	$mempy
 (*
__ri
 
__de
,

392 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

393 
__THROW
 
	`__nnu
 ((1, 2));

397 
__BEGIN_NAMESPACE_STD


399 
size_t
 
	$
 (cڡ *
__s
)

400 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

401 
__END_NAMESPACE_STD


403 #ifdef 
__USE_XOPEN2K8


406 
size_t
 
	$n
 (cڡ *
__rg
, 
size_t
 
__maxn
)

407 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

411 
__BEGIN_NAMESPACE_STD


413 *
	$
 (
__um

__THROW
;

414 
__END_NAMESPACE_STD


415 #i
defed
 
__USE_XOPEN2K
 || defed 
__USE_MISC


423 #i
defed
 
__USE_XOPEN2K
 && !defed 
__USE_GNU


426 #ifde
__REDIRECT_NTH


427 
	`__REDIRECT_NTH
 (
_r
,

428 (
__um
, *
__buf
, 
size_t
 
__bu
),

429 
__xpg__r

	`__nnu
 ((2));

431 
	$__xpg__r
 (
__um
, *
__buf
, 
size_t
 
__bu
)

432 
__THROW
 
	`__nnu
 ((2));

433 
	#_r
 
__xpg__r


	)

438 *
	$_r
 (
__um
, *
__buf
, 
size_t
 
__bu
)

439 
__THROW
 
	`__nnu
 ((2)
__wur
;

443 #ifde
__USE_XOPEN2K8


445 *
	$_l
 (
__um
, 
__lo_t
 
__l

__THROW
;

451 
	$__bzo
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

453 #ifde
__USE_BSD


455 
	$bcy
 (cڡ *
__c
, *
__de
, 
size_t
 
__n
)

456 
__THROW
 
	`__nnu
 ((1, 2));

459 
	$bzo
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

462 
	$bcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

463 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

466 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


469 *
	`dex
 (*
__s
, 
__c
)

470 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

471 cڡ *
	`dex
 (cڡ *
__s
, 
__c
)

472 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

474 #i
defed
 
__OPTIMIZE__
 && !defed 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


475 
__ex_ways_le
 *

476 
	`dex
 (*
__s
, 
__c

__THROW


478  
	`__but_dex
 (
__s
, 
__c
);

481 
__ex_ways_le
 const *

482 
	`dex
 (cڡ *
__s
, 
__c

__THROW


484  
	`__but_dex
 (
__s
, 
__c
);

487 
	}
}

489 *
	$dex
 (cڡ *
__s
, 
__c
)

490 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

494 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


497 *
	`rdex
 (*
__s
, 
__c
)

498 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

499 cڡ *
	`rdex
 (cڡ *
__s
, 
__c
)

500 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

502 #i
defed
 
__OPTIMIZE__
 && !defed 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


503 
__ex_ways_le
 *

504 
	`rdex
 (*
__s
, 
__c

__THROW


506  
	`__but_rdex
 (
__s
, 
__c
);

509 
__ex_ways_le
 const *

510 
	`rdex
 (cڡ *
__s
, 
__c

__THROW


512  
	`__but_rdex
 (
__s
, 
__c
);

515 
	}
}

517 *
	$rdex
 (cڡ *
__s
, 
__c
)

518 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

523 
	$ffs
 (
__i

__THROW
 
	`__ibu__
 ((
__cڡ__
));

527 #ifdef 
__USE_GNU


528 
	$ff
 (
__l

__THROW
 
	`__ibu__
 ((
__cڡ__
));

529 
__exnsi__
 
	$ffl
 (
__
)

530 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

534 
	$rcmp
 (cڡ *
__s1
, cڡ *
__s2
)

535 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

538 
	$cmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

539 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

542 #ifdef 
__USE_GNU


545 
	$rcmp_l
 (cڡ *
__s1
, cڡ *
__s2
,

546 
__lo_t
 
__loc
)

547 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 3));

549 
	$cmp_l
 (cڡ *
__s1
, cڡ *
__s2
,

550 
size_t
 
__n
, 
__lo_t
 
__loc
)

551 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 4));

554 #ifdef 
__USE_BSD


557 *
	$rp
 (**
__ri
 
__rgp
,

558 cڡ *
__ri
 
__dim
)

559 
__THROW
 
	`__nnu
 ((1, 2));

562 #ifdef 
__USE_XOPEN2K8


564 *
	$rsigl
 (
__sig

__THROW
;

567 *
	$__py
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

568 
__THROW
 
	`__nnu
 ((1, 2));

569 *
	$py
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

570 
__THROW
 
	`__nnu
 ((1, 2));

574 *
	$__y
 (*
__ri
 
__de
,

575 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

576 
__THROW
 
	`__nnu
 ((1, 2));

577 *
	$y
 (*
__ri
 
__de
,

578 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

579 
__THROW
 
	`__nnu
 ((1, 2));

582 #ifdef 
__USE_GNU


584 
	$rvscmp
 (cڡ *
__s1
, cڡ *
__s2
)

585 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

588 *
	$ry
 (*
__rg

__THROW
 
	`__nnu
 ((1));

591 *
	$memob
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

593 #ide
bame


598 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


599 "C++" *
	$bame
 (*
__fame
)

600 
__THROW
 
	`__asm
 ("bame"
	`__nnu
 ((1));

601 "C++" cڡ *
	$bame
 (cڡ *
__fame
)

602 
__THROW
 
	`__asm
 ("bame"
	`__nnu
 ((1));

604 *
	$bame
 (cڡ *
__fame

__THROW
 
	`__nnu
 ((1));

610 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

611 #i
defed
 
__OPTIMIZE__
 && !defed 
__OPTIMIZE_SIZE__
 \

612 && !
defed
 
__NO_INLINE__
 && !defed 
__lulus


632 
	~<bs/rg.h
>

635 
	~<bs/rg2.h
>

638 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


640 
	~<bs/rg3.h
>

644 
__END_DECLS


	@/usr/include/time.h

22 #idef 
_TIME_H


24 #i(! 
defed
 
__ed_time_t
 && !defed 
__ed_ock_t
 && \

25 ! 
defed
 
	g__ed_timeec
)

26 
	#_TIME_H
 1

	)

27 
	~<us.h
>

29 
	g__BEGIN_DECLS


33 #ifdef 
_TIME_H


35 
	#__ed_size_t


	)

36 
	#__ed_NULL


	)

37 
	~<ddef.h
>

41 
	~<bs/time.h
>

44 #i!
defed
 
__STRICT_ANSI__
 && !defed 
__USE_XOPEN2K


45 #ide
CLK_TCK


46 
	#CLK_TCK
 
CLOCKS_PER_SEC


	)

52 #i!
defed
 
__ock_t_defed
 && (defed 
_TIME_H
 || defed 
__ed_ock_t
)

53 
	#__ock_t_defed
 1

	)

55 
	~<bs/tys.h
>

57 
__BEGIN_NAMESPACE_STD


59 
__ock_t
 
	tock_t
;

60 
	g__END_NAMESPACE_STD


61 #i
defed
 
__USE_XOPEN
 || defed 
__USE_POSIX
 || defed 
__USE_MISC


62 
	$__USING_NAMESPACE_STD
(
ock_t
)

66 #unde
__ed_ock_t


68 #i!
defed
 
__time_t_defed
 && (defed 
_TIME_H
 || defed 
__ed_time_t
)

69 
	#__time_t_defed
 1

	)

71 
	~<bs/tys.h
>

73 
__BEGIN_NAMESPACE_STD


75 
__time_t
 
	ttime_t
;

76 
__END_NAMESPACE_STD


77 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC
 || defed 
__USE_SVID


78 
	$__USING_NAMESPACE_STD
(
time_t
)

82 #unde
__ed_time_t


84 #i!
defed
 
__ockid_t_defed
 && \

85 ((
defed
 
_TIME_H
 && defed 
__USE_POSIX199309
|| defed 
__ed_ockid_t
)

86 
	#__ockid_t_defed
 1

	)

88 
	~<bs/tys.h
>

91 
__ockid_t
 
	tockid_t
;

94 #unde
__ockid_time_t


96 #i!
defed
 
__tim_t_defed
 && \

97 ((
defed
 
_TIME_H
 && defed 
__USE_POSIX199309
|| defed 
__ed_tim_t
)

98 
	#__tim_t_defed
 1

	)

100 
	~<bs/tys.h
>

103 
__tim_t
 
	ttim_t
;

106 #unde
__ed_tim_t


109 #i(!
defed
 
__timeec_defed
 \

110 && ((
defed
 
_TIME_H
 \

111 && (
defed
 
__USE_POSIX199309
 || defed 
__USE_MISC
 \

112 || 
defed
 
__USE_ISOC11
)) \

113 || 
defed
 
__ed_timeec
))

114 
	#__timeec_defed
 1

	)

116 
	~<bs/tys.h
>

120 
	stimeec


122 
__time_t
 
tv_c
;

123 
__sys_g_t
 
tv_nc
;

127 #unde
__ed_timeec


130 #ifdef 
_TIME_H


131 
__BEGIN_NAMESPACE_STD


133 
	stm


135 
tm_c
;

136 
tm_m
;

137 
tm_hour
;

138 
tm_mday
;

139 
tm_m
;

140 
tm_yr
;

141 
tm_wday
;

142 
tm_yday
;

143 
tm_isd
;

145 #ifdef 
__USE_BSD


146 
tm_gmtoff
;

147 cڡ *
tm_ze
;

149 
__tm_gmtoff
;

150 cڡ *
__tm_ze
;

153 
__END_NAMESPACE_STD


154 #i
defed
 
__USE_XOPEN
 || defed 
__USE_POSIX
 || defed 
__USE_MISC


155 
	$__USING_NAMESPACE_STD
(
tm
)

159 #ifde
__USE_POSIX199309


161 
	simec


163 
timeec
 
_rv
;

164 
timeec
 
_vue
;

168 
sigevt
;

172 #ifde
__USE_XOPEN2K


173 #ide
__pid_t_defed


174 
__pid_t
 
	tpid_t
;

175 
	#__pid_t_defed


	)

180 #ifde
__USE_ISOC11


182 
	#TIME_UTC
 1

	)

186 
__BEGIN_NAMESPACE_STD


189 
ock_t
 
	$ock
 (
__THROW
;

192 
time_t
 
	$time
 (
time_t
 *
__tim

__THROW
;

195 
	$difime
 (
time_t
 
__time1
,ime_
__time0
)

196 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

199 
time_t
 
	$mktime
 (
tm
 *
__

__THROW
;

205 
size_t
 
	$rime
 (*
__ri
 
__s
, 
size_t
 
__maxsize
,

206 cڡ *
__ri
 
__fm
,

207 cڡ 
tm
 *
__ri
 
__

__THROW
;

208 
__END_NAMESPACE_STD


210 #ifde
__USE_XOPEN


213 *
	$time
 (cڡ *
__ri
 
__s
,

214 cڡ *
__ri
 
__fmt
, 
tm
 *
__
)

215 
__THROW
;

218 #ifde
__USE_XOPEN2K8


221 
	~<xlo.h
>

223 
size_t
 
	$rime_l
 (*
__ri
 
__s
, 
size_t
 
__maxsize
,

224 cڡ *
__ri
 
__fm
,

225 cڡ 
tm
 *
__ri
 
__
,

226 
__lo_t
 
__loc

__THROW
;

229 #ifde
__USE_GNU


230 *
	$time_l
 (cڡ *
__ri
 
__s
,

231 cڡ *
__ri
 
__fmt
, 
tm
 *
__
,

232 
__lo_t
 
__loc

__THROW
;

236 
__BEGIN_NAMESPACE_STD


239 
tm
 *
	$gmtime
 (cڡ 
time_t
 *
__tim

__THROW
;

243 
tm
 *
	$loime
 (cڡ 
time_t
 *
__tim

__THROW
;

244 
__END_NAMESPACE_STD


246 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


249 
tm
 *
	$gmtime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

250 
tm
 *
__ri
 
__

__THROW
;

254 
tm
 *
	$loime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

255 
tm
 *
__ri
 
__

__THROW
;

258 
__BEGIN_NAMESPACE_STD


261 *
	$asime
 (cڡ 
tm
 *
__

__THROW
;

264 *
	$ime
 (cڡ 
time_t
 *
__tim

__THROW
;

265 
__END_NAMESPACE_STD


267 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


272 *
	$asime_r
 (cڡ 
tm
 *
__ri
 
__
,

273 *
__ri
 
__buf

__THROW
;

276 *
	$ime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

277 *
__ri
 
__buf

__THROW
;

282 *
__tzme
[2];

283 
__daylight
;

284 
__timeze
;

287 #ifdef 
__USE_POSIX


289 *
tzme
[2];

293 
	$tzt
 (
__THROW
;

296 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


297 
daylight
;

298 
timeze
;

301 #ifde
__USE_SVID


304 
	$ime
 (cڡ 
time_t
 *
__wh

__THROW
;

310 
	#__ip
(
yr
) \

311 ((
yr
% 4 =0 && ((yr% 100 !0 || (yr% 400 =0))

	)

314 #ifde
__USE_MISC


319 
time_t
 
	$timegm
 (
tm
 *
__

__THROW
;

322 
time_t
 
	$timol
 (
tm
 *
__

__THROW
;

325 
	$dysize
 (
__yr

__THROW
 
	`__ibu__
 ((
__cڡ__
));

329 #ifde
__USE_POSIX199309


334 
	`nop
 (cڡ 
timeec
 *
__queed_time
,

335 
timeec
 *
__mag
);

339 
	$ock_gs
 (
ockid_t
 
__ock_id
, 
timeec
 *
__s

__THROW
;

342 
	$ock_gtime
 (
ockid_t
 
__ock_id
, 
timeec
 *
__

__THROW
;

345 
	$ock_ime
 (
ockid_t
 
__ock_id
, cڡ 
timeec
 *
__
)

346 
__THROW
;

348 #ifde
__USE_XOPEN2K


353 
	`ock_nop
 (
ockid_t
 
__ock_id
, 
__ags
,

354 cڡ 
timeec
 *
__q
,

355 
timeec
 *
__m
);

358 
	$ock_guockid
 (
pid_t
 
__pid
, 
ockid_t
 *
__ock_id

__THROW
;

363 
	$tim_
 (
ockid_t
 
__ock_id
,

364 
sigevt
 *
__ri
 
__evp
,

365 
tim_t
 *
__ri
 
__timid

__THROW
;

368 
	$tim_de
 (
tim_t
 
__timid

__THROW
;

371 
	$tim_ime
 (
tim_t
 
__timid
, 
__ags
,

372 cڡ 
imec
 *
__ri
 
__vue
,

373 
imec
 *
__ri
 
__ovue

__THROW
;

376 
	$tim_gtime
 (
tim_t
 
__timid
, 
imec
 *
__vue
)

377 
__THROW
;

380 
	$tim_govrun
 (
tim_t
 
__timid

__THROW
;

384 #ifde
__USE_ISOC11


386 
	$timeec_g
 (
timeec
 *
__ts
, 
__ba
)

387 
__THROW
 
	`__nnu
 ((1));

391 #ifde
__USE_XOPEN_EXTENDED


403 
gde_r
;

412 
tm
 *
	`gde
 (cڡ *
__rg
);

415 #ifde
__USE_GNU


426 
	`gde_r
 (cڡ *
__ri
 
__rg
,

427 
tm
 *
__ri
 
__sbu
);

430 
__END_DECLS


	@/usr/include/unistd.h

22 #idef 
_UNISTD_H


23 
	#_UNISTD_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


32 #ifde
__USE_XOPEN2K8


34 
	#_POSIX_VERSION
 200809L

	)

35 #i
defed
 
__USE_XOPEN2K


37 
	#_POSIX_VERSION
 200112L

	)

38 #i
defed
 
__USE_POSIX199506


40 
	#_POSIX_VERSION
 199506L

	)

41 #i
defed
 
__USE_POSIX199309


43 
	#_POSIX_VERSION
 199309L

	)

46 
	#_POSIX_VERSION
 199009L

	)

52 #ifde
__USE_XOPEN2K8


53 
	#__POSIX2_THIS_VERSION
 200809L

	)

55 #i
defed
 
__USE_XOPEN2K


57 
	#__POSIX2_THIS_VERSION
 200112L

	)

58 #i
defed
 
__USE_POSIX199506


60 
	#__POSIX2_THIS_VERSION
 199506L

	)

63 
	#__POSIX2_THIS_VERSION
 199209L

	)

67 
	#_POSIX2_VERSION
 
__POSIX2_THIS_VERSION


	)

71 
	#_POSIX2_C_BIND
 
__POSIX2_THIS_VERSION


	)

75 
	#_POSIX2_C_DEV
 
__POSIX2_THIS_VERSION


	)

79 
	#_POSIX2_SW_DEV
 
__POSIX2_THIS_VERSION


	)

83 
	#_POSIX2_LOCALEDEF
 
__POSIX2_THIS_VERSION


	)

86 #ifde
__USE_XOPEN2K8


87 
	#_XOPEN_VERSION
 700

	)

88 #i
defed
 
__USE_XOPEN2K


89 
	#_XOPEN_VERSION
 600

	)

90 #i
defed
 
__USE_UNIX98


91 
	#_XOPEN_VERSION
 500

	)

93 
	#_XOPEN_VERSION
 4

	)

97 
	#_XOPEN_XCU_VERSION
 4

	)

100 
	#_XOPEN_XPG2
 1

	)

101 
	#_XOPEN_XPG3
 1

	)

102 
	#_XOPEN_XPG4
 1

	)

105 
	#_XOPEN_UNIX
 1

	)

108 
	#_XOPEN_CRYPT
 1

	)

112 
	#_XOPEN_ENH_I18N
 1

	)

115 
	#_XOPEN_LEGACY
 1

	)

202 
	~<bs/posix_t.h
>

205 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


206 
	~<bs/vmts.h
>

210 
	#STDIN_FILENO
 0

	)

211 
	#STDOUT_FILENO
 1

	)

212 
	#STDERR_FILENO
 2

	)

217 
	~<bs/tys.h
>

219 #idef 
__ssize_t_defed


220 
__ssize_t
 
	tssize_t
;

221 
	#__ssize_t_defed


	)

224 
	#__ed_size_t


	)

225 
	#__ed_NULL


	)

226 
	~<ddef.h
>

228 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K


231 #ide
__gid_t_defed


232 
__gid_t
 
	tgid_t
;

233 
	#__gid_t_defed


	)

236 #ide
__uid_t_defed


237 
__uid_t
 
	tuid_t
;

238 
	#__uid_t_defed


	)

241 #ide
__off_t_defed


242 #ide
__USE_FILE_OFFSET64


243 
__off_t
 
	toff_t
;

245 
__off64_t
 
	toff_t
;

247 
	#__off_t_defed


	)

249 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


250 
__off64_t
 
	toff64_t
;

251 
	#__off64_t_defed


	)

254 #ide
__ucds_t_defed


255 
__ucds_t
 
	tucds_t
;

256 
	#__ucds_t_defed


	)

259 #ide
__pid_t_defed


260 
__pid_t
 
	tpid_t
;

261 
	#__pid_t_defed


	)

265 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K


266 #ide
___t_defed


267 
___t
 
	t_t
;

268 
	#___t_defed


	)

272 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN


273 #ide
__sockn_t_defed


274 
__sockn_t
 
	tsockn_t
;

275 
	#__sockn_t_defed


	)

281 
	#R_OK
 4

	)

282 
	#W_OK
 2

	)

283 
	#X_OK
 1

	)

284 
	#F_OK
 0

	)

287 
	$acss
 (cڡ *
__me
, 
__ty

__THROW
 
	`__nnu
 ((1));

289 #ifde
__USE_GNU


292 
	$euidacss
 (cڡ *
__me
, 
__ty
)

293 
__THROW
 
	`__nnu
 ((1));

296 
	$css
 (cڡ *
__me
, 
__ty
)

297 
__THROW
 
	`__nnu
 ((1));

300 #ifde
__USE_ATFILE


304 
	$cst
 (
__fd
, cڡ *
__fe
, 
__ty
, 
__ag
)

305 
__THROW
 
	`__nnu
 ((2)
__wur
;

310 #idef 
_STDIO_H


311 
	#SEEK_SET
 0

	)

312 
	#SEEK_CUR
 1

	)

313 
	#SEEK_END
 2

	)

314 #ifde
__USE_GNU


315 
	#SEEK_DATA
 3

	)

316 
	#SEEK_HOLE
 4

	)

320 #i
defed
 
__USE_BSD
 && !defed 
L_SET


322 
	#L_SET
 
SEEK_SET


	)

323 
	#L_INCR
 
SEEK_CUR


	)

324 
	#L_XTND
 
SEEK_END


	)

333 #ide
__USE_FILE_OFFSET64


334 
__off_t
 
	$lek
 (
__fd
, 
__off_t
 
__offt
, 
__wh

__THROW
;

336 #ifde
__REDIRECT_NTH


337 
__off64_t
 
	`__REDIRECT_NTH
 (
lek
,

338 (
__fd
, 
__off64_t
 
__offt
, 
__wh
),

339 
lek64
);

341 
	#lek
 
lek64


	)

344 #ifde
__USE_LARGEFILE64


345 
__off64_t
 
	$lek64
 (
__fd
, 
__off64_t
 
__offt
, 
__wh
)

346 
__THROW
;

353 
	`o
 (
__fd
);

360 
ssize_t
 
	$ad
 (
__fd
, *
__buf
, 
size_t
 
__nbys

__wur
;

366 
ssize_t
 
	$wre
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n

__wur
;

368 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


369 #ide
__USE_FILE_OFFSET64


376 
ssize_t
 
	$d
 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

377 
__off_t
 
__offt

__wur
;

384 
ssize_t
 
	$pwre
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n
,

385 
__off_t
 
__offt

__wur
;

387 #ifde
__REDIRECT


388 
ssize_t
 
	`__REDIRECT
 (
d
, (
__fd
, *
__buf
, 
size_t
 
__nbys
,

389 
__off64_t
 
__offt
),

390 
d64

__wur
;

391 
ssize_t
 
	`__REDIRECT
 (
pwre
, (
__fd
, cڡ *
__buf
,

392 
size_t
 
__nbys
, 
__off64_t
 
__offt
),

393 
pwre64

__wur
;

395 
	#d
 
d64


	)

396 
	#pwre
 
pwre64


	)

400 #ifde
__USE_LARGEFILE64


404 
ssize_t
 
	$d64
 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

405 
__off64_t
 
__offt

__wur
;

408 
ssize_t
 
	$pwre64
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n
,

409 
__off64_t
 
__offt

__wur
;

417 
	$pe
 (
__pedes
[2]
__THROW
 
__wur
;

419 #ifde
__USE_GNU


422 
	$pe2
 (
__pedes
[2], 
__ags

__THROW
 
__wur
;

432 
	$m
 (
__cds

__THROW
;

444 
	`p
 (
__cds
);

446 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

447 || 
defed
 
__USE_BSD


452 
__ucds_t
 
	$um
 (
__ucds_t
 
__vue
, __ucds_
__rv
)

453 
__THROW
;

460 
	`up
 (
__ucds_t
 
__ucds
);

469 
	`u
 ();

473 
	$chown
 (cڡ *
__fe
, 
__uid_t
 
__owr
, 
__gid_t
 
__group
)

474 
__THROW
 
	`__nnu
 ((1)
__wur
;

476 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


478 
	$fchown
 (
__fd
, 
__uid_t
 
__owr
, 
__gid_t
 
__group

__THROW
 
__wur
;

483 
	$lchown
 (cڡ *
__fe
, 
__uid_t
 
__owr
, 
__gid_t
 
__group
)

484 
__THROW
 
	`__nnu
 ((1)
__wur
;

488 #ifde
__USE_ATFILE


491 
	$fchowt
 (
__fd
, cڡ *
__fe
, 
__uid_t
 
__owr
,

492 
__gid_t
 
__group
, 
__ag
)

493 
__THROW
 
	`__nnu
 ((2)
__wur
;

497 
	$chd
 (cڡ *
__th

__THROW
 
	`__nnu
 ((1)
__wur
;

499 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


501 
	$fchd
 (
__fd

__THROW
 
__wur
;

511 *
	$gcwd
 (*
__buf
, 
size_t
 
__size

__THROW
 
__wur
;

513 #ifdef 
__USE_GNU


517 *
	$g_cut_d_me
 (
__THROW
;

520 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

521 || 
defed
 
__USE_BSD


525 *
	$gwd
 (*
__buf
)

526 
__THROW
 
	`__nnu
 ((1)
__ibu_dd__
 
__wur
;

531 
	$dup
 (
__fd

__THROW
 
__wur
;

534 
	$dup2
 (
__fd
, 
__fd2

__THROW
;

536 #ifde
__USE_GNU


539 
	$dup3
 (
__fd
, 
__fd2
, 
__ags

__THROW
;

543 **
__v
;

544 #ifde
__USE_GNU


545 **
v
;

551 
	$execve
 (cڡ *
__th
, *cڡ 
__gv
[],

552 *cڡ 
__vp
[]
__THROW
 
	`__nnu
 ((1, 2));

554 #ifde
__USE_XOPEN2K8


557 
	$xecve
 (
__fd
, *cڡ 
__gv
[], *cڡ 
__vp
[])

558 
__THROW
 
	`__nnu
 ((2));

563 
	$execv
 (cڡ *
__th
, *cڡ 
__gv
[])

564 
__THROW
 
	`__nnu
 ((1, 2));

568 
	$exee
 (cڡ *
__th
, cڡ *
__g
, ...)

569 
__THROW
 
	`__nnu
 ((1, 2));

573 
	$exe
 (cڡ *
__th
, cڡ *
__g
, ...)

574 
__THROW
 
	`__nnu
 ((1, 2));

578 
	$execvp
 (cڡ *
__fe
, *cڡ 
__gv
[])

579 
__THROW
 
	`__nnu
 ((1, 2));

584 
	$exep
 (cڡ *
__fe
, cڡ *
__g
, ...)

585 
__THROW
 
	`__nnu
 ((1, 2));

587 #ifde
__USE_GNU


590 
	$execv
 (cڡ *
__fe
, *cڡ 
__gv
[],

591 *cڡ 
__vp
[])

592 
__THROW
 
	`__nnu
 ((1, 2));

596 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


598 
	$ni
 (
__c

__THROW
 
__wur
;

603 
	$_ex
 (
__us

	`__ibu__
 ((
__nܑu__
));

609 
	~<bs/came.h
>

612 
	$thcf
 (cڡ *
__th
, 
__me
)

613 
__THROW
 
	`__nnu
 ((1));

616 
	$hcf
 (
__fd
, 
__me

__THROW
;

619 
	$syscf
 (
__me

__THROW
;

621 #ifdef 
__USE_POSIX2


623 
size_t
 
	$cfr
 (
__me
, *
__buf
, 
size_t
 
__n

__THROW
;

628 
__pid_t
 
	$gpid
 (
__THROW
;

631 
__pid_t
 
	$gid
 (
__THROW
;

634 
__pid_t
 
	$gpg
 (
__THROW
;

637 
__pid_t
 
	$__gpgid
 (
__pid_t
 
__pid

__THROW
;

638 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


639 
__pid_t
 
	$gpgid
 (
__pid_t
 
__pid

__THROW
;

646 
	$gid
 (
__pid_t
 
__pid
, __pid_
__pgid

__THROW
;

648 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


660 
	$g
 (
__THROW
;

667 
__pid_t
 
	$tsid
 (
__THROW
;

669 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


671 
__pid_t
 
	$gsid
 (
__pid_t
 
__pid

__THROW
;

675 
__uid_t
 
	$guid
 (
__THROW
;

678 
__uid_t
 
	$geuid
 (
__THROW
;

681 
__gid_t
 
	$ggid
 (
__THROW
;

684 
__gid_t
 
	$gegid
 (
__THROW
;

689 
	$ggroups
 (
__size
, 
__gid_t
 
__li
[]
__THROW
 
__wur
;

691 #ifdef 
__USE_GNU


693 
	$group_memb
 (
__gid_t
 
__gid

__THROW
;

700 
	$tuid
 (
__uid_t
 
__uid

__THROW
 
__wur
;

702 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


705 
	$euid
 (
__uid_t
 
__ruid
, __uid_
__euid

__THROW
 
__wur
;

708 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K


710 
	$uid
 (
__uid_t
 
__uid

__THROW
 
__wur
;

717 
	$tgid
 (
__gid_t
 
__gid

__THROW
 
__wur
;

719 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


722 
	$egid
 (
__gid_t
 
__rgid
, __gid_
__egid

__THROW
 
__wur
;

725 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K


727 
	$gid
 (
__gid_t
 
__gid

__THROW
 
__wur
;

730 #ifde
__USE_GNU


733 
	$gsuid
 (
__uid_t
 *
__ruid
, __uid_*
__euid
, __uid_*
__suid
)

734 
__THROW
;

738 
	$gsgid
 (
__gid_t
 *
__rgid
, __gid_*
__egid
, __gid_*
__sgid
)

739 
__THROW
;

743 
	$esuid
 (
__uid_t
 
__ruid
, __uid_
__euid
, __uid_
__suid
)

744 
__THROW
 
__wur
;

748 
	$esgid
 (
__gid_t
 
__rgid
, __gid_
__egid
, __gid_
__sgid
)

749 
__THROW
 
__wur
;

756 
__pid_t
 
	$fk
 (
__THROWNL
;

758 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

759 || 
defed
 
__USE_BSD


764 
__pid_t
 
	$vfk
 (
__THROW
;

770 *
	$yme
 (
__fd

__THROW
;

774 
	$yme_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
)

775 
__THROW
 
	`__nnu
 ((2)
__wur
;

779 
	$iy
 (
__fd

__THROW
;

781 #i
defed
 
__USE_BSD
 \

782 || (
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_UNIX98
)

785 
	$y
 (
__THROW
;

790 
	$lk
 (cڡ *
__om
, cڡ *
__to
)

791 
__THROW
 
	`__nnu
 ((1, 2)
__wur
;

793 #ifde
__USE_ATFILE


796 
	$lk
 (
__omfd
, cڡ *
__om
, 
__tofd
,

797 cڡ *
__to
, 
__ags
)

798 
__THROW
 
	`__nnu
 ((2, 4)
__wur
;

801 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K


803 
	$symlk
 (cڡ *
__om
, cڡ *
__to
)

804 
__THROW
 
	`__nnu
 ((1, 2)
__wur
;

809 
ssize_t
 
	$adlk
 (cڡ *
__ri
 
__th
,

810 *
__ri
 
__buf
, 
size_t
 
__n
)

811 
__THROW
 
	`__nnu
 ((1, 2)
__wur
;

814 #ifde
__USE_ATFILE


816 
	$symlk
 (cڡ *
__om
, 
__tofd
,

817 cڡ *
__to

__THROW
 
	`__nnu
 ((1, 3)
__wur
;

820 
ssize_t
 
	$adlk
 (
__fd
, cڡ *
__ri
 
__th
,

821 *
__ri
 
__buf
, 
size_t
 
__n
)

822 
__THROW
 
	`__nnu
 ((2, 3)
__wur
;

826 
	$uƚk
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1));

828 #ifde
__USE_ATFILE


830 
	$uƚk
 (
__fd
, cڡ *
__me
, 
__ag
)

831 
__THROW
 
	`__nnu
 ((2));

835 
	$rmd
 (cڡ *
__th

__THROW
 
	`__nnu
 ((1));

839 
__pid_t
 
	$tcgpg
 (
__fd

__THROW
;

842 
	$tcg
 (
__fd
, 
__pid_t
 
__pg_id

__THROW
;

849 *
	`glog
 ();

850 #i
defed
 
__USE_REENTRANT
 || defed 
__USE_POSIX199506


857 
	$glog_r
 (*
__me
, 
size_t
 
__me_n

	`__nnu
 ((1));

860 #ifdef 
__USE_BSD


862 
	$og
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1));

866 #ifdef 
__USE_POSIX2


870 
	#__ed_gt


	)

871 
	~<gt.h
>

875 #i
defed
 
__USE_BSD
 || defed 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


879 
	$ghome
 (*
__me
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

883 #i
defed
 
__USE_BSD
 || (defed 
__USE_XOPEN
 && !defed 
__USE_UNIX98
)

886 
	$thome
 (cڡ *
__me
, 
size_t
 
__n
)

887 
__THROW
 
	`__nnu
 ((1)
__wur
;

891 
	$thoid
 (
__id

__THROW
 
__wur
;

897 
	$gdomame
 (*
__me
, 
size_t
 
__n
)

898 
__THROW
 
	`__nnu
 ((1)
__wur
;

899 
	$tdomame
 (cڡ *
__me
, 
size_t
 
__n
)

900 
__THROW
 
	`__nnu
 ((1)
__wur
;

906 
	$vhgup
 (
__THROW
;

909 
	$voke
 (cڡ *
__fe

__THROW
 
	`__nnu
 ((1)
__wur
;

917 
	$of
 (*
__me_bufr
, 
size_t
 
__size
,

918 
size_t
 
__offt
, 
__s
)

919 
__THROW
 
	`__nnu
 ((1));

925 
	$ac
 (cڡ *
__me

__THROW
;

929 *
	$gurshl
 (
__THROW
;

930 
	$durshl
 (
__THROW
;

931 
	$turshl
 (
__THROW
;

937 
	$dm
 (
__nochd
, 
__noo

__THROW
 
__wur
;

941 #i
defed
 
__USE_BSD
 || (defed 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
)

944 
	$chro
 (cڡ *
__th

__THROW
 
	`__nnu
 ((1)
__wur
;

948 *
	$gss
 (cڡ *
__om

	`__nnu
 ((1));

956 
	`fsync
 (
__fd
);

959 #ifde
__USE_GNU


962 
	$syncfs
 (
__fd

__THROW
;

966 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


969 
	`ghoid
 ();

972 
	$sync
 (
__THROW
;

975 #i
defed
 
__USE_BSD
 || !defed 
__USE_XOPEN2K


978 
	$ggesize
 (
__THROW
 
	`__ibu__
 ((
__cڡ__
));

983 
	$gdbsize
 (
__THROW
;

989 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


992 #ide
__USE_FILE_OFFSET64


993 
	$un
 (cڡ *
__fe
, 
__off_t
 
__ngth
)

994 
__THROW
 
	`__nnu
 ((1)
__wur
;

996 #ifde
__REDIRECT_NTH


997 
	`__REDIRECT_NTH
 (
un
,

998 (cڡ *
__fe
, 
__off64_t
 
__ngth
),

999 
un64

	`__nnu
 ((1)
__wur
;

1001 
	#un
 
un64


	)

1004 #ifde
__USE_LARGEFILE64


1005 
	$un64
 (cڡ *
__fe
, 
__off64_t
 
__ngth
)

1006 
__THROW
 
	`__nnu
 ((1)
__wur
;

1011 #i
defed
 
__USE_BSD
 || defed 
__USE_POSIX199309
 \

1012 || 
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K


1015 #ide
__USE_FILE_OFFSET64


1016 
	$run
 (
__fd
, 
__off_t
 
__ngth

__THROW
 
__wur
;

1018 #ifde
__REDIRECT_NTH


1019 
	`__REDIRECT_NTH
 (
run
, (
__fd
, 
__off64_t
 
__ngth
),

1020 
run64

__wur
;

1022 
	#run
 
run64


	)

1025 #ifde
__USE_LARGEFILE64


1026 
	$run64
 (
__fd
, 
__off64_t
 
__ngth

__THROW
 
__wur
;

1032 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K
) \

1033 || 
defed
 
__USE_MISC


1037 
	$brk
 (*
__addr

__THROW
 
__wur
;

1043 *
	$sbrk
 (
_t
 
__d

__THROW
;

1047 #ifde
__USE_MISC


1058 
	$sys
 (
__syo
, ...
__THROW
;

1063 #i(
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
&& !defed 
F_LOCK


1075 
	#F_ULOCK
 0

	)

1076 
	#F_LOCK
 1

	)

1077 
	#F_TLOCK
 2

	)

1078 
	#F_TEST
 3

	)

1080 #ide
__USE_FILE_OFFSET64


1081 
	$lockf
 (
__fd
, 
__cmd
, 
__off_t
 
__n

__wur
;

1083 #ifde
__REDIRECT


1084 
	`__REDIRECT
 (
lockf
, (
__fd
, 
__cmd
, 
__off64_t
 
__n
),

1085 
lockf64

__wur
;

1087 
	#lockf
 
lockf64


	)

1090 #ifde
__USE_LARGEFILE64


1091 
	$lockf64
 (
__fd
, 
__cmd
, 
__off64_t
 
__n

__wur
;

1096 #ifde
__USE_GNU


1101 
	#TEMP_FAILURE_RETRY
(
exessi
) \

1102 (
__exnsi__
 \

1103 ({ 
__su
; \

1104 d
__su
 = ((
exessi
); \

1105 
__su
 =-1L && 
o
 =
EINTR
); \

1106 
__su
; 
	}
}))

	)

1109 #i
defed
 
__USE_POSIX199309
 || defed 
__USE_UNIX98


1112 
fdasync
 (
__fdes
);

1118 #ifdef 
__USE_XOPEN


1120 *
	$y
 (cڡ *
__key
, cڡ *
__
)

1121 
__THROW
 
	`__nnu
 ((1, 2));

1125 
	$y
 (*
__glibc_block
, 
__edag
)

1126 
__THROW
 
	`__nnu
 ((1));

1133 
	$swab
 (cڡ *
__ri
 
__om
, *__ri 
__to
,

1134 
ssize_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

1140 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K


1142 *
	$mid
 (*
__s

__THROW
;

1147 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


1148 
	~<bs/unid.h
>

1151 
__END_DECLS


	@/usr/include/alloca.h

18 #idef 
_ALLOCA_H


19 
	#_ALLOCA_H
 1

	)

21 
	~<us.h
>

23 
	#__ed_size_t


	)

24 
	~<ddef.h
>

26 
	g__BEGIN_DECLS


29 #unde
lo


32 *
	$lo
 (
size_t
 
__size

__THROW
;

34 #ifdef 
__GNUC__


35 
	#lo
(
size

	`__but_lo
 (size)

	)

38 
__END_DECLS


	@/usr/include/endian.h

18 #idef 
_ENDIAN_H


19 
	#_ENDIAN_H
 1

	)

21 
	~<us.h
>

31 
	#__LITTLE_ENDIAN
 1234

	)

32 
	#__BIG_ENDIAN
 4321

	)

33 
	#__PDP_ENDIAN
 3412

	)

36 
	~<bs/dn.h
>

40 #ide
__FLOAT_WORD_ORDER


41 
	#__FLOAT_WORD_ORDER
 
__BYTE_ORDER


	)

44 #ifdef 
__USE_BSD


45 
	#LITTLE_ENDIAN
 
__LITTLE_ENDIAN


	)

46 
	#BIG_ENDIAN
 
__BIG_ENDIAN


	)

47 
	#PDP_ENDIAN
 
__PDP_ENDIAN


	)

48 
	#BYTE_ORDER
 
__BYTE_ORDER


	)

51 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


52 
	#__LONG_LONG_PAIR
(
HI
, 
LO
LO, 
	)
HI

53 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


54 
	#__LONG_LONG_PAIR
(
HI
, 
LO
HI, 
	)
LO

58 #i
defed
 
__USE_BSD
 && !defed 
__ASSEMBLER__


60 
	~<bs/bysw.h
>

62 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


63 
	#htobe16
(
x

	`__bsw_16
 (x)

	)

64 
	#hte16
(
x
(x)

	)

65 
	#be16toh
(
x

	`__bsw_16
 (x)

	)

66 
	#16toh
(
x
(x)

	)

68 
	#htobe32
(
x

	`__bsw_32
 (x)

	)

69 
	#hte32
(
x
(x)

	)

70 
	#be32toh
(
x

	`__bsw_32
 (x)

	)

71 
	#32toh
(
x
(x)

	)

73 
	#htobe64
(
x

	`__bsw_64
 (x)

	)

74 
	#hte64
(
x
(x)

	)

75 
	#be64toh
(
x

	`__bsw_64
 (x)

	)

76 
	#64toh
(
x
(x)

	)

79 
	#htobe16
(
x
(x)

	)

80 
	#hte16
(
x

	`__bsw_16
 (x)

	)

81 
	#be16toh
(
x
(x)

	)

82 
	#16toh
(
x

	`__bsw_16
 (x)

	)

84 
	#htobe32
(
x
(x)

	)

85 
	#hte32
(
x

	`__bsw_32
 (x)

	)

86 
	#be32toh
(
x
(x)

	)

87 
	#32toh
(
x

	`__bsw_32
 (x)

	)

89 
	#htobe64
(
x
(x)

	)

90 
	#hte64
(
x

	`__bsw_64
 (x)

	)

91 
	#be64toh
(
x
(x)

	)

92 
	#64toh
(
x

	`__bsw_64
 (x)

	)

	@/usr/include/features.h

18 #idef 
_FEATURES_H


19 
	#_FEATURES_H
 1

	)

101 #unde
__USE_ISOC11


102 #unde
__USE_ISOC99


103 #unde
__USE_ISOC95


104 #unde
__USE_ISOCXX11


105 #unde
__USE_POSIX


106 #unde
__USE_POSIX2


107 #unde
__USE_POSIX199309


108 #unde
__USE_POSIX199506


109 #unde
__USE_XOPEN


110 #unde
__USE_XOPEN_EXTENDED


111 #unde
__USE_UNIX98


112 #unde
__USE_XOPEN2K


113 #unde
__USE_XOPEN2KXSI


114 #unde
__USE_XOPEN2K8


115 #unde
__USE_XOPEN2K8XSI


116 #unde
__USE_LARGEFILE


117 #unde
__USE_LARGEFILE64


118 #unde
__USE_FILE_OFFSET64


119 #unde
__USE_BSD


120 #unde
__USE_SVID


121 #unde
__USE_MISC


122 #unde
__USE_ATFILE


123 #unde
__USE_GNU


124 #unde
__USE_REENTRANT


125 #unde
__USE_FORTIFY_LEVEL


126 #unde
__KERNEL_STRICT_NAMES


130 #ide
_LOOSE_KERNEL_NAMES


131 
	#__KERNEL_STRICT_NAMES


	)

141 #i
defed
 
__GNUC__
 && defed 
__GNUC_MINOR__


142 
	#__GNUC_PREREQ
(
maj
, 
m
) \

143 ((
__GNUC__
 << 16+ 
__GNUC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

145 
	#__GNUC_PREREQ
(
maj
, 
m
0

	)

150 #ifde
_GNU_SOURCE


151 #unde
_ISOC95_SOURCE


152 
	#_ISOC95_SOURCE
 1

	)

153 #unde
_ISOC99_SOURCE


154 
	#_ISOC99_SOURCE
 1

	)

155 #unde
_ISOC11_SOURCE


156 
	#_ISOC11_SOURCE
 1

	)

157 #unde
_POSIX_SOURCE


158 
	#_POSIX_SOURCE
 1

	)

159 #unde
_POSIX_C_SOURCE


160 
	#_POSIX_C_SOURCE
 200809L

	)

161 #unde
_XOPEN_SOURCE


162 
	#_XOPEN_SOURCE
 700

	)

163 #unde
_XOPEN_SOURCE_EXTENDED


164 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

165 #unde
_LARGEFILE64_SOURCE


166 
	#_LARGEFILE64_SOURCE
 1

	)

167 #unde
_DEFAULT_SOURCE


168 
	#_DEFAULT_SOURCE
 1

	)

169 #unde
_BSD_SOURCE


170 
	#_BSD_SOURCE
 1

	)

171 #unde
_SVID_SOURCE


172 
	#_SVID_SOURCE
 1

	)

173 #unde
_ATFILE_SOURCE


174 
	#_ATFILE_SOURCE
 1

	)

179 #i(
defed
 
_DEFAULT_SOURCE
 \

180 || (!
defed
 
	g__STRICT_ANSI__
 \

181 && !
defed
 
	g_ISOC99_SOURCE
 \

182 && !
defed
 
	g_POSIX_SOURCE
 && !defed 
	g_POSIX_C_SOURCE
 \

183 && !
defed
 
	g_XOPEN_SOURCE
 \

184 && !
defed
 
	g_BSD_SOURCE
 && !defed 
	g_SVID_SOURCE
))

185 #unde
_DEFAULT_SOURCE


186 
	#_DEFAULT_SOURCE
 1

	)

187 #unde
_BSD_SOURCE


188 
	#_BSD_SOURCE
 1

	)

189 #unde
_SVID_SOURCE


190 
	#_SVID_SOURCE
 1

	)

194 #i(
defed
 
_ISOC11_SOURCE
 \

195 || (
defed
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 201112L))

196 
	#__USE_ISOC11
 1

	)

200 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

201 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

202 
	#__USE_ISOC99
 1

	)

206 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

207 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

208 
	#__USE_ISOC95
 1

	)

215 #i((
defed
 
__lulus
 && __cplusplus >= 201103L) \

216 || 
defed
 
__GXX_EXPERIMENTAL_CXX0X__
)

217 
	#__USE_ISOCXX11
 1

	)

223 #ifde
_DEFAULT_SOURCE


224 #i!
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE


225 
	#__USE_POSIX_IMPLICITLY
 1

	)

227 #unde
_POSIX_SOURCE


228 
	#_POSIX_SOURCE
 1

	)

229 #unde
_POSIX_C_SOURCE


230 
	#_POSIX_C_SOURCE
 200809L

	)

232 #i((!
defed
 
__STRICT_ANSI__
 || (
_XOPEN_SOURCE
 - 0) >= 500) && \

233 !
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE
)

234 
	#_POSIX_SOURCE
 1

	)

235 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

236 
	#_POSIX_C_SOURCE
 2

	)

237 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

238 
	#_POSIX_C_SOURCE
 199506L

	)

239 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

240 
	#_POSIX_C_SOURCE
 200112L

	)

242 
	#_POSIX_C_SOURCE
 200809L

	)

244 
	#__USE_POSIX_IMPLICITLY
 1

	)

247 #i
defed
 
_POSIX_SOURCE
 || 
_POSIX_C_SOURCE
 >1 || defed 
_XOPEN_SOURCE


248 
	#__USE_POSIX
 1

	)

251 #i
defed
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >2 || defed 
_XOPEN_SOURCE


252 
	#__USE_POSIX2
 1

	)

255 #i(
_POSIX_C_SOURCE
 - 0) >= 199309L

256 
	#__USE_POSIX199309
 1

	)

259 #i(
_POSIX_C_SOURCE
 - 0) >= 199506L

260 
	#__USE_POSIX199506
 1

	)

263 #i(
_POSIX_C_SOURCE
 - 0) >= 200112L

264 
	#__USE_XOPEN2K
 1

	)

265 #unde
__USE_ISOC95


266 
	#__USE_ISOC95
 1

	)

267 #unde
__USE_ISOC99


268 
	#__USE_ISOC99
 1

	)

271 #i(
_POSIX_C_SOURCE
 - 0) >= 200809L

272 
	#__USE_XOPEN2K8
 1

	)

273 #unde
_ATFILE_SOURCE


274 
	#_ATFILE_SOURCE
 1

	)

277 #ifdef 
_XOPEN_SOURCE


278 
	#__USE_XOPEN
 1

	)

279 #i(
_XOPEN_SOURCE
 - 0) >= 500

280 
	#__USE_XOPEN_EXTENDED
 1

	)

281 
	#__USE_UNIX98
 1

	)

282 #unde
_LARGEFILE_SOURCE


283 
	#_LARGEFILE_SOURCE
 1

	)

284 #i(
_XOPEN_SOURCE
 - 0) >= 600

285 #i(
_XOPEN_SOURCE
 - 0) >= 700

286 
	#__USE_XOPEN2K8
 1

	)

287 
	#__USE_XOPEN2K8XSI
 1

	)

289 
	#__USE_XOPEN2K
 1

	)

290 
	#__USE_XOPEN2KXSI
 1

	)

291 #unde
__USE_ISOC95


292 
	#__USE_ISOC95
 1

	)

293 #unde
__USE_ISOC99


294 
	#__USE_ISOC99
 1

	)

297 #ifde
_XOPEN_SOURCE_EXTENDED


298 
	#__USE_XOPEN_EXTENDED
 1

	)

303 #ifde
_LARGEFILE_SOURCE


304 
	#__USE_LARGEFILE
 1

	)

307 #ifde
_LARGEFILE64_SOURCE


308 
	#__USE_LARGEFILE64
 1

	)

311 #i
defed
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

312 
	#__USE_FILE_OFFSET64
 1

	)

315 #i
defed
 
_BSD_SOURCE
 || defed 
_SVID_SOURCE


316 
	#__USE_MISC
 1

	)

319 #ifdef 
_BSD_SOURCE


320 
	#__USE_BSD
 1

	)

323 #ifdef 
_SVID_SOURCE


324 
	#__USE_SVID
 1

	)

327 #ifdef 
_ATFILE_SOURCE


328 
	#__USE_ATFILE
 1

	)

331 #ifdef 
_GNU_SOURCE


332 
	#__USE_GNU
 1

	)

335 #i
defed
 
_REENTRANT
 || defed 
_THREAD_SAFE


336 
	#__USE_REENTRANT
 1

	)

339 #i
defed
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

340 && 
__GNUC_PREREQ
 (4, 1&& 
defed
 
	g__OPTIMIZE__
 && __OPTIMIZE__ > 0

341 #i
_FORTIFY_SOURCE
 > 1

342 
	#__USE_FORTIFY_LEVEL
 2

	)

344 
	#__USE_FORTIFY_LEVEL
 1

	)

347 
	#__USE_FORTIFY_LEVEL
 0

	)

352 
	~<dc-edef.h
>

360 #unde
__GNU_LIBRARY__


361 
	#__GNU_LIBRARY__
 6

	)

365 
	#__GLIBC__
 2

	)

366 
	#__GLIBC_MINOR__
 19

	)

368 
	#__GLIBC_PREREQ
(
maj
, 
m
) \

369 ((
__GLIBC__
 << 16+ 
__GLIBC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

372 #ide
__ASSEMBLER__


373 #ide
_SYS_CDEFS_H


374 
	~<sys/cdefs.h
>

379 #i
defed
 
__USE_FILE_OFFSET64
 && !defed 
__REDIRECT


380 
	#__USE_LARGEFILE
 1

	)

381 
	#__USE_LARGEFILE64
 1

	)

387 #i
__GNUC_PREREQ
 (2, 7&& 
defed
 
__OPTIMIZE__
 \

388 && !
defed
 
	g__OPTIMIZE_SIZE__
 && !defed 
	g__NO_INLINE__
 \

389 && 
defed
 
	g__ex_le


390 
	#__USE_EXTERN_INLINES
 1

	)

398 
	~<gnu/ubs.h
>

	@/usr/include/getopt.h

19 #ide
_GETOPT_H


21 #ide
__ed_gt


22 
	#_GETOPT_H
 1

	)

32 #i!
defed
 
__GNU_LIBRARY__


33 
	~<y.h
>

36 #ide
__THROW


37 #ide
__GNUC_PREREQ


38 
	#__GNUC_PREREQ
(
maj
, 
m
(0)

	)

40 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (2,8)

41 
	#__THROW
 
	`throw
 ()

	)

43 
	#__THROW


	)

47 #ifdef 
__lulus


57 *
ݏrg
;

71 
td
;

76 
݋
;

80 
tt
;

82 #ide
__ed_gt


104 
	sti


106 cڡ *
	gme
;

109 
	ghas_g
;

110 *
	gag
;

111 
	gv
;

116 
	#no_gumt
 0

	)

117 
	#qued_gumt
 1

	)

118 
	#tiڮ_gumt
 2

	)

146 #ifde
__GNU_LIBRARY__


150 
gt
 (
___gc
, *cڡ *
___gv
, cڡ *
__shtts
)

151 
__THROW
;

153 #i
defed
 
__ed_gt
 && defed 
__USE_POSIX2
 \

154 && !
defed
 
	g__USE_POSIX_IMPLICITLY
 && !defed 
	g__USE_GNU


158 #ifde
__REDIRECT


159 
__REDIRECT_NTH
 (
gt
, (
___gc
, *cڡ *
___gv
,

160 cڡ *
__shtts
),

161 
__posix_gt
);

163 
__posix_gt
 (
___gc
, *cڡ *
___gv
,

164 cڡ *
__shtts

__THROW
;

165 
	#gt
 
__posix_gt


	)

169 
gt
 ();

172 #ide
__ed_gt


173 
gt_lg
 (
___gc
, *cڡ *
___gv
,

174 cڡ *
__shtts
,

175 cڡ 
ti
 *
__lgts
, *
__lgd
)

176 
__THROW
;

177 
gt_lg_ly
 (
___gc
, *cڡ *
___gv
,

178 cڡ *
__shtts
,

179 cڡ 
ti
 *
__lgts
, *
__lgd
)

180 
__THROW
;

184 #ifdef 
__lulus


189 #unde
__ed_gt


	@/usr/include/libio.h

28 #ide
_IO_STDIO_H


29 
	#_IO_STDIO_H


	)

31 
	~<_G_cfig.h
>

33 
	#_IO_os_t
 
_G_os_t


	)

34 
	#_IO_os64_t
 
_G_os64_t


	)

35 
	#_IO_size_t
 
size_t


	)

36 
	#_IO_ssize_t
 
__ssize_t


	)

37 
	#_IO_off_t
 
__off_t


	)

38 
	#_IO_off64_t
 
__off64_t


	)

39 
	#_IO_pid_t
 
__pid_t


	)

40 
	#_IO_uid_t
 
__uid_t


	)

41 
	#_IO_icv_t
 
_G_icv_t


	)

42 
	#_IO_HAVE_ST_BLKSIZE
 
_G_HAVE_ST_BLKSIZE


	)

43 
	#_IO_BUFSIZ
 
_G_BUFSIZ


	)

44 
	#_IO_va_li
 
_G_va_li


	)

45 
	#_IO_wt_t
 
wt_t


	)

48 
	#__ed___va_li


	)

49 
	~<dg.h
>

50 #ifde
__GNUC_VA_LIST


51 #unde
_IO_va_li


52 
	#_IO_va_li
 
__gnuc_va_li


	)

55 #ide
__P


56 
	~<sys/cdefs.h
>

59 
	#_IO_UNIFIED_JUMPTABLES
 1

	)

61 #ide
EOF


62 
	#EOF
 (-1)

	)

64 #ide
NULL


65 #i
defed
 
__GNUG__
 && \

66 (
	g__GNUC__
 > 2 || (__GNUC__ =2 && 
__GNUC_MINOR__
 >= 8))

67 
	#NULL
 (
__nu
)

	)

69 #i!
defed
(
__lulus
)

70 
	#NULL
 ((*)0)

	)

72 
	#NULL
 (0)

	)

77 
	#_IOS_INPUT
 1

	)

78 
	#_IOS_OUTPUT
 2

	)

79 
	#_IOS_ATEND
 4

	)

80 
	#_IOS_APPEND
 8

	)

81 
	#_IOS_TRUNC
 16

	)

82 
	#_IOS_NOCREATE
 32

	)

83 
	#_IOS_NOREPLACE
 64

	)

84 
	#_IOS_BIN
 128

	)

92 
	#_IO_MAGIC
 0xFBAD0000

	)

93 
	#_OLD_STDIO_MAGIC
 0xFABC0000

	)

94 
	#_IO_MAGIC_MASK
 0xFFFF0000

	)

95 
	#_IO_USER_BUF
 1

	)

96 
	#_IO_UNBUFFERED
 2

	)

97 
	#_IO_NO_READS
 4

	)

98 
	#_IO_NO_WRITES
 8

	)

99 
	#_IO_EOF_SEEN
 0x10

	)

100 
	#_IO_ERR_SEEN
 0x20

	)

101 
	#_IO_DELETE_DONT_CLOSE
 0x40

	)

102 
	#_IO_LINKED
 0x80

	)

103 
	#_IO_IN_BACKUP
 0x100

	)

104 
	#_IO_LINE_BUF
 0x200

	)

105 
	#_IO_TIED_PUT_GET
 0x400

	)

106 
	#_IO_CURRENTLY_PUTTING
 0x800

	)

107 
	#_IO_IS_APPENDING
 0x1000

	)

108 
	#_IO_IS_FILEBUF
 0x2000

	)

109 
	#_IO_BAD_SEEN
 0x4000

	)

110 
	#_IO_USER_LOCK
 0x8000

	)

112 
	#_IO_FLAGS2_MMAP
 1

	)

113 
	#_IO_FLAGS2_NOTCANCEL
 2

	)

114 #ifde
_LIBC


115 
	#_IO_FLAGS2_FORTIFY
 4

	)

117 
	#_IO_FLAGS2_USER_WBUF
 8

	)

118 #ifde
_LIBC


119 
	#_IO_FLAGS2_SCANF_STD
 16

	)

120 
	#_IO_FLAGS2_NOCLOSE
 32

	)

121 
	#_IO_FLAGS2_CLOEXEC
 64

	)

125 
	#_IO_SKIPWS
 01

	)

126 
	#_IO_LEFT
 02

	)

127 
	#_IO_RIGHT
 04

	)

128 
	#_IO_INTERNAL
 010

	)

129 
	#_IO_DEC
 020

	)

130 
	#_IO_OCT
 040

	)

131 
	#_IO_HEX
 0100

	)

132 
	#_IO_SHOWBASE
 0200

	)

133 
	#_IO_SHOWPOINT
 0400

	)

134 
	#_IO_UPPERCASE
 01000

	)

135 
	#_IO_SHOWPOS
 02000

	)

136 
	#_IO_SCIENTIFIC
 04000

	)

137 
	#_IO_FIXED
 010000

	)

138 
	#_IO_UNITBUF
 020000

	)

139 
	#_IO_STDIO
 040000

	)

140 
	#_IO_DONT_CLOSE
 0100000

	)

141 
	#_IO_BOOLALPHA
 0200000

	)

144 
_IO_jump_t
; 
	g_IO_FILE
;

147 #ifde
_IO_MTSAFE_IO


148 #i
defed
 
__GLIBC__
 && __GLIBC__ >= 2

149 
	~<bs/dio-lock.h
>

154 
	t_IO_lock_t
;

160 
	s_IO_mk
 {

161 
_IO_mk
 *
	m_xt
;

162 
_IO_FILE
 *
	m_sbuf
;

166 
	m_pos
;

168 
t_ampos
(
ampos
 

{ 
	m_os
 = sp; }

169 
t_offt
(
offt
{ 
	m_pos
 = offt; 
	m_os
 = (
ampos
)(-2); }

170 
	mpublic
:

171 
ammk
(
ambuf
 *
sb
);

172 ~
ammk
();

173 
vg
({  
	m_os
 == -2; }

174 
d
(
ammk
&);

175 
d
();

180 
	e__codecvt_su


182 
	m__codecvt_ok
,

183 
	m__codecvt_l
,

184 
	m__codecvt_r
,

185 
	m__codecvt_nocv


188 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


191 
	s_IO_codecvt


193 (*
	m__codecvt_der
(
	m_IO_codecvt
 *);

194 
__codecvt_su
 (*
__codecvt_do_out
(
	m_IO_codecvt
 *,

195 
	m__mbe_t
 *,

196 cڡ 
	mwch_t
 *,

197 cڡ 
	mwch_t
 *,

198 cڡ 
	mwch_t
 **, *,

200 
__codecvt_su
 (*
__codecvt_do_unshi
(
	m_IO_codecvt
 *,

201 
	m__mbe_t
 *, *,

203 
__codecvt_su
 (*
__codecvt_do_
(
	m_IO_codecvt
 *,

204 
	m__mbe_t
 *,

206 cڡ **, 
	mwch_t
 *,

207 
	mwch_t
 *, wchar_t **);

208 (*
	m__codecvt_do_codg
(
	m_IO_codecvt
 *);

209 (*
	m__codecvt_do_ways_nocv
(
	m_IO_codecvt
 *);

210 (*
	m__codecvt_do_ngth
(
	m_IO_codecvt
 *, 
	m__mbe_t
 *,

211 cڡ *, cڡ *, 
	m_IO_size_t
);

212 (*
	m__codecvt_do_max_ngth
(
	m_IO_codecvt
 *);

214 
_IO_icv_t
 
	m__cd_
;

215 
_IO_icv_t
 
	m__cd_out
;

219 
	s_IO_wide_da


221 
wch_t
 *
	m_IO_ad_r
;

222 
wch_t
 *
	m_IO_ad_d
;

223 
wch_t
 *
	m_IO_ad_ba
;

224 
wch_t
 *
	m_IO_wre_ba
;

225 
wch_t
 *
	m_IO_wre_r
;

226 
wch_t
 *
	m_IO_wre_d
;

227 
wch_t
 *
	m_IO_buf_ba
;

228 
wch_t
 *
	m_IO_buf_d
;

230 
wch_t
 *
	m_IO_ve_ba
;

231 
wch_t
 *
	m_IO_backup_ba
;

233 
wch_t
 *
	m_IO_ve_d
;

235 
__mbe_t
 
	m_IO_e
;

236 
__mbe_t
 
	m_IO_ϡ_e
;

237 
_IO_codecvt
 
	m_codecvt
;

239 
wch_t
 
	m_shtbuf
[1];

241 cڡ 
_IO_jump_t
 *
	m_wide_vb
;

245 
	s_IO_FILE
 {

246 
	m_ags
;

247 
	#_IO_fe_ags
 
_ags


	)

251 * 
	m_IO_ad_r
;

252 * 
	m_IO_ad_d
;

253 * 
	m_IO_ad_ba
;

254 * 
	m_IO_wre_ba
;

255 * 
	m_IO_wre_r
;

256 * 
	m_IO_wre_d
;

257 * 
	m_IO_buf_ba
;

258 * 
	m_IO_buf_d
;

260 *
	m_IO_ve_ba
;

261 *
	m_IO_backup_ba
;

262 *
	m_IO_ve_d
;

264 
_IO_mk
 *
	m_mks
;

266 
_IO_FILE
 *
	m_cha
;

268 
	m_fo
;

270 
	m_blksize
;

272 
	m_ags2
;

274 
_IO_off_t
 
	m_d_offt
;

276 
	#__HAVE_COLUMN


	)

278 
	m_cur_cumn
;

279 sigd 
	m_vb_offt
;

280 
	m_shtbuf
[1];

284 
_IO_lock_t
 *
	m_lock
;

285 #ifde
_IO_USE_OLD_IO_FILE


288 
	s_IO_FILE_come


290 
_IO_FILE
 
	m_fe
;

292 #i
defed
 
_G_IO_IO_FILE_VERSION
 && _G_IO_IO_FILE_VERSION == 0x20001

293 
_IO_off64_t
 
	m_offt
;

294 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


296 
_IO_codecvt
 *
	m_codecvt
;

297 
_IO_wide_da
 *
	m_wide_da
;

298 
_IO_FILE
 *
	m_䓻s_li
;

299 *
	m_䓻s_buf
;

300 
size_t
 
	m_䓻s_size
;

302 *
	m__d1
;

303 *
	m__d2
;

304 *
	m__d3
;

305 *
	m__d4
;

306 
size_t
 
	m__d5
;

308 
	m_mode
;

310 
	m_unud2
[15 *  (- 4 *  (*-  (
size_t
)];

314 #ide
__lulus


315 
_IO_FILE
 
	t_IO_FILE
;

318 
	g_IO_FILE_us
;

320 
_IO_FILE_us
 
_IO_2_1_d_
;

321 
_IO_FILE_us
 
_IO_2_1_dout_
;

322 
_IO_FILE_us
 
_IO_2_1_dr_
;

323 #ide
_LIBC


324 
	#_IO_d
 ((
_IO_FILE
*)(&
_IO_2_1_d_
))

	)

325 
	#_IO_dout
 ((
_IO_FILE
*)(&
_IO_2_1_dout_
))

	)

326 
	#_IO_dr
 ((
_IO_FILE
*)(&
_IO_2_1_dr_
))

	)

328 
_IO_FILE
 *
_IO_d
 
ibu_hidd
;

329 
_IO_FILE
 *
_IO_dout
 
ibu_hidd
;

330 
_IO_FILE
 *
_IO_dr
 
ibu_hidd
;

338 
__ssize_t
 
	t__io_ad_
 (*
	t__cook
, *
	t__buf
, 
	tsize_t
 
	t__nbys
);

346 
__ssize_t
 
	t__io_wre_
 (*
	t__cook
, cڡ *
	t__buf
,

347 
	tsize_t
 
	t__n
);

355 
	t__io_ek_
 (*
	t__cook
, 
	t_IO_off64_t
 *
	t__pos
, 
	t__w
);

358 
	t__io_o_
 (*
	t__cook
);

361 #ifde
_GNU_SOURCE


363 
__io_ad_
 
	tcook_ad_funi_t
;

364 
__io_wre_
 
	tcook_wre_funi_t
;

365 
__io_ek_
 
	tcook_ek_funi_t
;

366 
__io_o_
 
	tcook_o_funi_t
;

371 
__io_ad_
 *
	mad
;

372 
__io_wre_
 *
	mwre
;

373 
__io_ek_
 *
	mek
;

374 
__io_o_
 *
	mo
;

375 } 
	t_IO_cook_io_funis_t
;

376 
_IO_cook_io_funis_t
 
	tcook_io_funis_t
;

378 
	g_IO_cook_fe
;

381 
_IO_cook_
 (
_IO_cook_fe
 *
__cfe
, 
__ad_wre
,

382 *
__cook
, 
_IO_cook_io_funis_t
 
__s
);

386 #ifde
__lulus


390 
__undow
 (
_IO_FILE
 *);

391 
__uow
 (
_IO_FILE
 *);

392 
__ovow
 (
_IO_FILE
 *, );

393 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


394 
_IO_wt_t
 
__wundow
 (
_IO_FILE
 *);

395 
_IO_wt_t
 
__wuow
 (
_IO_FILE
 *);

396 
_IO_wt_t
 
__wovow
 (
_IO_FILE
 *, _IO_wint_t);

399 #i 
__GNUC__
 >= 3

400 
	#_IO_BE
(
ex
, 
s

	`__but_ex
 (x),es)

	)

402 
	#_IO_BE
(
ex
, 
s
x)

	)

405 
	#_IO_gc_uocked
(
_
) \

406 (
	`_IO_BE
 ((
_
)->
_IO_ad_r
 >(_)->
_IO_ad_d
, 0) \

407 ? 
	`__uow
 (
_
: *(*(_)->
_IO_ad_r
++)

	)

408 
	#_IO_ekc_uocked
(
_
) \

409 (
	`_IO_BE
 ((
_
)->
_IO_ad_r
 >(_)->
_IO_ad_d
, 0) \

410 && 
	`__undow
 (
_
=
EOF
 ? EOF \

411 : *(*(
_
)->
_IO_ad_r
)

	)

412 
	#_IO_putc_uocked
(
_ch
, 
_
) \

413 (
	`_IO_BE
 ((
_
)->
_IO_wre_r
 >(_)->
_IO_wre_d
, 0) \

414 ? 
	`__ovow
 (
_
, ((
_ch
)) \

415 : ((*(
_
)->
_IO_wre_r
++ = (
_ch
)))

	)

417 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


418 
	#_IO_gwc_uocked
(
_
) \

419 (
	`_IO_BE
 ((
_
)->
_wide_da
 =
NULL
 \

420 || ((
_
)->
_wide_da
->
_IO_ad_r
 \

421 >(
_
)->
_wide_da
->
_IO_ad_d
), 0) \

422 ? 
	`__wuow
 (
_
: (
_IO_wt_t
*(_)->
_wide_da
->
_IO_ad_r
++)

	)

423 
	#_IO_putwc_uocked
(
_wch
, 
_
) \

424 (
	`_IO_BE
 ((
_
)->
_wide_da
 =
NULL
 \

425 || ((
_
)->
_wide_da
->
_IO_wre_r
 \

426 >(
_
)->
_wide_da
->
_IO_wre_d
), 0) \

427 ? 
	`__wovow
 (
_
, 
_wch
) \

428 : (
_IO_wt_t
(*(
_
)->
_wide_da
->
_IO_wre_r
++ = (
_wch
)))

	)

431 
	#_IO_of_uocked
(
__
(((__)->
_ags
 & 
_IO_EOF_SEEN
!0)

	)

432 
	#_IO__uocked
(
__
(((__)->
_ags
 & 
_IO_ERR_SEEN
!0)

	)

434 
_IO_gc
 (
_IO_FILE
 *
__
);

435 
_IO_putc
 (
__c
, 
_IO_FILE
 *
__
);

436 
_IO_of
 (
_IO_FILE
 *
__

__THROW
;

437 
_IO_
 (
_IO_FILE
 *
__

__THROW
;

439 
_IO_ekc_locked
 (
_IO_FILE
 *
__
);

442 
	#_IO_PENDING_OUTPUT_COUNT
(
_
) \

443 ((
_
)->
_IO_wre_r
 - (_)->
_IO_wre_ba
)

	)

445 
_IO_ockfe
 (
_IO_FILE
 *
__THROW
;

446 
_IO_fuockfe
 (
_IO_FILE
 *
__THROW
;

447 
_IO_rylockfe
 (
_IO_FILE
 *
__THROW
;

449 #ifde
_IO_MTSAFE_IO


450 
	#_IO_ekc
(
_

	`_IO_ekc_locked
 (_)

	)

451 
	#_IO_ockfe
(
_
) \

452 i(((
_
)->
_ags
 & 
_IO_USER_LOCK
=0
	`_IO_ockfe
 (_)

	)

453 
	#_IO_fuockfe
(
_
) \

454 i(((
_
)->
_ags
 & 
_IO_USER_LOCK
=0
	`_IO_fuockfe
 (_)

	)

456 
	#_IO_ekc
(
_

	`_IO_ekc_uocked
 (_)

	)

457 
	#_IO_ockfe
(
_


	)

458 
	#_IO_fuockfe
(
_


	)

459 
	#_IO_rylockfe
(
_


	)

460 
	#_IO_nup_gi_t
(
_f
, 
_


	)

461 
	#_IO_nup_gi_d
(
_Do


	)

464 
_IO_vfsnf
 (
_IO_FILE
 * 
__ri
, const * __restrict,

465 
_IO_va_li
, *
__ri
);

466 
_IO_vrtf
 (
_IO_FILE
 *
__ri
, const *__restrict,

467 
_IO_va_li
);

468 
_IO_ssize_t
 
_IO_dn
 (
_IO_FILE
 *, , _IO_ssize_t);

469 
_IO_size_t
 
_IO_sgn
 (
_IO_FILE
 *, *, _IO_size_t);

471 
_IO_off64_t
 
_IO_ekoff
 (
_IO_FILE
 *, _IO_off64_t, , );

472 
_IO_off64_t
 
_IO_ekpos
 (
_IO_FILE
 *, _IO_off64_t, );

474 
_IO__backup_
 (
_IO_FILE
 *
__THROW
;

476 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


477 
_IO_wt_t
 
_IO_gwc
 (
_IO_FILE
 *
__
);

478 
_IO_wt_t
 
_IO_putwc
 (
wch_t
 
__wc
, 
_IO_FILE
 *
__
);

479 
_IO_fwide
 (
_IO_FILE
 *
__
, 
__mode

__THROW
;

480 #i
__GNUC__
 >= 2

483 #i
defed
 
_LIBC
 && defed 
SHARED


484 
	~<shlib-comt.h
>

485 #i
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_1
)

486 
	#_IO_fwide_maybe_comtib
 \

487 (
	`__but_ex
 (&
_IO_d_ud
 =
NULL
, 0))

	)

488 cڡ 
_IO_d_ud
;

489 
wk_ex
 (
_IO_d_ud
);

492 #ide
_IO_fwide_maybe_comtib


493 
	#_IO_fwide_maybe_comtib
 (0)

	)

497 
	#_IO_fwide
(
__
, 
__mode
) \

498 ({ 
__su
 = (
__mode
); \

499 i(
__su
 < 0 && ! 
_IO_fwide_maybe_comtib
) \

501 i((
__
)->
_mode
 == 0) \

503 (
__
)->
_mode
 = -1; \

504 
__su
 = (
__
)->
_mode
; \

506 i(
	`__but_cڡt_p
 (
__mode
) && (__mode) == 0) \

507 
__su
 = 
_IO_fwide_maybe_comtib
 ? -1 : (
__
)->
_mode
; \

509 
__su
 = 
	`_IO_fwide
 (
__
, __result); \

510 
__su
; })

	)

513 
_IO_vfwsnf
 (
_IO_FILE
 * 
__ri
, cڡ 
wch_t
 * __restrict,

514 
_IO_va_li
, *
__ri
);

515 
_IO_vfwtf
 (
_IO_FILE
 *
__ri
, cڡ 
wch_t
 *__restrict,

516 
_IO_va_li
);

517 
_IO_ssize_t
 
_IO_wdn
 (
_IO_FILE
 *, 
wt_t
, _IO_ssize_t);

518 
_IO__wbackup_
 (
_IO_FILE
 *
__THROW
;

521 #ifde
__LDBL_COMPAT


522 
	~<bs/libio-ldbl.h
>

525 #ifde
__lulus


	@/usr/include/sched.h

19 #idef 
_SCHED_H


20 
	#_SCHED_H
 1

	)

22 
	~<us.h
>

25 
	~<bs/tys.h
>

27 
	#__ed_size_t


	)

28 
	~<ddef.h
>

30 
	#__ed_time_t


	)

31 
	#__ed_timeec


	)

32 
	~<time.h
>

34 #ide
__pid_t_defed


35 
__pid_t
 
	tpid_t
;

36 
	#__pid_t_defed


	)

41 
	~<bs/sched.h
>

43 
	#sched_iܙy
 
__sched_iܙy


	)

46 
__BEGIN_DECLS


49 
	$sched_am
 (
__pid_t
 
__pid
, cڡ 
sched_m
 *
__m
)

50 
__THROW
;

53 
	$sched_gm
 (
__pid_t
 
__pid
, 
sched_m
 *
__m

__THROW
;

56 
	$sched_tschedur
 (
__pid_t
 
__pid
, 
__picy
,

57 cڡ 
sched_m
 *
__m

__THROW
;

60 
	$sched_gschedur
 (
__pid_t
 
__pid

__THROW
;

63 
	$sched_yld
 (
__THROW
;

66 
	$sched_g_iܙy_max
 (
__gܙhm

__THROW
;

69 
	$sched_g_iܙy_m
 (
__gܙhm

__THROW
;

72 
	$sched__g_rv
 (
__pid_t
 
__pid
, 
timeec
 *
__t

__THROW
;

75 #ifde
__USE_GNU


77 
	#CPU_SETSIZE
 
__CPU_SETSIZE


	)

78 
	#CPU_SET
(
u
, 
u

	`__CPU_SET_S
 (u,  (
u_t_t
), cpu)

	)

79 
	#CPU_CLR
(
u
, 
u

	`__CPU_CLR_S
 (u,  (
u_t_t
), cpu)

	)

80 
	#CPU_ISSET
(
u
, 
u

	`__CPU_ISSET_S
 (u,  (
u_t_t
), \

81 
u
)

	)

82 
	#CPU_ZERO
(
u

	`__CPU_ZERO_S
 ( (
u_t_t
), cpu)

	)

83 
	#CPU_COUNT
(
u

	`__CPU_COUNT_S
 ( (
u_t_t
), cpu)

	)

85 
	#CPU_SET_S
(
u
, 
tsize
, 
u

	`__CPU_SET_S
 (u, ssize, cpu)

	)

86 
	#CPU_CLR_S
(
u
, 
tsize
, 
u

	`__CPU_CLR_S
 (u, ssize, cpu)

	)

87 
	#CPU_ISSET_S
(
u
, 
tsize
, 
u

	`__CPU_ISSET_S
 (cpu, setsize, \

88 
u
)

	)

89 
	#CPU_ZERO_S
(
tsize
, 
u

	`__CPU_ZERO_S
 (tsize, cpu)

	)

90 
	#CPU_COUNT_S
(
tsize
, 
u

	`__CPU_COUNT_S
 (tsize, cpu)

	)

92 
	#CPU_EQUAL
(
u1
, 
u2
) \

93 
	`__CPU_EQUAL_S
 ( (
u_t_t
), 
u1
, 
u2
)

	)

94 
	#CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

95 
	`__CPU_EQUAL_S
 (
tsize
, 
u1
, 
u2
)

	)

97 
	#CPU_AND
(
det
, 
ct1
, 
ct2
) \

98 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, &)

	)

99 
	#CPU_OR
(
det
, 
ct1
, 
ct2
) \

100 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, |)

	)

101 
	#CPU_XOR
(
det
, 
ct1
, 
ct2
) \

102 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, ^)

	)

103 
	#CPU_AND_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

104 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, &)

	)

105 
	#CPU_OR_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

106 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, |)

	)

107 
	#CPU_XOR_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

108 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, ^)

	)

110 
	#CPU_ALLOC_SIZE
(
cou

	`__CPU_ALLOC_SIZE
 (cou)

	)

111 
	#CPU_ALLOC
(
cou

	`__CPU_ALLOC
 (cou)

	)

112 
	#CPU_FREE
(
ut

	`__CPU_FREE
 (ut)

	)

116 
	$sched_ffy
 (
__pid_t
 
__pid
, 
size_t
 
__utsize
,

117 cڡ 
u_t_t
 *
__ut

__THROW
;

120 
	$sched_gaffy
 (
__pid_t
 
__pid
, 
size_t
 
__utsize
,

121 
u_t_t
 *
__ut

__THROW
;

124 
__END_DECLS


	@/usr/include/xlocale.h

20 #ide
_XLOCALE_H


21 
	#_XLOCALE_H
 1

	)

27 
	s__lo_ru


30 
__lo_da
 *
	m__los
[13];

33 cڡ *
	m__y_b
;

34 cڡ *
	m__y_tow
;

35 cڡ *
	m__y_tou
;

38 cڡ *
	m__mes
[13];

39 } *
	t__lo_t
;

42 
__lo_t
 
	tlo_t
;

	@/usr/include/_G_config.h

4 #ide
_G_cfig_h


5 
	#_G_cfig_h
 1

	)

9 
	~<bs/tys.h
>

10 
	#__ed_size_t


	)

11 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


12 
	#__ed_wch_t


	)

14 
	#__ed_NULL


	)

15 
	~<ddef.h
>

16 
	#__ed_mbe_t


	)

17 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


18 
	#__ed_wt_t


	)

20 
	~<wch.h
>

23 
__off_t
 
	m__pos
;

24 
__mbe_t
 
	m__e
;

25 } 
	t_G_os_t
;

28 
__off64_t
 
	m__pos
;

29 
__mbe_t
 
	m__e
;

30 } 
	t_G_os64_t
;

31 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


32 
	~<gcv.h
>

35 
__gcv_fo
 
	m__cd
;

38 
__gcv_fo
 
	m__cd
;

39 
__gcv__da
 
	m__da
;

40 } 
	m__combed
;

41 } 
	t_G_icv_t
;

46 
	#_G_va_li
 
__gnuc_va_li


	)

48 
	#_G_HAVE_MMAP
 1

	)

49 
	#_G_HAVE_MREMAP
 1

	)

51 
	#_G_IO_IO_FILE_VERSION
 0x20001

	)

54 
	#_G_HAVE_ST_BLKSIZE
 
	`defed
 (
_STATBUF_ST_BLKSIZE
)

	)

56 
	#_G_BUFSIZ
 8192

	)

	@/usr/include/stdc-predef.h

18 #idef 
_STDC_PREDEF_H


19 
	#_STDC_PREDEF_H
 1

	)

36 #ifde
__GCC_IEC_559


37 #i
__GCC_IEC_559
 > 0

38 
	#__STDC_IEC_559__
 1

	)

41 
	#__STDC_IEC_559__
 1

	)

44 #ifde
__GCC_IEC_559_COMPLEX


45 #i
__GCC_IEC_559_COMPLEX
 > 0

46 
	#__STDC_IEC_559_COMPLEX__
 1

	)

49 
	#__STDC_IEC_559_COMPLEX__
 1

	)

54 
	#__STDC_ISO_10646__
 201103L

	)

57 
	#__STDC_NO_THREADS__
 1

	)

	@/usr/include/gconv.h

22 #ide
_GCONV_H


23 
	#_GCONV_H
 1

	)

25 
	~<us.h
>

26 
	#__ed_mbe_t


	)

27 
	#__ed_wt_t


	)

28 
	~<wch.h
>

29 
	#__ed_size_t


	)

30 
	#__ed_wch_t


	)

31 
	~<ddef.h
>

34 
	#__UNKNOWN_10646_CHAR
 ((
wch_t
0xfffd)

	)

39 
	m__GCONV_OK
 = 0,

40 
	m__GCONV_NOCONV
,

41 
	m__GCONV_NODB
,

42 
	m__GCONV_NOMEM
,

44 
	m__GCONV_EMPTY_INPUT
,

45 
	m__GCONV_FULL_OUTPUT
,

46 
	m__GCONV_ILLEGAL_INPUT
,

47 
	m__GCONV_INCOMPLETE_INPUT
,

49 
	m__GCONV_ILLEGAL_DESCRIPTOR
,

50 
	m__GCONV_INTERNAL_ERROR


57 
	m__GCONV_IS_LAST
 = 0x0001,

58 
	m__GCONV_IGNORE_ERRORS
 = 0x0002,

59 
	m__GCONV_SWAP
 = 0x0004

64 
	g__gcv_
;

65 
	g__gcv__da
;

66 
	g__gcv_lded_obje
;

67 
	g__gcv_s_da
;

71 (*
	t__gcv_f
(
	t__gcv_
 *, 
	t__gcv__da
 *,

73 **, 
	tsize_t
 *, , );

76 
	$wt_t
 (*
	t__gcv_btowc_f
(
	t__gcv_
 *, );

79 (*
	t__gcv__f
(
	t__gcv_
 *);

80 (*
	t__gcv_d_f
(
	t__gcv_
 *);

84 (*
	t__gcv_s_f
(
	t__gcv_
 *,

85 
	t__gcv__da
 *, *,

89 
	tsize_t
 *);

92 (*
	t__gcv_s_cڋxt_f
) (*, const *,

97 (*
	t__gcv_s_quy_f
) (const *, const ***,

98 
	tsize_t
 *);

101 (*
	t__gcv_s__f
) (**, const *);

102 (*
	t__gcv_s_d_f
) (*);

104 
	s__gcv_s_da


107 
__gcv_s_f
 
__s_f
;

108 
__gcv_s_cڋxt_f
 
__s_cڋxt_f
;

109 
__gcv_s_d_f
 
__s_d_f
;

110 *
__da
;

111 
__gcv_s_da
 *
__xt
;

116 
	s__gcv_


118 
__gcv_lded_obje
 *
__shlib_hd
;

119 cڡ *
__modme
;

121 
__cou
;

123 *
__om_me
;

124 *
__to_me
;

126 
__gcv_f
 
__f
;

127 
__gcv_btowc_f
 
__btowc_f
;

128 
__gcv__f
 
___f
;

129 
__gcv_d_f
 
__d_f
;

133 
__m_eded_om
;

134 
__max_eded_om
;

135 
__m_eded_to
;

136 
__max_eded_to
;

139 
__eful
;

141 *
__da
;

146 
	s__gcv__da


148 *
__outbuf
;

149 *
__outbund
;

153 
__ags
;

157 
__voti_cou
;

161 
___u
;

163 
__mbe_t
 *
__
;

164 
__mbe_t
 
__e
;

168 
__gcv_s_da
 *
__s
;

173 
	s__gcv_fo


175 
size_t
 
__ns
;

176 
__gcv_
 *
__s
;

177 
__exnsi__
 
__gcv__da
 
__da
 
__exr
;

178 } *
	t__gcv_t
;

	@/usr/include/wchar.h

23 #ide
_WCHAR_H


25 #i!
defed
 
__ed_mbe_t
 && !defed 
__ed_wt_t


26 
	#_WCHAR_H
 1

	)

27 
	~<us.h
>

30 #ifde
_WCHAR_H


32 
	#__ed___FILE


	)

33 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


34 
	#__ed_FILE


	)

36 
	~<dio.h
>

38 
	#__ed___va_li


	)

39 
	~<dg.h
>

41 
	~<bs/wch.h
>

44 
	#__ed_size_t


	)

45 
	#__ed_wch_t


	)

46 
	#__ed_NULL


	)

48 #i
defed
 
_WCHAR_H
 || defed 
__ed_wt_t
 || !defed 
__WINT_TYPE__


49 #unde
__ed_wt_t


50 
	#__ed_wt_t


	)

51 
	~<ddef.h
>

55 #ide
_WINT_T


60 
	#_WINT_T


	)

61 
	twt_t
;

65 #i
defed
 
__lulus
 && defed 
_GLIBCPP_USE_NAMESPACES
 \

66 && 
defed
 
__WINT_TYPE__


67 
__BEGIN_NAMESPACE_STD


68 
__WINT_TYPE__
 
	twt_t
;

69 
	g__END_NAMESPACE_STD


74 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (4, 4)

75 
	#__CORRECT_ISO_CPP_WCHAR_H_PROTO


	)

79 #i(
defed
 
_WCHAR_H
 || defed 
__ed_mbe_t
&& !defed 
____mbe_t_defed


80 
	#____mbe_t_defed
 1

	)

84 
	m__cou
;

87 #ifde
__WINT_TYPE__


88 
__WINT_TYPE__
 
	m__wch
;

90 
wt_t
 
	m__wch
;

92 
	m__wchb
[4];

93 } 
	m__vue
;

94 } 
	t__mbe_t
;

96 #unde
__ed_mbe_t


101 #ifde
_WCHAR_H


103 #ide
__mbe_t_defed


104 
__BEGIN_NAMESPACE_C99


106 
__mbe_t
 
	tmbe_t
;

107 
	g__END_NAMESPACE_C99


108 
	#__mbe_t_defed
 1

	)

111 #ifde
__USE_GNU


112 
	$__USING_NAMESPACE_C99
(
mbe_t
)

115 #ide
WCHAR_MIN


117 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

118 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

121 #ide
WEOF


122 
	#WEOF
 (0xffffffffu)

	)

127 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_UNIX98


128 
	~<wy.h
>

132 
__BEGIN_DECLS


134 
__BEGIN_NAMESPACE_STD


137 
tm
;

138 
__END_NAMESPACE_STD


142 
	$__USING_NAMESPACE_STD
(
tm
)

145 
__BEGIN_NAMESPACE_STD


147 
wch_t
 *
	$wcsy
 (
wch_t
 *
__ri
 
__de
,

148 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

150 
wch_t
 *
	$wcy
 (
wch_t
 *
__ri
 
__de
,

151 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

152 
__THROW
;

155 
wch_t
 *
	$wcst
 (
wch_t
 *
__ri
 
__de
,

156 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

158 
wch_t
 *
	$wct
 (
wch_t
 *
__ri
 
__de
,

159 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

160 
__THROW
;

163 
	$wcscmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
)

164 
__THROW
 
__ibu_pu__
;

166 
	$wccmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

167 
__THROW
 
__ibu_pu__
;

168 
__END_NAMESPACE_STD


170 #ifde
__USE_XOPEN2K8


172 
	$wcscmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2

__THROW
;

175 
	$wccmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

176 
size_t
 
__n

__THROW
;

180 
	~<xlo.h
>

182 
	$wcscmp_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

183 
__lo_t
 
__loc

__THROW
;

185 
	$wccmp_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

186 
size_t
 
__n
, 
__lo_t
 
__loc

__THROW
;

189 
__BEGIN_NAMESPACE_STD


192 
	$wcscl
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2

__THROW
;

196 
size_t
 
	$wcsxm
 (
wch_t
 *
__ri
 
__s1
,

197 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n

__THROW
;

198 
__END_NAMESPACE_STD


200 #ifde
__USE_XOPEN2K8


206 
	$wcscl_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

207 
__lo_t
 
__loc

__THROW
;

212 
size_t
 
	$wcsxm_l
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

213 
size_t
 
__n
, 
__lo_t
 
__loc

__THROW
;

216 
wch_t
 *
	$wcsdup
 (cڡ 
wch_t
 *
__s

__THROW
 
__ibu_mloc__
;

219 
__BEGIN_NAMESPACE_STD


221 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


222 "C++" 
wch_t
 *
	$wcschr
 (
wch_t
 *
__wcs
, wch_
__wc
)

223 
__THROW
 
	`__asm
 ("wcschr"
__ibu_pu__
;

224 "C++" cڡ 
wch_t
 *
	$wcschr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

225 
__THROW
 
	`__asm
 ("wcschr"
__ibu_pu__
;

227 
wch_t
 *
	$wcschr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

228 
__THROW
 
__ibu_pu__
;

231 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


232 "C++" 
wch_t
 *
	$wcchr
 (
wch_t
 *
__wcs
, wch_
__wc
)

233 
__THROW
 
	`__asm
 ("wcchr"
__ibu_pu__
;

234 "C++" cڡ 
wch_t
 *
	$wcchr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

235 
__THROW
 
	`__asm
 ("wcchr"
__ibu_pu__
;

237 
wch_t
 *
	$wcchr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

238 
__THROW
 
__ibu_pu__
;

240 
__END_NAMESPACE_STD


242 #ifde
__USE_GNU


245 
wch_t
 *
	$wcschul
 (cڡ 
wch_t
 *
__s
, wch_
__wc
)

246 
__THROW
 
__ibu_pu__
;

249 
__BEGIN_NAMESPACE_STD


252 
size_t
 
	$wcscn
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__je
)

253 
__THROW
 
__ibu_pu__
;

256 
size_t
 
	$wcsn
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

257 
__THROW
 
__ibu_pu__
;

259 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


260 "C++" 
wch_t
 *
	$wcbrk
 (
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

261 
__THROW
 
	`__asm
 ("wcbrk"
__ibu_pu__
;

262 "C++" cڡ 
wch_t
 *
	$wcbrk
 (cڡ 
wch_t
 *
__wcs
,

263 cڡ 
wch_t
 *
__ac
)

264 
__THROW
 
	`__asm
 ("wcbrk"
__ibu_pu__
;

266 
wch_t
 *
	$wcbrk
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

267 
__THROW
 
__ibu_pu__
;

270 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


271 "C++" 
wch_t
 *
	$wcsr
 (
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

272 
__THROW
 
	`__asm
 ("wcsr"
__ibu_pu__
;

273 "C++" cڡ 
wch_t
 *
	$wcsr
 (cڡ 
wch_t
 *
__hayack
,

274 cڡ 
wch_t
 *
__ed
)

275 
__THROW
 
	`__asm
 ("wcsr"
__ibu_pu__
;

277 
wch_t
 *
	$wcsr
 (cڡ 
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

278 
__THROW
 
__ibu_pu__
;

282 
wch_t
 *
	$wcok
 (
wch_t
 *
__ri
 
__s
,

283 cڡ 
wch_t
 *
__ri
 
__dim
,

284 
wch_t
 **
__ri
 
__r

__THROW
;

287 
size_t
 
	$wc
 (cڡ 
wch_t
 *
__s

__THROW
 
__ibu_pu__
;

288 
__END_NAMESPACE_STD


290 #ifde
__USE_XOPEN


292 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


293 "C++" 
wch_t
 *
	$wcswcs
 (
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

294 
__THROW
 
	`__asm
 ("wcswcs"
__ibu_pu__
;

295 "C++" cڡ 
wch_t
 *
	$wcswcs
 (cڡ 
wch_t
 *
__hayack
,

296 cڡ 
wch_t
 *
__ed
)

297 
__THROW
 
	`__asm
 ("wcswcs"
__ibu_pu__
;

299 
wch_t
 *
	$wcswcs
 (cڡ 
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

300 
__THROW
 
__ibu_pu__
;

304 #ifde
__USE_XOPEN2K8


306 
size_t
 
	$wcn
 (cڡ 
wch_t
 *
__s
, 
size_t
 
__maxn
)

307 
__THROW
 
__ibu_pu__
;

311 
__BEGIN_NAMESPACE_STD


313 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


314 "C++" 
wch_t
 *
	$wmemchr
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
)

315 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
;

316 "C++" cڡ 
wch_t
 *
	$wmemchr
 (cڡ 
wch_t
 *
__s
, wch_
__c
,

317 
size_t
 
__n
)

318 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
;

320 
wch_t
 *
	$wmemchr
 (cڡ 
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
)

321 
__THROW
 
__ibu_pu__
;

325 
	$wmemcmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

326 
__THROW
 
__ibu_pu__
;

329 
wch_t
 *
	$wmemy
 (
wch_t
 *
__ri
 
__s1
,

330 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n

__THROW
;

334 
wch_t
 *
	$wmemmove
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

335 
__THROW
;

338 
wch_t
 *
	$wmemt
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n

__THROW
;

339 
__END_NAMESPACE_STD


341 #ifde
__USE_GNU


344 
wch_t
 *
	$wmempy
 (
wch_t
 *
__ri
 
__s1
,

345 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
)

346 
__THROW
;

350 
__BEGIN_NAMESPACE_STD


353 
wt_t
 
	$btowc
 (
__c

__THROW
;

357 
	$wob
 (
wt_t
 
__c

__THROW
;

361 
	$mbs
 (cڡ 
mbe_t
 *
__ps

__THROW
 
__ibu_pu__
;

365 
size_t
 
	$mbowc
 (
wch_t
 *
__ri
 
__pwc
,

366 cڡ *
__ri
 
__s
, 
size_t
 
__n
,

367 
mbe_t
 *
__ri
 
__p

__THROW
;

370 
size_t
 
	$wtomb
 (*
__ri
 
__s
, 
wch_t
 
__wc
,

371 
mbe_t
 *
__ri
 
__ps

__THROW
;

374 
size_t
 
	$__mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

375 
mbe_t
 *
__ri
 
__ps

__THROW
;

376 
size_t
 
	$mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

377 
mbe_t
 *
__ri
 
__ps

__THROW
;

378 
__END_NAMESPACE_STD


380 #ifde
__USE_EXTERN_INLINES


386 
wt_t
 
	$__btowc_s
 (
__c

	`__asm
 ("btowc");

387 
__ex_le
 
wt_t


388 
	`__NTH
 (
	$btowc
 (
__c
))

389 {  (
	`__but_cڡt_p
 (
__c
) && __c >= '\0' && __c <= '\x7f'

390 ? (
wt_t

__c
 : 
	`__btowc_s
 (__c)); 
	}
}

392 
	$__wob_s
 (
wt_t
 
__c

	`__asm
 ("wctob");

393 
__ex_le
 

394 
	`__NTH
 (
	$wob
 (
wt_t
 
__wc
))

395 {  (
	`__but_cڡt_p
 (
__wc
&& __w>
L
'\0' && __wc <= L'\x7f'

396 ? (
__wc
 : 
	`__wob_s
 (__wc)); 
	}
}

398 
__ex_le
 
size_t


399 
__NTH
 (
	$mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

400 
mbe_t
 *
__ri
 
__ps
))

401 {  (
__ps
 !
NULL


402 ? 
	`mbowc
 (
NULL
, 
__s
, 
__n
, 
__ps
: 
	`__mb
 (__s, __n, NULL)); 
	}
}

405 
__BEGIN_NAMESPACE_STD


408 
size_t
 
	$mbtowcs
 (
wch_t
 *
__ri
 
__d
,

409 cڡ **
__ri
 
__c
, 
size_t
 
__n
,

410 
mbe_t
 *
__ri
 
__ps

__THROW
;

414 
size_t
 
	$wctombs
 (*
__ri
 
__d
,

415 cڡ 
wch_t
 **
__ri
 
__c
, 
size_t
 
__n
,

416 
mbe_t
 *
__ri
 
__ps

__THROW
;

417 
__END_NAMESPACE_STD


420 #ifdef 
__USE_XOPEN2K8


423 
size_t
 
	$mbowcs
 (
wch_t
 *
__ri
 
__d
,

424 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

425 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps

__THROW
;

429 
size_t
 
	$wcombs
 (*
__ri
 
__d
,

430 cڡ 
wch_t
 **
__ri
 
__c
,

431 
size_t
 
__nwc
, size_
__n
,

432 
mbe_t
 *
__ri
 
__ps

__THROW
;

437 #ifde
__USE_XOPEN


439 
	$wcwidth
 (
wch_t
 
__c

__THROW
;

443 
	$wcswidth
 (cڡ 
wch_t
 *
__s
, 
size_t
 
__n

__THROW
;

447 
__BEGIN_NAMESPACE_STD


450 
	$wcod
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

451 
wch_t
 **
__ri
 
__dr

__THROW
;

452 
__END_NAMESPACE_STD


454 #ifde
__USE_ISOC99


455 
__BEGIN_NAMESPACE_C99


457 
	$wcof
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

458 
wch_t
 **
__ri
 
__dr

__THROW
;

459 
	$wcd
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

460 
wch_t
 **
__ri
 
__dr

__THROW
;

461 
__END_NAMESPACE_C99


465 
__BEGIN_NAMESPACE_STD


468 
	$wc
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

469 
wch_t
 **
__ri
 
__dr
, 
__ba

__THROW
;

473 
	$wcoul
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

474 
wch_t
 **
__ri
 
__dr
, 
__ba
)

475 
__THROW
;

476 
__END_NAMESPACE_STD


478 #ifde
__USE_ISOC99


479 
__BEGIN_NAMESPACE_C99


482 
__exnsi__


483 
	$wcl
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

484 
wch_t
 **
__ri
 
__dr
, 
__ba
)

485 
__THROW
;

489 
__exnsi__


490 
	$wcou
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

491 
wch_t
 **
__ri
 
__dr
,

492 
__ba

__THROW
;

493 
__END_NAMESPACE_C99


496 #ifde
__USE_GNU


499 
__exnsi__


500 
	$wcoq
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

501 
wch_t
 **
__ri
 
__dr
, 
__ba
)

502 
__THROW
;

506 
__exnsi__


507 
	$wcouq
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

508 
wch_t
 **
__ri
 
__dr
,

509 
__ba

__THROW
;

512 #ifde
__USE_GNU


526 
	~<xlo.h
>

530 
	$wc_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

531 
wch_t
 **
__ri
 
__dr
, 
__ba
,

532 
__lo_t
 
__loc

__THROW
;

534 
	$wcoul_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

535 
wch_t
 **
__ri
 
__dr
,

536 
__ba
, 
__lo_t
 
__loc

__THROW
;

538 
__exnsi__


539 
	$wcl_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

540 
wch_t
 **
__ri
 
__dr
,

541 
__ba
, 
__lo_t
 
__loc

__THROW
;

543 
__exnsi__


544 
	$wcou_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

545 
wch_t
 **
__ri
 
__dr
,

546 
__ba
, 
__lo_t
 
__loc
)

547 
__THROW
;

549 
	$wcod_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

550 
wch_t
 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

551 
__THROW
;

553 
	$wcof_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

554 
wch_t
 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

555 
__THROW
;

557 
	$wcd_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

558 
wch_t
 **
__ri
 
__dr
,

559 
__lo_t
 
__loc

__THROW
;

563 #ifde
__USE_XOPEN2K8


566 
wch_t
 *
	$wy
 (
wch_t
 *
__ri
 
__de
,

567 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

571 
wch_t
 *
	$wny
 (
wch_t
 *
__ri
 
__de
,

572 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

573 
__THROW
;

580 
__FILE
 *
	$ݒ_wmemam
 (
wch_t
 **
__buoc
, 
size_t
 *
__sizoc

__THROW
;

583 #i
defed
 
__USE_ISOC95
 || defed 
__USE_UNIX98


584 
__BEGIN_NAMESPACE_STD


587 
	$fwide
 (
__FILE
 *
__
, 
__mode

__THROW
;

594 
	`fwtf
 (
__FILE
 *
__ri
 
__am
,

595 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

601 
	`wtf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...)

604 
	$swtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

605 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

606 
__THROW
 ;

612 
	`vfwtf
 (
__FILE
 *
__ri
 
__s
,

613 cڡ 
wch_t
 *
__ri
 
__fm
,

614 
__gnuc_va_li
 
__g
)

620 
	`vwtf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

621 
__gnuc_va_li
 
__g
)

625 
	$vswtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

626 cڡ 
wch_t
 *
__ri
 
__fm
,

627 
__gnuc_va_li
 
__g
)

628 
__THROW
 ;

635 
	`fwsnf
 (
__FILE
 *
__ri
 
__am
,

636 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

642 
	`wsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...)

645 
	$swsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

646 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

647 
__THROW
 ;

649 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

650 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

651 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

652 #ifde
__REDIRECT


656 
	`__REDIRECT
 (
fwsnf
, (
__FILE
 *
__ri
 
__am
,

657 cڡ 
wch_t
 *
__ri
 
__fm
, ...),

658 
__isoc99_fwsnf
)

660 
	`__REDIRECT
 (
wsnf
, (cڡ 
wch_t
 *
__ri
 
__fm
, ...),

661 
__isoc99_wsnf
)

663 
	`__REDIRECT_NTH
 (
swsnf
, (cڡ 
wch_t
 *
__ri
 
__s
,

664 cڡ 
wch_t
 *
__ri
 
__fm
,

665 ...), 
__isoc99_swsnf
)

668 
	`__isoc99_fwsnf
 (
__FILE
 *
__ri
 
__am
,

669 cڡ 
wch_t
 *
__ri
 
__fm
, ...);

670 
	`__isoc99_wsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...);

671 
	$__isoc99_swsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

672 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

673 
__THROW
;

674 
	#fwsnf
 
__isoc99_fwsnf


	)

675 
	#wsnf
 
__isoc99_wsnf


	)

676 
	#swsnf
 
__isoc99_swsnf


	)

680 
__END_NAMESPACE_STD


683 #ifde
__USE_ISOC99


684 
__BEGIN_NAMESPACE_C99


689 
	`vfwsnf
 (
__FILE
 *
__ri
 
__s
,

690 cڡ 
wch_t
 *
__ri
 
__fm
,

691 
__gnuc_va_li
 
__g
)

697 
	`vwsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

698 
__gnuc_va_li
 
__g
)

701 
	$vswsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

702 cڡ 
wch_t
 *
__ri
 
__fm
,

703 
__gnuc_va_li
 
__g
)

704 
__THROW
 ;

706 #i!
defed
 
__USE_GNU
 \

707 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

708 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

709 #ifde
__REDIRECT


710 
	`__REDIRECT
 (
vfwsnf
, (
__FILE
 *
__ri
 
__s
,

711 cڡ 
wch_t
 *
__ri
 
__fm
,

712 
__gnuc_va_li
 
__g
), 
__isoc99_vfwsnf
)

714 
	`__REDIRECT
 (
vwsnf
, (cڡ 
wch_t
 *
__ri
 
__fm
,

715 
__gnuc_va_li
 
__g
), 
__isoc99_vwsnf
)

717 
	`__REDIRECT_NTH
 (
vswsnf
, (cڡ 
wch_t
 *
__ri
 
__s
,

718 cڡ 
wch_t
 *
__ri
 
__fm
,

719 
__gnuc_va_li
 
__g
), 
__isoc99_vswsnf
)

722 
	`__isoc99_vfwsnf
 (
__FILE
 *
__ri
 
__s
,

723 cڡ 
wch_t
 *
__ri
 
__fm
,

724 
__gnuc_va_li
 
__g
);

725 
	`__isoc99_vwsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

726 
__gnuc_va_li
 
__g
);

727 
	$__isoc99_vswsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

728 cڡ 
wch_t
 *
__ri
 
__fm
,

729 
__gnuc_va_li
 
__g

__THROW
;

730 
	#vfwsnf
 
__isoc99_vfwsnf


	)

731 
	#vwsnf
 
__isoc99_vwsnf


	)

732 
	#vswsnf
 
__isoc99_vswsnf


	)

736 
__END_NAMESPACE_C99


740 
__BEGIN_NAMESPACE_STD


745 
wt_t
 
	`fgwc
 (
__FILE
 *
__am
);

746 
wt_t
 
	`gwc
 (
__FILE
 *
__am
);

752 
wt_t
 
	`gwch
 ();

759 
wt_t
 
	`utwc
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

760 
wt_t
 
	`putwc
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

766 
wt_t
 
	`putwch
 (
wch_t
 
__wc
);

774 
wch_t
 *
	`fgws
 (wch_*
__ri
 
__ws
, 
__n
,

775 
__FILE
 *
__ri
 
__am
);

781 
	`utws
 (cڡ 
wch_t
 *
__ri
 
__ws
,

782 
__FILE
 *
__ri
 
__am
);

789 
wt_t
 
	`ungwc
 (wt_
__wc
, 
__FILE
 *
__am
);

790 
__END_NAMESPACE_STD


793 #ifde
__USE_GNU


801 
wt_t
 
	`gwc_uocked
 (
__FILE
 *
__am
);

802 
wt_t
 
	`gwch_uocked
 ();

810 
wt_t
 
	`fgwc_uocked
 (
__FILE
 *
__am
);

818 
wt_t
 
	`utwc_uocked
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

827 
wt_t
 
	`putwc_uocked
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

828 
wt_t
 
	`putwch_uocked
 (
wch_t
 
__wc
);

837 
wch_t
 *
	`fgws_uocked
 (wch_*
__ri
 
__ws
, 
__n
,

838 
__FILE
 *
__ri
 
__am
);

846 
	`utws_uocked
 (cڡ 
wch_t
 *
__ri
 
__ws
,

847 
__FILE
 *
__ri
 
__am
);

851 
__BEGIN_NAMESPACE_C99


855 
size_t
 
	$wcsime
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__maxsize
,

856 cڡ 
wch_t
 *
__ri
 
__fm
,

857 cڡ 
tm
 *
__ri
 
__

__THROW
;

858 
__END_NAMESPACE_C99


860 #ifde
__USE_GNU


861 
	~<xlo.h
>

865 
size_t
 
	$wcsime_l
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__maxsize
,

866 cڡ 
wch_t
 *
__ri
 
__fm
,

867 cڡ 
tm
 *
__ri
 
__
,

868 
__lo_t
 
__loc

__THROW
;

877 #i
defed
 
__USE_UNIX98
 && !defed 
__USE_GNU


878 
	#__ed_iswxxx


	)

879 
	~<wy.h
>

883 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


884 
	~<bs/wch2.h
>

887 #ifde
__LDBL_COMPAT


888 
	~<bs/wch-ldbl.h
>

891 
__END_DECLS


899 #unde
__ed_mbe_t


900 #unde
__ed_wt_t


	@/usr/include/wctype.h

23 #ide
_WCTYPE_H


25 
	~<us.h
>

26 
	~<bs/tys.h
>

28 #ide
__ed_iswxxx


29 
	#_WCTYPE_H
 1

	)

32 
	#__ed_wt_t


	)

33 
	~<wch.h
>

37 #ide
WEOF


38 
	#WEOF
 (0xffffffffu)

	)

41 #unde
__ed_iswxxx


46 #ide
__iswxxx_defed


47 
	#__iswxxx_defed
 1

	)

49 
__BEGIN_NAMESPACE_C99


52 
	twy_t
;

53 
	g__END_NAMESPACE_C99


55 #ide
_ISwb


60 
	~<dn.h
>

61 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


62 
	#_ISwb
(
b
(1 << (b))

	)

64 
	#_ISwb
(
b
) \

65 ((
b
) < 8 ? () ((1UL << (bit)) << 24) \

66 : ((
b
) < 16 ? () ((1UL << (bit)) << 8) \

67 : ((
b
) < 24 ? () ((1UL << (bit)) >> 8) \

68 : (((1UL << (
b
)>> 24))))

	)

73 
	m__ISwu
 = 0,

74 
	m__ISwlow
 = 1,

75 
	m__ISwpha
 = 2,

76 
	m__ISwdig
 = 3,

77 
	m__ISwxdig
 = 4,

78 
	m__ISwa
 = 5,

79 
	m__ISwt
 = 6,

80 
	m__ISwgph
 = 7,

81 
	m__ISwbnk
 = 8,

82 
	m__ISwl
 = 9,

83 
	m__ISwpun
 = 10,

84 
	m__ISwnum
 = 11,

86 
	m_ISwu
 = 
_ISwb
 (
__ISwu
),

87 
	m_ISwlow
 = 
_ISwb
 (
__ISwlow
),

88 
	m_ISwpha
 = 
_ISwb
 (
__ISwpha
),

89 
	m_ISwdig
 = 
_ISwb
 (
__ISwdig
),

90 
	m_ISwxdig
 = 
_ISwb
 (
__ISwxdig
),

91 
	m_ISwa
 = 
_ISwb
 (
__ISwa
),

92 
	m_ISwt
 = 
_ISwb
 (
__ISwt
),

93 
	m_ISwgph
 = 
_ISwb
 (
__ISwgph
),

94 
	m_ISwbnk
 = 
_ISwb
 (
__ISwbnk
),

95 
	m_ISwl
 = 
_ISwb
 (
__ISwl
),

96 
	m_ISwpun
 = 
_ISwb
 (
__ISwpun
),

97 
	m_ISwnum
 = 
_ISwb
 (
__ISwnum
)

102 
__BEGIN_DECLS


104 
__BEGIN_NAMESPACE_C99


111 
	$iswnum
 (
wt_t
 
__wc

__THROW
;

117 
	$iswpha
 (
wt_t
 
__wc

__THROW
;

120 
	$iswl
 (
wt_t
 
__wc

__THROW
;

124 
	$iswdig
 (
wt_t
 
__wc

__THROW
;

128 
	$iswgph
 (
wt_t
 
__wc

__THROW
;

133 
	$iswlow
 (
wt_t
 
__wc

__THROW
;

136 
	$iswt
 (
wt_t
 
__wc

__THROW
;

141 
	$iswpun
 (
wt_t
 
__wc

__THROW
;

146 
	$iswa
 (
wt_t
 
__wc

__THROW
;

151 
	$iswu
 (
wt_t
 
__wc

__THROW
;

156 
	$iswxdig
 (
wt_t
 
__wc

__THROW
;

161 #ifde
__USE_ISOC99


162 
	$iswbnk
 (
wt_t
 
__wc

__THROW
;

171 
wy_t
 
	$wy
 (cڡ *
__ݔty

__THROW
;

175 
	$iswy
 (
wt_t
 
__wc
, 
wy_t
 
__desc

__THROW
;

176 
__END_NAMESPACE_C99


183 
__BEGIN_NAMESPACE_C99


186 cڡ 
	t__t32_t
 *
	twns_t
;

187 
__END_NAMESPACE_C99


188 #ifde
__USE_GNU


189 
	$__USING_NAMESPACE_C99
(
wns_t
)

192 
__BEGIN_NAMESPACE_C99


194 
wt_t
 
	$towlow
 (
wt_t
 
__wc

__THROW
;

197 
wt_t
 
	$towu
 (
wt_t
 
__wc

__THROW
;

198 
__END_NAMESPACE_C99


200 
__END_DECLS


207 #ifde
_WCTYPE_H


213 
__BEGIN_DECLS


215 
__BEGIN_NAMESPACE_C99


218 
wns_t
 
	$wns
 (cڡ *
__ݔty

__THROW
;

221 
wt_t
 
	$towns
 (
wt_t
 
__wc
, 
wns_t
 
__desc

__THROW
;

222 
__END_NAMESPACE_C99


224 #ifde
__USE_XOPEN2K8


226 
	~<xlo.h
>

230 
	$iswnum_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

236 
	$iswpha_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

239 
	$iswl_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

243 
	$iswdig_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

247 
	$iswgph_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

252 
	$iswlow_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

255 
	$iswt_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

260 
	$iswpun_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

265 
	$iswa_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

270 
	$iswu_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

275 
	$iswxdig_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

280 
	$iswbnk_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

284 
wy_t
 
	$wy_l
 (cڡ *
__ݔty
, 
__lo_t
 
__lo
)

285 
__THROW
;

289 
	$iswy_l
 (
wt_t
 
__wc
, 
wy_t
 
__desc
, 
__lo_t
 
__lo
)

290 
__THROW
;

298 
wt_t
 
	$towlow_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

301 
wt_t
 
	$towu_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

305 
wns_t
 
	$wns_l
 (cڡ *
__ݔty
, 
__lo_t
 
__lo
)

306 
__THROW
;

309 
wt_t
 
	$towns_l
 (
wt_t
 
__wc
, 
wns_t
 
__desc
,

310 
__lo_t
 
__lo

__THROW
;

314 
__END_DECLS


	@
1
.
1
/usr/include
257
9160
include/cert-service-debug.h
include/cert-service-process.h
include/cert-service-store.h
include/cert-service-util.h
include/cert-service.h
srcs/cert-service-process.c
srcs/cert-service-store.c
srcs/cert-service-util.c
srcs/cert-service.c
tests/capi/api_tests.cpp
tests/capi/api_tests.h
tests/capi/crl_cache.h
tests/capi/test_suite_01.cpp
tests/capi/test_suite_02.cpp
tests/cert-svc/delete_test.c
tests/cert-svc/extract_test.c
tests/cert-svc/extract_test_pfx.c
tests/cert-svc/mem_test.c
tests/cert-svc/search_test.c
tests/cert-svc/store_test.c
tests/cert-svc/test_caflag.c
tests/cert-svc/test_ocsp.c
tests/cert-svc/test_suite.h
tests/cert-svc/test_suite_main.c
tests/cert-svc/verify_sig.c
tests/cert-svc/verify_test.c
tests/pkcs12/new_test_cases.cpp
tests/pkcs12/pkcs12_test.cpp
tests/vcore/TestCRL.cpp
tests/vcore/TestCRL.h
tests/vcore/TestCases.cpp
tests/vcore/TestEnv.cpp
tests/vcore/TestEnv.h
tests/vcore/vcore_tests.cpp
vcore/src/cert-svc/ccert.h
vcore/src/cert-svc/ccrl.h
vcore/src/cert-svc/cerror.h
vcore/src/cert-svc/cinstance.h
vcore/src/cert-svc/cocsp.h
vcore/src/cert-svc/cpkcs12.h
vcore/src/cert-svc/cprimitives.h
vcore/src/cert-svc/cstring.h
vcore/src/dpl/core/include/dpl/abstract_input.h
vcore/src/dpl/core/include/dpl/abstract_input_output.h
vcore/src/dpl/core/include/dpl/abstract_output.h
vcore/src/dpl/core/include/dpl/abstract_waitable_input.h
vcore/src/dpl/core/include/dpl/assert.h
vcore/src/dpl/core/include/dpl/availability.h
vcore/src/dpl/core/include/dpl/binary_queue.h
vcore/src/dpl/core/include/dpl/char_traits.h
vcore/src/dpl/core/include/dpl/colors.h
vcore/src/dpl/core/include/dpl/errno_string.h
vcore/src/dpl/core/include/dpl/exception.h
vcore/src/dpl/core/include/dpl/file_input.h
vcore/src/dpl/core/include/dpl/foreach.h
vcore/src/dpl/core/include/dpl/free_deleter.h
vcore/src/dpl/core/include/dpl/lexical_cast.h
vcore/src/dpl/core/include/dpl/noncopyable.h
vcore/src/dpl/core/include/dpl/optional.h
vcore/src/dpl/core/include/dpl/optional_typedefs.h
vcore/src/dpl/core/include/dpl/preprocessor.h
vcore/src/dpl/core/include/dpl/scoped_array.h
vcore/src/dpl/core/include/dpl/scoped_fclose.h
vcore/src/dpl/core/include/dpl/scoped_free.h
vcore/src/dpl/core/include/dpl/scoped_resource.h
vcore/src/dpl/core/include/dpl/singleton.h
vcore/src/dpl/core/include/dpl/singleton_impl.h
vcore/src/dpl/core/include/dpl/string.h
vcore/src/dpl/core/include/dpl/thread.h
vcore/src/dpl/core/include/dpl/type_list.h
vcore/src/dpl/core/include/dpl/waitable_event.h
vcore/src/dpl/core/include/dpl/waitable_handle.h
vcore/src/dpl/core/include/dpl/waitable_handle_watch_support.h
vcore/src/dpl/core/include/dpl/workaround.h
vcore/src/dpl/core/src/assert.cpp
vcore/src/dpl/core/src/binary_queue.cpp
vcore/src/dpl/core/src/char_traits.cpp
vcore/src/dpl/core/src/colors.cpp
vcore/src/dpl/core/src/errno_string.cpp
vcore/src/dpl/core/src/exception.cpp
vcore/src/dpl/core/src/file_input.cpp
vcore/src/dpl/core/src/noncopyable.cpp
vcore/src/dpl/core/src/singleton.cpp
vcore/src/dpl/core/src/string.cpp
vcore/src/dpl/core/src/thread.cpp
vcore/src/dpl/core/src/type_list.cpp
vcore/src/dpl/core/src/waitable_event.cpp
vcore/src/dpl/core/src/waitable_handle.cpp
vcore/src/dpl/core/src/waitable_handle_watch_support.cpp
vcore/src/dpl/db/include/dpl/db/naive_synchronization_object.h
vcore/src/dpl/db/include/dpl/db/orm.h
vcore/src/dpl/db/include/dpl/db/orm_generator.h
vcore/src/dpl/db/include/dpl/db/orm_interface.h
vcore/src/dpl/db/include/dpl/db/orm_macros.h
vcore/src/dpl/db/include/dpl/db/sql_connection.h
vcore/src/dpl/db/include/dpl/db/thread_database_support.h
vcore/src/dpl/db/src/naive_synchronization_object.cpp
vcore/src/dpl/db/src/orm.cpp
vcore/src/dpl/db/src/sql_connection.cpp
vcore/src/dpl/db/src/thread_database_support.cpp
vcore/src/dpl/log/include/dpl/log/abstract_log_provider.h
vcore/src/dpl/log/include/dpl/log/dlog_log_provider.h
vcore/src/dpl/log/include/dpl/log/log.h
vcore/src/dpl/log/include/dpl/log/old_style_log_provider.h
vcore/src/dpl/log/include/dpl/log/vcore_log.h
vcore/src/dpl/log/include/dpl/log/wrt_log.h
vcore/src/dpl/log/src/abstract_log_provider.cpp
vcore/src/dpl/log/src/dlog_log_provider.cpp
vcore/src/dpl/log/src/log.cpp
vcore/src/dpl/log/src/old_style_log_provider.cpp
vcore/src/dpl/test/include/dpl/test/abstract_input_parser.h
vcore/src/dpl/test/include/dpl/test/abstract_input_reader.h
vcore/src/dpl/test/include/dpl/test/abstract_input_tokenizer.h
vcore/src/dpl/test/include/dpl/test/process_pipe.h
vcore/src/dpl/test/include/dpl/test/test_results_collector.h
vcore/src/dpl/test/include/dpl/test/test_runner.h
vcore/src/dpl/test/include/dpl/test/test_runner_child.h
vcore/src/dpl/test/include/dpl/test/test_runner_multiprocess.h
vcore/src/dpl/test/include/dpl/test/value_separated_parser.h
vcore/src/dpl/test/include/dpl/test/value_separated_policies.h
vcore/src/dpl/test/include/dpl/test/value_separated_reader.h
vcore/src/dpl/test/include/dpl/test/value_separated_tokenizer.h
vcore/src/dpl/test/include/dpl/test/value_separated_tokens.h
vcore/src/dpl/test/src/process_pipe.cpp
vcore/src/dpl/test/src/test_results_collector.cpp
vcore/src/dpl/test/src/test_runner.cpp
vcore/src/dpl/test/src/test_runner_child.cpp
vcore/src/dpl/test/src/test_runner_multiprocess.cpp
vcore/src/dpl/test/src/value_separated_policies.cpp
vcore/src/dpl/test/src/value_separated_tokens.cpp
vcore/src/orm/orm_generator_vcore.h
vcore/src/orm/vcore_db_sql_generator.h
vcore/src/server/include/cert-server-logic.h
vcore/src/server/src/cert-server-logic.c
vcore/src/server/src/cert-server-main.c
vcore/src/vcore/Base64.cpp
vcore/src/vcore/Base64.h
vcore/src/vcore/CRL.cpp
vcore/src/vcore/CRL.h
vcore/src/vcore/CRLCacheDAO.cpp
vcore/src/vcore/CRLCacheDAO.h
vcore/src/vcore/CRLCacheInterface.h
vcore/src/vcore/CRLImpl.cpp
vcore/src/vcore/CRLImpl.h
vcore/src/vcore/CachedCRL.cpp
vcore/src/vcore/CachedCRL.h
vcore/src/vcore/CachedOCSP.cpp
vcore/src/vcore/CachedOCSP.h
vcore/src/vcore/CertStoreType.cpp
vcore/src/vcore/CertStoreType.h
vcore/src/vcore/Certificate.cpp
vcore/src/vcore/Certificate.h
vcore/src/vcore/CertificateCacheDAO.cpp
vcore/src/vcore/CertificateCacheDAO.h
vcore/src/vcore/CertificateCollection.cpp
vcore/src/vcore/CertificateCollection.h
vcore/src/vcore/CertificateConfigReader.cpp
vcore/src/vcore/CertificateConfigReader.h
vcore/src/vcore/CertificateIdentifier.h
vcore/src/vcore/CertificateLoader.cpp
vcore/src/vcore/CertificateLoader.h
vcore/src/vcore/CertificateStorage.h
vcore/src/vcore/CertificateVerifier.cpp
vcore/src/vcore/CertificateVerifier.h
vcore/src/vcore/Config.cpp
vcore/src/vcore/Config.h
vcore/src/vcore/CryptoHash.cpp
vcore/src/vcore/CryptoHash.h
vcore/src/vcore/Database.cpp
vcore/src/vcore/Database.h
vcore/src/vcore/IAbstractResponseCache.h
vcore/src/vcore/OCSP.cpp
vcore/src/vcore/OCSP.h
vcore/src/vcore/OCSPCertMgrUtil.cpp
vcore/src/vcore/OCSPCertMgrUtil.h
vcore/src/vcore/OCSPImpl.cpp
vcore/src/vcore/OCSPImpl.h
vcore/src/vcore/OCSPUtil.c
vcore/src/vcore/ParserSchema.h
vcore/src/vcore/ReferenceValidator.cpp
vcore/src/vcore/ReferenceValidator.h
vcore/src/vcore/RevocationCheckerBase.cpp
vcore/src/vcore/RevocationCheckerBase.h
vcore/src/vcore/SSLContainers.h
vcore/src/vcore/SaxReader.cpp
vcore/src/vcore/SaxReader.h
vcore/src/vcore/SignatureData.cpp
vcore/src/vcore/SignatureData.h
vcore/src/vcore/SignatureFinder.cpp
vcore/src/vcore/SignatureFinder.h
vcore/src/vcore/SignatureReader.cpp
vcore/src/vcore/SignatureReader.h
vcore/src/vcore/SignatureValidator.cpp
vcore/src/vcore/SignatureValidator.h
vcore/src/vcore/SoupMessageSendBase.cpp
vcore/src/vcore/SoupMessageSendBase.h
vcore/src/vcore/SoupMessageSendSync.cpp
vcore/src/vcore/SoupMessageSendSync.h
vcore/src/vcore/TimeConversion.cpp
vcore/src/vcore/TimeConversion.h
vcore/src/vcore/VCore.cpp
vcore/src/vcore/VCore.h
vcore/src/vcore/VCorePrivate.h
vcore/src/vcore/ValidatorCommon.h
vcore/src/vcore/ValidatorFactories.cpp
vcore/src/vcore/ValidatorFactories.h
vcore/src/vcore/VerificationStatus.cpp
vcore/src/vcore/VerificationStatus.h
vcore/src/vcore/WacOrigin.cpp
vcore/src/vcore/WacOrigin.h
vcore/src/vcore/WrtSignatureValidator.cpp
vcore/src/vcore/WrtSignatureValidator.h
vcore/src/vcore/XmlsecAdapter.cpp
vcore/src/vcore/XmlsecAdapter.h
vcore/src/vcore/api.cpp
vcore/src/vcore/cert-svc-client.c
vcore/src/vcore/cert-svc-client.h
vcore/src/vcore/exception.cpp
vcore/src/vcore/exception.h
vcore/src/vcore/pkcs12.cpp
vcore/src/vcore/pkcs12.h
vcore/src/vcore/scoped_gpointer.h
vcore/src/vcore/utils.c
vcore/src/vcore/utils.h
/usr/include/ctype.h
/usr/include/dirent.h
/usr/include/dlfcn.h
/usr/include/errno.h
/usr/include/error.h
/usr/include/fcntl.h
/usr/include/fts.h
/usr/include/iconv.h
/usr/include/libgen.h
/usr/include/limits.h
/usr/include/malloc.h
/usr/include/memory.h
/usr/include/poll.h
/usr/include/pthread.h
/usr/include/signal.h
/usr/include/stdint.h
/usr/include/stdio.h
/usr/include/stdlib.h
/usr/include/string.h
/usr/include/time.h
/usr/include/unistd.h
/usr/include/alloca.h
/usr/include/endian.h
/usr/include/features.h
/usr/include/getopt.h
/usr/include/libio.h
/usr/include/sched.h
/usr/include/xlocale.h
/usr/include/_G_config.h
/usr/include/stdc-predef.h
/usr/include/gconv.h
/usr/include/wchar.h
/usr/include/wctype.h
